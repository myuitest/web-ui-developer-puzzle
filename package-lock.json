{
  "name": "tmo",
  "version": "0.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "@angular-devkit/architect": {
      "version": "0.1000.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/architect/-/architect-0.1000.6.tgz",
      "integrity": "sha512-IZ8yiiW+LQ5mI3VbNHzisTIn0j6D1inQZgcZtc5W2A7fFNvBlIh6vGU3mB6Qvg678Gt6tlvnNT6/R9A9Ct7VnA==",
      "requires": {
        "@angular-devkit/core": "10.0.6",
        "rxjs": "6.5.5"
      }
    },
    "@angular-devkit/build-angular": {
      "version": "0.1000.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/build-angular/-/build-angular-0.1000.6.tgz",
      "integrity": "sha512-tKyVD8Wqfo2wFdfWmc7OMzFn30Zl37heEusnMrQD5/zZ3Hw4Nqt2kf3pf3hbWl1GExUVFYyRNoCOCh9DaIfh0w==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "0.1000.6",
        "@angular-devkit/build-optimizer": "0.1000.6",
        "@angular-devkit/build-webpack": "0.1000.6",
        "@angular-devkit/core": "10.0.6",
        "@babel/core": "7.9.6",
        "@babel/generator": "7.9.6",
        "@babel/plugin-transform-runtime": "7.9.6",
        "@babel/preset-env": "7.9.6",
        "@babel/runtime": "7.9.6",
        "@babel/template": "7.8.6",
        "@jsdevtools/coverage-istanbul-loader": "3.0.3",
        "@ngtools/webpack": "10.0.6",
        "ajv": "6.12.3",
        "autoprefixer": "9.8.0",
        "babel-loader": "8.1.0",
        "browserslist": "^4.9.1",
        "cacache": "15.0.3",
        "caniuse-lite": "^1.0.30001032",
        "circular-dependency-plugin": "5.2.0",
        "copy-webpack-plugin": "6.0.3",
        "core-js": "3.6.4",
        "css-loader": "3.5.3",
        "cssnano": "4.1.10",
        "file-loader": "6.0.0",
        "find-cache-dir": "3.3.1",
        "glob": "7.1.6",
        "jest-worker": "26.0.0",
        "karma-source-map-support": "1.4.0",
        "less-loader": "6.1.0",
        "license-webpack-plugin": "2.2.0",
        "loader-utils": "2.0.0",
        "mini-css-extract-plugin": "0.9.0",
        "minimatch": "3.0.4",
        "open": "7.0.4",
        "parse5": "4.0.0",
        "pnp-webpack-plugin": "1.6.4",
        "postcss": "7.0.31",
        "postcss-import": "12.0.1",
        "postcss-loader": "3.0.0",
        "raw-loader": "4.0.1",
        "regenerator-runtime": "0.13.5",
        "resolve-url-loader": "3.1.1",
        "rimraf": "3.0.2",
        "rollup": "2.10.9",
        "rxjs": "6.5.5",
        "sass": "1.26.5",
        "sass-loader": "8.0.2",
        "semver": "7.3.2",
        "source-map": "0.7.3",
        "source-map-loader": "1.0.0",
        "source-map-support": "0.5.19",
        "speed-measure-webpack-plugin": "1.3.3",
        "style-loader": "1.2.1",
        "stylus": "0.54.7",
        "stylus-loader": "3.0.2",
        "terser": "4.7.0",
        "terser-webpack-plugin": "3.0.1",
        "tree-kill": "1.2.2",
        "webpack": "4.43.0",
        "webpack-dev-middleware": "3.7.2",
        "webpack-dev-server": "3.11.0",
        "webpack-merge": "4.2.2",
        "webpack-sources": "1.4.3",
        "webpack-subresource-integrity": "1.4.1",
        "worker-plugin": "4.0.3"
      },
      "dependencies": {
        "@angular-devkit/architect": {
          "version": "0.1000.6",
          "resolved": "https://registry.npmjs.org/@angular-devkit/architect/-/architect-0.1000.6.tgz",
          "integrity": "sha512-IZ8yiiW+LQ5mI3VbNHzisTIn0j6D1inQZgcZtc5W2A7fFNvBlIh6vGU3mB6Qvg678Gt6tlvnNT6/R9A9Ct7VnA==",
          "dev": true,
          "requires": {
            "@angular-devkit/core": "10.0.6",
            "rxjs": "6.5.5"
          }
        },
        "@angular-devkit/build-webpack": {
          "version": "0.1000.6",
          "resolved": "https://registry.npmjs.org/@angular-devkit/build-webpack/-/build-webpack-0.1000.6.tgz",
          "integrity": "sha512-R01bJWuvckU5IdjcqoCeikLBpHRqt5fgfD0a4Hsg3evqW6xxXcSgc+YhWfeEmyU/nF/kVel8G2bFyPzhZP4QdQ==",
          "dev": true,
          "requires": {
            "@angular-devkit/architect": "0.1000.6",
            "@angular-devkit/core": "10.0.6",
            "rxjs": "6.5.5"
          }
        },
        "@angular-devkit/core": {
          "version": "10.0.6",
          "resolved": "https://registry.npmjs.org/@angular-devkit/core/-/core-10.0.6.tgz",
          "integrity": "sha512-mVvqSEoeErZ7bAModk95EAa6R9Nl23rvX+/TXuKVTK2dziMFBOrwHjb1DYhnZxFIH4xfUftCx+BWHjXBXCPYlA==",
          "dev": true,
          "requires": {
            "ajv": "6.12.3",
            "fast-json-stable-stringify": "2.1.0",
            "magic-string": "0.25.7",
            "rxjs": "6.5.5",
            "source-map": "0.7.3"
          }
        },
        "@babel/core": {
          "version": "7.9.6",
          "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.9.6.tgz",
          "integrity": "sha512-nD3deLvbsApbHAHttzIssYqgb883yU/d9roe4RZymBCDaZryMJDbptVpEpeQuRh4BJ+SYI8le9YGxKvFEvl1Wg==",
          "dev": true,
          "requires": {
            "@babel/code-frame": "^7.8.3",
            "@babel/generator": "^7.9.6",
            "@babel/helper-module-transforms": "^7.9.0",
            "@babel/helpers": "^7.9.6",
            "@babel/parser": "^7.9.6",
            "@babel/template": "^7.8.6",
            "@babel/traverse": "^7.9.6",
            "@babel/types": "^7.9.6",
            "convert-source-map": "^1.7.0",
            "debug": "^4.1.0",
            "gensync": "^1.0.0-beta.1",
            "json5": "^2.1.2",
            "lodash": "^4.17.13",
            "resolve": "^1.3.2",
            "semver": "^5.4.1",
            "source-map": "^0.5.0"
          },
          "dependencies": {
            "semver": {
              "version": "5.7.1",
              "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
              "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
              "dev": true
            },
            "source-map": {
              "version": "0.5.7",
              "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
              "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
              "dev": true
            }
          }
        },
        "@babel/preset-env": {
          "version": "7.9.6",
          "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.9.6.tgz",
          "integrity": "sha512-0gQJ9RTzO0heXOhzftog+a/WyOuqMrAIugVYxMYf83gh1CQaQDjMtsOpqOwXyDL/5JcWsrCm8l4ju8QC97O7EQ==",
          "dev": true,
          "requires": {
            "@babel/compat-data": "^7.9.6",
            "@babel/helper-compilation-targets": "^7.9.6",
            "@babel/helper-module-imports": "^7.8.3",
            "@babel/helper-plugin-utils": "^7.8.3",
            "@babel/plugin-proposal-async-generator-functions": "^7.8.3",
            "@babel/plugin-proposal-dynamic-import": "^7.8.3",
            "@babel/plugin-proposal-json-strings": "^7.8.3",
            "@babel/plugin-proposal-nullish-coalescing-operator": "^7.8.3",
            "@babel/plugin-proposal-numeric-separator": "^7.8.3",
            "@babel/plugin-proposal-object-rest-spread": "^7.9.6",
            "@babel/plugin-proposal-optional-catch-binding": "^7.8.3",
            "@babel/plugin-proposal-optional-chaining": "^7.9.0",
            "@babel/plugin-proposal-unicode-property-regex": "^7.8.3",
            "@babel/plugin-syntax-async-generators": "^7.8.0",
            "@babel/plugin-syntax-dynamic-import": "^7.8.0",
            "@babel/plugin-syntax-json-strings": "^7.8.0",
            "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.0",
            "@babel/plugin-syntax-numeric-separator": "^7.8.0",
            "@babel/plugin-syntax-object-rest-spread": "^7.8.0",
            "@babel/plugin-syntax-optional-catch-binding": "^7.8.0",
            "@babel/plugin-syntax-optional-chaining": "^7.8.0",
            "@babel/plugin-syntax-top-level-await": "^7.8.3",
            "@babel/plugin-transform-arrow-functions": "^7.8.3",
            "@babel/plugin-transform-async-to-generator": "^7.8.3",
            "@babel/plugin-transform-block-scoped-functions": "^7.8.3",
            "@babel/plugin-transform-block-scoping": "^7.8.3",
            "@babel/plugin-transform-classes": "^7.9.5",
            "@babel/plugin-transform-computed-properties": "^7.8.3",
            "@babel/plugin-transform-destructuring": "^7.9.5",
            "@babel/plugin-transform-dotall-regex": "^7.8.3",
            "@babel/plugin-transform-duplicate-keys": "^7.8.3",
            "@babel/plugin-transform-exponentiation-operator": "^7.8.3",
            "@babel/plugin-transform-for-of": "^7.9.0",
            "@babel/plugin-transform-function-name": "^7.8.3",
            "@babel/plugin-transform-literals": "^7.8.3",
            "@babel/plugin-transform-member-expression-literals": "^7.8.3",
            "@babel/plugin-transform-modules-amd": "^7.9.6",
            "@babel/plugin-transform-modules-commonjs": "^7.9.6",
            "@babel/plugin-transform-modules-systemjs": "^7.9.6",
            "@babel/plugin-transform-modules-umd": "^7.9.0",
            "@babel/plugin-transform-named-capturing-groups-regex": "^7.8.3",
            "@babel/plugin-transform-new-target": "^7.8.3",
            "@babel/plugin-transform-object-super": "^7.8.3",
            "@babel/plugin-transform-parameters": "^7.9.5",
            "@babel/plugin-transform-property-literals": "^7.8.3",
            "@babel/plugin-transform-regenerator": "^7.8.7",
            "@babel/plugin-transform-reserved-words": "^7.8.3",
            "@babel/plugin-transform-shorthand-properties": "^7.8.3",
            "@babel/plugin-transform-spread": "^7.8.3",
            "@babel/plugin-transform-sticky-regex": "^7.8.3",
            "@babel/plugin-transform-template-literals": "^7.8.3",
            "@babel/plugin-transform-typeof-symbol": "^7.8.4",
            "@babel/plugin-transform-unicode-regex": "^7.8.3",
            "@babel/preset-modules": "^0.1.3",
            "@babel/types": "^7.9.6",
            "browserslist": "^4.11.1",
            "core-js-compat": "^3.6.2",
            "invariant": "^2.2.2",
            "levenary": "^1.1.1",
            "semver": "^5.5.0"
          },
          "dependencies": {
            "semver": {
              "version": "5.7.1",
              "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
              "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
              "dev": true
            }
          }
        },
        "@webassemblyjs/ast": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.9.0.tgz",
          "integrity": "sha512-C6wW5L+b7ogSDVqymbkkvuW9kruN//YisMED04xzeBBqjHa2FYnmvOlS6Xj68xWQRgWvI9cIglsjFowH/RJyEA==",
          "dev": true,
          "requires": {
            "@webassemblyjs/helper-module-context": "1.9.0",
            "@webassemblyjs/helper-wasm-bytecode": "1.9.0",
            "@webassemblyjs/wast-parser": "1.9.0"
          }
        },
        "@webassemblyjs/floating-point-hex-parser": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.9.0.tgz",
          "integrity": "sha512-TG5qcFsS8QB4g4MhrxK5TqfdNe7Ey/7YL/xN+36rRjl/BlGE/NcBvJcqsRgCP6Z92mRE+7N50pRIi8SmKUbcQA==",
          "dev": true
        },
        "@webassemblyjs/helper-api-error": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.9.0.tgz",
          "integrity": "sha512-NcMLjoFMXpsASZFxJ5h2HZRcEhDkvnNFOAKneP5RbKRzaWJN36NC4jqQHKwStIhGXu5mUWlUUk7ygdtrO8lbmw==",
          "dev": true
        },
        "@webassemblyjs/helper-buffer": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.9.0.tgz",
          "integrity": "sha512-qZol43oqhq6yBPx7YM3m9Bv7WMV9Eevj6kMi6InKOuZxhw+q9hOkvq5e/PpKSiLfyetpaBnogSbNCfBwyB00CA==",
          "dev": true
        },
        "@webassemblyjs/helper-code-frame": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-code-frame/-/helper-code-frame-1.9.0.tgz",
          "integrity": "sha512-ERCYdJBkD9Vu4vtjUYe8LZruWuNIToYq/ME22igL+2vj2dQ2OOujIZr3MEFvfEaqKoVqpsFKAGsRdBSBjrIvZA==",
          "dev": true,
          "requires": {
            "@webassemblyjs/wast-printer": "1.9.0"
          }
        },
        "@webassemblyjs/helper-fsm": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-fsm/-/helper-fsm-1.9.0.tgz",
          "integrity": "sha512-OPRowhGbshCb5PxJ8LocpdX9Kl0uB4XsAjl6jH/dWKlk/mzsANvhwbiULsaiqT5GZGT9qinTICdj6PLuM5gslw==",
          "dev": true
        },
        "@webassemblyjs/helper-module-context": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-module-context/-/helper-module-context-1.9.0.tgz",
          "integrity": "sha512-MJCW8iGC08tMk2enck1aPW+BE5Cw8/7ph/VGZxwyvGbJwjktKkDK7vy7gAmMDx88D7mhDTCNKAW5tED+gZ0W8g==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0"
          }
        },
        "@webassemblyjs/helper-wasm-bytecode": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.9.0.tgz",
          "integrity": "sha512-R7FStIzyNcd7xKxCZH5lE0Bqy+hGTwS3LJjuv1ZVxd9O7eHCedSdrId/hMOd20I+v8wDXEn+bjfKDLzTepoaUw==",
          "dev": true
        },
        "@webassemblyjs/helper-wasm-section": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.9.0.tgz",
          "integrity": "sha512-XnMB8l3ek4tvrKUUku+IVaXNHz2YsJyOOmz+MMkZvh8h1uSJpSen6vYnw3IoQ7WwEuAhL8Efjms1ZWjqh2agvw==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-buffer": "1.9.0",
            "@webassemblyjs/helper-wasm-bytecode": "1.9.0",
            "@webassemblyjs/wasm-gen": "1.9.0"
          }
        },
        "@webassemblyjs/ieee754": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.9.0.tgz",
          "integrity": "sha512-dcX8JuYU/gvymzIHc9DgxTzUUTLexWwt8uCTWP3otys596io0L5aW02Gb1RjYpx2+0Jus1h4ZFqjla7umFniTg==",
          "dev": true,
          "requires": {
            "@xtuc/ieee754": "^1.2.0"
          }
        },
        "@webassemblyjs/leb128": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.9.0.tgz",
          "integrity": "sha512-ENVzM5VwV1ojs9jam6vPys97B/S65YQtv/aanqnU7D8aSoHFX8GyhGg0CMfyKNIHBuAVjy3tlzd5QMMINa7wpw==",
          "dev": true,
          "requires": {
            "@xtuc/long": "4.2.2"
          }
        },
        "@webassemblyjs/utf8": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.9.0.tgz",
          "integrity": "sha512-GZbQlWtopBTP0u7cHrEx+73yZKrQoBMpwkGEIqlacljhXCkVM1kMQge/Mf+csMJAjEdSwhOyLAS0AoR3AG5P8w==",
          "dev": true
        },
        "@webassemblyjs/wasm-edit": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.9.0.tgz",
          "integrity": "sha512-FgHzBm80uwz5M8WKnMTn6j/sVbqilPdQXTWraSjBwFXSYGirpkSWE2R9Qvz9tNiTKQvoKILpCuTjBKzOIm0nxw==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-buffer": "1.9.0",
            "@webassemblyjs/helper-wasm-bytecode": "1.9.0",
            "@webassemblyjs/helper-wasm-section": "1.9.0",
            "@webassemblyjs/wasm-gen": "1.9.0",
            "@webassemblyjs/wasm-opt": "1.9.0",
            "@webassemblyjs/wasm-parser": "1.9.0",
            "@webassemblyjs/wast-printer": "1.9.0"
          }
        },
        "@webassemblyjs/wasm-gen": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.9.0.tgz",
          "integrity": "sha512-cPE3o44YzOOHvlsb4+E9qSqjc9Qf9Na1OO/BHFy4OI91XDE14MjFN4lTMezzaIWdPqHnsTodGGNP+iRSYfGkjA==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-wasm-bytecode": "1.9.0",
            "@webassemblyjs/ieee754": "1.9.0",
            "@webassemblyjs/leb128": "1.9.0",
            "@webassemblyjs/utf8": "1.9.0"
          }
        },
        "@webassemblyjs/wasm-opt": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.9.0.tgz",
          "integrity": "sha512-Qkjgm6Anhm+OMbIL0iokO7meajkzQD71ioelnfPEj6r4eOFuqm4YC3VBPqXjFyyNwowzbMD+hizmprP/Fwkl2A==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-buffer": "1.9.0",
            "@webassemblyjs/wasm-gen": "1.9.0",
            "@webassemblyjs/wasm-parser": "1.9.0"
          }
        },
        "@webassemblyjs/wasm-parser": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.9.0.tgz",
          "integrity": "sha512-9+wkMowR2AmdSWQzsPEjFU7njh8HTO5MqO8vjwEHuM+AMHioNqSBONRdr0NQQ3dVQrzp0s8lTcYqzUdb7YgELA==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-api-error": "1.9.0",
            "@webassemblyjs/helper-wasm-bytecode": "1.9.0",
            "@webassemblyjs/ieee754": "1.9.0",
            "@webassemblyjs/leb128": "1.9.0",
            "@webassemblyjs/utf8": "1.9.0"
          }
        },
        "@webassemblyjs/wast-parser": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-parser/-/wast-parser-1.9.0.tgz",
          "integrity": "sha512-qsqSAP3QQ3LyZjNC/0jBJ/ToSxfYJ8kYyuiGvtn/8MK89VrNEfwj7BPQzJVHi0jGTRK2dGdJ5PRqhtjzoww+bw==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/floating-point-hex-parser": "1.9.0",
            "@webassemblyjs/helper-api-error": "1.9.0",
            "@webassemblyjs/helper-code-frame": "1.9.0",
            "@webassemblyjs/helper-fsm": "1.9.0",
            "@xtuc/long": "4.2.2"
          }
        },
        "@webassemblyjs/wast-printer": {
          "version": "1.9.0",
          "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.9.0.tgz",
          "integrity": "sha512-2J0nE95rHXHyQ24cWjMKJ1tqB/ds8z/cyeOZxJhcb+rW+SQASVjuznUSmdz5GpVJTzU8JkhYut0D3siFDD6wsA==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/wast-parser": "1.9.0",
            "@xtuc/long": "4.2.2"
          }
        },
        "ajv": {
          "version": "6.12.3",
          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.3.tgz",
          "integrity": "sha512-4K0cK3L1hsqk9xIb2z9vs/XU+PGJZ9PNpJRDS9YLzmNdX6jmVPfamLvTJr0aDAusnHyCHO6MjzlkAsgtqp9teA==",
          "dev": true,
          "requires": {
            "fast-deep-equal": "^3.1.1",
            "fast-json-stable-stringify": "^2.0.0",
            "json-schema-traverse": "^0.4.1",
            "uri-js": "^4.2.2"
          }
        },
        "array-union": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
          "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
          "dev": true
        },
        "babel-loader": {
          "version": "8.1.0",
          "resolved": "https://registry.npmjs.org/babel-loader/-/babel-loader-8.1.0.tgz",
          "integrity": "sha512-7q7nC1tYOrqvUrN3LQK4GwSk/TQorZSOlO9C+RZDZpODgyN4ZlCqE5q9cDsyWOliN+aU9B4JX01xK9eJXowJLw==",
          "dev": true,
          "requires": {
            "find-cache-dir": "^2.1.0",
            "loader-utils": "^1.4.0",
            "mkdirp": "^0.5.3",
            "pify": "^4.0.1",
            "schema-utils": "^2.6.5"
          },
          "dependencies": {
            "find-cache-dir": {
              "version": "2.1.0",
              "resolved": "https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-2.1.0.tgz",
              "integrity": "sha512-Tq6PixE0w/VMFfCgbONnkiQIVol/JJL7nRMi20fqzA4NRs9AfeqMGeRdPi3wIhYkxjeBaWh2rxwapn5Tu3IqOQ==",
              "dev": true,
              "requires": {
                "commondir": "^1.0.1",
                "make-dir": "^2.0.0",
                "pkg-dir": "^3.0.0"
              }
            },
            "json5": {
              "version": "1.0.1",
              "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
              "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
              "dev": true,
              "requires": {
                "minimist": "^1.2.0"
              }
            },
            "loader-utils": {
              "version": "1.4.0",
              "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.4.0.tgz",
              "integrity": "sha512-qH0WSMBtn/oHuwjy/NucEgbx5dbxxnxup9s4PVXJUDHZBQY+s0NWA9rJf53RBnQZxfch7euUui7hpoAPvALZdA==",
              "dev": true,
              "requires": {
                "big.js": "^5.2.2",
                "emojis-list": "^3.0.0",
                "json5": "^1.0.1"
              }
            }
          }
        },
        "cacache": {
          "version": "15.0.3",
          "resolved": "https://registry.npmjs.org/cacache/-/cacache-15.0.3.tgz",
          "integrity": "sha512-bc3jKYjqv7k4pWh7I/ixIjfcjPul4V4jme/WbjvwGS5LzoPL/GzXr4C5EgPNLO/QEZl9Oi61iGitYEdwcrwLCQ==",
          "dev": true,
          "requires": {
            "chownr": "^2.0.0",
            "fs-minipass": "^2.0.0",
            "glob": "^7.1.4",
            "infer-owner": "^1.0.4",
            "lru-cache": "^5.1.1",
            "minipass": "^3.1.1",
            "minipass-collect": "^1.0.2",
            "minipass-flush": "^1.0.5",
            "minipass-pipeline": "^1.2.2",
            "mkdirp": "^1.0.3",
            "move-file": "^2.0.0",
            "p-map": "^4.0.0",
            "promise-inflight": "^1.0.1",
            "rimraf": "^3.0.2",
            "ssri": "^8.0.0",
            "tar": "^6.0.2",
            "unique-filename": "^1.1.1"
          },
          "dependencies": {
            "mkdirp": {
              "version": "1.0.4",
              "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
              "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
              "dev": true
            }
          }
        },
        "chownr": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
          "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
          "dev": true
        },
        "copy-webpack-plugin": {
          "version": "6.0.3",
          "resolved": "https://registry.npmjs.org/copy-webpack-plugin/-/copy-webpack-plugin-6.0.3.tgz",
          "integrity": "sha512-q5m6Vz4elsuyVEIUXr7wJdIdePWTubsqVbEMvf1WQnHGv0Q+9yPRu7MtYFPt+GBOXRav9lvIINifTQ1vSCs+eA==",
          "dev": true,
          "requires": {
            "cacache": "^15.0.4",
            "fast-glob": "^3.2.4",
            "find-cache-dir": "^3.3.1",
            "glob-parent": "^5.1.1",
            "globby": "^11.0.1",
            "loader-utils": "^2.0.0",
            "normalize-path": "^3.0.0",
            "p-limit": "^3.0.1",
            "schema-utils": "^2.7.0",
            "serialize-javascript": "^4.0.0",
            "webpack-sources": "^1.4.3"
          },
          "dependencies": {
            "cacache": {
              "version": "15.0.5",
              "resolved": "https://registry.npmjs.org/cacache/-/cacache-15.0.5.tgz",
              "integrity": "sha512-lloiL22n7sOjEEXdL8NAjTgv9a1u43xICE9/203qonkZUCj5X1UEWIdf2/Y0d6QcCtMzbKQyhrcDbdvlZTs/+A==",
              "dev": true,
              "requires": {
                "@npmcli/move-file": "^1.0.1",
                "chownr": "^2.0.0",
                "fs-minipass": "^2.0.0",
                "glob": "^7.1.4",
                "infer-owner": "^1.0.4",
                "lru-cache": "^6.0.0",
                "minipass": "^3.1.1",
                "minipass-collect": "^1.0.2",
                "minipass-flush": "^1.0.5",
                "minipass-pipeline": "^1.2.2",
                "mkdirp": "^1.0.3",
                "p-map": "^4.0.0",
                "promise-inflight": "^1.0.1",
                "rimraf": "^3.0.2",
                "ssri": "^8.0.0",
                "tar": "^6.0.2",
                "unique-filename": "^1.1.1"
              }
            },
            "lru-cache": {
              "version": "6.0.0",
              "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
              "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
              "dev": true,
              "requires": {
                "yallist": "^4.0.0"
              }
            },
            "mkdirp": {
              "version": "1.0.4",
              "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
              "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
              "dev": true
            }
          }
        },
        "core-js": {
          "version": "3.6.4",
          "resolved": "https://registry.npmjs.org/core-js/-/core-js-3.6.4.tgz",
          "integrity": "sha512-4paDGScNgZP2IXXilaffL9X7968RuvwlkK3xWtZRVqgd8SYNiVKRJvkFd1aqqEuPfN7E68ZHEp9hDj6lHj4Hyw==",
          "dev": true
        },
        "dir-glob": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
          "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
          "dev": true,
          "requires": {
            "path-type": "^4.0.0"
          }
        },
        "find-cache-dir": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-3.3.1.tgz",
          "integrity": "sha512-t2GDMt3oGC/v+BMwzmllWDuJF/xcDtE5j/fCGbqDD7OLuJkj0cfh1YSA5VKPvwMeLFLNDBkwOKZ2X85jGLVftQ==",
          "dev": true,
          "requires": {
            "commondir": "^1.0.1",
            "make-dir": "^3.0.2",
            "pkg-dir": "^4.1.0"
          },
          "dependencies": {
            "make-dir": {
              "version": "3.1.0",
              "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
              "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
              "dev": true,
              "requires": {
                "semver": "^6.0.0"
              }
            },
            "pkg-dir": {
              "version": "4.2.0",
              "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
              "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
              "dev": true,
              "requires": {
                "find-up": "^4.0.0"
              }
            },
            "semver": {
              "version": "6.3.0",
              "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
              "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
              "dev": true
            }
          }
        },
        "globby": {
          "version": "11.0.1",
          "resolved": "https://registry.npmjs.org/globby/-/globby-11.0.1.tgz",
          "integrity": "sha512-iH9RmgwCmUJHi2z5o2l3eTtGBtXek1OYlHrbcxOYugyHLmAsZrPj43OtHThd62Buh/Vv6VyCBD2bdyWcGNQqoQ==",
          "dev": true,
          "requires": {
            "array-union": "^2.1.0",
            "dir-glob": "^3.0.1",
            "fast-glob": "^3.1.1",
            "ignore": "^5.1.4",
            "merge2": "^1.3.0",
            "slash": "^3.0.0"
          }
        },
        "ignore": {
          "version": "5.1.8",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.1.8.tgz",
          "integrity": "sha512-BMpfD7PpiETpBl/A6S498BaIJ6Y/ABT93ETbby2fP00v4EbvPBXWEoaR1UBPKs3iR53pJY7EtZk5KACI57i1Uw==",
          "dev": true
        },
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        },
        "make-dir": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-2.1.0.tgz",
          "integrity": "sha512-LS9X+dc8KLxXCb8dni79fLIIUA5VyZoyjSMCwTluaXA0o27cCK0bhXkpgw+sTXVpPy/lSO57ilRixqk0vDmtRA==",
          "dev": true,
          "requires": {
            "pify": "^4.0.1",
            "semver": "^5.6.0"
          },
          "dependencies": {
            "semver": {
              "version": "5.7.1",
              "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
              "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
              "dev": true
            }
          }
        },
        "open": {
          "version": "7.0.4",
          "resolved": "https://registry.npmjs.org/open/-/open-7.0.4.tgz",
          "integrity": "sha512-brSA+/yq+b08Hsr4c8fsEW2CRzk1BmfN3SAK/5VCHQ9bdoZJ4qa/+AfR0xHjlbbZUyPkUHs1b8x1RqdyZdkVqQ==",
          "dev": true,
          "requires": {
            "is-docker": "^2.0.0",
            "is-wsl": "^2.1.1"
          }
        },
        "p-limit": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.0.2.tgz",
          "integrity": "sha512-iwqZSOoWIW+Ew4kAGUlN16J4M7OB3ysMLSZtnhmqx7njIHFPlxWBX8xo3lVTyFVq6mI/lL9qt2IsN1sHwaxJkg==",
          "dev": true,
          "requires": {
            "p-try": "^2.0.0"
          }
        },
        "p-map": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
          "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
          "dev": true,
          "requires": {
            "aggregate-error": "^3.0.0"
          }
        },
        "path-type": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
          "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
          "dev": true
        },
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        },
        "serialize-javascript": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-4.0.0.tgz",
          "integrity": "sha512-GaNA54380uFefWghODBWEGisLZFj00nS5ACs6yHa9nLqlLpVLO8ChDGeKRjZnV4Nh4n0Qi7nhYZD/9fCPzEqkw==",
          "dev": true,
          "requires": {
            "randombytes": "^2.1.0"
          }
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        },
        "source-map-support": {
          "version": "0.5.19",
          "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.19.tgz",
          "integrity": "sha512-Wonm7zOCIJzBGQdB+thsPar0kYuCIzYvxZwlBa87yi/Mdjv7Tip2cyVbLj5o0cFPN4EVkuTwb3GDDyUx2DGnGw==",
          "dev": true,
          "requires": {
            "buffer-from": "^1.0.0",
            "source-map": "^0.6.0"
          },
          "dependencies": {
            "source-map": {
              "version": "0.6.1",
              "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
              "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
              "dev": true
            }
          }
        },
        "terser": {
          "version": "4.7.0",
          "resolved": "https://registry.npmjs.org/terser/-/terser-4.7.0.tgz",
          "integrity": "sha512-Lfb0RiZcjRDXCC3OSHJpEkxJ9Qeqs6mp2v4jf2MHfy8vGERmVDuvjXdd/EnP5Deme5F2yBRBymKmKHCBg2echw==",
          "dev": true,
          "requires": {
            "commander": "^2.20.0",
            "source-map": "~0.6.1",
            "source-map-support": "~0.5.12"
          },
          "dependencies": {
            "source-map": {
              "version": "0.6.1",
              "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
              "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
              "dev": true
            }
          }
        },
        "webpack": {
          "version": "4.43.0",
          "resolved": "https://registry.npmjs.org/webpack/-/webpack-4.43.0.tgz",
          "integrity": "sha512-GW1LjnPipFW2Y78OOab8NJlCflB7EFskMih2AHdvjbpKMeDJqEgSx24cXXXiPS65+WSwVyxtDsJH6jGX2czy+g==",
          "dev": true,
          "requires": {
            "@webassemblyjs/ast": "1.9.0",
            "@webassemblyjs/helper-module-context": "1.9.0",
            "@webassemblyjs/wasm-edit": "1.9.0",
            "@webassemblyjs/wasm-parser": "1.9.0",
            "acorn": "^6.4.1",
            "ajv": "^6.10.2",
            "ajv-keywords": "^3.4.1",
            "chrome-trace-event": "^1.0.2",
            "enhanced-resolve": "^4.1.0",
            "eslint-scope": "^4.0.3",
            "json-parse-better-errors": "^1.0.2",
            "loader-runner": "^2.4.0",
            "loader-utils": "^1.2.3",
            "memory-fs": "^0.4.1",
            "micromatch": "^3.1.10",
            "mkdirp": "^0.5.3",
            "neo-async": "^2.6.1",
            "node-libs-browser": "^2.2.1",
            "schema-utils": "^1.0.0",
            "tapable": "^1.1.3",
            "terser-webpack-plugin": "^1.4.3",
            "watchpack": "^1.6.1",
            "webpack-sources": "^1.4.1"
          },
          "dependencies": {
            "cacache": {
              "version": "12.0.4",
              "resolved": "https://registry.npmjs.org/cacache/-/cacache-12.0.4.tgz",
              "integrity": "sha512-a0tMB40oefvuInr4Cwb3GerbL9xTj1D5yg0T5xrjGCGyfvbxseIXX7BAO/u/hIXdafzOI5JC3wDwHyf24buOAQ==",
              "dev": true,
              "requires": {
                "bluebird": "^3.5.5",
                "chownr": "^1.1.1",
                "figgy-pudding": "^3.5.1",
                "glob": "^7.1.4",
                "graceful-fs": "^4.1.15",
                "infer-owner": "^1.0.3",
                "lru-cache": "^5.1.1",
                "mississippi": "^3.0.0",
                "mkdirp": "^0.5.1",
                "move-concurrently": "^1.0.1",
                "promise-inflight": "^1.0.1",
                "rimraf": "^2.6.3",
                "ssri": "^6.0.1",
                "unique-filename": "^1.1.1",
                "y18n": "^4.0.0"
              }
            },
            "chownr": {
              "version": "1.1.4",
              "resolved": "https://registry.npmjs.org/chownr/-/chownr-1.1.4.tgz",
              "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==",
              "dev": true
            },
            "find-cache-dir": {
              "version": "2.1.0",
              "resolved": "https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-2.1.0.tgz",
              "integrity": "sha512-Tq6PixE0w/VMFfCgbONnkiQIVol/JJL7nRMi20fqzA4NRs9AfeqMGeRdPi3wIhYkxjeBaWh2rxwapn5Tu3IqOQ==",
              "dev": true,
              "requires": {
                "commondir": "^1.0.1",
                "make-dir": "^2.0.0",
                "pkg-dir": "^3.0.0"
              }
            },
            "is-wsl": {
              "version": "1.1.0",
              "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-1.1.0.tgz",
              "integrity": "sha1-HxbkqiKwTRM2tmGIpmrzxgDDpm0=",
              "dev": true
            },
            "json5": {
              "version": "1.0.1",
              "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
              "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
              "dev": true,
              "requires": {
                "minimist": "^1.2.0"
              }
            },
            "loader-utils": {
              "version": "1.4.0",
              "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.4.0.tgz",
              "integrity": "sha512-qH0WSMBtn/oHuwjy/NucEgbx5dbxxnxup9s4PVXJUDHZBQY+s0NWA9rJf53RBnQZxfch7euUui7hpoAPvALZdA==",
              "dev": true,
              "requires": {
                "big.js": "^5.2.2",
                "emojis-list": "^3.0.0",
                "json5": "^1.0.1"
              }
            },
            "rimraf": {
              "version": "2.7.1",
              "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
              "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
              "dev": true,
              "requires": {
                "glob": "^7.1.3"
              }
            },
            "schema-utils": {
              "version": "1.0.0",
              "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
              "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
              "dev": true,
              "requires": {
                "ajv": "^6.1.0",
                "ajv-errors": "^1.0.0",
                "ajv-keywords": "^3.1.0"
              }
            },
            "source-map": {
              "version": "0.6.1",
              "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
              "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
              "dev": true
            },
            "ssri": {
              "version": "6.0.1",
              "resolved": "https://registry.npmjs.org/ssri/-/ssri-6.0.1.tgz",
              "integrity": "sha512-3Wge10hNcT1Kur4PDFwEieXSCMCJs/7WvSACcrMYrNp+b8kDL1/0wJch5Ni2WrtwEa2IO8OsVfeKIciKCDx/QA==",
              "dev": true,
              "requires": {
                "figgy-pudding": "^3.5.1"
              }
            },
            "terser-webpack-plugin": {
              "version": "1.4.5",
              "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-1.4.5.tgz",
              "integrity": "sha512-04Rfe496lN8EYruwi6oPQkG0vo8C+HT49X687FZnpPF0qMAIHONI6HEXYPKDOE8e5HjXTyKfqRd/agHtH0kOtw==",
              "dev": true,
              "requires": {
                "cacache": "^12.0.2",
                "find-cache-dir": "^2.1.0",
                "is-wsl": "^1.1.0",
                "schema-utils": "^1.0.0",
                "serialize-javascript": "^4.0.0",
                "source-map": "^0.6.1",
                "terser": "^4.1.2",
                "webpack-sources": "^1.4.0",
                "worker-farm": "^1.7.0"
              }
            }
          }
        }
      }
    },
    "@angular-devkit/build-optimizer": {
      "version": "0.1000.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/build-optimizer/-/build-optimizer-0.1000.6.tgz",
      "integrity": "sha512-R8zDEAvd9PeUKvOKh6I7xp3w+MViCwjGKoOZcznjH/i/9PQjOHCMwU5S48RQloQjMGu96eDMUGOVnd9qkzXUEw==",
      "dev": true,
      "requires": {
        "loader-utils": "2.0.0",
        "source-map": "0.7.3",
        "tslib": "2.0.0",
        "webpack-sources": "1.4.3"
      },
      "dependencies": {
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        },
        "tslib": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz",
          "integrity": "sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g==",
          "dev": true
        }
      }
    },
    "@angular-devkit/build-webpack": {
      "version": "0.1000.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/build-webpack/-/build-webpack-0.1000.6.tgz",
      "integrity": "sha512-R01bJWuvckU5IdjcqoCeikLBpHRqt5fgfD0a4Hsg3evqW6xxXcSgc+YhWfeEmyU/nF/kVel8G2bFyPzhZP4QdQ==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "0.1000.6",
        "@angular-devkit/core": "10.0.6",
        "rxjs": "6.5.5"
      }
    },
    "@angular-devkit/core": {
      "version": "10.0.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/core/-/core-10.0.6.tgz",
      "integrity": "sha512-mVvqSEoeErZ7bAModk95EAa6R9Nl23rvX+/TXuKVTK2dziMFBOrwHjb1DYhnZxFIH4xfUftCx+BWHjXBXCPYlA==",
      "requires": {
        "ajv": "6.12.3",
        "fast-json-stable-stringify": "2.1.0",
        "magic-string": "0.25.7",
        "rxjs": "6.5.5",
        "source-map": "0.7.3"
      },
      "dependencies": {
        "ajv": {
          "version": "6.12.3",
          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.3.tgz",
          "integrity": "sha512-4K0cK3L1hsqk9xIb2z9vs/XU+PGJZ9PNpJRDS9YLzmNdX6jmVPfamLvTJr0aDAusnHyCHO6MjzlkAsgtqp9teA==",
          "requires": {
            "fast-deep-equal": "^3.1.1",
            "fast-json-stable-stringify": "^2.0.0",
            "json-schema-traverse": "^0.4.1",
            "uri-js": "^4.2.2"
          }
        }
      }
    },
    "@angular-devkit/schematics": {
      "version": "10.0.6",
      "resolved": "https://registry.npmjs.org/@angular-devkit/schematics/-/schematics-10.0.6.tgz",
      "integrity": "sha512-V3T4cf+jVKiPYyBrSVHf3ZSnk4wIc1WEaaeFta56HccEGQCQpvAFKqDurmtMHer50Hhaxhn7IC3Oi5kPnvkNyQ==",
      "requires": {
        "@angular-devkit/core": "10.0.6",
        "ora": "4.0.4",
        "rxjs": "6.5.5"
      }
    },
    "@angular/animations": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/animations/-/animations-10.0.10.tgz",
      "integrity": "sha512-lIbNeLVVl9bO41orPFpKoobCvxZIZ2wdcKJBEFtQiOdw0khRQQ8k7so4TAWOZXRJR+MkOUCjU2pO8gbMXgBweQ==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/cdk": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/@angular/cdk/-/cdk-9.2.2.tgz",
      "integrity": "sha512-VNd+KuMN6cBcy4/8OyMxqYaxdjPP6IyCqIVijB2JREkc5Sg4VWmPgx2L3rHt/DzjsVBVRgx35uqOMymDezG3jQ==",
      "requires": {
        "parse5": "^5.0.0"
      },
      "dependencies": {
        "parse5": {
          "version": "5.1.1",
          "resolved": "https://registry.npmjs.org/parse5/-/parse5-5.1.1.tgz",
          "integrity": "sha512-ugq4DFI0Ptb+WWjAdOK16+u/nHfiIrcE+sh8kZMaM0WllQKLI9rOUq6c2b7cwPkXdzfQESqvoqK6ug7U/Yyzug==",
          "optional": true
        }
      }
    },
    "@angular/cli": {
      "version": "10.0.6",
      "resolved": "https://registry.npmjs.org/@angular/cli/-/cli-10.0.6.tgz",
      "integrity": "sha512-gQbQA/CsCyMf9RKEv1hJBCdBebV2BHeT4lGi56Eii0IkvZD5WIH0dNfQzR+6ErqGDgE1EI+9YCuX3psMEvCRUA==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "0.1000.6",
        "@angular-devkit/core": "10.0.6",
        "@angular-devkit/schematics": "10.0.6",
        "@schematics/angular": "10.0.6",
        "@schematics/update": "0.1000.6",
        "@yarnpkg/lockfile": "1.1.0",
        "ansi-colors": "4.1.1",
        "debug": "4.1.1",
        "ini": "1.3.5",
        "inquirer": "7.1.0",
        "npm-package-arg": "8.0.1",
        "npm-pick-manifest": "6.1.0",
        "open": "7.0.4",
        "pacote": "9.5.12",
        "read-package-tree": "5.3.1",
        "rimraf": "3.0.2",
        "semver": "7.3.2",
        "symbol-observable": "1.2.0",
        "universal-analytics": "0.4.20",
        "uuid": "8.1.0"
      },
      "dependencies": {
        "ansi-colors": {
          "version": "4.1.1",
          "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
          "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
          "dev": true
        },
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        },
        "uuid": {
          "version": "8.1.0",
          "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.1.0.tgz",
          "integrity": "sha512-CI18flHDznR0lq54xBycOVmphdCYnQLKn8abKn7PXUiKUGdEd+/l9LWNJmugXel4hXq7S+RMNl34ecyC9TntWg==",
          "dev": true
        }
      }
    },
    "@angular/common": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/common/-/common-10.0.10.tgz",
      "integrity": "sha512-p6/pTk0s0Ai5uUkOHHFZwp+TjxRNPldPxTU2LVxg2xuBEQTO53BsfBKn3zi74epdb1kBC0Yjdj6yEL4dITBs7A==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/compiler": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/compiler/-/compiler-10.0.10.tgz",
      "integrity": "sha512-fO7kml0HUgnMa5eviKUk+j7NACASkoMAEgvbcVdKmGsSDu9YVkaqSdLXuj2vu9glSJWDRkZJKSrt9MzbmhyB5A==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/compiler-cli": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/compiler-cli/-/compiler-cli-10.0.10.tgz",
      "integrity": "sha512-XkvWdJKr6HkyzAbcmy99HyDR4z949z9nHGwHNLBQjLbkX11i03fvS3bI5kgwqtNiLWYqxiPfXnpAyLBeFghCcw==",
      "dev": true,
      "requires": {
        "canonical-path": "1.0.0",
        "chokidar": "^3.0.0",
        "convert-source-map": "^1.5.1",
        "dependency-graph": "^0.7.2",
        "fs-extra": "4.0.2",
        "magic-string": "^0.25.0",
        "minimist": "^1.2.0",
        "reflect-metadata": "^0.1.2",
        "semver": "^6.3.0",
        "source-map": "^0.6.1",
        "sourcemap-codec": "^1.4.8",
        "tslib": "^2.0.0",
        "yargs": "15.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ==",
          "dev": true
        }
      }
    },
    "@angular/core": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/core/-/core-10.0.10.tgz",
      "integrity": "sha512-PIQhLqjZayVXJoXs4WQu7orkePqFiux19y7bgBrsSAithe+g9BkrSIdX7+tkkX0zggUWKywY92YuMZCJ/S+uiw==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/forms": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/forms/-/forms-10.0.10.tgz",
      "integrity": "sha512-bWjbsqMTiCNQZzXAfiEwT/tiAzSvChnqBimrJWNSHVYRkp71TkDcKXn6mA+E//YR0eZ84GKNNiVlKFxqkmeyqQ==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/language-service": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/language-service/-/language-service-10.0.10.tgz",
      "integrity": "sha512-Id3hmPR5UeWAKsDeB6+O7m+4+FpUr5zcYdM8xXAzTjjn8laSuDUMb17wsAVRntPgRJv4SeaqUbWevwSkM5KExA==",
      "dev": true
    },
    "@angular/material": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/@angular/material/-/material-9.2.2.tgz",
      "integrity": "sha512-gdQiMJ6PtW/5fd+0mglHFyzxULDCBGjn9RTET3sUq2rkc9+jBXr4OvnsUyBWSnqqv97XqotVDIx5JgE4/YX/Rw=="
    },
    "@angular/platform-browser": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/platform-browser/-/platform-browser-10.0.10.tgz",
      "integrity": "sha512-srNGkvg9177skff7QOe3L+nGOSbrKLzFt3Z5O3oM0N0TWr8QlWEA+zQm8n0zLHI8AmdZbmFzAYYJiBvVCSc5RQ==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/platform-browser-dynamic": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/platform-browser-dynamic/-/platform-browser-dynamic-10.0.10.tgz",
      "integrity": "sha512-6jbn0Ldyc+80BCETGtE7pzfKlbjfa/wEPhLEGWoYtxrrJ5UB3CblGpDMOsv1ibOQijPZ/JSmIMmAxz66+pLx3g==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@angular/router": {
      "version": "10.0.10",
      "resolved": "https://registry.npmjs.org/@angular/router/-/router-10.0.10.tgz",
      "integrity": "sha512-wDmr/Spuv4OhPK5a49AvgJhaedRw4yb7nmPMd51sWqzOV31RRcGXORjiXZOcSpElLxM9f7JV0tWDR5p5ko/kPA==",
      "requires": {
        "tslib": "^2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.1.tgz",
          "integrity": "sha512-SgIkNheinmEBgx1IUNirK0TUD4X9yjjBRTqqjggWCU3pUEqIk3/Uwl3yRixYKT6WjQuGiwDv4NomL3wqRCj+CQ=="
        }
      }
    },
    "@babel/code-frame": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.8.3.tgz",
      "integrity": "sha512-a9gxpmdXtZEInkCSHUJDLHZVBgb1QS0jhss4cPP93EW7s+uC5bikET2twEF3KV+7rDblJcmNvTR7VJejqd2C2g==",
      "requires": {
        "@babel/highlight": "^7.8.3"
      }
    },
    "@babel/compat-data": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.9.6.tgz",
      "integrity": "sha512-5QPTrNen2bm7RBc7dsOmcA5hbrS4O2Vhmk5XOL4zWW/zD/hV0iinpefDlkm+tBBy8kDtFaaeEvmAqt+nURAV2g==",
      "dev": true,
      "requires": {
        "browserslist": "^4.11.1",
        "invariant": "^2.2.4",
        "semver": "^5.5.0"
      }
    },
    "@babel/core": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.9.0.tgz",
      "integrity": "sha512-kWc7L0fw1xwvI0zi8OKVBuxRVefwGOrKSQMvrQ3dW+bIIavBY3/NpXmpjMy7bQnLgwgzWQZ8TlM57YHpHNHz4w==",
      "requires": {
        "@babel/code-frame": "^7.8.3",
        "@babel/generator": "^7.9.0",
        "@babel/helper-module-transforms": "^7.9.0",
        "@babel/helpers": "^7.9.0",
        "@babel/parser": "^7.9.0",
        "@babel/template": "^7.8.6",
        "@babel/traverse": "^7.9.0",
        "@babel/types": "^7.9.0",
        "convert-source-map": "^1.7.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.1",
        "json5": "^2.1.2",
        "lodash": "^4.17.13",
        "resolve": "^1.3.2",
        "semver": "^5.4.1",
        "source-map": "^0.5.0"
      },
      "dependencies": {
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="
        }
      }
    },
    "@babel/generator": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.9.6.tgz",
      "integrity": "sha512-+htwWKJbH2bL72HRluF8zumBxzuX0ZZUFl3JLNyoUjM/Ho8wnVpPXM6aUz8cfKDqQ/h7zHqKt4xzJteUosckqQ==",
      "requires": {
        "@babel/types": "^7.9.6",
        "jsesc": "^2.5.1",
        "lodash": "^4.17.13",
        "source-map": "^0.5.0"
      },
      "dependencies": {
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="
        }
      }
    },
    "@babel/helper-annotate-as-pure": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.8.3.tgz",
      "integrity": "sha512-6o+mJrZBxOoEX77Ezv9zwW7WV8DdluouRKNY/IR5u/YTMuKHgugHOzYWlYvYLpLA9nPsQCAAASpCIbjI9Mv+Uw==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-builder-binary-assignment-operator-visitor": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-builder-binary-assignment-operator-visitor/-/helper-builder-binary-assignment-operator-visitor-7.8.3.tgz",
      "integrity": "sha512-5eFOm2SyFPK4Rh3XMMRDjN7lBH0orh3ss0g3rTYZnBQ+r6YPj7lgDyCvPphynHvUrobJmeMignBr6Acw9mAPlw==",
      "dev": true,
      "requires": {
        "@babel/helper-explode-assignable-expression": "^7.8.3",
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-compilation-targets": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.9.6.tgz",
      "integrity": "sha512-x2Nvu0igO0ejXzx09B/1fGBxY9NXQlBW2kZsSxCJft+KHN8t9XWzIvFxtPHnBOAXpVsdxZKZFbRUC8TsNKajMw==",
      "dev": true,
      "requires": {
        "@babel/compat-data": "^7.9.6",
        "browserslist": "^4.11.1",
        "invariant": "^2.2.4",
        "levenary": "^1.1.1",
        "semver": "^5.5.0"
      }
    },
    "@babel/helper-create-class-features-plugin": {
      "version": "7.10.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.10.5.tgz",
      "integrity": "sha512-0nkdeijB7VlZoLT3r/mY3bUkw3T8WG/hNw+FATs/6+pG2039IJWjTYL0VTISqsNHMUTEnwbVnc89WIJX9Qed0A==",
      "optional": true,
      "requires": {
        "@babel/helper-function-name": "^7.10.4",
        "@babel/helper-member-expression-to-functions": "^7.10.5",
        "@babel/helper-optimise-call-expression": "^7.10.4",
        "@babel/helper-plugin-utils": "^7.10.4",
        "@babel/helper-replace-supers": "^7.10.4",
        "@babel/helper-split-export-declaration": "^7.10.4"
      },
      "dependencies": {
        "@babel/code-frame": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.10.4.tgz",
          "integrity": "sha512-vG6SvB6oYEhvgisZNFRmRCUkLz11c7rp+tbNTynGqc6mS1d5ATd/sGyV6W0KZZnXRKMTzZDRgQT3Ou9jhpAfUg==",
          "optional": true,
          "requires": {
            "@babel/highlight": "^7.10.4"
          }
        },
        "@babel/generator": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.11.0.tgz",
          "integrity": "sha512-fEm3Uzw7Mc9Xi//qU20cBKatTfs2aOtKqmvy/Vm7RkJEGFQ4xc9myCfbXxqK//ZS8MR/ciOHw6meGASJuKmDfQ==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0",
            "jsesc": "^2.5.1",
            "source-map": "^0.5.0"
          }
        },
        "@babel/helper-function-name": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.10.4.tgz",
          "integrity": "sha512-YdaSyz1n8gY44EmN7x44zBn9zQ1Ry2Y+3GTA+3vH6Mizke1Vw0aWDM66FOYEPw8//qKkmqOckrGgTYa+6sceqQ==",
          "optional": true,
          "requires": {
            "@babel/helper-get-function-arity": "^7.10.4",
            "@babel/template": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-get-function-arity": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-get-function-arity/-/helper-get-function-arity-7.10.4.tgz",
          "integrity": "sha512-EkN3YDB+SRDgiIUnNgcmiD361ti+AVbL3f3Henf6dqqUyr5dMsorno0lJWJuLhDhkI5sYEpgj6y9kB8AOU1I2A==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-member-expression-to-functions": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.11.0.tgz",
          "integrity": "sha512-JbFlKHFntRV5qKw3YC0CvQnDZ4XMwgzzBbld7Ly4Mj4cbFy3KywcR8NtNctRToMWJOVvLINJv525Gd6wwVEx/Q==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0"
          }
        },
        "@babel/helper-optimise-call-expression": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.10.4.tgz",
          "integrity": "sha512-n3UGKY4VXwXThEiKrgRAoVPBMqeoPgHVqiHZOanAJCG9nQUL2pLRQirUzl0ioKclHGpGqRgIOkgcIJaIWLpygg==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        },
        "@babel/helper-replace-supers": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.10.4.tgz",
          "integrity": "sha512-sPxZfFXocEymYTdVK1UNmFPBN+Hv5mJkLPsYWwGBxZAxaWfFu+xqp7b6qWD0yjNuNL2VKc6L5M18tOXUP7NU0A==",
          "optional": true,
          "requires": {
            "@babel/helper-member-expression-to-functions": "^7.10.4",
            "@babel/helper-optimise-call-expression": "^7.10.4",
            "@babel/traverse": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-split-export-declaration": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.11.0.tgz",
          "integrity": "sha512-74Vejvp6mHkGE+m+k5vHY93FX2cAtrw1zXrZXRlG4l410Nm9PxfEiVTn1PjDPV5SnmieiueY4AFg2xqhNFuuZg==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0"
          }
        },
        "@babel/helper-validator-identifier": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.10.4.tgz",
          "integrity": "sha512-3U9y+43hz7ZM+rzG24Qe2mufW5KhvFg/NhnNph+i9mgCtdTCtMJuI1TMkrIUiK7Ix4PYlRF9I5dhqaLYA/ADXw==",
          "optional": true
        },
        "@babel/highlight": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.10.4.tgz",
          "integrity": "sha512-i6rgnR/YgPEQzZZnbTHHuZdlE8qyoBNalD6F+q4vAFlcMEcqmkoG+mPqJYJCo63qPf74+Y1UZsl3l6f7/RIkmA==",
          "optional": true,
          "requires": {
            "@babel/helper-validator-identifier": "^7.10.4",
            "chalk": "^2.0.0",
            "js-tokens": "^4.0.0"
          }
        },
        "@babel/parser": {
          "version": "7.11.3",
          "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.11.3.tgz",
          "integrity": "sha512-REo8xv7+sDxkKvoxEywIdsNFiZLybwdI7hcT5uEPyQrSMB4YQ973BfC9OOrD/81MaIjh6UxdulIQXkjmiH3PcA==",
          "optional": true
        },
        "@babel/template": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.10.4.tgz",
          "integrity": "sha512-ZCjD27cGJFUB6nmCB1Enki3r+L5kJveX9pq1SvAUKoICy6CZ9yD8xO086YXdYhvNjBdnekm4ZnaP5yC8Cs/1tA==",
          "optional": true,
          "requires": {
            "@babel/code-frame": "^7.10.4",
            "@babel/parser": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/traverse": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.11.0.tgz",
          "integrity": "sha512-ZB2V+LskoWKNpMq6E5UUCrjtDUh5IOTAyIl0dTjIEoXum/iKWkoIEKIRDnUucO6f+2FzNkE0oD4RLKoPIufDtg==",
          "optional": true,
          "requires": {
            "@babel/code-frame": "^7.10.4",
            "@babel/generator": "^7.11.0",
            "@babel/helper-function-name": "^7.10.4",
            "@babel/helper-split-export-declaration": "^7.11.0",
            "@babel/parser": "^7.11.0",
            "@babel/types": "^7.11.0",
            "debug": "^4.1.0",
            "globals": "^11.1.0",
            "lodash": "^4.17.19"
          }
        },
        "@babel/types": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.11.0.tgz",
          "integrity": "sha512-O53yME4ZZI0jO1EVGtF1ePGl0LHirG4P1ibcD80XyzZcKhcMFeCXmh4Xb1ifGBIV233Qg12x4rBfQgA+tmOukA==",
          "optional": true,
          "requires": {
            "@babel/helper-validator-identifier": "^7.10.4",
            "lodash": "^4.17.19",
            "to-fast-properties": "^2.0.0"
          }
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "optional": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
          "optional": true
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "optional": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@babel/helper-create-regexp-features-plugin": {
      "version": "7.8.8",
      "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.8.8.tgz",
      "integrity": "sha512-LYVPdwkrQEiX9+1R29Ld/wTrmQu1SSKYnuOk3g0CkcZMA1p0gsNxJFj/3gBdaJ7Cg0Fnek5z0DsMULePP7Lrqg==",
      "requires": {
        "@babel/helper-annotate-as-pure": "^7.8.3",
        "@babel/helper-regex": "^7.8.3",
        "regexpu-core": "^4.7.0"
      }
    },
    "@babel/helper-define-map": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-define-map/-/helper-define-map-7.8.3.tgz",
      "integrity": "sha512-PoeBYtxoZGtct3md6xZOCWPcKuMuk3IHhgxsRRNtnNShebf4C8YonTSblsK4tvDbm+eJAw2HAPOfCr+Q/YRG/g==",
      "dev": true,
      "requires": {
        "@babel/helper-function-name": "^7.8.3",
        "@babel/types": "^7.8.3",
        "lodash": "^4.17.13"
      }
    },
    "@babel/helper-explode-assignable-expression": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-explode-assignable-expression/-/helper-explode-assignable-expression-7.8.3.tgz",
      "integrity": "sha512-N+8eW86/Kj147bO9G2uclsg5pwfs/fqqY5rwgIL7eTBklgXjcOJ3btzS5iM6AitJcftnY7pm2lGsrJVYLGjzIw==",
      "dev": true,
      "requires": {
        "@babel/traverse": "^7.8.3",
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-function-name": {
      "version": "7.9.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.9.5.tgz",
      "integrity": "sha512-JVcQZeXM59Cd1qanDUxv9fgJpt3NeKUaqBqUEvfmQ+BCOKq2xUgaWZW2hr0dkbyJgezYuplEoh5knmrnS68efw==",
      "requires": {
        "@babel/helper-get-function-arity": "^7.8.3",
        "@babel/template": "^7.8.3",
        "@babel/types": "^7.9.5"
      }
    },
    "@babel/helper-get-function-arity": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-get-function-arity/-/helper-get-function-arity-7.8.3.tgz",
      "integrity": "sha512-FVDR+Gd9iLjUMY1fzE2SR0IuaJToR4RkCDARVfsBBPSP53GEqSFjD8gNyxg246VUyc/ALRxFaAK8rVG7UT7xRA==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-hoist-variables": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.8.3.tgz",
      "integrity": "sha512-ky1JLOjcDUtSc+xkt0xhYff7Z6ILTAHKmZLHPxAhOP0Nd77O+3nCsd6uSVYur6nJnCI029CrNbYlc0LoPfAPQg==",
      "dev": true,
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-member-expression-to-functions": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.8.3.tgz",
      "integrity": "sha512-fO4Egq88utkQFjbPrSHGmGLFqmrshs11d46WI+WZDESt7Wu7wN2G2Iu+NMMZJFDOVRHAMIkB5SNh30NtwCA7RA==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-module-imports": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.8.3.tgz",
      "integrity": "sha512-R0Bx3jippsbAEtzkpZ/6FIiuzOURPcMjHp+Z6xPe6DtApDJx+w7UYyOLanZqO8+wKR9G10s/FmHXvxaMd9s6Kg==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-module-transforms": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.9.0.tgz",
      "integrity": "sha512-0FvKyu0gpPfIQ8EkxlrAydOWROdHpBmiCiRwLkUiBGhCUPRRbVD2/tm3sFr/c/GWFrQ/ffutGUAnx7V0FzT2wA==",
      "requires": {
        "@babel/helper-module-imports": "^7.8.3",
        "@babel/helper-replace-supers": "^7.8.6",
        "@babel/helper-simple-access": "^7.8.3",
        "@babel/helper-split-export-declaration": "^7.8.3",
        "@babel/template": "^7.8.6",
        "@babel/types": "^7.9.0",
        "lodash": "^4.17.13"
      }
    },
    "@babel/helper-optimise-call-expression": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.8.3.tgz",
      "integrity": "sha512-Kag20n86cbO2AvHca6EJsvqAd82gc6VMGule4HwebwMlwkpXuVqrNRj6CkCV2sKxgi9MyAUnZVnZ6lJ1/vKhHQ==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-plugin-utils": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.8.3.tgz",
      "integrity": "sha512-j+fq49Xds2smCUNYmEHF9kGNkhbet6yVIBp4e6oeQpH1RUs/Ir06xUKzDjDkGcaaokPiTNs2JBWHjaE4csUkZQ=="
    },
    "@babel/helper-regex": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-regex/-/helper-regex-7.8.3.tgz",
      "integrity": "sha512-BWt0QtYv/cg/NecOAZMdcn/waj/5P26DR4mVLXfFtDokSR6fyuG0Pj+e2FqtSME+MqED1khnSMulkmGl8qWiUQ==",
      "requires": {
        "lodash": "^4.17.13"
      }
    },
    "@babel/helper-remap-async-to-generator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.8.3.tgz",
      "integrity": "sha512-kgwDmw4fCg7AVgS4DukQR/roGp+jP+XluJE5hsRZwxCYGg+Rv9wSGErDWhlI90FODdYfd4xG4AQRiMDjjN0GzA==",
      "dev": true,
      "requires": {
        "@babel/helper-annotate-as-pure": "^7.8.3",
        "@babel/helper-wrap-function": "^7.8.3",
        "@babel/template": "^7.8.3",
        "@babel/traverse": "^7.8.3",
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-replace-supers": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.9.6.tgz",
      "integrity": "sha512-qX+chbxkbArLyCImk3bWV+jB5gTNU/rsze+JlcF6Nf8tVTigPJSI1o1oBow/9Resa1yehUO9lIipsmu9oG4RzA==",
      "requires": {
        "@babel/helper-member-expression-to-functions": "^7.8.3",
        "@babel/helper-optimise-call-expression": "^7.8.3",
        "@babel/traverse": "^7.9.6",
        "@babel/types": "^7.9.6"
      }
    },
    "@babel/helper-simple-access": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.8.3.tgz",
      "integrity": "sha512-VNGUDjx5cCWg4vvCTR8qQ7YJYZ+HBjxOgXEl7ounz+4Sn7+LMD3CFrCTEU6/qXKbA2nKg21CwhhBzO0RpRbdCw==",
      "requires": {
        "@babel/template": "^7.8.3",
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-skip-transparent-expression-wrappers": {
      "version": "7.11.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-skip-transparent-expression-wrappers/-/helper-skip-transparent-expression-wrappers-7.11.0.tgz",
      "integrity": "sha512-0XIdiQln4Elglgjbwo9wuJpL/K7AGCY26kmEt0+pRP0TAj4jjyNq1MjoRvikrTVqKcx4Gysxt4cXvVFXP/JO2Q==",
      "optional": true,
      "requires": {
        "@babel/types": "^7.11.0"
      },
      "dependencies": {
        "@babel/helper-validator-identifier": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.10.4.tgz",
          "integrity": "sha512-3U9y+43hz7ZM+rzG24Qe2mufW5KhvFg/NhnNph+i9mgCtdTCtMJuI1TMkrIUiK7Ix4PYlRF9I5dhqaLYA/ADXw==",
          "optional": true
        },
        "@babel/types": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.11.0.tgz",
          "integrity": "sha512-O53yME4ZZI0jO1EVGtF1ePGl0LHirG4P1ibcD80XyzZcKhcMFeCXmh4Xb1ifGBIV233Qg12x4rBfQgA+tmOukA==",
          "optional": true,
          "requires": {
            "@babel/helper-validator-identifier": "^7.10.4",
            "lodash": "^4.17.19",
            "to-fast-properties": "^2.0.0"
          }
        }
      }
    },
    "@babel/helper-split-export-declaration": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.8.3.tgz",
      "integrity": "sha512-3x3yOeyBhW851hroze7ElzdkeRXQYQbFIb7gLK1WQYsw2GWDay5gAJNw1sWJ0VFP6z5J1whqeXH/WCdCjZv6dA==",
      "requires": {
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helper-validator-identifier": {
      "version": "7.9.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.9.5.tgz",
      "integrity": "sha512-/8arLKUFq882w4tWGj9JYzRpAlZgiWUJ+dtteNTDqrRBz9Iguck9Rn3ykuBDoUwh2TO4tSAJlrxDUOXWklJe4g=="
    },
    "@babel/helper-wrap-function": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.8.3.tgz",
      "integrity": "sha512-LACJrbUET9cQDzb6kG7EeD7+7doC3JNvUgTEQOx2qaO1fKlzE/Bf05qs9w1oXQMmXlPO65lC3Tq9S6gZpTErEQ==",
      "dev": true,
      "requires": {
        "@babel/helper-function-name": "^7.8.3",
        "@babel/template": "^7.8.3",
        "@babel/traverse": "^7.8.3",
        "@babel/types": "^7.8.3"
      }
    },
    "@babel/helpers": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.9.6.tgz",
      "integrity": "sha512-tI4bUbldloLcHWoRUMAj4g1bF313M/o6fBKhIsb3QnGVPwRm9JsNf/gqMkQ7zjqReABiffPV6RWj7hEglID5Iw==",
      "requires": {
        "@babel/template": "^7.8.3",
        "@babel/traverse": "^7.9.6",
        "@babel/types": "^7.9.6"
      }
    },
    "@babel/highlight": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.9.0.tgz",
      "integrity": "sha512-lJZPilxX7Op3Nv/2cvFdnlepPXDxi29wxteT57Q965oc5R9v86ztx0jfxVrTcBk8C2kcPkkDa2Z4T3ZsPPVWsQ==",
      "requires": {
        "@babel/helper-validator-identifier": "^7.9.0",
        "chalk": "^2.0.0",
        "js-tokens": "^4.0.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@babel/parser": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.9.6.tgz",
      "integrity": "sha512-AoeIEJn8vt+d/6+PXDRPaksYhnlbMIiejioBZvvMQsOjW/JYK6k/0dKnvvP3EhK5GfMBWDPtrxRtegWdAcdq9Q=="
    },
    "@babel/plugin-proposal-async-generator-functions": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-async-generator-functions/-/plugin-proposal-async-generator-functions-7.8.3.tgz",
      "integrity": "sha512-NZ9zLv848JsV3hs8ryEh7Uaz/0KsmPLqv0+PdkDJL1cJy0K4kOCFa8zc1E3mp+RHPQcpdfb/6GovEsW4VDrOMw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-remap-async-to-generator": "^7.8.3",
        "@babel/plugin-syntax-async-generators": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-class-properties": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-class-properties/-/plugin-proposal-class-properties-7.10.4.tgz",
      "integrity": "sha512-vhwkEROxzcHGNu2mzUC0OFFNXdZ4M23ib8aRRcJSsW8BZK9pQMD7QB7csl97NBbgGZO7ZyHUyKDnxzOaP4IrCg==",
      "optional": true,
      "requires": {
        "@babel/helper-create-class-features-plugin": "^7.10.4",
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "dependencies": {
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        }
      }
    },
    "@babel/plugin-proposal-dynamic-import": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-dynamic-import/-/plugin-proposal-dynamic-import-7.8.3.tgz",
      "integrity": "sha512-NyaBbyLFXFLT9FP+zk0kYlUlA8XtCUbehs67F0nnEg7KICgMc2mNkIeu9TYhKzyXMkrapZFwAhXLdnt4IYHy1w==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-dynamic-import": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-export-namespace-from": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-export-namespace-from/-/plugin-proposal-export-namespace-from-7.10.4.tgz",
      "integrity": "sha512-aNdf0LY6/3WXkhh0Fdb6Zk9j1NMD8ovj3F6r0+3j837Pn1S1PdNtcwJ5EG9WkVPNHPxyJDaxMaAOVq4eki0qbg==",
      "optional": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.10.4",
        "@babel/plugin-syntax-export-namespace-from": "^7.8.3"
      },
      "dependencies": {
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        }
      }
    },
    "@babel/plugin-proposal-json-strings": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-json-strings/-/plugin-proposal-json-strings-7.8.3.tgz",
      "integrity": "sha512-KGhQNZ3TVCQG/MjRbAUwuH+14y9q0tpxs1nWWs3pbSleRdDro9SAMMDyye8HhY1gqZ7/NqIc8SKhya0wRDgP1Q==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-json-strings": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-logical-assignment-operators": {
      "version": "7.11.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-logical-assignment-operators/-/plugin-proposal-logical-assignment-operators-7.11.0.tgz",
      "integrity": "sha512-/f8p4z+Auz0Uaf+i8Ekf1iM7wUNLcViFUGiPxKeXvxTSl63B875YPiVdUDdem7hREcI0E0kSpEhS8tF5RphK7Q==",
      "optional": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.10.4",
        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4"
      },
      "dependencies": {
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        },
        "@babel/plugin-syntax-logical-assignment-operators": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
          "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        }
      }
    },
    "@babel/plugin-proposal-nullish-coalescing-operator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-nullish-coalescing-operator/-/plugin-proposal-nullish-coalescing-operator-7.8.3.tgz",
      "integrity": "sha512-TS9MlfzXpXKt6YYomudb/KU7nQI6/xnapG6in1uZxoxDghuSMZsPb6D2fyUwNYSAp4l1iR7QtFOjkqcRYcUsfw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-numeric-separator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-numeric-separator/-/plugin-proposal-numeric-separator-7.8.3.tgz",
      "integrity": "sha512-jWioO1s6R/R+wEHizfaScNsAx+xKgwTLNXSh7tTC4Usj3ItsPEhYkEpU4h+lpnBwq7NBVOJXfO6cRFYcX69JUQ==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-numeric-separator": "^7.8.3"
      }
    },
    "@babel/plugin-proposal-object-rest-spread": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-object-rest-spread/-/plugin-proposal-object-rest-spread-7.9.6.tgz",
      "integrity": "sha512-Ga6/fhGqA9Hj+y6whNpPv8psyaK5xzrQwSPsGPloVkvmH+PqW1ixdnfJ9uIO06OjQNYol3PMnfmJ8vfZtkzF+A==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-object-rest-spread": "^7.8.0",
        "@babel/plugin-transform-parameters": "^7.9.5"
      }
    },
    "@babel/plugin-proposal-optional-catch-binding": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-catch-binding/-/plugin-proposal-optional-catch-binding-7.8.3.tgz",
      "integrity": "sha512-0gkX7J7E+AtAw9fcwlVQj8peP61qhdg/89D5swOkjYbkboA2CVckn3kiyum1DE0wskGb7KJJxBdyEBApDLLVdw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-optional-catch-binding": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-optional-chaining": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-chaining/-/plugin-proposal-optional-chaining-7.9.0.tgz",
      "integrity": "sha512-NDn5tu3tcv4W30jNhmc2hyD5c56G6cXx4TesJubhxrJeCvuuMpttxr0OnNCqbZGhFjLrg+NIhxxC+BK5F6yS3w==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/plugin-syntax-optional-chaining": "^7.8.0"
      }
    },
    "@babel/plugin-proposal-private-methods": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-private-methods/-/plugin-proposal-private-methods-7.10.4.tgz",
      "integrity": "sha512-wh5GJleuI8k3emgTg5KkJK6kHNsGEr0uBTDBuQUBJwckk9xs1ez79ioheEVVxMLyPscB0LfkbVHslQqIzWV6Bw==",
      "optional": true,
      "requires": {
        "@babel/helper-create-class-features-plugin": "^7.10.4",
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "dependencies": {
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        }
      }
    },
    "@babel/plugin-proposal-unicode-property-regex": {
      "version": "7.8.8",
      "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-unicode-property-regex/-/plugin-proposal-unicode-property-regex-7.8.8.tgz",
      "integrity": "sha512-EVhjVsMpbhLw9ZfHWSx2iy13Q8Z/eg8e8ccVWt23sWQK5l1UdkoLJPN5w69UA4uITGBnEZD2JOe4QOHycYKv8A==",
      "requires": {
        "@babel/helper-create-regexp-features-plugin": "^7.8.8",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-syntax-async-generators": {
      "version": "7.8.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-async-generators/-/plugin-syntax-async-generators-7.8.4.tgz",
      "integrity": "sha512-tycmZxkGfZaxhMRbXlPXuVFpdWlXpir2W4AMhSJgRKzk/eDlIXOhb2LHWoLpDF7TEHylV5zNhykX6KAgHJmTNw==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-bigint": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-bigint/-/plugin-syntax-bigint-7.8.3.tgz",
      "integrity": "sha512-wnTnFlG+YxQm3vDxpGE57Pj0srRU4sHE/mDkt1qv2YJJSeUAec2ma4WLUnUPeKjyrfntVwe/N6dCXpU+zL3Npg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-class-properties": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.8.3.tgz",
      "integrity": "sha512-UcAyQWg2bAN647Q+O811tG9MrJ38Z10jjhQdKNAL8fsyPzE3cCN/uT+f55cFVY4aGO4jqJAvmqsuY3GQDwAoXg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-syntax-dynamic-import": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-dynamic-import/-/plugin-syntax-dynamic-import-7.8.3.tgz",
      "integrity": "sha512-5gdGbFon+PszYzqs83S3E5mpi7/y/8M9eC90MRTZfduQOYW76ig6SOSPNe41IG5LoP3FGBn2N0RjVDSQiS94kQ==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-export-namespace-from": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-export-namespace-from/-/plugin-syntax-export-namespace-from-7.8.3.tgz",
      "integrity": "sha512-MXf5laXo6c1IbEbegDmzGPwGNTsHZmEy6QGznu5Sh2UCWvueywb2ee+CCE4zQiZstxU9BMoQO9i6zUFSY0Kj0Q==",
      "optional": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-syntax-json-strings": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-json-strings/-/plugin-syntax-json-strings-7.8.3.tgz",
      "integrity": "sha512-lY6kdGpWHvjoe2vk4WrAapEuBR69EMxZl+RoGRhrFGNYVK8mOPAW8VfbT/ZgrFbXlDNiiaxQnAtgVCZ6jv30EA==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-logical-assignment-operators": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.8.3.tgz",
      "integrity": "sha512-Zpg2Sgc++37kuFl6ppq2Q7Awc6E6AIW671x5PY8E/f7MCIyPPGK/EoeZXvvY3P42exZ3Q4/t3YOzP/HiN79jDg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-syntax-nullish-coalescing-operator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-nullish-coalescing-operator/-/plugin-syntax-nullish-coalescing-operator-7.8.3.tgz",
      "integrity": "sha512-aSff4zPII1u2QD7y+F8oDsz19ew4IGEJg9SVW+bqwpwtfFleiQDMdzA/R+UlWDzfnHFCxxleFT0PMIrR36XLNQ==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-numeric-separator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.8.3.tgz",
      "integrity": "sha512-H7dCMAdN83PcCmqmkHB5dtp+Xa9a6LKSvA2hiFBC/5alSHxM5VgWZXFqDi0YFe8XNGT6iCa+z4V4zSt/PdZ7Dw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-syntax-object-rest-spread": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-object-rest-spread/-/plugin-syntax-object-rest-spread-7.8.3.tgz",
      "integrity": "sha512-XoqMijGZb9y3y2XskN+P1wUGiVwWZ5JmoDRwx5+3GmEplNyVM2s2Dg8ILFQm8rWM48orGy5YpI5Bl8U1y7ydlA==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-optional-catch-binding": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-catch-binding/-/plugin-syntax-optional-catch-binding-7.8.3.tgz",
      "integrity": "sha512-6VPD0Pc1lpTqw0aKoeRTMiB+kWhAoT24PA+ksWSBrFtl5SIRVpZlwN3NNPQjehA2E/91FV3RjLWoVTglWcSV3Q==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-optional-chaining": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-optional-chaining/-/plugin-syntax-optional-chaining-7.8.3.tgz",
      "integrity": "sha512-KoK9ErH1MBlCPxV0VANkXW2/dw4vlbGDrFgz8bmUsBGYkFRcbRwMh6cIJubdPrkxRwuGdtCk0v/wPTKbQgBjkg==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.0"
      }
    },
    "@babel/plugin-syntax-top-level-await": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.8.3.tgz",
      "integrity": "sha512-kwj1j9lL/6Wd0hROD3b/OZZ7MSrZLqqn9RAZ5+cYYsflQ9HZBIKCUkr3+uL1MEJ1NePiUbf98jjiMQSv0NMR9g==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-arrow-functions": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.8.3.tgz",
      "integrity": "sha512-0MRF+KC8EqH4dbuITCWwPSzsyO3HIWWlm30v8BbbpOrS1B++isGxPnnuq/IZvOX5J2D/p7DQalQm+/2PnlKGxg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-async-to-generator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.8.3.tgz",
      "integrity": "sha512-imt9tFLD9ogt56Dd5CI/6XgpukMwd/fLGSrix2httihVe7LOGVPhyhMh1BU5kDM7iHD08i8uUtmV2sWaBFlHVQ==",
      "dev": true,
      "requires": {
        "@babel/helper-module-imports": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-remap-async-to-generator": "^7.8.3"
      }
    },
    "@babel/plugin-transform-block-scoped-functions": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.8.3.tgz",
      "integrity": "sha512-vo4F2OewqjbB1+yaJ7k2EJFHlTP3jR634Z9Cj9itpqNjuLXvhlVxgnjsHsdRgASR8xYDrx6onw4vW5H6We0Jmg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-block-scoping": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.8.3.tgz",
      "integrity": "sha512-pGnYfm7RNRgYRi7bids5bHluENHqJhrV4bCZRwc5GamaWIIs07N4rZECcmJL6ZClwjDz1GbdMZFtPs27hTB06w==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "lodash": "^4.17.13"
      }
    },
    "@babel/plugin-transform-classes": {
      "version": "7.9.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.9.5.tgz",
      "integrity": "sha512-x2kZoIuLC//O5iA7PEvecB105o7TLzZo8ofBVhP79N+DO3jaX+KYfww9TQcfBEZD0nikNyYcGB1IKtRq36rdmg==",
      "dev": true,
      "requires": {
        "@babel/helper-annotate-as-pure": "^7.8.3",
        "@babel/helper-define-map": "^7.8.3",
        "@babel/helper-function-name": "^7.9.5",
        "@babel/helper-optimise-call-expression": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-replace-supers": "^7.8.6",
        "@babel/helper-split-export-declaration": "^7.8.3",
        "globals": "^11.1.0"
      }
    },
    "@babel/plugin-transform-computed-properties": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.8.3.tgz",
      "integrity": "sha512-O5hiIpSyOGdrQZRQ2ccwtTVkgUDBBiCuK//4RJ6UfePllUTCENOzKxfh6ulckXKc0DixTFLCfb2HVkNA7aDpzA==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-destructuring": {
      "version": "7.9.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.9.5.tgz",
      "integrity": "sha512-j3OEsGel8nHL/iusv/mRd5fYZ3DrOxWC82x0ogmdN/vHfAP4MYw+AFKYanzWlktNwikKvlzUV//afBW5FTp17Q==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-dotall-regex": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.8.3.tgz",
      "integrity": "sha512-kLs1j9Nn4MQoBYdRXH6AeaXMbEJFaFu/v1nQkvib6QzTj8MZI5OQzqmD83/2jEM1z0DLilra5aWO5YpyC0ALIw==",
      "requires": {
        "@babel/helper-create-regexp-features-plugin": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-duplicate-keys": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.8.3.tgz",
      "integrity": "sha512-s8dHiBUbcbSgipS4SMFuWGqCvyge5V2ZeAWzR6INTVC3Ltjig/Vw1G2Gztv0vU/hRG9X8IvKvYdoksnUfgXOEQ==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-exponentiation-operator": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.8.3.tgz",
      "integrity": "sha512-zwIpuIymb3ACcInbksHaNcR12S++0MDLKkiqXHl3AzpgdKlFNhog+z/K0+TGW+b0w5pgTq4H6IwV/WhxbGYSjQ==",
      "dev": true,
      "requires": {
        "@babel/helper-builder-binary-assignment-operator-visitor": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-for-of": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.9.0.tgz",
      "integrity": "sha512-lTAnWOpMwOXpyDx06N+ywmF3jNbafZEqZ96CGYabxHrxNX8l5ny7dt4bK/rGwAh9utyP2b2Hv7PlZh1AAS54FQ==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-function-name": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.8.3.tgz",
      "integrity": "sha512-rO/OnDS78Eifbjn5Py9v8y0aR+aSYhDhqAwVfsTl0ERuMZyr05L1aFSCJnbv2mmsLkit/4ReeQ9N2BgLnOcPCQ==",
      "dev": true,
      "requires": {
        "@babel/helper-function-name": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-literals": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.8.3.tgz",
      "integrity": "sha512-3Tqf8JJ/qB7TeldGl+TT55+uQei9JfYaregDcEAyBZ7akutriFrt6C/wLYIer6OYhleVQvH/ntEhjE/xMmy10A==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-member-expression-literals": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.8.3.tgz",
      "integrity": "sha512-3Wk2EXhnw+rP+IDkK6BdtPKsUE5IeZ6QOGrPYvw52NwBStw9V1ZVzxgK6fSKSxqUvH9eQPR3tm3cOq79HlsKYA==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-modules-amd": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.9.6.tgz",
      "integrity": "sha512-zoT0kgC3EixAyIAU+9vfaUVKTv9IxBDSabgHoUCBP6FqEJ+iNiN7ip7NBKcYqbfUDfuC2mFCbM7vbu4qJgOnDw==",
      "dev": true,
      "requires": {
        "@babel/helper-module-transforms": "^7.9.0",
        "@babel/helper-plugin-utils": "^7.8.3",
        "babel-plugin-dynamic-import-node": "^2.3.3"
      }
    },
    "@babel/plugin-transform-modules-commonjs": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.9.6.tgz",
      "integrity": "sha512-7H25fSlLcn+iYimmsNe3uK1at79IE6SKW9q0/QeEHTMC9MdOZ+4bA+T1VFB5fgOqBWoqlifXRzYD0JPdmIrgSQ==",
      "dev": true,
      "requires": {
        "@babel/helper-module-transforms": "^7.9.0",
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-simple-access": "^7.8.3",
        "babel-plugin-dynamic-import-node": "^2.3.3"
      }
    },
    "@babel/plugin-transform-modules-systemjs": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.9.6.tgz",
      "integrity": "sha512-NW5XQuW3N2tTHim8e1b7qGy7s0kZ2OH3m5octc49K1SdAKGxYxeIx7hiIz05kS1R2R+hOWcsr1eYwcGhrdHsrg==",
      "dev": true,
      "requires": {
        "@babel/helper-hoist-variables": "^7.8.3",
        "@babel/helper-module-transforms": "^7.9.0",
        "@babel/helper-plugin-utils": "^7.8.3",
        "babel-plugin-dynamic-import-node": "^2.3.3"
      }
    },
    "@babel/plugin-transform-modules-umd": {
      "version": "7.9.0",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.9.0.tgz",
      "integrity": "sha512-uTWkXkIVtg/JGRSIABdBoMsoIeoHQHPTL0Y2E7xf5Oj7sLqwVsNXOkNk0VJc7vF0IMBsPeikHxFjGe+qmwPtTQ==",
      "dev": true,
      "requires": {
        "@babel/helper-module-transforms": "^7.9.0",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-named-capturing-groups-regex": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.8.3.tgz",
      "integrity": "sha512-f+tF/8UVPU86TrCb06JoPWIdDpTNSGGcAtaD9mLP0aYGA0OS0j7j7DHJR0GTFrUZPUU6loZhbsVZgTh0N+Qdnw==",
      "dev": true,
      "requires": {
        "@babel/helper-create-regexp-features-plugin": "^7.8.3"
      }
    },
    "@babel/plugin-transform-new-target": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.8.3.tgz",
      "integrity": "sha512-QuSGysibQpyxexRyui2vca+Cmbljo8bcRckgzYV4kRIsHpVeyeC3JDO63pY+xFZ6bWOBn7pfKZTqV4o/ix9sFw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-object-super": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.8.3.tgz",
      "integrity": "sha512-57FXk+gItG/GejofIyLIgBKTas4+pEU47IXKDBWFTxdPd7F80H8zybyAY7UoblVfBhBGs2EKM+bJUu2+iUYPDQ==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-replace-supers": "^7.8.3"
      }
    },
    "@babel/plugin-transform-parameters": {
      "version": "7.9.5",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.9.5.tgz",
      "integrity": "sha512-0+1FhHnMfj6lIIhVvS4KGQJeuhe1GI//h5uptK4PvLt+BGBxsoUJbd3/IW002yk//6sZPlFgsG1hY6OHLcy6kA==",
      "dev": true,
      "requires": {
        "@babel/helper-get-function-arity": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-property-literals": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.8.3.tgz",
      "integrity": "sha512-uGiiXAZMqEoQhRWMK17VospMZh5sXWg+dlh2soffpkAl96KAm+WZuJfa6lcELotSRmooLqg0MWdH6UUq85nmmg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-regenerator": {
      "version": "7.8.7",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.8.7.tgz",
      "integrity": "sha512-TIg+gAl4Z0a3WmD3mbYSk+J9ZUH6n/Yc57rtKRnlA/7rcCvpekHXe0CMZHP1gYp7/KLe9GHTuIba0vXmls6drA==",
      "dev": true,
      "requires": {
        "regenerator-transform": "^0.14.2"
      }
    },
    "@babel/plugin-transform-reserved-words": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.8.3.tgz",
      "integrity": "sha512-mwMxcycN3omKFDjDQUl+8zyMsBfjRFr0Zn/64I41pmjv4NJuqcYlEtezwYtw9TFd9WR1vN5kiM+O0gMZzO6L0A==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-runtime": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-runtime/-/plugin-transform-runtime-7.9.6.tgz",
      "integrity": "sha512-qcmiECD0mYOjOIt8YHNsAP1SxPooC/rDmfmiSK9BNY72EitdSc7l44WTEklaWuFtbOEBjNhWWyph/kOImbNJ4w==",
      "dev": true,
      "requires": {
        "@babel/helper-module-imports": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3",
        "resolve": "^1.8.1",
        "semver": "^5.5.1"
      }
    },
    "@babel/plugin-transform-shorthand-properties": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.8.3.tgz",
      "integrity": "sha512-I9DI6Odg0JJwxCHzbzW08ggMdCezoWcuQRz3ptdudgwaHxTjxw5HgdFJmZIkIMlRymL6YiZcped4TTCB0JcC8w==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-spread": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.8.3.tgz",
      "integrity": "sha512-CkuTU9mbmAoFOI1tklFWYYbzX5qCIZVXPVy0jpXgGwkplCndQAa58s2jr66fTeQnA64bDox0HL4U56CFYoyC7g==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-sticky-regex": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.8.3.tgz",
      "integrity": "sha512-9Spq0vGCD5Bb4Z/ZXXSK5wbbLFMG085qd2vhL1JYu1WcQ5bXqZBAYRzU1d+p79GcHs2szYv5pVQCX13QgldaWw==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3",
        "@babel/helper-regex": "^7.8.3"
      }
    },
    "@babel/plugin-transform-template-literals": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.8.3.tgz",
      "integrity": "sha512-820QBtykIQOLFT8NZOcTRJ1UNuztIELe4p9DCgvj4NK+PwluSJ49we7s9FB1HIGNIYT7wFUJ0ar2QpCDj0escQ==",
      "dev": true,
      "requires": {
        "@babel/helper-annotate-as-pure": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-typeof-symbol": {
      "version": "7.8.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.8.4.tgz",
      "integrity": "sha512-2QKyfjGdvuNfHsb7qnBBlKclbD4CfshH2KvDabiijLMGXPHJXGxtDzwIF7bQP+T0ysw8fYTtxPafgfs/c1Lrqg==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/plugin-transform-unicode-escapes": {
      "version": "7.10.4",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-escapes/-/plugin-transform-unicode-escapes-7.10.4.tgz",
      "integrity": "sha512-y5XJ9waMti2J+e7ij20e+aH+fho7Wb7W8rNuu72aKRwCHFqQdhkdU2lo3uZ9tQuboEJcUFayXdARhcxLQ3+6Fg==",
      "optional": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "dependencies": {
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        }
      }
    },
    "@babel/plugin-transform-unicode-regex": {
      "version": "7.8.3",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.8.3.tgz",
      "integrity": "sha512-+ufgJjYdmWfSQ+6NS9VGUR2ns8cjJjYbrbi11mZBTaWm+Fui/ncTLFF28Ei1okavY+xkojGr1eJxNsWYeA5aZw==",
      "dev": true,
      "requires": {
        "@babel/helper-create-regexp-features-plugin": "^7.8.3",
        "@babel/helper-plugin-utils": "^7.8.3"
      }
    },
    "@babel/preset-env": {
      "version": "7.11.0",
      "resolved": "https://registry.npmjs.org/@babel/preset-env/-/preset-env-7.11.0.tgz",
      "integrity": "sha512-2u1/k7rG/gTh02dylX2kL3S0IJNF+J6bfDSp4DI2Ma8QN6Y9x9pmAax59fsCk6QUQG0yqH47yJWA+u1I1LccAg==",
      "optional": true,
      "requires": {
        "@babel/compat-data": "^7.11.0",
        "@babel/helper-compilation-targets": "^7.10.4",
        "@babel/helper-module-imports": "^7.10.4",
        "@babel/helper-plugin-utils": "^7.10.4",
        "@babel/plugin-proposal-async-generator-functions": "^7.10.4",
        "@babel/plugin-proposal-class-properties": "^7.10.4",
        "@babel/plugin-proposal-dynamic-import": "^7.10.4",
        "@babel/plugin-proposal-export-namespace-from": "^7.10.4",
        "@babel/plugin-proposal-json-strings": "^7.10.4",
        "@babel/plugin-proposal-logical-assignment-operators": "^7.11.0",
        "@babel/plugin-proposal-nullish-coalescing-operator": "^7.10.4",
        "@babel/plugin-proposal-numeric-separator": "^7.10.4",
        "@babel/plugin-proposal-object-rest-spread": "^7.11.0",
        "@babel/plugin-proposal-optional-catch-binding": "^7.10.4",
        "@babel/plugin-proposal-optional-chaining": "^7.11.0",
        "@babel/plugin-proposal-private-methods": "^7.10.4",
        "@babel/plugin-proposal-unicode-property-regex": "^7.10.4",
        "@babel/plugin-syntax-async-generators": "^7.8.0",
        "@babel/plugin-syntax-class-properties": "^7.10.4",
        "@babel/plugin-syntax-dynamic-import": "^7.8.0",
        "@babel/plugin-syntax-export-namespace-from": "^7.8.3",
        "@babel/plugin-syntax-json-strings": "^7.8.0",
        "@babel/plugin-syntax-logical-assignment-operators": "^7.10.4",
        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.0",
        "@babel/plugin-syntax-numeric-separator": "^7.10.4",
        "@babel/plugin-syntax-object-rest-spread": "^7.8.0",
        "@babel/plugin-syntax-optional-catch-binding": "^7.8.0",
        "@babel/plugin-syntax-optional-chaining": "^7.8.0",
        "@babel/plugin-syntax-top-level-await": "^7.10.4",
        "@babel/plugin-transform-arrow-functions": "^7.10.4",
        "@babel/plugin-transform-async-to-generator": "^7.10.4",
        "@babel/plugin-transform-block-scoped-functions": "^7.10.4",
        "@babel/plugin-transform-block-scoping": "^7.10.4",
        "@babel/plugin-transform-classes": "^7.10.4",
        "@babel/plugin-transform-computed-properties": "^7.10.4",
        "@babel/plugin-transform-destructuring": "^7.10.4",
        "@babel/plugin-transform-dotall-regex": "^7.10.4",
        "@babel/plugin-transform-duplicate-keys": "^7.10.4",
        "@babel/plugin-transform-exponentiation-operator": "^7.10.4",
        "@babel/plugin-transform-for-of": "^7.10.4",
        "@babel/plugin-transform-function-name": "^7.10.4",
        "@babel/plugin-transform-literals": "^7.10.4",
        "@babel/plugin-transform-member-expression-literals": "^7.10.4",
        "@babel/plugin-transform-modules-amd": "^7.10.4",
        "@babel/plugin-transform-modules-commonjs": "^7.10.4",
        "@babel/plugin-transform-modules-systemjs": "^7.10.4",
        "@babel/plugin-transform-modules-umd": "^7.10.4",
        "@babel/plugin-transform-named-capturing-groups-regex": "^7.10.4",
        "@babel/plugin-transform-new-target": "^7.10.4",
        "@babel/plugin-transform-object-super": "^7.10.4",
        "@babel/plugin-transform-parameters": "^7.10.4",
        "@babel/plugin-transform-property-literals": "^7.10.4",
        "@babel/plugin-transform-regenerator": "^7.10.4",
        "@babel/plugin-transform-reserved-words": "^7.10.4",
        "@babel/plugin-transform-shorthand-properties": "^7.10.4",
        "@babel/plugin-transform-spread": "^7.11.0",
        "@babel/plugin-transform-sticky-regex": "^7.10.4",
        "@babel/plugin-transform-template-literals": "^7.10.4",
        "@babel/plugin-transform-typeof-symbol": "^7.10.4",
        "@babel/plugin-transform-unicode-escapes": "^7.10.4",
        "@babel/plugin-transform-unicode-regex": "^7.10.4",
        "@babel/preset-modules": "^0.1.3",
        "@babel/types": "^7.11.0",
        "browserslist": "^4.12.0",
        "core-js-compat": "^3.6.2",
        "invariant": "^2.2.2",
        "levenary": "^1.1.1",
        "semver": "^5.5.0"
      },
      "dependencies": {
        "@babel/code-frame": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.10.4.tgz",
          "integrity": "sha512-vG6SvB6oYEhvgisZNFRmRCUkLz11c7rp+tbNTynGqc6mS1d5ATd/sGyV6W0KZZnXRKMTzZDRgQT3Ou9jhpAfUg==",
          "optional": true,
          "requires": {
            "@babel/highlight": "^7.10.4"
          }
        },
        "@babel/compat-data": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.11.0.tgz",
          "integrity": "sha512-TPSvJfv73ng0pfnEOh17bYMPQbI95+nGWc71Ss4vZdRBHTDqmM9Z8ZV4rYz8Ks7sfzc95n30k6ODIq5UGnXcYQ==",
          "optional": true,
          "requires": {
            "browserslist": "^4.12.0",
            "invariant": "^2.2.4",
            "semver": "^5.5.0"
          }
        },
        "@babel/generator": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.11.0.tgz",
          "integrity": "sha512-fEm3Uzw7Mc9Xi//qU20cBKatTfs2aOtKqmvy/Vm7RkJEGFQ4xc9myCfbXxqK//ZS8MR/ciOHw6meGASJuKmDfQ==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0",
            "jsesc": "^2.5.1",
            "source-map": "^0.5.0"
          }
        },
        "@babel/helper-annotate-as-pure": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.10.4.tgz",
          "integrity": "sha512-XQlqKQP4vXFB7BN8fEEerrmYvHp3fK/rBkRFz9jaJbzK0B1DSfej9Kc7ZzE8Z/OnId1jpJdNAZ3BFQjWG68rcA==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-builder-binary-assignment-operator-visitor": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-builder-binary-assignment-operator-visitor/-/helper-builder-binary-assignment-operator-visitor-7.10.4.tgz",
          "integrity": "sha512-L0zGlFrGWZK4PbT8AszSfLTM5sDU1+Az/En9VrdT8/LmEiJt4zXt+Jve9DCAnQcbqDhCI+29y/L93mrDzddCcg==",
          "optional": true,
          "requires": {
            "@babel/helper-explode-assignable-expression": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-compilation-targets": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.10.4.tgz",
          "integrity": "sha512-a3rYhlsGV0UHNDvrtOXBg8/OpfV0OKTkxKPzIplS1zpx7CygDcWWxckxZeDd3gzPzC4kUT0A4nVFDK0wGMh4MQ==",
          "optional": true,
          "requires": {
            "@babel/compat-data": "^7.10.4",
            "browserslist": "^4.12.0",
            "invariant": "^2.2.4",
            "levenary": "^1.1.1",
            "semver": "^5.5.0"
          }
        },
        "@babel/helper-create-regexp-features-plugin": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-create-regexp-features-plugin/-/helper-create-regexp-features-plugin-7.10.4.tgz",
          "integrity": "sha512-2/hu58IEPKeoLF45DBwx3XFqsbCXmkdAay4spVr2x0jYgRxrSNp+ePwvSsy9g6YSaNDcKIQVPXk1Ov8S2edk2g==",
          "optional": true,
          "requires": {
            "@babel/helper-annotate-as-pure": "^7.10.4",
            "@babel/helper-regex": "^7.10.4",
            "regexpu-core": "^4.7.0"
          }
        },
        "@babel/helper-define-map": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/helper-define-map/-/helper-define-map-7.10.5.tgz",
          "integrity": "sha512-fMw4kgFB720aQFXSVaXr79pjjcW5puTCM16+rECJ/plGS+zByelE8l9nCpV1GibxTnFVmUuYG9U8wYfQHdzOEQ==",
          "optional": true,
          "requires": {
            "@babel/helper-function-name": "^7.10.4",
            "@babel/types": "^7.10.5",
            "lodash": "^4.17.19"
          }
        },
        "@babel/helper-explode-assignable-expression": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-explode-assignable-expression/-/helper-explode-assignable-expression-7.10.4.tgz",
          "integrity": "sha512-4K71RyRQNPRrR85sr5QY4X3VwG4wtVoXZB9+L3r1Gp38DhELyHCtovqydRi7c1Ovb17eRGiQ/FD5s8JdU0Uy5A==",
          "optional": true,
          "requires": {
            "@babel/traverse": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-function-name": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.10.4.tgz",
          "integrity": "sha512-YdaSyz1n8gY44EmN7x44zBn9zQ1Ry2Y+3GTA+3vH6Mizke1Vw0aWDM66FOYEPw8//qKkmqOckrGgTYa+6sceqQ==",
          "optional": true,
          "requires": {
            "@babel/helper-get-function-arity": "^7.10.4",
            "@babel/template": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-get-function-arity": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-get-function-arity/-/helper-get-function-arity-7.10.4.tgz",
          "integrity": "sha512-EkN3YDB+SRDgiIUnNgcmiD361ti+AVbL3f3Henf6dqqUyr5dMsorno0lJWJuLhDhkI5sYEpgj6y9kB8AOU1I2A==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-hoist-variables": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.10.4.tgz",
          "integrity": "sha512-wljroF5PgCk2juF69kanHVs6vrLwIPNp6DLD+Lrl3hoQ3PpPPikaDRNFA+0t81NOoMt2DL6WW/mdU8k4k6ZzuA==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-member-expression-to-functions": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.11.0.tgz",
          "integrity": "sha512-JbFlKHFntRV5qKw3YC0CvQnDZ4XMwgzzBbld7Ly4Mj4cbFy3KywcR8NtNctRToMWJOVvLINJv525Gd6wwVEx/Q==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0"
          }
        },
        "@babel/helper-module-imports": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.10.4.tgz",
          "integrity": "sha512-nEQJHqYavI217oD9+s5MUBzk6x1IlvoS9WTPfgG43CbMEeStE0v+r+TucWdx8KFGowPGvyOkDT9+7DHedIDnVw==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-module-transforms": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.11.0.tgz",
          "integrity": "sha512-02EVu8COMuTRO1TAzdMtpBPbe6aQ1w/8fePD2YgQmxZU4gpNWaL9gK3Jp7dxlkUlUCJOTaSeA+Hrm1BRQwqIhg==",
          "optional": true,
          "requires": {
            "@babel/helper-module-imports": "^7.10.4",
            "@babel/helper-replace-supers": "^7.10.4",
            "@babel/helper-simple-access": "^7.10.4",
            "@babel/helper-split-export-declaration": "^7.11.0",
            "@babel/template": "^7.10.4",
            "@babel/types": "^7.11.0",
            "lodash": "^4.17.19"
          }
        },
        "@babel/helper-optimise-call-expression": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.10.4.tgz",
          "integrity": "sha512-n3UGKY4VXwXThEiKrgRAoVPBMqeoPgHVqiHZOanAJCG9nQUL2pLRQirUzl0ioKclHGpGqRgIOkgcIJaIWLpygg==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-plugin-utils": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.10.4.tgz",
          "integrity": "sha512-O4KCvQA6lLiMU9l2eawBPMf1xPP8xPfB3iEQw150hOVTqj/rfXz0ThTb4HEzqQfs2Bmo5Ay8BzxfzVtBrr9dVg==",
          "optional": true
        },
        "@babel/helper-regex": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/helper-regex/-/helper-regex-7.10.5.tgz",
          "integrity": "sha512-68kdUAzDrljqBrio7DYAEgCoJHxppJOERHOgOrDN7WjOzP0ZQ1LsSDRXcemzVZaLvjaJsJEESb6qt+znNuENDg==",
          "optional": true,
          "requires": {
            "lodash": "^4.17.19"
          }
        },
        "@babel/helper-remap-async-to-generator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-remap-async-to-generator/-/helper-remap-async-to-generator-7.10.4.tgz",
          "integrity": "sha512-86Lsr6NNw3qTNl+TBcF1oRZMaVzJtbWTyTko+CQL/tvNvcGYEFKbLXDPxtW0HKk3McNOk4KzY55itGWCAGK5tg==",
          "optional": true,
          "requires": {
            "@babel/helper-annotate-as-pure": "^7.10.4",
            "@babel/helper-wrap-function": "^7.10.4",
            "@babel/template": "^7.10.4",
            "@babel/traverse": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-replace-supers": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.10.4.tgz",
          "integrity": "sha512-sPxZfFXocEymYTdVK1UNmFPBN+Hv5mJkLPsYWwGBxZAxaWfFu+xqp7b6qWD0yjNuNL2VKc6L5M18tOXUP7NU0A==",
          "optional": true,
          "requires": {
            "@babel/helper-member-expression-to-functions": "^7.10.4",
            "@babel/helper-optimise-call-expression": "^7.10.4",
            "@babel/traverse": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-simple-access": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.10.4.tgz",
          "integrity": "sha512-0fMy72ej/VEvF8ULmX6yb5MtHG4uH4Dbd6I/aHDb/JVg0bbivwt9Wg+h3uMvX+QSFtwr5MeItvazbrc4jtRAXw==",
          "optional": true,
          "requires": {
            "@babel/template": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/helper-split-export-declaration": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.11.0.tgz",
          "integrity": "sha512-74Vejvp6mHkGE+m+k5vHY93FX2cAtrw1zXrZXRlG4l410Nm9PxfEiVTn1PjDPV5SnmieiueY4AFg2xqhNFuuZg==",
          "optional": true,
          "requires": {
            "@babel/types": "^7.11.0"
          }
        },
        "@babel/helper-validator-identifier": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.10.4.tgz",
          "integrity": "sha512-3U9y+43hz7ZM+rzG24Qe2mufW5KhvFg/NhnNph+i9mgCtdTCtMJuI1TMkrIUiK7Ix4PYlRF9I5dhqaLYA/ADXw==",
          "optional": true
        },
        "@babel/helper-wrap-function": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/helper-wrap-function/-/helper-wrap-function-7.10.4.tgz",
          "integrity": "sha512-6py45WvEF0MhiLrdxtRjKjufwLL1/ob2qDJgg5JgNdojBAZSAKnAjkyOCNug6n+OBl4VW76XjvgSFTdaMcW0Ug==",
          "optional": true,
          "requires": {
            "@babel/helper-function-name": "^7.10.4",
            "@babel/template": "^7.10.4",
            "@babel/traverse": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/highlight": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.10.4.tgz",
          "integrity": "sha512-i6rgnR/YgPEQzZZnbTHHuZdlE8qyoBNalD6F+q4vAFlcMEcqmkoG+mPqJYJCo63qPf74+Y1UZsl3l6f7/RIkmA==",
          "optional": true,
          "requires": {
            "@babel/helper-validator-identifier": "^7.10.4",
            "chalk": "^2.0.0",
            "js-tokens": "^4.0.0"
          }
        },
        "@babel/parser": {
          "version": "7.11.3",
          "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.11.3.tgz",
          "integrity": "sha512-REo8xv7+sDxkKvoxEywIdsNFiZLybwdI7hcT5uEPyQrSMB4YQ973BfC9OOrD/81MaIjh6UxdulIQXkjmiH3PcA==",
          "optional": true
        },
        "@babel/plugin-proposal-async-generator-functions": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-async-generator-functions/-/plugin-proposal-async-generator-functions-7.10.5.tgz",
          "integrity": "sha512-cNMCVezQbrRGvXJwm9fu/1sJj9bHdGAgKodZdLqOQIpfoH3raqmRPBM17+lh7CzhiKRRBrGtZL9WcjxSoGYUSg==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-remap-async-to-generator": "^7.10.4",
            "@babel/plugin-syntax-async-generators": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-dynamic-import": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-dynamic-import/-/plugin-proposal-dynamic-import-7.10.4.tgz",
          "integrity": "sha512-up6oID1LeidOOASNXgv/CFbgBqTuKJ0cJjz6An5tWD+NVBNlp3VNSBxv2ZdU7SYl3NxJC7agAQDApZusV6uFwQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-dynamic-import": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-json-strings": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-json-strings/-/plugin-proposal-json-strings-7.10.4.tgz",
          "integrity": "sha512-fCL7QF0Jo83uy1K0P2YXrfX11tj3lkpN7l4dMv9Y9VkowkhkQDwFHFd8IiwyK5MZjE8UpbgokkgtcReH88Abaw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-json-strings": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-nullish-coalescing-operator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-nullish-coalescing-operator/-/plugin-proposal-nullish-coalescing-operator-7.10.4.tgz",
          "integrity": "sha512-wq5n1M3ZUlHl9sqT2ok1T2/MTt6AXE0e1Lz4WzWBr95LsAZ5qDXe4KnFuauYyEyLiohvXFMdbsOTMyLZs91Zlw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-numeric-separator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-numeric-separator/-/plugin-proposal-numeric-separator-7.10.4.tgz",
          "integrity": "sha512-73/G7QoRoeNkLZFxsoCCvlg4ezE4eM+57PnOqgaPOozd5myfj7p0muD1mRVJvbUWbOzD+q3No2bWbaKy+DJ8DA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-numeric-separator": "^7.10.4"
          }
        },
        "@babel/plugin-proposal-object-rest-spread": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-object-rest-spread/-/plugin-proposal-object-rest-spread-7.11.0.tgz",
          "integrity": "sha512-wzch41N4yztwoRw0ak+37wxwJM2oiIiy6huGCoqkvSTA9acYWcPfn9Y4aJqmFFJ70KTJUu29f3DQ43uJ9HXzEA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-object-rest-spread": "^7.8.0",
            "@babel/plugin-transform-parameters": "^7.10.4"
          }
        },
        "@babel/plugin-proposal-optional-catch-binding": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-catch-binding/-/plugin-proposal-optional-catch-binding-7.10.4.tgz",
          "integrity": "sha512-LflT6nPh+GK2MnFiKDyLiqSqVHkQnVf7hdoAvyTnnKj9xB3docGRsdPuxp6qqqW19ifK3xgc9U5/FwrSaCNX5g==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/plugin-syntax-optional-catch-binding": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-optional-chaining": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-optional-chaining/-/plugin-proposal-optional-chaining-7.11.0.tgz",
          "integrity": "sha512-v9fZIu3Y8562RRwhm1BbMRxtqZNFmFA2EG+pT2diuU8PT3H6T/KXoZ54KgYisfOFZHV6PfvAiBIZ9Rcz+/JCxA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-skip-transparent-expression-wrappers": "^7.11.0",
            "@babel/plugin-syntax-optional-chaining": "^7.8.0"
          }
        },
        "@babel/plugin-proposal-unicode-property-regex": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-proposal-unicode-property-regex/-/plugin-proposal-unicode-property-regex-7.10.4.tgz",
          "integrity": "sha512-H+3fOgPnEXFL9zGYtKQe4IDOPKYlZdF1kqFDQRRb8PK4B8af1vAGK04tF5iQAAsui+mHNBQSAtd2/ndEDe9wuA==",
          "optional": true,
          "requires": {
            "@babel/helper-create-regexp-features-plugin": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-syntax-class-properties": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-class-properties/-/plugin-syntax-class-properties-7.10.4.tgz",
          "integrity": "sha512-GCSBF7iUle6rNugfURwNmCGG3Z/2+opxAMLs1nND4bhEG5PuxTIggDBoeYYSujAlLtsupzOHYJQgPS3pivwXIA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-syntax-logical-assignment-operators": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-logical-assignment-operators/-/plugin-syntax-logical-assignment-operators-7.10.4.tgz",
          "integrity": "sha512-d8waShlpFDinQ5MtvGU9xDAOzKH47+FFoney2baFIoMr952hKOLp1HR7VszoZvOsV/4+RRszNY7D17ba0te0ig==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-syntax-numeric-separator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-numeric-separator/-/plugin-syntax-numeric-separator-7.10.4.tgz",
          "integrity": "sha512-9H6YdfkcK/uOnY/K7/aA2xpzaAgkQn37yzWUMRK7OaPOqOpGS1+n0H5hxT9AUw9EsSjPW8SVyMJwYRtWs3X3ug==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-syntax-top-level-await": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-top-level-await/-/plugin-syntax-top-level-await-7.10.4.tgz",
          "integrity": "sha512-ni1brg4lXEmWyafKr0ccFWkJG0CeMt4WV1oyeBW6EFObF4oOHclbkj5cARxAPQyAQ2UTuplJyK4nfkXIMMFvsQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-arrow-functions": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-arrow-functions/-/plugin-transform-arrow-functions-7.10.4.tgz",
          "integrity": "sha512-9J/oD1jV0ZCBcgnoFWFq1vJd4msoKb/TCpGNFyyLt0zABdcvgK3aYikZ8HjzB14c26bc7E3Q1yugpwGy2aTPNA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-async-to-generator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-async-to-generator/-/plugin-transform-async-to-generator-7.10.4.tgz",
          "integrity": "sha512-F6nREOan7J5UXTLsDsZG3DXmZSVofr2tGNwfdrVwkDWHfQckbQXnXSPfD7iO+c/2HGqycwyLST3DnZ16n+cBJQ==",
          "optional": true,
          "requires": {
            "@babel/helper-module-imports": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-remap-async-to-generator": "^7.10.4"
          }
        },
        "@babel/plugin-transform-block-scoped-functions": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoped-functions/-/plugin-transform-block-scoped-functions-7.10.4.tgz",
          "integrity": "sha512-WzXDarQXYYfjaV1szJvN3AD7rZgZzC1JtjJZ8dMHUyiK8mxPRahynp14zzNjU3VkPqPsO38CzxiWO1c9ARZ8JA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-block-scoping": {
          "version": "7.11.1",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-block-scoping/-/plugin-transform-block-scoping-7.11.1.tgz",
          "integrity": "sha512-00dYeDE0EVEHuuM+26+0w/SCL0BH2Qy7LwHuI4Hi4MH5gkC8/AqMN5uWFJIsoXZrAphiMm1iXzBw6L2T+eA0ew==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-classes": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-classes/-/plugin-transform-classes-7.10.4.tgz",
          "integrity": "sha512-2oZ9qLjt161dn1ZE0Ms66xBncQH4In8Sqw1YWgBUZuGVJJS5c0OFZXL6dP2MRHrkU/eKhWg8CzFJhRQl50rQxA==",
          "optional": true,
          "requires": {
            "@babel/helper-annotate-as-pure": "^7.10.4",
            "@babel/helper-define-map": "^7.10.4",
            "@babel/helper-function-name": "^7.10.4",
            "@babel/helper-optimise-call-expression": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-replace-supers": "^7.10.4",
            "@babel/helper-split-export-declaration": "^7.10.4",
            "globals": "^11.1.0"
          }
        },
        "@babel/plugin-transform-computed-properties": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-computed-properties/-/plugin-transform-computed-properties-7.10.4.tgz",
          "integrity": "sha512-JFwVDXcP/hM/TbyzGq3l/XWGut7p46Z3QvqFMXTfk6/09m7xZHJUN9xHfsv7vqqD4YnfI5ueYdSJtXqqBLyjBw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-destructuring": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-destructuring/-/plugin-transform-destructuring-7.10.4.tgz",
          "integrity": "sha512-+WmfvyfsyF603iPa6825mq6Qrb7uLjTOsa3XOFzlYcYDHSS4QmpOWOL0NNBY5qMbvrcf3tq0Cw+v4lxswOBpgA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-dotall-regex": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-dotall-regex/-/plugin-transform-dotall-regex-7.10.4.tgz",
          "integrity": "sha512-ZEAVvUTCMlMFAbASYSVQoxIbHm2OkG2MseW6bV2JjIygOjdVv8tuxrCTzj1+Rynh7ODb8GivUy7dzEXzEhuPaA==",
          "optional": true,
          "requires": {
            "@babel/helper-create-regexp-features-plugin": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-duplicate-keys": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-duplicate-keys/-/plugin-transform-duplicate-keys-7.10.4.tgz",
          "integrity": "sha512-GL0/fJnmgMclHiBTTWXNlYjYsA7rDrtsazHG6mglaGSTh0KsrW04qml+Bbz9FL0LcJIRwBWL5ZqlNHKTkU3xAA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-exponentiation-operator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-exponentiation-operator/-/plugin-transform-exponentiation-operator-7.10.4.tgz",
          "integrity": "sha512-S5HgLVgkBcRdyQAHbKj+7KyuWx8C6t5oETmUuwz1pt3WTWJhsUV0WIIXuVvfXMxl/QQyHKlSCNNtaIamG8fysw==",
          "optional": true,
          "requires": {
            "@babel/helper-builder-binary-assignment-operator-visitor": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-for-of": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-for-of/-/plugin-transform-for-of-7.10.4.tgz",
          "integrity": "sha512-ItdQfAzu9AlEqmusA/65TqJ79eRcgGmpPPFvBnGILXZH975G0LNjP1yjHvGgfuCxqrPPueXOPe+FsvxmxKiHHQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-function-name": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-function-name/-/plugin-transform-function-name-7.10.4.tgz",
          "integrity": "sha512-OcDCq2y5+E0dVD5MagT5X+yTRbcvFjDI2ZVAottGH6tzqjx/LKpgkUepu3hp/u4tZBzxxpNGwLsAvGBvQ2mJzg==",
          "optional": true,
          "requires": {
            "@babel/helper-function-name": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-literals": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-literals/-/plugin-transform-literals-7.10.4.tgz",
          "integrity": "sha512-Xd/dFSTEVuUWnyZiMu76/InZxLTYilOSr1UlHV+p115Z/Le2Fi1KXkJUYz0b42DfndostYlPub3m8ZTQlMaiqQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-member-expression-literals": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-member-expression-literals/-/plugin-transform-member-expression-literals-7.10.4.tgz",
          "integrity": "sha512-0bFOvPyAoTBhtcJLr9VcwZqKmSjFml1iVxvPL0ReomGU53CX53HsM4h2SzckNdkQcHox1bpAqzxBI1Y09LlBSw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-modules-amd": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-amd/-/plugin-transform-modules-amd-7.10.5.tgz",
          "integrity": "sha512-elm5uruNio7CTLFItVC/rIzKLfQ17+fX7EVz5W0TMgIHFo1zY0Ozzx+lgwhL4plzl8OzVn6Qasx5DeEFyoNiRw==",
          "optional": true,
          "requires": {
            "@babel/helper-module-transforms": "^7.10.5",
            "@babel/helper-plugin-utils": "^7.10.4",
            "babel-plugin-dynamic-import-node": "^2.3.3"
          }
        },
        "@babel/plugin-transform-modules-commonjs": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-commonjs/-/plugin-transform-modules-commonjs-7.10.4.tgz",
          "integrity": "sha512-Xj7Uq5o80HDLlW64rVfDBhao6OX89HKUmb+9vWYaLXBZOma4gA6tw4Ni1O5qVDoZWUV0fxMYA0aYzOawz0l+1w==",
          "optional": true,
          "requires": {
            "@babel/helper-module-transforms": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-simple-access": "^7.10.4",
            "babel-plugin-dynamic-import-node": "^2.3.3"
          }
        },
        "@babel/plugin-transform-modules-systemjs": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-systemjs/-/plugin-transform-modules-systemjs-7.10.5.tgz",
          "integrity": "sha512-f4RLO/OL14/FP1AEbcsWMzpbUz6tssRaeQg11RH1BP/XnPpRoVwgeYViMFacnkaw4k4wjRSjn3ip1Uw9TaXuMw==",
          "optional": true,
          "requires": {
            "@babel/helper-hoist-variables": "^7.10.4",
            "@babel/helper-module-transforms": "^7.10.5",
            "@babel/helper-plugin-utils": "^7.10.4",
            "babel-plugin-dynamic-import-node": "^2.3.3"
          }
        },
        "@babel/plugin-transform-modules-umd": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-modules-umd/-/plugin-transform-modules-umd-7.10.4.tgz",
          "integrity": "sha512-mohW5q3uAEt8T45YT7Qc5ws6mWgJAaL/8BfWD9Dodo1A3RKWli8wTS+WiQ/knF+tXlPirW/1/MqzzGfCExKECA==",
          "optional": true,
          "requires": {
            "@babel/helper-module-transforms": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-named-capturing-groups-regex": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-named-capturing-groups-regex/-/plugin-transform-named-capturing-groups-regex-7.10.4.tgz",
          "integrity": "sha512-V6LuOnD31kTkxQPhKiVYzYC/Jgdq53irJC/xBSmqcNcqFGV+PER4l6rU5SH2Vl7bH9mLDHcc0+l9HUOe4RNGKA==",
          "optional": true,
          "requires": {
            "@babel/helper-create-regexp-features-plugin": "^7.10.4"
          }
        },
        "@babel/plugin-transform-new-target": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-new-target/-/plugin-transform-new-target-7.10.4.tgz",
          "integrity": "sha512-YXwWUDAH/J6dlfwqlWsztI2Puz1NtUAubXhOPLQ5gjR/qmQ5U96DY4FQO8At33JN4XPBhrjB8I4eMmLROjjLjw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-object-super": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-object-super/-/plugin-transform-object-super-7.10.4.tgz",
          "integrity": "sha512-5iTw0JkdRdJvr7sY0vHqTpnruUpTea32JHmq/atIWqsnNussbRzjEDyWep8UNztt1B5IusBYg8Irb0bLbiEBCQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-replace-supers": "^7.10.4"
          }
        },
        "@babel/plugin-transform-parameters": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-parameters/-/plugin-transform-parameters-7.10.5.tgz",
          "integrity": "sha512-xPHwUj5RdFV8l1wuYiu5S9fqWGM2DrYc24TMvUiRrPVm+SM3XeqU9BcokQX/kEUe+p2RBwy+yoiR1w/Blq6ubw==",
          "optional": true,
          "requires": {
            "@babel/helper-get-function-arity": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-property-literals": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-property-literals/-/plugin-transform-property-literals-7.10.4.tgz",
          "integrity": "sha512-ofsAcKiUxQ8TY4sScgsGeR2vJIsfrzqvFb9GvJ5UdXDzl+MyYCaBj/FGzXuv7qE0aJcjWMILny1epqelnFlz8g==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-regenerator": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-regenerator/-/plugin-transform-regenerator-7.10.4.tgz",
          "integrity": "sha512-3thAHwtor39A7C04XucbMg17RcZ3Qppfxr22wYzZNcVIkPHfpM9J0SO8zuCV6SZa265kxBJSrfKTvDCYqBFXGw==",
          "optional": true,
          "requires": {
            "regenerator-transform": "^0.14.2"
          }
        },
        "@babel/plugin-transform-reserved-words": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-reserved-words/-/plugin-transform-reserved-words-7.10.4.tgz",
          "integrity": "sha512-hGsw1O6Rew1fkFbDImZIEqA8GoidwTAilwCyWqLBM9f+e/u/sQMQu7uX6dyokfOayRuuVfKOW4O7HvaBWM+JlQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-shorthand-properties": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-shorthand-properties/-/plugin-transform-shorthand-properties-7.10.4.tgz",
          "integrity": "sha512-AC2K/t7o07KeTIxMoHneyX90v3zkm5cjHJEokrPEAGEy3UCp8sLKfnfOIGdZ194fyN4wfX/zZUWT9trJZ0qc+Q==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-spread": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-spread/-/plugin-transform-spread-7.11.0.tgz",
          "integrity": "sha512-UwQYGOqIdQJe4aWNyS7noqAnN2VbaczPLiEtln+zPowRNlD+79w3oi2TWfYe0eZgd+gjZCbsydN7lzWysDt+gw==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-skip-transparent-expression-wrappers": "^7.11.0"
          }
        },
        "@babel/plugin-transform-sticky-regex": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-sticky-regex/-/plugin-transform-sticky-regex-7.10.4.tgz",
          "integrity": "sha512-Ddy3QZfIbEV0VYcVtFDCjeE4xwVTJWTmUtorAJkn6u/92Z/nWJNV+mILyqHKrUxXYKA2EoCilgoPePymKL4DvQ==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4",
            "@babel/helper-regex": "^7.10.4"
          }
        },
        "@babel/plugin-transform-template-literals": {
          "version": "7.10.5",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-template-literals/-/plugin-transform-template-literals-7.10.5.tgz",
          "integrity": "sha512-V/lnPGIb+KT12OQikDvgSuesRX14ck5FfJXt6+tXhdkJ+Vsd0lDCVtF6jcB4rNClYFzaB2jusZ+lNISDk2mMMw==",
          "optional": true,
          "requires": {
            "@babel/helper-annotate-as-pure": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-typeof-symbol": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typeof-symbol/-/plugin-transform-typeof-symbol-7.10.4.tgz",
          "integrity": "sha512-QqNgYwuuW0y0H+kUE/GWSR45t/ccRhe14Fs/4ZRouNNQsyd4o3PG4OtHiIrepbM2WKUBDAXKCAK/Lk4VhzTaGA==",
          "optional": true,
          "requires": {
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/plugin-transform-unicode-regex": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/plugin-transform-unicode-regex/-/plugin-transform-unicode-regex-7.10.4.tgz",
          "integrity": "sha512-wNfsc4s8N2qnIwpO/WP2ZiSyjfpTamT2C9V9FDH/Ljub9zw6P3SjkXcFmc0RQUt96k2fmIvtla2MMjgTwIAC+A==",
          "optional": true,
          "requires": {
            "@babel/helper-create-regexp-features-plugin": "^7.10.4",
            "@babel/helper-plugin-utils": "^7.10.4"
          }
        },
        "@babel/template": {
          "version": "7.10.4",
          "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.10.4.tgz",
          "integrity": "sha512-ZCjD27cGJFUB6nmCB1Enki3r+L5kJveX9pq1SvAUKoICy6CZ9yD8xO086YXdYhvNjBdnekm4ZnaP5yC8Cs/1tA==",
          "optional": true,
          "requires": {
            "@babel/code-frame": "^7.10.4",
            "@babel/parser": "^7.10.4",
            "@babel/types": "^7.10.4"
          }
        },
        "@babel/traverse": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.11.0.tgz",
          "integrity": "sha512-ZB2V+LskoWKNpMq6E5UUCrjtDUh5IOTAyIl0dTjIEoXum/iKWkoIEKIRDnUucO6f+2FzNkE0oD4RLKoPIufDtg==",
          "optional": true,
          "requires": {
            "@babel/code-frame": "^7.10.4",
            "@babel/generator": "^7.11.0",
            "@babel/helper-function-name": "^7.10.4",
            "@babel/helper-split-export-declaration": "^7.11.0",
            "@babel/parser": "^7.11.0",
            "@babel/types": "^7.11.0",
            "debug": "^4.1.0",
            "globals": "^11.1.0",
            "lodash": "^4.17.19"
          }
        },
        "@babel/types": {
          "version": "7.11.0",
          "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.11.0.tgz",
          "integrity": "sha512-O53yME4ZZI0jO1EVGtF1ePGl0LHirG4P1ibcD80XyzZcKhcMFeCXmh4Xb1ifGBIV233Qg12x4rBfQgA+tmOukA==",
          "optional": true,
          "requires": {
            "@babel/helper-validator-identifier": "^7.10.4",
            "lodash": "^4.17.19",
            "to-fast-properties": "^2.0.0"
          }
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "optional": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
          "optional": true
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "optional": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@babel/preset-modules": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@babel/preset-modules/-/preset-modules-0.1.3.tgz",
      "integrity": "sha512-Ra3JXOHBq2xd56xSF7lMKXdjBn3T772Y1Wet3yWnkDly9zHvJki029tAFzvAAK5cf4YV3yoxuP61crYRol6SVg==",
      "requires": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@babel/plugin-proposal-unicode-property-regex": "^7.4.4",
        "@babel/plugin-transform-dotall-regex": "^7.4.4",
        "@babel/types": "^7.4.4",
        "esutils": "^2.0.2"
      }
    },
    "@babel/runtime": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.9.6.tgz",
      "integrity": "sha512-64AF1xY3OAkFHqOb9s4jpgk1Mm5vDZ4L3acHvAml+53nO1XbXLuDodsVpO4OIUsmemlUHMxNdYMNJmsvOwLrvQ==",
      "requires": {
        "regenerator-runtime": "^0.13.4"
      }
    },
    "@babel/template": {
      "version": "7.8.6",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.8.6.tgz",
      "integrity": "sha512-zbMsPMy/v0PWFZEhQJ66bqjhH+z0JgMoBWuikXybgG3Gkd/3t5oQ1Rw2WQhnSrsOmsKXnZOx15tkC4qON/+JPg==",
      "requires": {
        "@babel/code-frame": "^7.8.3",
        "@babel/parser": "^7.8.6",
        "@babel/types": "^7.8.6"
      }
    },
    "@babel/traverse": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.9.6.tgz",
      "integrity": "sha512-b3rAHSjbxy6VEAvlxM8OV/0X4XrG72zoxme6q1MOoe2vd0bEc+TwayhuC1+Dfgqh1QEG+pj7atQqvUprHIccsg==",
      "requires": {
        "@babel/code-frame": "^7.8.3",
        "@babel/generator": "^7.9.6",
        "@babel/helper-function-name": "^7.9.5",
        "@babel/helper-split-export-declaration": "^7.8.3",
        "@babel/parser": "^7.9.6",
        "@babel/types": "^7.9.6",
        "debug": "^4.1.0",
        "globals": "^11.1.0",
        "lodash": "^4.17.13"
      }
    },
    "@babel/types": {
      "version": "7.9.6",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.9.6.tgz",
      "integrity": "sha512-qxXzvBO//jO9ZnoasKF1uJzHd2+M6Q2ZPIVfnFps8JJvXy0ZBbwbNOmE6SGIY5XOY6d1Bo5lb9d9RJ8nv3WSeA==",
      "requires": {
        "@babel/helper-validator-identifier": "^7.9.5",
        "lodash": "^4.17.13",
        "to-fast-properties": "^2.0.0"
      }
    },
    "@bcoe/v8-coverage": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
      "dev": true
    },
    "@cnakazawa/watch": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@cnakazawa/watch/-/watch-1.0.4.tgz",
      "integrity": "sha512-v9kIhKwjeZThiWrLmj0y17CWoyddASLj9O2yvbZkbvw/N3rWOYy9zkV66ursAoVr0mV15bL8g0c4QZUE6cdDoQ==",
      "dev": true,
      "requires": {
        "exec-sh": "^0.3.2",
        "minimist": "^1.2.0"
      }
    },
    "@cypress/listr-verbose-renderer": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@cypress/listr-verbose-renderer/-/listr-verbose-renderer-0.4.1.tgz",
      "integrity": "sha1-p3SS9LEdzHxEajSz4ochr9M8ZCo=",
      "dev": true,
      "requires": {
        "chalk": "^1.1.3",
        "cli-cursor": "^1.0.2",
        "date-fns": "^1.27.2",
        "figures": "^1.7.0"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
          "integrity": "sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=",
          "dev": true
        },
        "chalk": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
          "integrity": "sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=",
          "dev": true,
          "requires": {
            "ansi-styles": "^2.2.1",
            "escape-string-regexp": "^1.0.2",
            "has-ansi": "^2.0.0",
            "strip-ansi": "^3.0.0",
            "supports-color": "^2.0.0"
          }
        },
        "cli-cursor": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-1.0.2.tgz",
          "integrity": "sha1-ZNo/fValRBLll5S9Ytw1KV6PKYc=",
          "dev": true,
          "requires": {
            "restore-cursor": "^1.0.1"
          }
        },
        "figures": {
          "version": "1.7.0",
          "resolved": "https://registry.npmjs.org/figures/-/figures-1.7.0.tgz",
          "integrity": "sha1-y+Hjr/zxzUS4DK3+0o3Hk6lwHS4=",
          "dev": true,
          "requires": {
            "escape-string-regexp": "^1.0.5",
            "object-assign": "^4.1.0"
          }
        },
        "onetime": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/onetime/-/onetime-1.1.0.tgz",
          "integrity": "sha1-ofeDj4MUxRbwXs78vEzP4EtO14k=",
          "dev": true
        },
        "restore-cursor": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-1.0.1.tgz",
          "integrity": "sha1-NGYfRohjJ/7SmRR5FSJS35LapUE=",
          "dev": true,
          "requires": {
            "exit-hook": "^1.0.0",
            "onetime": "^1.0.0"
          }
        },
        "supports-color": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
          "integrity": "sha1-U10EXOa2Nj+kARcIRimZXp3zJMc=",
          "dev": true
        }
      }
    },
    "@cypress/request": {
      "version": "2.88.5",
      "resolved": "https://registry.npmjs.org/@cypress/request/-/request-2.88.5.tgz",
      "integrity": "sha512-TzEC1XMi1hJkywWpRfD2clreTa/Z+lOrXDCxxBTBPEcY5azdPi56A6Xw+O4tWJnaJH3iIE7G5aDXZC6JgRZLcA==",
      "dev": true,
      "requires": {
        "aws-sign2": "~0.7.0",
        "aws4": "^1.8.0",
        "caseless": "~0.12.0",
        "combined-stream": "~1.0.6",
        "extend": "~3.0.2",
        "forever-agent": "~0.6.1",
        "form-data": "~2.3.2",
        "har-validator": "~5.1.3",
        "http-signature": "~1.2.0",
        "is-typedarray": "~1.0.0",
        "isstream": "~0.1.2",
        "json-stringify-safe": "~5.0.1",
        "mime-types": "~2.1.19",
        "oauth-sign": "~0.9.0",
        "performance-now": "^2.1.0",
        "qs": "~6.5.2",
        "safe-buffer": "^5.1.2",
        "tough-cookie": "~2.5.0",
        "tunnel-agent": "^0.6.0",
        "uuid": "^3.3.2"
      }
    },
    "@cypress/webpack-preprocessor": {
      "version": "4.1.5",
      "resolved": "https://registry.npmjs.org/@cypress/webpack-preprocessor/-/webpack-preprocessor-4.1.5.tgz",
      "integrity": "sha512-B4miSaS3VCMVSlfuvbWCjytTywdnquRsF1tQ3quC7TGUzEXnQZ4+o8WUKibjMozrOomALkUdMxqOJ1ib5oFkKw==",
      "requires": {
        "@babel/core": "^7.0.1",
        "@babel/preset-env": "^7.0.0",
        "babel-loader": "^8.0.2",
        "bluebird": "3.7.1",
        "debug": "4.1.1"
      },
      "dependencies": {
        "bluebird": {
          "version": "3.7.1",
          "resolved": "https://registry.npmjs.org/bluebird/-/bluebird-3.7.1.tgz",
          "integrity": "sha512-DdmyoGCleJnkbp3nkbxTLJ18rjDsE4yCggEwKNXkeV123sPNfOCYeDoeuOY+F2FrSjO1YXcTU+dsy96KMy+gcg=="
        }
      }
    },
    "@cypress/xvfb": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@cypress/xvfb/-/xvfb-1.2.4.tgz",
      "integrity": "sha512-skbBzPggOVYCbnGgV+0dmBdW/s77ZkAOXIC1knS8NagwDjBrNC1LuXtQJeiN6l+m7lzmHtaoUw/ctJKdqkG57Q==",
      "dev": true,
      "requires": {
        "debug": "^3.1.0",
        "lodash.once": "^4.1.1"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.7",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
          "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        }
      }
    },
    "@istanbuljs/load-nyc-config": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@istanbuljs/load-nyc-config/-/load-nyc-config-1.0.0.tgz",
      "integrity": "sha512-ZR0rq/f/E4f4XcgnDvtMWXCUJpi8eO0rssVhmztsZqLIEFA9UUP9zmpE0VxlM+kv/E1ul2I876Fwil2ayptDVg==",
      "dev": true,
      "requires": {
        "camelcase": "^5.3.1",
        "find-up": "^4.1.0",
        "js-yaml": "^3.13.1",
        "resolve-from": "^5.0.0"
      },
      "dependencies": {
        "resolve-from": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
          "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
          "dev": true
        }
      }
    },
    "@istanbuljs/schema": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.2.tgz",
      "integrity": "sha512-tsAQNx32a8CoFhjhijUIhI4kccIAgmGhy8LZMZgGfmXcpMbPRUqn5LWmgRttILi6yeGmBJd2xsPkFMs0PzgPCw==",
      "dev": true
    },
    "@jest/console": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/console/-/console-25.5.0.tgz",
      "integrity": "sha512-T48kZa6MK1Y6k4b89sexwmSF4YLeZS/Udqg3Jj3jG/cHH+N/sLFCEoXEDMOKugJQ9FxPN1osxIknvKkxt6MKyw==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "jest-message-util": "^25.5.0",
        "jest-util": "^25.5.0",
        "slash": "^3.0.0"
      },
      "dependencies": {
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        }
      }
    },
    "@jest/core": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/@jest/core/-/core-25.5.4.tgz",
      "integrity": "sha512-3uSo7laYxF00Dg/DMgbn4xMJKmDdWvZnf89n8Xj/5/AeQ2dOQmn6b6Hkj/MleyzZWXpwv+WSdYWl4cLsy2JsoA==",
      "dev": true,
      "requires": {
        "@jest/console": "^25.5.0",
        "@jest/reporters": "^25.5.1",
        "@jest/test-result": "^25.5.0",
        "@jest/transform": "^25.5.1",
        "@jest/types": "^25.5.0",
        "ansi-escapes": "^4.2.1",
        "chalk": "^3.0.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.4",
        "jest-changed-files": "^25.5.0",
        "jest-config": "^25.5.4",
        "jest-haste-map": "^25.5.1",
        "jest-message-util": "^25.5.0",
        "jest-regex-util": "^25.2.6",
        "jest-resolve": "^25.5.1",
        "jest-resolve-dependencies": "^25.5.4",
        "jest-runner": "^25.5.4",
        "jest-runtime": "^25.5.4",
        "jest-snapshot": "^25.5.1",
        "jest-util": "^25.5.0",
        "jest-validate": "^25.5.0",
        "jest-watcher": "^25.5.0",
        "micromatch": "^4.0.2",
        "p-each-series": "^2.1.0",
        "realpath-native": "^2.0.0",
        "rimraf": "^3.0.0",
        "slash": "^3.0.0",
        "strip-ansi": "^6.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "@jest/environment": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/environment/-/environment-25.5.0.tgz",
      "integrity": "sha512-U2VXPEqL07E/V7pSZMSQCvV5Ea4lqOlT+0ZFijl/i316cRMHvZ4qC+jBdryd+lmRetjQo0YIQr6cVPNxxK87mA==",
      "dev": true,
      "requires": {
        "@jest/fake-timers": "^25.5.0",
        "@jest/types": "^25.5.0",
        "jest-mock": "^25.5.0"
      }
    },
    "@jest/fake-timers": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/fake-timers/-/fake-timers-25.5.0.tgz",
      "integrity": "sha512-9y2+uGnESw/oyOI3eww9yaxdZyHq7XvprfP/eeoCsjqKYts2yRlsHS/SgjPDV8FyMfn2nbMy8YzUk6nyvdLOpQ==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "jest-message-util": "^25.5.0",
        "jest-mock": "^25.5.0",
        "jest-util": "^25.5.0",
        "lolex": "^5.0.0"
      }
    },
    "@jest/globals": {
      "version": "25.5.2",
      "resolved": "https://registry.npmjs.org/@jest/globals/-/globals-25.5.2.tgz",
      "integrity": "sha512-AgAS/Ny7Q2RCIj5kZ+0MuKM1wbF0WMLxbCVl/GOMoCNbODRdJ541IxJ98xnZdVSZXivKpJlNPIWa3QmY0l4CXA==",
      "dev": true,
      "requires": {
        "@jest/environment": "^25.5.0",
        "@jest/types": "^25.5.0",
        "expect": "^25.5.0"
      }
    },
    "@jest/reporters": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/@jest/reporters/-/reporters-25.5.1.tgz",
      "integrity": "sha512-3jbd8pPDTuhYJ7vqiHXbSwTJQNavczPs+f1kRprRDxETeE3u6srJ+f0NPuwvOmk+lmunZzPkYWIFZDLHQPkviw==",
      "dev": true,
      "requires": {
        "@bcoe/v8-coverage": "^0.2.3",
        "@jest/console": "^25.5.0",
        "@jest/test-result": "^25.5.0",
        "@jest/transform": "^25.5.1",
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "collect-v8-coverage": "^1.0.0",
        "exit": "^0.1.2",
        "glob": "^7.1.2",
        "graceful-fs": "^4.2.4",
        "istanbul-lib-coverage": "^3.0.0",
        "istanbul-lib-instrument": "^4.0.0",
        "istanbul-lib-report": "^3.0.0",
        "istanbul-lib-source-maps": "^4.0.0",
        "istanbul-reports": "^3.0.2",
        "jest-haste-map": "^25.5.1",
        "jest-resolve": "^25.5.1",
        "jest-util": "^25.5.0",
        "jest-worker": "^25.5.0",
        "node-notifier": "^6.0.0",
        "slash": "^3.0.0",
        "source-map": "^0.6.0",
        "string-length": "^3.1.0",
        "terminal-link": "^2.0.0",
        "v8-to-istanbul": "^4.1.3"
      },
      "dependencies": {
        "jest-worker": {
          "version": "25.5.0",
          "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-25.5.0.tgz",
          "integrity": "sha512-/dsSmUkIy5EBGfv/IjjqmFxrNAUpBERfGs1oHROyD7yxjG/w+t0GOJDX8O1k32ySmd7+a5IhnJU2qQFcJ4n1vw==",
          "dev": true,
          "requires": {
            "merge-stream": "^2.0.0",
            "supports-color": "^7.0.0"
          }
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "@jest/source-map": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/source-map/-/source-map-25.5.0.tgz",
      "integrity": "sha512-eIGx0xN12yVpMcPaVpjXPnn3N30QGJCJQSkEDUt9x1fI1Gdvb07Ml6K5iN2hG7NmMP6FDmtPEssE3z6doOYUwQ==",
      "dev": true,
      "requires": {
        "callsites": "^3.0.0",
        "graceful-fs": "^4.2.4",
        "source-map": "^0.6.0"
      },
      "dependencies": {
        "callsites": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
          "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "@jest/test-result": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/test-result/-/test-result-25.5.0.tgz",
      "integrity": "sha512-oV+hPJgXN7IQf/fHWkcS99y0smKLU2czLBJ9WA0jHITLst58HpQMtzSYxzaBvYc6U5U6jfoMthqsUlUlbRXs0A==",
      "dev": true,
      "requires": {
        "@jest/console": "^25.5.0",
        "@jest/types": "^25.5.0",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "collect-v8-coverage": "^1.0.0"
      }
    },
    "@jest/test-sequencer": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/@jest/test-sequencer/-/test-sequencer-25.5.4.tgz",
      "integrity": "sha512-pTJGEkSeg1EkCO2YWq6hbFvKNXk8ejqlxiOg1jBNLnWrgXOkdY6UmqZpwGFXNnRt9B8nO1uWMzLLZ4eCmhkPNA==",
      "dev": true,
      "requires": {
        "@jest/test-result": "^25.5.0",
        "graceful-fs": "^4.2.4",
        "jest-haste-map": "^25.5.1",
        "jest-runner": "^25.5.4",
        "jest-runtime": "^25.5.4"
      }
    },
    "@jest/transform": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/@jest/transform/-/transform-25.5.1.tgz",
      "integrity": "sha512-Y8CEoVwXb4QwA6Y/9uDkn0Xfz0finGkieuV0xkdF9UtZGJeLukD5nLkaVrVsODB1ojRWlaoD0AJZpVHCSnJEvg==",
      "dev": true,
      "requires": {
        "@babel/core": "^7.1.0",
        "@jest/types": "^25.5.0",
        "babel-plugin-istanbul": "^6.0.0",
        "chalk": "^3.0.0",
        "convert-source-map": "^1.4.0",
        "fast-json-stable-stringify": "^2.0.0",
        "graceful-fs": "^4.2.4",
        "jest-haste-map": "^25.5.1",
        "jest-regex-util": "^25.2.6",
        "jest-util": "^25.5.0",
        "micromatch": "^4.0.2",
        "pirates": "^4.0.1",
        "realpath-native": "^2.0.0",
        "slash": "^3.0.0",
        "source-map": "^0.6.1",
        "write-file-atomic": "^3.0.0"
      },
      "dependencies": {
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "@jest/types": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/@jest/types/-/types-25.5.0.tgz",
      "integrity": "sha512-OXD0RgQ86Tu3MazKo8bnrkDRaDXXMGUqd+kTtLtK1Zb7CRzQcaSRPPPV37SvYTdevXEBVxe0HXylEjs8ibkmCw==",
      "dev": true,
      "requires": {
        "@types/istanbul-lib-coverage": "^2.0.0",
        "@types/istanbul-reports": "^1.1.1",
        "@types/yargs": "^15.0.0",
        "chalk": "^3.0.0"
      }
    },
    "@jsdevtools/coverage-istanbul-loader": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@jsdevtools/coverage-istanbul-loader/-/coverage-istanbul-loader-3.0.3.tgz",
      "integrity": "sha512-TAdNkeGB5Fe4Og+ZkAr1Kvn9by2sfL44IAHFtxlh1BA1XJ5cLpO9iSNki5opWESv3l3vSHsZ9BNKuqFKbEbFaA==",
      "dev": true,
      "requires": {
        "convert-source-map": "^1.7.0",
        "istanbul-lib-instrument": "^4.0.1",
        "loader-utils": "^1.4.0",
        "merge-source-map": "^1.1.0",
        "schema-utils": "^2.6.4"
      }
    },
    "@nestjs/common": {
      "version": "7.4.2",
      "resolved": "https://registry.npmjs.org/@nestjs/common/-/common-7.4.2.tgz",
      "integrity": "sha512-gHfoUPPufBDLUdkBdhC60rgMwyiOKIFVmxCnFNHsMH1mrbt1DcXQD+5nefZm0XaLY20QeBoqZjJDc4KdvE444w==",
      "requires": {
        "axios": "0.19.2",
        "cli-color": "2.0.0",
        "iterare": "1.2.1",
        "tslib": "2.0.0",
        "uuid": "8.3.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz",
          "integrity": "sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g=="
        },
        "uuid": {
          "version": "8.3.0",
          "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.0.tgz",
          "integrity": "sha512-fX6Z5o4m6XsXBdli9g7DtWgAx+osMsRRZFKma1mIUsLCz6vRvv+pz5VNbyu9UEDzpMWulZfvpgb/cmDXVulYFQ=="
        }
      }
    },
    "@nestjs/core": {
      "version": "7.4.2",
      "resolved": "https://registry.npmjs.org/@nestjs/core/-/core-7.4.2.tgz",
      "integrity": "sha512-zLWVY+qj5RRIuDaL2J6a7f/Tn8wPMYOUHDZhXdRZFqonuY96dH9yc6DU9cWyX7fnmCIAxqdu5B7qd/S7VPHxow==",
      "requires": {
        "@nuxtjs/opencollective": "0.2.2",
        "fast-safe-stringify": "2.0.7",
        "iterare": "1.2.1",
        "object-hash": "2.0.3",
        "path-to-regexp": "3.2.0",
        "tslib": "2.0.0",
        "uuid": "8.3.0"
      },
      "dependencies": {
        "path-to-regexp": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-3.2.0.tgz",
          "integrity": "sha512-jczvQbCUS7XmS7o+y1aEO9OBVFeZBQ1MDSEqmO7xSoPgOPoowY/SxLpZ6Vh97/8qHZOteiCKb7gkG9gA2ZUxJA=="
        },
        "tslib": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz",
          "integrity": "sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g=="
        },
        "uuid": {
          "version": "8.3.0",
          "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.0.tgz",
          "integrity": "sha512-fX6Z5o4m6XsXBdli9g7DtWgAx+osMsRRZFKma1mIUsLCz6vRvv+pz5VNbyu9UEDzpMWulZfvpgb/cmDXVulYFQ=="
        }
      }
    },
    "@nestjs/platform-express": {
      "version": "7.4.2",
      "resolved": "https://registry.npmjs.org/@nestjs/platform-express/-/platform-express-7.4.2.tgz",
      "integrity": "sha512-pbwmUaKpAyLwp8iTfChvFqY/40wHXuqIPX2HGkHU0dbofd7sUpLJMlJCsOepR06/L+voRhmNC86yQm1EDAG7ag==",
      "requires": {
        "body-parser": "1.19.0",
        "cors": "2.8.5",
        "express": "4.17.1",
        "multer": "1.4.2",
        "tslib": "2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz",
          "integrity": "sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g=="
        }
      }
    },
    "@nestjs/schematics": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/@nestjs/schematics/-/schematics-7.0.1.tgz",
      "integrity": "sha512-MOnJPqKPpuwBHDdw96gHoshd/QEYrUlLPF92xQFXm6uIOo1EGISg8OOSoji2isEtp2gHpO+bL8p/h4oPG10Fqw==",
      "dev": true,
      "requires": {
        "@angular-devkit/core": "9.1.7",
        "@angular-devkit/schematics": "9.1.7",
        "fs-extra": "9.0.0"
      },
      "dependencies": {
        "@angular-devkit/core": {
          "version": "9.1.7",
          "resolved": "https://registry.npmjs.org/@angular-devkit/core/-/core-9.1.7.tgz",
          "integrity": "sha512-guvolu9Cl+qYMTtedLZD9wCqustJjdqzJ2psD2C1Sr1LrX9T0mprmDldR/YnhsitThveJEb6sM/0EvqWxoSvKw==",
          "dev": true,
          "requires": {
            "ajv": "6.12.0",
            "fast-json-stable-stringify": "2.1.0",
            "magic-string": "0.25.7",
            "rxjs": "6.5.4",
            "source-map": "0.7.3"
          }
        },
        "@angular-devkit/schematics": {
          "version": "9.1.7",
          "resolved": "https://registry.npmjs.org/@angular-devkit/schematics/-/schematics-9.1.7.tgz",
          "integrity": "sha512-oeHPJePBcPp/bd94jHQeFUnft93PGF5iJiKV9szxqS8WWC5OMZ5eK7icRY0PwvLyfenspAZxdZcNaqJqPMul5A==",
          "dev": true,
          "requires": {
            "@angular-devkit/core": "9.1.7",
            "ora": "4.0.3",
            "rxjs": "6.5.4"
          }
        },
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "fs-extra": {
          "version": "9.0.0",
          "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-9.0.0.tgz",
          "integrity": "sha512-pmEYSk3vYsG/bF651KPUXZ+hvjpgWYw/Gc7W9NFUe3ZVLczKKWIij3IKpOrQcdw4TILtibFslZ0UmR8Vvzig4g==",
          "dev": true,
          "requires": {
            "at-least-node": "^1.0.0",
            "graceful-fs": "^4.2.0",
            "jsonfile": "^6.0.1",
            "universalify": "^1.0.0"
          }
        },
        "jsonfile": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-6.0.1.tgz",
          "integrity": "sha512-jR2b5v7d2vIOust+w3wtFKZIfpC2pnRmFAhAC/BuweZFQR8qZzxH1OyrQ10HmdVYiXWkYUqPVsz91cG7EL2FBg==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.6",
            "universalify": "^1.0.0"
          }
        },
        "ora": {
          "version": "4.0.3",
          "resolved": "https://registry.npmjs.org/ora/-/ora-4.0.3.tgz",
          "integrity": "sha512-fnDebVFyz309A73cqCipVL1fBZewq4vwgSHfxh43vVy31mbyoQ8sCH3Oeaog/owYOs/lLlGVPCISQonTneg6Pg==",
          "dev": true,
          "requires": {
            "chalk": "^3.0.0",
            "cli-cursor": "^3.1.0",
            "cli-spinners": "^2.2.0",
            "is-interactive": "^1.0.0",
            "log-symbols": "^3.0.0",
            "mute-stream": "0.0.8",
            "strip-ansi": "^6.0.0",
            "wcwidth": "^1.0.1"
          }
        },
        "rxjs": {
          "version": "6.5.4",
          "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.5.4.tgz",
          "integrity": "sha512-naMQXcgEo3csAEGvw/NydRA0fuS2nDZJiw1YUWFKU7aPPAPGZEsD4Iimit96qwCieH6y614MCLYwdkrWx7z/7Q==",
          "dev": true,
          "requires": {
            "tslib": "^1.9.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        },
        "universalify": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/universalify/-/universalify-1.0.0.tgz",
          "integrity": "sha512-rb6X1W158d7pRQBg5gkR8uPaSfiids68LTJQYOtEUhoJUWBdaQHsuT/EUduxXYxcrt4r5PJ4fuHW1MHT6p0qug==",
          "dev": true
        }
      }
    },
    "@nestjs/testing": {
      "version": "7.4.2",
      "resolved": "https://registry.npmjs.org/@nestjs/testing/-/testing-7.4.2.tgz",
      "integrity": "sha512-wnb0ApdTrJ03sg/1YiNNjjDIdf/f0izOea/5Bx9goKEJQPf8IW5AlV4yK9FB1uotED0mcjzp0awqzbfHfipP7w==",
      "dev": true,
      "requires": {
        "optional": "0.1.4",
        "tslib": "2.0.0"
      },
      "dependencies": {
        "tslib": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.0.0.tgz",
          "integrity": "sha512-lTqkx847PI7xEDYJntxZH89L2/aXInsyF2luSafe/+0fHOMjlBNXdH6th7f70qxLDhul7KZK0zC8V5ZIyHl0/g==",
          "dev": true
        }
      }
    },
    "@ngrx/effects": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/effects/-/effects-9.1.0.tgz",
      "integrity": "sha512-DPMtp/2YTrvuxMqaehQ39FeoNODuMcRB6xDImvrnMFPIkUcP3mDHnIg6UB5c2JvfHlZZClKR+Fb+RE2nuVub8w=="
    },
    "@ngrx/entity": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/entity/-/entity-9.1.0.tgz",
      "integrity": "sha512-MrjdJeJIaUpPogxzK7S/z5Cc/6XWyyQfUgkXrTS20JZyX4amjVZYL3oU3FF3JhXO9ZkhaBFi07IDPEtvyYl/Mg=="
    },
    "@ngrx/router-store": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/router-store/-/router-store-9.1.0.tgz",
      "integrity": "sha512-zdIBUsfyrrA64mUqajHMARSwttOAOJ5FSyVJLHQfBlz9/vil6Kby1KhVLEG7mGmkz799YYlIM135QsrJhgf7wA=="
    },
    "@ngrx/schematics": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/schematics/-/schematics-9.1.0.tgz",
      "integrity": "sha512-CYfBFP/jCNFFQkV+Afc4kPCRf3Ye2NlNIEwU5urtZMt8WV8RWFbzsbL0O9UMH6zshPvwoZoBqU/5ZftZupxcHA==",
      "dev": true
    },
    "@ngrx/store": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/store/-/store-9.1.0.tgz",
      "integrity": "sha512-Ah2nApPZXTvKl7ybaFMIFwEdMg8b7PvIKATigbDTUftAsFxked2+T7blNv6aCgSfEqbOVMBTYPk7OsLCYZoz4Q=="
    },
    "@ngrx/store-devtools": {
      "version": "9.1.0",
      "resolved": "https://registry.npmjs.org/@ngrx/store-devtools/-/store-devtools-9.1.0.tgz",
      "integrity": "sha512-KDvuNBxfTgDHjESiouEoPXq8GCUYbHnA+jOs8MzzwVDmxNLeZuDy3amaVzKv9Q5nncI6mNGcXOzTKWzapET8Sw==",
      "dev": true
    },
    "@ngtools/webpack": {
      "version": "10.0.6",
      "resolved": "https://registry.npmjs.org/@ngtools/webpack/-/webpack-10.0.6.tgz",
      "integrity": "sha512-AbSDhPmsljkZO2jHFpge/5AHLQIrbscWgo4brrhF7NQ5TvPgE0Xn0wU7gxB9++hVUKQLGnnbAvewJyB/uYb9Nw==",
      "dev": true,
      "requires": {
        "@angular-devkit/core": "10.0.6",
        "enhanced-resolve": "4.1.1",
        "rxjs": "6.5.5",
        "webpack-sources": "1.4.3"
      },
      "dependencies": {
        "@angular-devkit/core": {
          "version": "10.0.6",
          "resolved": "https://registry.npmjs.org/@angular-devkit/core/-/core-10.0.6.tgz",
          "integrity": "sha512-mVvqSEoeErZ7bAModk95EAa6R9Nl23rvX+/TXuKVTK2dziMFBOrwHjb1DYhnZxFIH4xfUftCx+BWHjXBXCPYlA==",
          "dev": true,
          "requires": {
            "ajv": "6.12.3",
            "fast-json-stable-stringify": "2.1.0",
            "magic-string": "0.25.7",
            "rxjs": "6.5.5",
            "source-map": "0.7.3"
          }
        },
        "ajv": {
          "version": "6.12.3",
          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.3.tgz",
          "integrity": "sha512-4K0cK3L1hsqk9xIb2z9vs/XU+PGJZ9PNpJRDS9YLzmNdX6jmVPfamLvTJr0aDAusnHyCHO6MjzlkAsgtqp9teA==",
          "dev": true,
          "requires": {
            "fast-deep-equal": "^3.1.1",
            "fast-json-stable-stringify": "^2.0.0",
            "json-schema-traverse": "^0.4.1",
            "uri-js": "^4.2.2"
          }
        }
      }
    },
    "@nodelib/fs.scandir": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.3.tgz",
      "integrity": "sha512-eGmwYQn3gxo4r7jdQnkrrN6bY478C3P+a/y72IJukF8LjB6ZHeB3c+Ehacj3sYeSmUXGlnA67/PmbM9CVwL7Dw==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "2.0.3",
        "run-parallel": "^1.1.9"
      }
    },
    "@nodelib/fs.stat": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.3.tgz",
      "integrity": "sha512-bQBFruR2TAwoevBEd/NWMoAAtNGzTRgdrqnYCc7dhzfoNvqPzLyqlEQnzZ3kVnNrSp25iyxE00/3h2fqGAGArA==",
      "dev": true
    },
    "@nodelib/fs.walk": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.4.tgz",
      "integrity": "sha512-1V9XOY4rDW0rehzbrcqAmHnz8e7SKvX27gh8Gt2WgB0+pdzdiLV83p72kZPU+jvMbS1qU5mauP2iOvO8rhmurQ==",
      "dev": true,
      "requires": {
        "@nodelib/fs.scandir": "2.1.3",
        "fastq": "^1.6.0"
      }
    },
    "@npmcli/move-file": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@npmcli/move-file/-/move-file-1.0.1.tgz",
      "integrity": "sha512-Uv6h1sT+0DrblvIrolFtbvM1FgWm+/sy4B3pvLp67Zys+thcukzS5ekn7HsZFGpWP4Q3fYJCljbWQE/XivMRLw==",
      "dev": true,
      "requires": {
        "mkdirp": "^1.0.4"
      },
      "dependencies": {
        "mkdirp": {
          "version": "1.0.4",
          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
          "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
          "dev": true
        }
      }
    },
    "@nrwl/angular": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/angular/-/angular-10.0.12.tgz",
      "integrity": "sha512-xISTVUJ7XDTIFz8TqARXuHVz3vsG6YoZ8gS4tN8dTuxF+q9dFUEXOyfgeZLBf0Ckxw4FsyvwvN/COA7OI+o/cg==",
      "requires": {
        "@angular-devkit/schematics": "~10.0.0",
        "@nrwl/cypress": "10.0.12",
        "@nrwl/jest": "10.0.12",
        "@schematics/angular": "~10.0.0",
        "jasmine-marbles": "~0.6.0"
      }
    },
    "@nrwl/cli": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/cli/-/cli-10.0.12.tgz",
      "integrity": "sha512-7FBRjOxAXAn0r2Z9MuJj/PZA8GhTt9knWANWGubGzJh6Izr1jexgpaXMtvVcJUt8G/XFBAn2sBhWyyFZ8HqG5A==",
      "dev": true,
      "requires": {
        "@nrwl/tao": "10.0.12",
        "chalk": "2.4.2",
        "tmp": "0.0.33",
        "yargs": "^11.0.0",
        "yargs-parser": "10.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
          "dev": true
        },
        "camelcase": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-4.1.0.tgz",
          "integrity": "sha1-1UVjW+HjPFQmScaRc+Xeas+uNN0=",
          "dev": true
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "cliui": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-4.1.0.tgz",
          "integrity": "sha512-4FG+RSG9DL7uEwRUZXZn3SS34DiDPfzP0VOiEwtUWlE+AR2EIg+hSyvrIgUUfhdgR/UkAeW2QHgeP+hWrXs7jQ==",
          "dev": true,
          "requires": {
            "string-width": "^2.1.1",
            "strip-ansi": "^4.0.0",
            "wrap-ansi": "^2.0.0"
          }
        },
        "find-up": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz",
          "integrity": "sha1-RdG35QbHF93UgndaK3eSCjwMV6c=",
          "dev": true,
          "requires": {
            "locate-path": "^2.0.0"
          }
        },
        "get-caller-file": {
          "version": "1.0.3",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.3.tgz",
          "integrity": "sha512-3t6rVToeoZfYSGd8YoLFR2DJkiQrIiUrGcjvFX2mDw3bn6k2OtwHN0TNCLbBO+w8qTvimhDkv+LSscbJY1vE6w==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "dev": true,
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "locate-path": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-2.0.0.tgz",
          "integrity": "sha1-K1aLJl7slExtnA3pw9u7ygNUzY4=",
          "dev": true,
          "requires": {
            "p-locate": "^2.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-limit": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-1.3.0.tgz",
          "integrity": "sha512-vvcXsLAJ9Dr5rQOPk7toZQZJApBl2K4J6dANSsEuh6QI41JYcsS/qhTGa9ErIUUgK3WNQoJYvylxvjqmiqEA9Q==",
          "dev": true,
          "requires": {
            "p-try": "^1.0.0"
          }
        },
        "p-locate": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-2.0.0.tgz",
          "integrity": "sha1-IKAQOyIqcMj9OcwuWAaA893l7EM=",
          "dev": true,
          "requires": {
            "p-limit": "^1.1.0"
          }
        },
        "p-try": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/p-try/-/p-try-1.0.0.tgz",
          "integrity": "sha1-y8ec26+P1CKOE/Yh8rGiN8GyB7M=",
          "dev": true
        },
        "require-main-filename": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-1.0.1.tgz",
          "integrity": "sha1-l/cXtp1IeE9fUmpsWqj/3aBVpNE=",
          "dev": true
        },
        "strip-ansi": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^3.0.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "wrap-ansi": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
          "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
          "dev": true,
          "requires": {
            "string-width": "^1.0.1",
            "strip-ansi": "^3.0.1"
          },
          "dependencies": {
            "ansi-regex": {
              "version": "2.1.1",
              "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
              "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8=",
              "dev": true
            },
            "string-width": {
              "version": "1.0.2",
              "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
              "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
              "dev": true,
              "requires": {
                "code-point-at": "^1.0.0",
                "is-fullwidth-code-point": "^1.0.0",
                "strip-ansi": "^3.0.0"
              }
            },
            "strip-ansi": {
              "version": "3.0.1",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
              "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
              "dev": true,
              "requires": {
                "ansi-regex": "^2.0.0"
              }
            }
          }
        },
        "y18n": {
          "version": "3.2.1",
          "resolved": "https://registry.npmjs.org/y18n/-/y18n-3.2.1.tgz",
          "integrity": "sha1-bRX7qITAhnnA136I53WegR4H+kE=",
          "dev": true
        },
        "yargs": {
          "version": "11.1.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-11.1.1.tgz",
          "integrity": "sha512-PRU7gJrJaXv3q3yQZ/+/X6KBswZiaQ+zOmdprZcouPYtQgvNU35i+68M4b1ZHLZtYFT5QObFLV+ZkmJYcwKdiw==",
          "dev": true,
          "requires": {
            "cliui": "^4.0.0",
            "decamelize": "^1.1.1",
            "find-up": "^2.1.0",
            "get-caller-file": "^1.0.1",
            "os-locale": "^3.1.0",
            "require-directory": "^2.1.1",
            "require-main-filename": "^1.0.1",
            "set-blocking": "^2.0.0",
            "string-width": "^2.0.0",
            "which-module": "^2.0.0",
            "y18n": "^3.2.1",
            "yargs-parser": "^9.0.2"
          },
          "dependencies": {
            "yargs-parser": {
              "version": "9.0.2",
              "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-9.0.2.tgz",
              "integrity": "sha1-nM9qQ0YP5O1Aqbto9I1DuKaMwHc=",
              "dev": true,
              "requires": {
                "camelcase": "^4.1.0"
              }
            }
          }
        },
        "yargs-parser": {
          "version": "10.0.0",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-10.0.0.tgz",
          "integrity": "sha512-+DHejWujTVYeMHLff8U96rLc4uE4Emncoftvn5AjhB1Jw1pWxLzgBUT/WYbPrHmy6YPEBTZQx5myHhVcuuu64g==",
          "dev": true,
          "requires": {
            "camelcase": "^4.1.0"
          }
        }
      }
    },
    "@nrwl/cypress": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/cypress/-/cypress-10.0.12.tgz",
      "integrity": "sha512-ko+VuMATITg6mtAl3dgiaZH+PTp7f1kdO10dJO561jZkWkMYraleqlec8nBI6S9KHHn1WjfNqEZSrBUSgnGwtA==",
      "requires": {
        "@angular-devkit/architect": "~0.1000.0",
        "@angular-devkit/core": "~10.0.0",
        "@cypress/webpack-preprocessor": "~4.1.2",
        "fork-ts-checker-webpack-plugin": "^3.1.1",
        "tree-kill": "1.2.2",
        "ts-loader": "^5.3.1",
        "tsconfig-paths-webpack-plugin": "3.2.0",
        "webpack-node-externals": "1.7.2"
      }
    },
    "@nrwl/eslint-plugin-nx": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/eslint-plugin-nx/-/eslint-plugin-nx-10.0.12.tgz",
      "integrity": "sha512-/SM3ADR0FMwxdGn0wnkBSPsq66SLYXLmlfsXKkeW3ZFf/QU00L7ki9toWk9kNjCCK496kPtZFMdr/+kuwOQQxA==",
      "dev": true,
      "requires": {
        "@typescript-eslint/experimental-utils": "^2.19.2"
      }
    },
    "@nrwl/jest": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/jest/-/jest-10.0.12.tgz",
      "integrity": "sha512-7dz9s7Bt1V+NR4vPYfTLpq5p+3D5mxWyaWt2cqHLZCBLep0V0LiMi+OrgHt9Ryr2r4yzrQP8eJK9a65E3ejgfA==",
      "requires": {
        "@angular-devkit/architect": "~0.1000.0",
        "@angular-devkit/core": "~10.0.0",
        "@angular-devkit/schematics": "~10.0.0"
      }
    },
    "@nrwl/linter": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/linter/-/linter-10.0.12.tgz",
      "integrity": "sha512-vZ+Jv+TfLOCUQFJmyYN8i7I/dqZagnrdyt5iHThlrrRRCF8GTBEgzHep1u/KTZYT0YkYswyD4rCHbPfhBUnHKQ==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "~0.1000.0"
      }
    },
    "@nrwl/nest": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/nest/-/nest-10.0.12.tgz",
      "integrity": "sha512-kRONHcB2cFw0Jlzkfr3pXwptb6vlrS85dGrX6FWWoZDdNbLRF/3PrAYlTEGjKkPk8rGQD+cU0MtuHyGOrQdynA==",
      "dev": true,
      "requires": {
        "@angular-devkit/schematics": "~10.0.0",
        "@nestjs/schematics": "^7.0.0",
        "@nrwl/jest": "10.0.12",
        "@nrwl/node": "10.0.12"
      }
    },
    "@nrwl/node": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/node/-/node-10.0.12.tgz",
      "integrity": "sha512-egzp6+eKXvgPslls6xpEEt6+QkyhptqFAuUN989zgpnefijoKoFxN13iCwto7izcUBa8e7lYsBVgiAd8ySz9cA==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "~0.1000.0",
        "@angular-devkit/build-webpack": "~0.1000.0",
        "@angular-devkit/core": "~10.0.0",
        "@angular-devkit/schematics": "~10.0.0",
        "@nrwl/jest": "10.0.12",
        "@nrwl/linter": "10.0.12",
        "circular-dependency-plugin": "5.2.0",
        "copy-webpack-plugin": "5.1.1",
        "fork-ts-checker-webpack-plugin": "^3.1.1",
        "license-webpack-plugin": "2.1.2",
        "source-map-support": "0.5.12",
        "tree-kill": "1.2.2",
        "ts-loader": "5.4.5",
        "tsconfig-paths-webpack-plugin": "3.2.0",
        "webpack": "4.42.0",
        "webpack-dev-server": "3.9.0",
        "webpack-merge": "4.2.1",
        "webpack-node-externals": "1.7.2"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
          "dev": true
        },
        "anymatch": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-2.0.0.tgz",
          "integrity": "sha512-5teOsQWABXHHBFP9y3skS5P3d/WfWXpv3FUpy+LorMrNYaT9pI4oLMQX7jzQ2KklNpGpWHzdCXTDT2Y3XGlZBw==",
          "dev": true,
          "requires": {
            "micromatch": "^3.1.4",
            "normalize-path": "^2.1.1"
          },
          "dependencies": {
            "normalize-path": {
              "version": "2.1.1",
              "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
              "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
              "dev": true,
              "requires": {
                "remove-trailing-separator": "^1.0.1"
              }
            }
          }
        },
        "binary-extensions": {
          "version": "1.13.1",
          "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.1.tgz",
          "integrity": "sha512-Un7MIEDdUC5gNpcGDV97op1Ywk748MpHcFTHoYs6qnj1Z3j7I53VG3nwZhKzoBZmbdRNnb6WRdFlwl7tSDuZGw==",
          "dev": true
        },
        "braces": {
          "version": "2.3.2",
          "resolved": "https://registry.npmjs.org/braces/-/braces-2.3.2.tgz",
          "integrity": "sha512-aNdbnj9P8PjdXU4ybaWLK2IF3jc/EoDYbC7AazW6to3TRsfXxscC9UXOB5iDiEQrkyIbWp2SLQda4+QAa7nc3w==",
          "dev": true,
          "requires": {
            "arr-flatten": "^1.1.0",
            "array-unique": "^0.3.2",
            "extend-shallow": "^2.0.1",
            "fill-range": "^4.0.0",
            "isobject": "^3.0.1",
            "repeat-element": "^1.1.2",
            "snapdragon": "^0.8.1",
            "snapdragon-node": "^2.0.1",
            "split-string": "^3.0.2",
            "to-regex": "^3.0.1"
          }
        },
        "chokidar": {
          "version": "2.1.8",
          "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-2.1.8.tgz",
          "integrity": "sha512-ZmZUazfOzf0Nve7duiCKD23PFSCs4JPoYyccjUFF3aQkQadqBhfzhjkwBH2mNOG9cTBwhamM37EIsIkZw3nRgg==",
          "dev": true,
          "requires": {
            "anymatch": "^2.0.0",
            "async-each": "^1.0.1",
            "braces": "^2.3.2",
            "fsevents": "^1.2.7",
            "glob-parent": "^3.1.0",
            "inherits": "^2.0.3",
            "is-binary-path": "^1.0.0",
            "is-glob": "^4.0.0",
            "normalize-path": "^3.0.0",
            "path-is-absolute": "^1.0.0",
            "readdirp": "^2.2.1",
            "upath": "^1.1.1"
          }
        },
        "cliui": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-4.1.0.tgz",
          "integrity": "sha512-4FG+RSG9DL7uEwRUZXZn3SS34DiDPfzP0VOiEwtUWlE+AR2EIg+hSyvrIgUUfhdgR/UkAeW2QHgeP+hWrXs7jQ==",
          "dev": true,
          "requires": {
            "string-width": "^2.1.1",
            "strip-ansi": "^4.0.0",
            "wrap-ansi": "^2.0.0"
          },
          "dependencies": {
            "strip-ansi": {
              "version": "4.0.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
              "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
              "dev": true,
              "requires": {
                "ansi-regex": "^3.0.0"
              }
            }
          }
        },
        "fill-range": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-4.0.0.tgz",
          "integrity": "sha1-1USBHUKPmOsGpj3EAtJAPDKMOPc=",
          "dev": true,
          "requires": {
            "extend-shallow": "^2.0.1",
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1",
            "to-regex-range": "^2.1.0"
          }
        },
        "find-up": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
          "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
          "dev": true,
          "requires": {
            "locate-path": "^3.0.0"
          }
        },
        "fsevents": {
          "version": "1.2.13",
          "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-1.2.13.tgz",
          "integrity": "sha512-oWb1Z6mkHIskLzEJ/XWX0srkpkTQ7vaopMQkyaEIoq0fmtFVxOthb8cCxeT+p3ynTdkk/RZwbgG4brR5BeWECw==",
          "dev": true,
          "optional": true,
          "requires": {
            "bindings": "^1.5.0",
            "nan": "^2.12.1"
          }
        },
        "get-caller-file": {
          "version": "1.0.3",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.3.tgz",
          "integrity": "sha512-3t6rVToeoZfYSGd8YoLFR2DJkiQrIiUrGcjvFX2mDw3bn6k2OtwHN0TNCLbBO+w8qTvimhDkv+LSscbJY1vE6w==",
          "dev": true
        },
        "glob-parent": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-3.1.0.tgz",
          "integrity": "sha1-nmr2KZ2NO9K9QEMIMr0RPfkGxa4=",
          "dev": true,
          "requires": {
            "is-glob": "^3.1.0",
            "path-dirname": "^1.0.0"
          },
          "dependencies": {
            "is-glob": {
              "version": "3.1.0",
              "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-3.1.0.tgz",
              "integrity": "sha1-e6WuJCF4BKxwcHuWkiVnSGzD6Eo=",
              "dev": true,
              "requires": {
                "is-extglob": "^2.1.0"
              }
            }
          }
        },
        "is-absolute-url": {
          "version": "3.0.3",
          "resolved": "https://registry.npmjs.org/is-absolute-url/-/is-absolute-url-3.0.3.tgz",
          "integrity": "sha512-opmNIX7uFnS96NtPmhWQgQx6/NYFgsUXYMllcfzwWKUMwfo8kku1TvE6hkNcH+Q1ts5cMVrsY7j0bxXQDciu9Q==",
          "dev": true
        },
        "is-binary-path": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-1.0.1.tgz",
          "integrity": "sha1-dfFmQrSA8YenEcgUFh/TpKdlWJg=",
          "dev": true,
          "requires": {
            "binary-extensions": "^1.0.0"
          }
        },
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "dev": true,
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "license-webpack-plugin": {
          "version": "2.1.2",
          "resolved": "https://registry.npmjs.org/license-webpack-plugin/-/license-webpack-plugin-2.1.2.tgz",
          "integrity": "sha512-7poZHRla+ae0eEButlwMrPpkXyhNVBf2EHePYWT0jyLnI6311/OXJkTI2sOIRungRpQgU2oDMpro5bSFPT5F0A==",
          "dev": true,
          "requires": {
            "@types/webpack-sources": "^0.1.5",
            "webpack-sources": "^1.2.0"
          }
        },
        "locate-path": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
          "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
          "dev": true,
          "requires": {
            "p-locate": "^3.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-locate": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
          "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
          "dev": true,
          "requires": {
            "p-limit": "^2.0.0"
          }
        },
        "readdirp": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-2.2.1.tgz",
          "integrity": "sha512-1JU/8q+VgFZyxwrJ+SVIOsh+KywWGpds3NTqikiKpDMZWScmAYyKIgqkO+ARvNWJfXeXR1zxz7aHF4u4CyH6vQ==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.11",
            "micromatch": "^3.1.10",
            "readable-stream": "^2.0.2"
          }
        },
        "require-main-filename": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-1.0.1.tgz",
          "integrity": "sha1-l/cXtp1IeE9fUmpsWqj/3aBVpNE=",
          "dev": true
        },
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "source-map-support": {
          "version": "0.5.12",
          "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.12.tgz",
          "integrity": "sha512-4h2Pbvyy15EE02G+JOZpUCmqWJuqrs+sEkzewTm++BPi7Hvn/HwcqLAcNxYAyI0x13CpPPn+kMjl+hplXMHITQ==",
          "dev": true,
          "requires": {
            "buffer-from": "^1.0.0",
            "source-map": "^0.6.0"
          }
        },
        "supports-color": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.1.0.tgz",
          "integrity": "sha512-qe1jfm1Mg7Nq/NSh6XE24gPXROEVsWHxC1LIx//XNlD9iw7YZQGjZNjYN7xGaEG6iKdA8EtNFW6R0gjnVXp+wQ==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "to-regex-range": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-2.1.1.tgz",
          "integrity": "sha1-fIDBe53+vlmeJzZ+DU3VWQFB2zg=",
          "dev": true,
          "requires": {
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1"
          }
        },
        "webpack-dev-server": {
          "version": "3.9.0",
          "resolved": "https://registry.npmjs.org/webpack-dev-server/-/webpack-dev-server-3.9.0.tgz",
          "integrity": "sha512-E6uQ4kRrTX9URN9s/lIbqTAztwEPdvzVrcmHE8EQ9YnuT9J8Es5Wrd8n9BKg1a0oZ5EgEke/EQFgUsp18dSTBw==",
          "dev": true,
          "requires": {
            "ansi-html": "0.0.7",
            "bonjour": "^3.5.0",
            "chokidar": "^2.1.8",
            "compression": "^1.7.4",
            "connect-history-api-fallback": "^1.6.0",
            "debug": "^4.1.1",
            "del": "^4.1.1",
            "express": "^4.17.1",
            "html-entities": "^1.2.1",
            "http-proxy-middleware": "0.19.1",
            "import-local": "^2.0.0",
            "internal-ip": "^4.3.0",
            "ip": "^1.1.5",
            "is-absolute-url": "^3.0.3",
            "killable": "^1.0.1",
            "loglevel": "^1.6.4",
            "opn": "^5.5.0",
            "p-retry": "^3.0.1",
            "portfinder": "^1.0.25",
            "schema-utils": "^1.0.0",
            "selfsigned": "^1.10.7",
            "semver": "^6.3.0",
            "serve-index": "^1.9.1",
            "sockjs": "0.3.19",
            "sockjs-client": "1.4.0",
            "spdy": "^4.0.1",
            "strip-ansi": "^3.0.1",
            "supports-color": "^6.1.0",
            "url": "^0.11.0",
            "webpack-dev-middleware": "^3.7.2",
            "webpack-log": "^2.0.0",
            "ws": "^6.2.1",
            "yargs": "12.0.5"
          }
        },
        "webpack-merge": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/webpack-merge/-/webpack-merge-4.2.1.tgz",
          "integrity": "sha512-4p8WQyS98bUJcCvFMbdGZyZmsKuWjWVnVHnAS3FFg0HDaRVrPbkivx2RYCre8UiemD67RsiFFLfn4JhLAin8Vw==",
          "dev": true,
          "requires": {
            "lodash": "^4.17.5"
          }
        },
        "wrap-ansi": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
          "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
          "dev": true,
          "requires": {
            "string-width": "^1.0.1",
            "strip-ansi": "^3.0.1"
          },
          "dependencies": {
            "string-width": {
              "version": "1.0.2",
              "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
              "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
              "dev": true,
              "requires": {
                "code-point-at": "^1.0.0",
                "is-fullwidth-code-point": "^1.0.0",
                "strip-ansi": "^3.0.0"
              }
            }
          }
        },
        "yargs": {
          "version": "12.0.5",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-12.0.5.tgz",
          "integrity": "sha512-Lhz8TLaYnxq/2ObqHDql8dX8CJi97oHxrjUcYtzKbbykPtVW9WB+poxI+NM2UIzsMgNCZTIf0AQwsjK5yMAqZw==",
          "dev": true,
          "requires": {
            "cliui": "^4.0.0",
            "decamelize": "^1.2.0",
            "find-up": "^3.0.0",
            "get-caller-file": "^1.0.1",
            "os-locale": "^3.0.0",
            "require-directory": "^2.1.1",
            "require-main-filename": "^1.0.1",
            "set-blocking": "^2.0.0",
            "string-width": "^2.0.0",
            "which-module": "^2.0.0",
            "y18n": "^3.2.1 || ^4.0.0",
            "yargs-parser": "^11.1.1"
          }
        },
        "yargs-parser": {
          "version": "11.1.1",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-11.1.1.tgz",
          "integrity": "sha512-C6kB/WJDiaxONLJQnF8ccx9SEeoTTLek8RVbaOIsrAUS8VrBEXfmeSnCZxygc+XC2sNMBIwOOnfcxiynjHsVSQ==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "@nrwl/tao": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/tao/-/tao-10.0.12.tgz",
      "integrity": "sha512-L73NxtkAj9HXdfUpX7x+HkrldooInML9fPybiBP0LCgCLotpkKF0cC+Fans4S3qb+S/9ntHkjcYx0DlElxC2+w==",
      "dev": true,
      "requires": {
        "@angular-devkit/architect": "~0.1000.0",
        "@angular-devkit/core": "~10.0.0",
        "@angular-devkit/schematics": "~10.0.0",
        "inquirer": "^6.3.1",
        "minimist": "^1.2.0",
        "strip-json-comments": "2.0.1"
      },
      "dependencies": {
        "ansi-escapes": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-3.2.0.tgz",
          "integrity": "sha512-cBhpre4ma+U0T1oM5fXg7Dy1Jw7zzwv7lt/GoCpr+hDQJoYnKVPLL4dCvSEFMmQurOQvSrwT7SL/DAlhBI97RQ==",
          "dev": true
        },
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "cli-cursor": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-2.1.0.tgz",
          "integrity": "sha1-s12sN2R5+sw+lHR9QdDQ9SOP/LU=",
          "dev": true,
          "requires": {
            "restore-cursor": "^2.0.0"
          }
        },
        "figures": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/figures/-/figures-2.0.0.tgz",
          "integrity": "sha1-OrGi0qYsi/tDGgyUy3l6L84nyWI=",
          "dev": true,
          "requires": {
            "escape-string-regexp": "^1.0.5"
          }
        },
        "inquirer": {
          "version": "6.5.2",
          "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-6.5.2.tgz",
          "integrity": "sha512-cntlB5ghuB0iuO65Ovoi8ogLHiWGs/5yNrtUcKjFhSSiVeAIVpD7koaSU9RM8mpXw5YDi9RdYXGQMaOURB7ycQ==",
          "dev": true,
          "requires": {
            "ansi-escapes": "^3.2.0",
            "chalk": "^2.4.2",
            "cli-cursor": "^2.1.0",
            "cli-width": "^2.0.0",
            "external-editor": "^3.0.3",
            "figures": "^2.0.0",
            "lodash": "^4.17.12",
            "mute-stream": "0.0.7",
            "run-async": "^2.2.0",
            "rxjs": "^6.4.0",
            "string-width": "^2.1.0",
            "strip-ansi": "^5.1.0",
            "through": "^2.3.6"
          }
        },
        "mimic-fn": {
          "version": "1.2.0",
          "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.2.0.tgz",
          "integrity": "sha512-jf84uxzwiuiIVKiOLpfYk7N46TSy8ubTonmneY9vrpHNAnp0QBt2BxWV9dO3/j+BoVAb+a5G6YDPW3M5HOdMWQ==",
          "dev": true
        },
        "mute-stream": {
          "version": "0.0.7",
          "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.7.tgz",
          "integrity": "sha1-MHXOk7whuPq0PhvE2n6BFe0ee6s=",
          "dev": true
        },
        "onetime": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/onetime/-/onetime-2.0.1.tgz",
          "integrity": "sha1-BnQoIw/WdEOyeUsiu6UotoZ5YtQ=",
          "dev": true,
          "requires": {
            "mimic-fn": "^1.0.0"
          }
        },
        "restore-cursor": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-2.0.0.tgz",
          "integrity": "sha1-n37ih/gv0ybU/RYpI9YhKe7g368=",
          "dev": true,
          "requires": {
            "onetime": "^2.0.0",
            "signal-exit": "^3.0.2"
          }
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@nrwl/workspace": {
      "version": "10.0.12",
      "resolved": "https://registry.npmjs.org/@nrwl/workspace/-/workspace-10.0.12.tgz",
      "integrity": "sha512-5K9DsTT8BqDzBTXlT68YSo8KbSKm8ZxItu7hztH0tS017N4ZT4NZ3gc3t5ppMqNTJK1LCVSxFU7+dMYvvof5ig==",
      "dev": true,
      "requires": {
        "@angular-devkit/core": "~10.0.0",
        "@angular-devkit/schematics": "~10.0.0",
        "@nrwl/cli": "10.0.12",
        "axios": "0.19.2",
        "chalk": "2.4.2",
        "cosmiconfig": "4.0.0",
        "dotenv": "8.2.0",
        "fs-extra": "6.0.0",
        "ignore": "5.0.4",
        "npm-run-all": "4.1.5",
        "opn": "^5.3.0",
        "rxjs": "^6.5.4",
        "semver": "5.4.1",
        "strip-json-comments": "2.0.1",
        "tmp": "0.0.33",
        "yargs": "^11.0.0",
        "yargs-parser": "10.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
          "dev": true
        },
        "camelcase": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-4.1.0.tgz",
          "integrity": "sha1-1UVjW+HjPFQmScaRc+Xeas+uNN0=",
          "dev": true
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "cliui": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-4.1.0.tgz",
          "integrity": "sha512-4FG+RSG9DL7uEwRUZXZn3SS34DiDPfzP0VOiEwtUWlE+AR2EIg+hSyvrIgUUfhdgR/UkAeW2QHgeP+hWrXs7jQ==",
          "dev": true,
          "requires": {
            "string-width": "^2.1.1",
            "strip-ansi": "^4.0.0",
            "wrap-ansi": "^2.0.0"
          }
        },
        "cosmiconfig": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-4.0.0.tgz",
          "integrity": "sha512-6e5vDdrXZD+t5v0L8CrurPeybg4Fmf+FCSYxXKYVAqLUtyCSbuyqE059d0kDthTNRzKVjL7QMgNpEUlsoYH3iQ==",
          "dev": true,
          "requires": {
            "is-directory": "^0.3.1",
            "js-yaml": "^3.9.0",
            "parse-json": "^4.0.0",
            "require-from-string": "^2.0.1"
          }
        },
        "dotenv": {
          "version": "8.2.0",
          "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-8.2.0.tgz",
          "integrity": "sha512-8sJ78ElpbDJBHNeBzUbUVLsqKdccaa/BXF1uPTw3GrvQTBgrQrtObr2mUrE38vzYd8cEv+m/JBfDLioYcfXoaw==",
          "dev": true
        },
        "find-up": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz",
          "integrity": "sha1-RdG35QbHF93UgndaK3eSCjwMV6c=",
          "dev": true,
          "requires": {
            "locate-path": "^2.0.0"
          }
        },
        "fs-extra": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-6.0.0.tgz",
          "integrity": "sha512-lk2cUCo8QzbiEWEbt7Cw3m27WMiRG321xsssbcIpfMhpRjrlC08WBOVQqj1/nQYYNnPtyIhP1oqLO3QwT2tPCw==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.2",
            "jsonfile": "^4.0.0",
            "universalify": "^0.1.0"
          }
        },
        "get-caller-file": {
          "version": "1.0.3",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-1.0.3.tgz",
          "integrity": "sha512-3t6rVToeoZfYSGd8YoLFR2DJkiQrIiUrGcjvFX2mDw3bn6k2OtwHN0TNCLbBO+w8qTvimhDkv+LSscbJY1vE6w==",
          "dev": true
        },
        "ignore": {
          "version": "5.0.4",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.0.4.tgz",
          "integrity": "sha512-WLsTMEhsQuXpCiG173+f3aymI43SXa+fB1rSfbzyP4GkPP+ZFVuO0/3sFUGNBtifisPeDcl/uD/Y2NxZ7xFq4g==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "dev": true,
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "locate-path": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-2.0.0.tgz",
          "integrity": "sha1-K1aLJl7slExtnA3pw9u7ygNUzY4=",
          "dev": true,
          "requires": {
            "p-locate": "^2.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-limit": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-1.3.0.tgz",
          "integrity": "sha512-vvcXsLAJ9Dr5rQOPk7toZQZJApBl2K4J6dANSsEuh6QI41JYcsS/qhTGa9ErIUUgK3WNQoJYvylxvjqmiqEA9Q==",
          "dev": true,
          "requires": {
            "p-try": "^1.0.0"
          }
        },
        "p-locate": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-2.0.0.tgz",
          "integrity": "sha1-IKAQOyIqcMj9OcwuWAaA893l7EM=",
          "dev": true,
          "requires": {
            "p-limit": "^1.1.0"
          }
        },
        "p-try": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/p-try/-/p-try-1.0.0.tgz",
          "integrity": "sha1-y8ec26+P1CKOE/Yh8rGiN8GyB7M=",
          "dev": true
        },
        "require-main-filename": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-1.0.1.tgz",
          "integrity": "sha1-l/cXtp1IeE9fUmpsWqj/3aBVpNE=",
          "dev": true
        },
        "semver": {
          "version": "5.4.1",
          "resolved": "https://registry.npmjs.org/semver/-/semver-5.4.1.tgz",
          "integrity": "sha512-WfG/X9+oATh81XtllIo/I8gOiY9EXRdv1cQdyykeXK17YcUW3EXUAi2To4pcH6nZtJPr7ZOpM5OMyWJZm+8Rsg==",
          "dev": true
        },
        "strip-ansi": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^3.0.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "wrap-ansi": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-2.1.0.tgz",
          "integrity": "sha1-2Pw9KE3QV5T+hJc8rs3Rz4JP3YU=",
          "dev": true,
          "requires": {
            "string-width": "^1.0.1",
            "strip-ansi": "^3.0.1"
          },
          "dependencies": {
            "ansi-regex": {
              "version": "2.1.1",
              "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
              "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8=",
              "dev": true
            },
            "string-width": {
              "version": "1.0.2",
              "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
              "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
              "dev": true,
              "requires": {
                "code-point-at": "^1.0.0",
                "is-fullwidth-code-point": "^1.0.0",
                "strip-ansi": "^3.0.0"
              }
            },
            "strip-ansi": {
              "version": "3.0.1",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
              "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
              "dev": true,
              "requires": {
                "ansi-regex": "^2.0.0"
              }
            }
          }
        },
        "y18n": {
          "version": "3.2.1",
          "resolved": "https://registry.npmjs.org/y18n/-/y18n-3.2.1.tgz",
          "integrity": "sha1-bRX7qITAhnnA136I53WegR4H+kE=",
          "dev": true
        },
        "yargs": {
          "version": "11.1.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-11.1.1.tgz",
          "integrity": "sha512-PRU7gJrJaXv3q3yQZ/+/X6KBswZiaQ+zOmdprZcouPYtQgvNU35i+68M4b1ZHLZtYFT5QObFLV+ZkmJYcwKdiw==",
          "dev": true,
          "requires": {
            "cliui": "^4.0.0",
            "decamelize": "^1.1.1",
            "find-up": "^2.1.0",
            "get-caller-file": "^1.0.1",
            "os-locale": "^3.1.0",
            "require-directory": "^2.1.1",
            "require-main-filename": "^1.0.1",
            "set-blocking": "^2.0.0",
            "string-width": "^2.0.0",
            "which-module": "^2.0.0",
            "y18n": "^3.2.1",
            "yargs-parser": "^9.0.2"
          },
          "dependencies": {
            "yargs-parser": {
              "version": "9.0.2",
              "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-9.0.2.tgz",
              "integrity": "sha1-nM9qQ0YP5O1Aqbto9I1DuKaMwHc=",
              "dev": true,
              "requires": {
                "camelcase": "^4.1.0"
              }
            }
          }
        },
        "yargs-parser": {
          "version": "10.0.0",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-10.0.0.tgz",
          "integrity": "sha512-+DHejWujTVYeMHLff8U96rLc4uE4Emncoftvn5AjhB1Jw1pWxLzgBUT/WYbPrHmy6YPEBTZQx5myHhVcuuu64g==",
          "dev": true,
          "requires": {
            "camelcase": "^4.1.0"
          }
        }
      }
    },
    "@nuxtjs/opencollective": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/@nuxtjs/opencollective/-/opencollective-0.2.2.tgz",
      "integrity": "sha512-69gFVDs7mJfNjv9Zs5DFVD+pvBW+k1TaHSOqUWqAyTTfLcKI/EMYQgvEvziRd+zAFtUOoye6MfWh0qvinGISPw==",
      "requires": {
        "chalk": "^2.4.1",
        "consola": "^2.3.0",
        "node-fetch": "^2.3.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "@samverschueren/stream-to-observable": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/@samverschueren/stream-to-observable/-/stream-to-observable-0.3.1.tgz",
      "integrity": "sha512-c/qwwcHyafOQuVQJj0IlBjf5yYgBI7YPJ77k4fOJYesb41jio65eaJODRUmfYKhTOFBrIZ66kgvGPlNbjuoRdQ==",
      "dev": true,
      "requires": {
        "any-observable": "^0.3.0"
      }
    },
    "@schematics/angular": {
      "version": "10.0.6",
      "resolved": "https://registry.npmjs.org/@schematics/angular/-/angular-10.0.6.tgz",
      "integrity": "sha512-TPBpo0GnMJLvKE6rYZDkSy9pnkMH55rSJ6nfLDpQ5zzmhoD/QnASUr8trfTFs3+MqmPlX61xI00+HmStmI8sJQ==",
      "requires": {
        "@angular-devkit/core": "10.0.6",
        "@angular-devkit/schematics": "10.0.6"
      }
    },
    "@schematics/update": {
      "version": "0.1000.6",
      "resolved": "https://registry.npmjs.org/@schematics/update/-/update-0.1000.6.tgz",
      "integrity": "sha512-GGfPGPjRF/MA4EeJ+h1ebzoYDzChF4BV7SaTfpT107LPCD3McRjKS39Jw2qH/ArGNSbrbJ8fYNOIj3g/uh1GoA==",
      "dev": true,
      "requires": {
        "@angular-devkit/core": "10.0.6",
        "@angular-devkit/schematics": "10.0.6",
        "@yarnpkg/lockfile": "1.1.0",
        "ini": "1.3.5",
        "npm-package-arg": "^8.0.0",
        "pacote": "9.5.12",
        "rxjs": "6.5.5",
        "semver": "7.3.2",
        "semver-intersect": "1.4.0"
      },
      "dependencies": {
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        }
      }
    },
    "@sinonjs/commons": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/@sinonjs/commons/-/commons-1.7.2.tgz",
      "integrity": "sha512-+DUO6pnp3udV/v2VfUWgaY5BIE1IfT7lLfeDzPVeMT1XKkaAp9LgSI9x5RtrFQoZ9Oi0PgXQQHPaoKu7dCjVxw==",
      "dev": true,
      "requires": {
        "type-detect": "4.0.8"
      }
    },
    "@sinonjs/fake-timers": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/@sinonjs/fake-timers/-/fake-timers-6.0.1.tgz",
      "integrity": "sha512-MZPUxrmFubI36XS1DI3qmI0YdN1gks62JtFZvxR67ljjSNCeK6U08Zx4msEWOXuofgqUt6zPHSi1H9fbjR/NRA==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1.7.0"
      }
    },
    "@sinonjs/formatio": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/@sinonjs/formatio/-/formatio-5.0.1.tgz",
      "integrity": "sha512-KaiQ5pBf1MpS09MuA0kp6KBQt2JUOQycqVG1NZXvzeaXe5LGFqAKueIS0bw4w0P9r7KuBSVdUk5QjXsUdu2CxQ==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1",
        "@sinonjs/samsam": "^5.0.2"
      }
    },
    "@sinonjs/samsam": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/@sinonjs/samsam/-/samsam-5.0.3.tgz",
      "integrity": "sha512-QucHkc2uMJ0pFGjJUDP3F9dq5dx8QIaqISl9QgwLOh6P9yv877uONPGXh/OH/0zmM3tW1JjuJltAZV2l7zU+uQ==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1.6.0",
        "lodash.get": "^4.4.2",
        "type-detect": "^4.0.8"
      }
    },
    "@sinonjs/text-encoding": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/@sinonjs/text-encoding/-/text-encoding-0.7.1.tgz",
      "integrity": "sha512-+iTbntw2IZPb/anVDbypzfQa+ay64MW0Zo8aJ8gZPWMMK6/OubMVb6lUPMagqjOPnmtauXnFCACVl3O7ogjeqQ==",
      "dev": true
    },
    "@types/babel__core": {
      "version": "7.1.7",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.1.7.tgz",
      "integrity": "sha512-RL62NqSFPCDK2FM1pSDH0scHpJvsXtZNiYlMB73DgPBaG1E38ZYVL+ei5EkWRbr+KC4YNiAUNBnRj+bgwpgjMw==",
      "dev": true,
      "requires": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "@types/babel__generator": {
      "version": "7.6.1",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.6.1.tgz",
      "integrity": "sha512-bBKm+2VPJcMRVwNhxKu8W+5/zT7pwNEqeokFOmbvVSqGzFneNxYcEBro9Ac7/N9tlsaPYnZLK8J1LWKkMsLAew==",
      "dev": true,
      "requires": {
        "@babel/types": "^7.0.0"
      }
    },
    "@types/babel__template": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.0.2.tgz",
      "integrity": "sha512-/K6zCpeW7Imzgab2bLkLEbz0+1JlFSrUMdw7KoIIu+IUdu51GWaBZpd3y1VXGVXzynvGa4DaIaxNZHiON3GXUg==",
      "dev": true,
      "requires": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "@types/babel__traverse": {
      "version": "7.0.11",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.0.11.tgz",
      "integrity": "sha512-ddHK5icION5U6q11+tV2f9Mo6CZVuT8GJKld2q9LqHSZbvLbH34Kcu2yFGckZut453+eQU6btIA3RihmnRgI+Q==",
      "dev": true,
      "requires": {
        "@babel/types": "^7.3.0"
      }
    },
    "@types/chai": {
      "version": "4.2.11",
      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-4.2.11.tgz",
      "integrity": "sha512-t7uW6eFafjO+qJ3BIV2gGUyZs27egcNRkUdalkud+Qa3+kg//f129iuOFivHDXQ+vnU3fDXuwgv0cqMCbcE8sw==",
      "dev": true
    },
    "@types/color-name": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@types/color-name/-/color-name-1.1.1.tgz",
      "integrity": "sha512-rr+OQyAjxze7GgWrSaJwydHStIhHq2lvY3BOC2Mj7KnzI7XK0Uw1TOOdI9lDoajEbSWLiYgoo4f1R51erQfhPQ=="
    },
    "@types/eslint-visitor-keys": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@types/eslint-visitor-keys/-/eslint-visitor-keys-1.0.0.tgz",
      "integrity": "sha512-OCutwjDZ4aFS6PB1UZ988C4YgwlBHJd6wCeQqaLdmadZ/7e+w79+hbMUFC1QXDNCmdyoRfAFdm0RypzwR+Qpag==",
      "dev": true
    },
    "@types/events": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@types/events/-/events-3.0.0.tgz",
      "integrity": "sha512-EaObqwIvayI5a8dCzhFrjKzVwKLxjoG9T6Ppd5CEo07LRKfQ8Yokw54r5+Wq7FaBQ+yXRvQAYPrHwya1/UFt9g==",
      "dev": true
    },
    "@types/glob": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/@types/glob/-/glob-7.1.1.tgz",
      "integrity": "sha512-1Bh06cbWJUHMC97acuD6UMG29nMt0Aqz1vF3guLfG+kHHJhy3AyohZFFxYk2f7Q1SQIrNwvncxAE0N/9s70F2w==",
      "dev": true,
      "requires": {
        "@types/events": "*",
        "@types/minimatch": "*",
        "@types/node": "*"
      }
    },
    "@types/graceful-fs": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.3.tgz",
      "integrity": "sha512-AiHRaEB50LQg0pZmm659vNBb9f4SJ0qrAnteuzhSeAUcJKxoYgEnprg/83kppCnc2zvtCKbdZry1a5pVY3lOTQ==",
      "dev": true,
      "requires": {
        "@types/node": "*"
      }
    },
    "@types/istanbul-lib-coverage": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/@types/istanbul-lib-coverage/-/istanbul-lib-coverage-2.0.1.tgz",
      "integrity": "sha512-hRJD2ahnnpLgsj6KWMYSrmXkM3rm2Dl1qkx6IOFD5FnuNPXJIG5L0dhgKXCYTRMGzU4n0wImQ/xfmRc4POUFlg==",
      "dev": true
    },
    "@types/istanbul-lib-report": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@types/istanbul-lib-report/-/istanbul-lib-report-3.0.0.tgz",
      "integrity": "sha512-plGgXAPfVKFoYfa9NpYDAkseG+g6Jr294RqeqcqDixSbU34MZVJRi/P+7Y8GDpzkEwLaGZZOpKIEmeVZNtKsrg==",
      "dev": true,
      "requires": {
        "@types/istanbul-lib-coverage": "*"
      }
    },
    "@types/istanbul-reports": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/@types/istanbul-reports/-/istanbul-reports-1.1.1.tgz",
      "integrity": "sha512-UpYjBi8xefVChsCoBpKShdxTllC9pwISirfoZsUa2AAdQg/Jd2KQGtSbw+ya7GPo7x/wAPlH6JBhKhAsXUEZNA==",
      "dev": true,
      "requires": {
        "@types/istanbul-lib-coverage": "*",
        "@types/istanbul-lib-report": "*"
      }
    },
    "@types/jasmine": {
      "version": "3.5.12",
      "resolved": "https://registry.npmjs.org/@types/jasmine/-/jasmine-3.5.12.tgz",
      "integrity": "sha512-vJaQ58oceFao+NzpKNqLOWwHPsqA7YEhKv+mOXvYU4/qh+BfVWIxaBtL0Ck5iCS67yOkNwGkDCrzepnzIWF+7g==",
      "dev": true
    },
    "@types/jest": {
      "version": "25.1.4",
      "resolved": "https://registry.npmjs.org/@types/jest/-/jest-25.1.4.tgz",
      "integrity": "sha512-QDDY2uNAhCV7TMCITrxz+MRk1EizcsevzfeS6LykIlq2V1E5oO4wXG8V2ZEd9w7Snxeeagk46YbMgZ8ESHx3sw==",
      "dev": true,
      "requires": {
        "jest-diff": "^25.1.0",
        "pretty-format": "^25.1.0"
      }
    },
    "@types/json-schema": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.5.tgz",
      "integrity": "sha512-7+2BITlgjgDhH0vvwZU/HZJVyk+2XUlvxXe8dFMedNX/aMkaOq++rMAFXc0tM7ij15QaWlbdQASBR9dihi+bDQ=="
    },
    "@types/json5": {
      "version": "0.0.29",
      "resolved": "https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz",
      "integrity": "sha1-7ihweulOEdK4J7y+UnC86n8+ce4="
    },
    "@types/minimatch": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz",
      "integrity": "sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA==",
      "dev": true
    },
    "@types/mocha": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/@types/mocha/-/mocha-7.0.2.tgz",
      "integrity": "sha512-ZvO2tAcjmMi8V/5Z3JsyofMe3hasRcaw88cto5etSVMwVQfeivGAlEYmaQgceUSVYFofVjT+ioHsATjdWcFt1w==",
      "dev": true
    },
    "@types/node": {
      "version": "8.9.5",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-8.9.5.tgz",
      "integrity": "sha512-jRHfWsvyMtXdbhnz5CVHxaBgnV6duZnPlQuRSo/dm/GnmikNcmZhxIES4E9OZjUmQ8C+HCl4KJux+cXN/ErGDQ==",
      "dev": true
    },
    "@types/normalize-package-data": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/@types/normalize-package-data/-/normalize-package-data-2.4.0.tgz",
      "integrity": "sha512-f5j5b/Gf71L+dbqxIpQ4Z2WlmI/mPJ0fOkGGmFgtb6sAu97EPczzbS3/tJKxmcYDj55OX6ssqwDAWOHIYDRDGA==",
      "dev": true
    },
    "@types/prettier": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/@types/prettier/-/prettier-1.19.1.tgz",
      "integrity": "sha512-5qOlnZscTn4xxM5MeGXAMOsIOIKIbh9e85zJWfBRVPlRMEVawzoPhINYbRGkBZCI8LxvBe7tJCdWiarA99OZfQ==",
      "dev": true
    },
    "@types/q": {
      "version": "1.5.4",
      "resolved": "https://registry.npmjs.org/@types/q/-/q-1.5.4.tgz",
      "integrity": "sha512-1HcDas8SEj4z1Wc696tH56G8OlRaH/sqZOynNNB+HF0WOeXPaxTtbYzJY2oEfiUxjSKjhCKr+MvR7dCHcEelug==",
      "dev": true
    },
    "@types/selenium-webdriver": {
      "version": "3.0.17",
      "resolved": "https://registry.npmjs.org/@types/selenium-webdriver/-/selenium-webdriver-3.0.17.tgz",
      "integrity": "sha512-tGomyEuzSC1H28y2zlW6XPCaDaXFaD6soTdb4GNdmte2qfHtrKqhy0ZFs4r/1hpazCfEZqeTSRLvSasmEx89uw==",
      "dev": true
    },
    "@types/sinon": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/@types/sinon/-/sinon-9.0.0.tgz",
      "integrity": "sha512-v2TkYHkts4VXshMkcmot/H+ERZ2SevKa10saGaJPGCJ8vh3lKrC4u663zYEeRZxep+VbG6YRDtQ6gVqw9dYzPA==",
      "dev": true,
      "requires": {
        "@types/sinonjs__fake-timers": "*"
      }
    },
    "@types/sinon-chai": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/@types/sinon-chai/-/sinon-chai-3.2.4.tgz",
      "integrity": "sha512-xq5KOWNg70PRC7dnR2VOxgYQ6paumW+4pTZP+6uTSdhpYsAUEeeT5bw6rRHHQrZ4KyR+M5ojOR+lje6TGSpUxA==",
      "dev": true,
      "requires": {
        "@types/chai": "*",
        "@types/sinon": "*"
      }
    },
    "@types/sinon-test": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/@types/sinon-test/-/sinon-test-2.4.1.tgz",
      "integrity": "sha512-5LyV9FVbnA/NXjJCE9m/mK0hInsBM+GEt2/meEmRzBTFHkvDB7fFujH3ORSCrxVuqcgpa61TWBBabGqMdGRU9g==",
      "dev": true,
      "requires": {
        "@types/sinon": "*"
      }
    },
    "@types/sinonjs__fake-timers": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/@types/sinonjs__fake-timers/-/sinonjs__fake-timers-6.0.1.tgz",
      "integrity": "sha512-yYezQwGWty8ziyYLdZjwxyMb0CZR49h8JALHGrxjQHWlqGgc8kLdHEgWrgL0uZ29DMvEVBDnHU2Wg36zKSIUtA==",
      "dev": true
    },
    "@types/sizzle": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/@types/sizzle/-/sizzle-2.3.2.tgz",
      "integrity": "sha512-7EJYyKTL7tFR8+gDbB6Wwz/arpGa0Mywk1TJbNzKzHtzbwVmY4HR9WqS5VV7dsBUKQmPNr192jHr/VpBluj/hg==",
      "dev": true
    },
    "@types/source-list-map": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/@types/source-list-map/-/source-list-map-0.1.2.tgz",
      "integrity": "sha512-K5K+yml8LTo9bWJI/rECfIPrGgxdpeNbj+d53lwN4QjW1MCwlkhUms+gtdzigTeUyBr09+u8BwOIY3MXvHdcsA==",
      "dev": true
    },
    "@types/stack-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@types/stack-utils/-/stack-utils-1.0.1.tgz",
      "integrity": "sha512-l42BggppR6zLmpfU6fq9HEa2oGPEI8yrSPL3GITjfRInppYFahObbIQOQK3UGxEnyQpltZLaPe75046NOZQikw==",
      "dev": true
    },
    "@types/webpack-sources": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/@types/webpack-sources/-/webpack-sources-0.1.7.tgz",
      "integrity": "sha512-XyaHrJILjK1VHVC4aVlKsdNN5KBTwufMb43cQs+flGxtPAf/1Qwl8+Q0tp5BwEGaI8D6XT1L+9bSWXckgkjTLw==",
      "dev": true,
      "requires": {
        "@types/node": "*",
        "@types/source-list-map": "*",
        "source-map": "^0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "@types/yargs": {
      "version": "15.0.4",
      "resolved": "https://registry.npmjs.org/@types/yargs/-/yargs-15.0.4.tgz",
      "integrity": "sha512-9T1auFmbPZoxHz0enUFlUuKRy3it01R+hlggyVUMtnCTQRunsQYifnSGb8hET4Xo8yiC0o0r1paW3ud5+rbURg==",
      "dev": true,
      "requires": {
        "@types/yargs-parser": "*"
      }
    },
    "@types/yargs-parser": {
      "version": "15.0.0",
      "resolved": "https://registry.npmjs.org/@types/yargs-parser/-/yargs-parser-15.0.0.tgz",
      "integrity": "sha512-FA/BWv8t8ZWJ+gEOnLLd8ygxH/2UFbAvgEonyfN6yWGLKc7zVjbpl2Y4CTjid9h2RfgPP6SEt6uHwEOply00yw==",
      "dev": true
    },
    "@typescript-eslint/eslint-plugin": {
      "version": "2.19.2",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-2.19.2.tgz",
      "integrity": "sha512-HX2qOq2GOV04HNrmKnTpSIpHjfl7iwdXe3u/Nvt+/cpmdvzYvY0NHSiTkYN257jHnq4OM/yo+OsFgati+7LqJA==",
      "dev": true,
      "requires": {
        "@typescript-eslint/experimental-utils": "2.19.2",
        "eslint-utils": "^1.4.3",
        "functional-red-black-tree": "^1.0.1",
        "regexpp": "^3.0.0",
        "tsutils": "^3.17.1"
      },
      "dependencies": {
        "@typescript-eslint/experimental-utils": {
          "version": "2.19.2",
          "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.19.2.tgz",
          "integrity": "sha512-B88QuwT1wMJR750YvTJBNjMZwmiPpbmKYLm1yI7PCc3x0NariqPwqaPsoJRwU9DmUi0cd9dkhz1IqEnwfD+P1A==",
          "dev": true,
          "requires": {
            "@types/json-schema": "^7.0.3",
            "@typescript-eslint/typescript-estree": "2.19.2",
            "eslint-scope": "^5.0.0"
          }
        },
        "@typescript-eslint/typescript-estree": {
          "version": "2.19.2",
          "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.19.2.tgz",
          "integrity": "sha512-Xu/qa0MDk6upQWqE4Qy2X16Xg8Vi32tQS2PR0AvnT/ZYS4YGDvtn2MStOh5y8Zy2mg4NuL06KUHlvCh95j9C6Q==",
          "dev": true,
          "requires": {
            "debug": "^4.1.1",
            "eslint-visitor-keys": "^1.1.0",
            "glob": "^7.1.6",
            "is-glob": "^4.0.1",
            "lodash": "^4.17.15",
            "semver": "^6.3.0",
            "tsutils": "^3.17.1"
          }
        },
        "eslint-scope": {
          "version": "5.1.1",
          "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
          "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
          "dev": true,
          "requires": {
            "esrecurse": "^4.3.0",
            "estraverse": "^4.1.1"
          }
        },
        "esrecurse": {
          "version": "4.3.0",
          "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
          "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
          "dev": true,
          "requires": {
            "estraverse": "^5.2.0"
          },
          "dependencies": {
            "estraverse": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
              "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
              "dev": true
            }
          }
        },
        "regexpp": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.1.0.tgz",
          "integrity": "sha512-ZOIzd8yVsQQA7j8GCSlPGXwg5PfmA1mrq0JP4nGhh54LaKN3xdai/vHUDu74pKwV8OxseMS65u2NImosQcSD0Q==",
          "dev": true
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "tsutils": {
          "version": "3.21.0",
          "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
          "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
          "dev": true,
          "requires": {
            "tslib": "^1.8.1"
          }
        }
      }
    },
    "@typescript-eslint/experimental-utils": {
      "version": "2.34.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.34.0.tgz",
      "integrity": "sha512-eS6FTkq+wuMJ+sgtuNTtcqavWXqsflWcfBnlYhg/nS4aZ1leewkXGbvBhaapn1q6qf4M71bsR1tez5JTRMuqwA==",
      "dev": true,
      "requires": {
        "@types/json-schema": "^7.0.3",
        "@typescript-eslint/typescript-estree": "2.34.0",
        "eslint-scope": "^5.0.0",
        "eslint-utils": "^2.0.0"
      },
      "dependencies": {
        "eslint-scope": {
          "version": "5.1.1",
          "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
          "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
          "dev": true,
          "requires": {
            "esrecurse": "^4.3.0",
            "estraverse": "^4.1.1"
          }
        },
        "eslint-utils": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz",
          "integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==",
          "dev": true,
          "requires": {
            "eslint-visitor-keys": "^1.1.0"
          }
        },
        "esrecurse": {
          "version": "4.3.0",
          "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
          "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
          "dev": true,
          "requires": {
            "estraverse": "^5.2.0"
          },
          "dependencies": {
            "estraverse": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
              "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
              "dev": true
            }
          }
        }
      }
    },
    "@typescript-eslint/parser": {
      "version": "2.19.2",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-2.19.2.tgz",
      "integrity": "sha512-8uwnYGKqX9wWHGPGdLB9sk9+12sjcdqEEYKGgbS8A0IvYX59h01o8os5qXUHMq2na8vpDRaV0suTLM7S8wraTA==",
      "dev": true,
      "requires": {
        "@types/eslint-visitor-keys": "^1.0.0",
        "@typescript-eslint/experimental-utils": "2.19.2",
        "@typescript-eslint/typescript-estree": "2.19.2",
        "eslint-visitor-keys": "^1.1.0"
      },
      "dependencies": {
        "@typescript-eslint/experimental-utils": {
          "version": "2.19.2",
          "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-2.19.2.tgz",
          "integrity": "sha512-B88QuwT1wMJR750YvTJBNjMZwmiPpbmKYLm1yI7PCc3x0NariqPwqaPsoJRwU9DmUi0cd9dkhz1IqEnwfD+P1A==",
          "dev": true,
          "requires": {
            "@types/json-schema": "^7.0.3",
            "@typescript-eslint/typescript-estree": "2.19.2",
            "eslint-scope": "^5.0.0"
          }
        },
        "@typescript-eslint/typescript-estree": {
          "version": "2.19.2",
          "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.19.2.tgz",
          "integrity": "sha512-Xu/qa0MDk6upQWqE4Qy2X16Xg8Vi32tQS2PR0AvnT/ZYS4YGDvtn2MStOh5y8Zy2mg4NuL06KUHlvCh95j9C6Q==",
          "dev": true,
          "requires": {
            "debug": "^4.1.1",
            "eslint-visitor-keys": "^1.1.0",
            "glob": "^7.1.6",
            "is-glob": "^4.0.1",
            "lodash": "^4.17.15",
            "semver": "^6.3.0",
            "tsutils": "^3.17.1"
          }
        },
        "eslint-scope": {
          "version": "5.1.1",
          "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
          "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
          "dev": true,
          "requires": {
            "esrecurse": "^4.3.0",
            "estraverse": "^4.1.1"
          }
        },
        "esrecurse": {
          "version": "4.3.0",
          "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
          "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
          "dev": true,
          "requires": {
            "estraverse": "^5.2.0"
          },
          "dependencies": {
            "estraverse": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.2.0.tgz",
              "integrity": "sha512-BxbNGGNm0RyRYvUdHpIwv9IWzeM9XClbOxwoATuFdOE7ZE6wHL+HQ5T8hoPM+zHvmKzzsEqhgy0GrQ5X13afiQ==",
              "dev": true
            }
          }
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "tsutils": {
          "version": "3.21.0",
          "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
          "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
          "dev": true,
          "requires": {
            "tslib": "^1.8.1"
          }
        }
      }
    },
    "@typescript-eslint/typescript-estree": {
      "version": "2.34.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-2.34.0.tgz",
      "integrity": "sha512-OMAr+nJWKdlVM9LOqCqh3pQQPwxHAN7Du8DR6dmwCrAmxtiXQnhHJ6tBNtf+cggqfo51SG/FCwnKhXCIM7hnVg==",
      "dev": true,
      "requires": {
        "debug": "^4.1.1",
        "eslint-visitor-keys": "^1.1.0",
        "glob": "^7.1.6",
        "is-glob": "^4.0.1",
        "lodash": "^4.17.15",
        "semver": "^7.3.2",
        "tsutils": "^3.17.1"
      },
      "dependencies": {
        "lru-cache": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
          "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
          "dev": true,
          "requires": {
            "yallist": "^4.0.0"
          }
        },
        "semver": {
          "version": "7.3.5",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.5.tgz",
          "integrity": "sha512-PoeGJYh8HK4BTO/a9Tf6ZG3veo/A7ZVsYrSA6J8ny9nb3B1VrpkuN+z9OE5wfE5p6H4LchYZsegiQgbJD94ZFQ==",
          "dev": true,
          "requires": {
            "lru-cache": "^6.0.0"
          }
        },
        "tsutils": {
          "version": "3.21.0",
          "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
          "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
          "dev": true,
          "requires": {
            "tslib": "^1.8.1"
          }
        }
      }
    },
    "@webassemblyjs/ast": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.8.5.tgz",
      "integrity": "sha512-aJMfngIZ65+t71C3y2nBBg5FFG0Okt9m0XEgWZ7Ywgn1oMAT8cNwx00Uv1cQyHtidq0Xn94R4TAywO+LCQ+ZAQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/helper-module-context": "1.8.5",
        "@webassemblyjs/helper-wasm-bytecode": "1.8.5",
        "@webassemblyjs/wast-parser": "1.8.5"
      }
    },
    "@webassemblyjs/floating-point-hex-parser": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.8.5.tgz",
      "integrity": "sha512-9p+79WHru1oqBh9ewP9zW95E3XAo+90oth7S5Re3eQnECGq59ly1Ri5tsIipKGpiStHsUYmY3zMLqtk3gTcOtQ==",
      "dev": true
    },
    "@webassemblyjs/helper-api-error": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.8.5.tgz",
      "integrity": "sha512-Za/tnzsvnqdaSPOUXHyKJ2XI7PDX64kWtURyGiJJZKVEdFOsdKUCPTNEVFZq3zJ2R0G5wc2PZ5gvdTRFgm81zA==",
      "dev": true
    },
    "@webassemblyjs/helper-buffer": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.8.5.tgz",
      "integrity": "sha512-Ri2R8nOS0U6G49Q86goFIPNgjyl6+oE1abW1pS84BuhP1Qcr5JqMwRFT3Ah3ADDDYGEgGs1iyb1DGX+kAi/c/Q==",
      "dev": true
    },
    "@webassemblyjs/helper-code-frame": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-code-frame/-/helper-code-frame-1.8.5.tgz",
      "integrity": "sha512-VQAadSubZIhNpH46IR3yWO4kZZjMxN1opDrzePLdVKAZ+DFjkGD/rf4v1jap744uPVU6yjL/smZbRIIJTOUnKQ==",
      "dev": true,
      "requires": {
        "@webassemblyjs/wast-printer": "1.8.5"
      }
    },
    "@webassemblyjs/helper-fsm": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-fsm/-/helper-fsm-1.8.5.tgz",
      "integrity": "sha512-kRuX/saORcg8se/ft6Q2UbRpZwP4y7YrWsLXPbbmtepKr22i8Z4O3V5QE9DbZK908dh5Xya4Un57SDIKwB9eow==",
      "dev": true
    },
    "@webassemblyjs/helper-module-context": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-module-context/-/helper-module-context-1.8.5.tgz",
      "integrity": "sha512-/O1B236mN7UNEU4t9X7Pj38i4VoU8CcMHyy3l2cV/kIF4U5KoHXDVqcDuOs1ltkac90IM4vZdHc52t1x8Yfs3g==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "mamacro": "^0.0.3"
      }
    },
    "@webassemblyjs/helper-wasm-bytecode": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.8.5.tgz",
      "integrity": "sha512-Cu4YMYG3Ddl72CbmpjU/wbP6SACcOPVbHN1dI4VJNJVgFwaKf1ppeFJrwydOG3NDHxVGuCfPlLZNyEdIYlQ6QQ==",
      "dev": true
    },
    "@webassemblyjs/helper-wasm-section": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.8.5.tgz",
      "integrity": "sha512-VV083zwR+VTrIWWtgIUpqfvVdK4ff38loRmrdDBgBT8ADXYsEZ5mPQ4Nde90N3UYatHdYoDIFb7oHzMncI02tA==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-buffer": "1.8.5",
        "@webassemblyjs/helper-wasm-bytecode": "1.8.5",
        "@webassemblyjs/wasm-gen": "1.8.5"
      }
    },
    "@webassemblyjs/ieee754": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.8.5.tgz",
      "integrity": "sha512-aaCvQYrvKbY/n6wKHb/ylAJr27GglahUO89CcGXMItrOBqRarUMxWLJgxm9PJNuKULwN5n1csT9bYoMeZOGF3g==",
      "dev": true,
      "requires": {
        "@xtuc/ieee754": "^1.2.0"
      }
    },
    "@webassemblyjs/leb128": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.8.5.tgz",
      "integrity": "sha512-plYUuUwleLIziknvlP8VpTgO4kqNaH57Y3JnNa6DLpu/sGcP6hbVdfdX5aHAV716pQBKrfuU26BJK29qY37J7A==",
      "dev": true,
      "requires": {
        "@xtuc/long": "4.2.2"
      }
    },
    "@webassemblyjs/utf8": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.8.5.tgz",
      "integrity": "sha512-U7zgftmQriw37tfD934UNInokz6yTmn29inT2cAetAsaU9YeVCveWEwhKL1Mg4yS7q//NGdzy79nlXh3bT8Kjw==",
      "dev": true
    },
    "@webassemblyjs/wasm-edit": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.8.5.tgz",
      "integrity": "sha512-A41EMy8MWw5yvqj7MQzkDjU29K7UJq1VrX2vWLzfpRHt3ISftOXqrtojn7nlPsZ9Ijhp5NwuODuycSvfAO/26Q==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-buffer": "1.8.5",
        "@webassemblyjs/helper-wasm-bytecode": "1.8.5",
        "@webassemblyjs/helper-wasm-section": "1.8.5",
        "@webassemblyjs/wasm-gen": "1.8.5",
        "@webassemblyjs/wasm-opt": "1.8.5",
        "@webassemblyjs/wasm-parser": "1.8.5",
        "@webassemblyjs/wast-printer": "1.8.5"
      }
    },
    "@webassemblyjs/wasm-gen": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.8.5.tgz",
      "integrity": "sha512-BCZBT0LURC0CXDzj5FXSc2FPTsxwp3nWcqXQdOZE4U7h7i8FqtFK5Egia6f9raQLpEKT1VL7zr4r3+QX6zArWg==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-wasm-bytecode": "1.8.5",
        "@webassemblyjs/ieee754": "1.8.5",
        "@webassemblyjs/leb128": "1.8.5",
        "@webassemblyjs/utf8": "1.8.5"
      }
    },
    "@webassemblyjs/wasm-opt": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.8.5.tgz",
      "integrity": "sha512-HKo2mO/Uh9A6ojzu7cjslGaHaUU14LdLbGEKqTR7PBKwT6LdPtLLh9fPY33rmr5wcOMrsWDbbdCHq4hQUdd37Q==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-buffer": "1.8.5",
        "@webassemblyjs/wasm-gen": "1.8.5",
        "@webassemblyjs/wasm-parser": "1.8.5"
      }
    },
    "@webassemblyjs/wasm-parser": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.8.5.tgz",
      "integrity": "sha512-pi0SYE9T6tfcMkthwcgCpL0cM9nRYr6/6fjgDtL6q/ZqKHdMWvxitRi5JcZ7RI4SNJJYnYNaWy5UUrHQy998lw==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-api-error": "1.8.5",
        "@webassemblyjs/helper-wasm-bytecode": "1.8.5",
        "@webassemblyjs/ieee754": "1.8.5",
        "@webassemblyjs/leb128": "1.8.5",
        "@webassemblyjs/utf8": "1.8.5"
      }
    },
    "@webassemblyjs/wast-parser": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-parser/-/wast-parser-1.8.5.tgz",
      "integrity": "sha512-daXC1FyKWHF1i11obK086QRlsMsY4+tIOKgBqI1lxAnkp9xe9YMcgOxm9kLe+ttjs5aWV2KKE1TWJCN57/Btsg==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/floating-point-hex-parser": "1.8.5",
        "@webassemblyjs/helper-api-error": "1.8.5",
        "@webassemblyjs/helper-code-frame": "1.8.5",
        "@webassemblyjs/helper-fsm": "1.8.5",
        "@xtuc/long": "4.2.2"
      }
    },
    "@webassemblyjs/wast-printer": {
      "version": "1.8.5",
      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.8.5.tgz",
      "integrity": "sha512-w0U0pD4EhlnvRyeJzBqaVSJAo9w/ce7/WPogeXLzGkO6hzhr4GnQIZ4W4uUt5b9ooAaXPtnXlj0gzsXEOUNYMg==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/wast-parser": "1.8.5",
        "@xtuc/long": "4.2.2"
      }
    },
    "@xtuc/ieee754": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@xtuc/ieee754/-/ieee754-1.2.0.tgz",
      "integrity": "sha512-DX8nKgqcGwsc0eJSqYt5lwP4DH5FlHnmuWWBRy7X0NcaGR0ZtuyeESgMwTYVEtxmsNGY+qit4QYT/MIYTOTPeA==",
      "dev": true
    },
    "@xtuc/long": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/@xtuc/long/-/long-4.2.2.tgz",
      "integrity": "sha512-NuHqBY1PB/D8xU6s/thBgOAiAP7HOYDQ32+BFZILJ8ivkUkAHQnWfn6WhL79Owj1qmUnoN/YPhktdIoucipkAQ==",
      "dev": true
    },
    "@yarnpkg/lockfile": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@yarnpkg/lockfile/-/lockfile-1.1.0.tgz",
      "integrity": "sha512-GpSwvyXOcOOlV70vbnzjj4fW5xW/FdUF6nQEt1ENy7m4ZCczi1+/buVUPAqmGfqznsORNFzUMjctTIp8a9tuCQ==",
      "dev": true
    },
    "JSONStream": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/JSONStream/-/JSONStream-1.3.5.tgz",
      "integrity": "sha512-E+iruNOY8VV9s4JEbe1aNEm6MiszPRr/UfcHMz0TQh1BXSxHK+ASV1R6W4HpjBhSeS+54PIsAMCBmwD06LLsqQ==",
      "dev": true,
      "requires": {
        "jsonparse": "^1.2.0",
        "through": ">=2.2.7 <3"
      }
    },
    "abab": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/abab/-/abab-2.0.3.tgz",
      "integrity": "sha512-tsFzPpcttalNjFBCFMqsKYQcWxxen1pgJR56by//QwvJc4/OUS3kPOOttx2tSIfjsylB0pYu7f5D3K1RCxUnUg==",
      "dev": true
    },
    "accepts": {
      "version": "1.3.7",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.7.tgz",
      "integrity": "sha512-Il80Qs2WjYlJIBNzNkK6KYqlVMTbZLXgHx2oT0pU/fjRHyEp+PEfEPY0R3WCwAGVOtauxh1hOxNgIf5bv7dQpA==",
      "requires": {
        "mime-types": "~2.1.24",
        "negotiator": "0.6.2"
      }
    },
    "acorn": {
      "version": "6.4.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-6.4.1.tgz",
      "integrity": "sha512-ZVA9k326Nwrj3Cj9jlh3wGFutC2ZornPNARZwsNYqQYgN0EsV2d53w5RN/co65Ohn4sUAUtb1rSUAOD6XN9idA==",
      "dev": true
    },
    "acorn-globals": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/acorn-globals/-/acorn-globals-4.3.4.tgz",
      "integrity": "sha512-clfQEh21R+D0leSbUdWf3OcfqyaCSAQ8Ryq00bofSekfr9W8u1jyYZo6ir0xu9Gtcf7BjcHJpnbZH7JOCpP60A==",
      "dev": true,
      "requires": {
        "acorn": "^6.0.1",
        "acorn-walk": "^6.0.1"
      }
    },
    "acorn-jsx": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.2.0.tgz",
      "integrity": "sha512-HiUX/+K2YpkpJ+SzBffkM/AQ2YE03S0U1kjTLVpoJdhZMOWy8qvXVN9JdLqv2QsaQ6MPYQIuNmwD8zOiYUofLQ==",
      "dev": true
    },
    "acorn-walk": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-6.2.0.tgz",
      "integrity": "sha512-7evsyfH1cLOCdAzZAd43Cic04yKydNx0cF+7tiA19p1XnLLPU4dpCQOqpjqwokFe//vS0QqfqqjCS2JkiIs0cA==",
      "dev": true
    },
    "adjust-sourcemap-loader": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/adjust-sourcemap-loader/-/adjust-sourcemap-loader-2.0.0.tgz",
      "integrity": "sha512-4hFsTsn58+YjrU9qKzML2JSSDqKvN8mUGQ0nNIrfPi8hmIONT4L3uUaT6MKdMsZ9AjsU6D2xDkZxCkbQPxChrA==",
      "dev": true,
      "requires": {
        "assert": "1.4.1",
        "camelcase": "5.0.0",
        "loader-utils": "1.2.3",
        "object-path": "0.11.4",
        "regex-parser": "2.2.10"
      },
      "dependencies": {
        "assert": {
          "version": "1.4.1",
          "resolved": "https://registry.npmjs.org/assert/-/assert-1.4.1.tgz",
          "integrity": "sha1-mZEtWRg2tab1s0XA8H7vwI/GXZE=",
          "dev": true,
          "requires": {
            "util": "0.10.3"
          }
        },
        "camelcase": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.0.0.tgz",
          "integrity": "sha512-faqwZqnWxbxn+F1d399ygeamQNy3lPp/H9H6rNrqYh4FSVCtcY+3cub1MxA8o9mDd55mM8Aghuu/kuyYA6VTsA==",
          "dev": true
        },
        "emojis-list": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz",
          "integrity": "sha1-TapNnbAPmBmIDHn6RXrlsJof04k=",
          "dev": true
        },
        "inherits": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz",
          "integrity": "sha1-sX0I0ya0Qj5Wjv9xn5GwscvfafE=",
          "dev": true
        },
        "json5": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
          "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
          "dev": true,
          "requires": {
            "minimist": "^1.2.0"
          }
        },
        "loader-utils": {
          "version": "1.2.3",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.2.3.tgz",
          "integrity": "sha512-fkpz8ejdnEMG3s37wGL07iSBDg99O9D5yflE9RGNH3hRdx9SOwYfnGYdZOUIZitN8E+E2vkq3MUMYMvPYl5ZZA==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^2.0.0",
            "json5": "^1.0.1"
          }
        },
        "util": {
          "version": "0.10.3",
          "resolved": "https://registry.npmjs.org/util/-/util-0.10.3.tgz",
          "integrity": "sha1-evsa/lCAUkZInj23/g7TeTNqwPk=",
          "dev": true,
          "requires": {
            "inherits": "2.0.1"
          }
        }
      }
    },
    "adm-zip": {
      "version": "0.4.16",
      "resolved": "https://registry.npmjs.org/adm-zip/-/adm-zip-0.4.16.tgz",
      "integrity": "sha512-TFi4HBKSGfIKsK5YCkKaaFG2m4PEDyViZmEwof3MTIgzimHLto6muaHVpbrljdIvIrFZzEq/p4nafOeLcYegrg==",
      "dev": true
    },
    "agent-base": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-4.3.0.tgz",
      "integrity": "sha512-salcGninV0nPrwpGNn4VTXBb1SOuXQBiqbrNXoeizJsHrsL6ERFM2Ne3JUSBWRE6aeNJI2ROP/WEEIDUiDe3cg==",
      "dev": true,
      "requires": {
        "es6-promisify": "^5.0.0"
      }
    },
    "agentkeepalive": {
      "version": "3.5.2",
      "resolved": "https://registry.npmjs.org/agentkeepalive/-/agentkeepalive-3.5.2.tgz",
      "integrity": "sha512-e0L/HNe6qkQ7H19kTlRRqUibEAwDK5AFk6y3PtMsuut2VAH6+Q4xZml1tNDJD7kSAyqmbG/K08K5WEJYtUrSlQ==",
      "dev": true,
      "requires": {
        "humanize-ms": "^1.2.1"
      }
    },
    "aggregate-error": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.0.1.tgz",
      "integrity": "sha512-quoaXsZ9/BLNae5yiNoUz+Nhkwz83GhWwtYFglcjEQB2NDHCIpApbqXxIFnm4Pq/Nvhrsq5sYJFyohrrxnTGAA==",
      "dev": true,
      "requires": {
        "clean-stack": "^2.0.0",
        "indent-string": "^4.0.0"
      }
    },
    "ajv": {
      "version": "6.12.0",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.0.tgz",
      "integrity": "sha512-D6gFiFA0RRLyUbvijN74DWAjXSFxWKaWP7mldxkVhyhAV3+SWA9HEJPHQ2c9soIeTFJqcSdFDGFgdqs1iUU2Hw==",
      "dev": true,
      "requires": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      }
    },
    "ajv-errors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ajv-errors/-/ajv-errors-1.0.1.tgz",
      "integrity": "sha512-DCRfO/4nQ+89p/RK43i8Ezd41EqdGIU4ld7nGF8OQ14oc/we5rEntLCUa7+jrn3nn83BosfwZA0wb4pon2o8iQ==",
      "dev": true
    },
    "ajv-keywords": {
      "version": "3.4.1",
      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.4.1.tgz",
      "integrity": "sha512-RO1ibKvd27e6FEShVFfPALuHI3WjSVNeK5FIsmme/LYRNxjKuNj+Dt7bucLa6NdSv3JcVTyMlm9kGR84z1XpaQ=="
    },
    "alphanum-sort": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/alphanum-sort/-/alphanum-sort-1.0.2.tgz",
      "integrity": "sha1-l6ERlkmyEa0zaR2fn0hqjsn74KM=",
      "dev": true
    },
    "ansi-colors": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-3.2.4.tgz",
      "integrity": "sha512-hHUXGagefjN2iRrID63xckIvotOXOojhQKWIPUZ4mNUZ9nLZW+7FMNoE1lOkEhNWYsx/7ysGIuJYCiMAA9FnrA==",
      "dev": true
    },
    "ansi-escapes": {
      "version": "4.3.1",
      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.1.tgz",
      "integrity": "sha512-JWF7ocqNrp8u9oqpgV+wH5ftbt+cfvv+PTjOvKLT3AdYly/LmORARfEVT1iyjwN+4MqE5UmVKoAdIBqeoCHgLA==",
      "dev": true,
      "requires": {
        "type-fest": "^0.11.0"
      }
    },
    "ansi-html": {
      "version": "0.0.7",
      "resolved": "https://registry.npmjs.org/ansi-html/-/ansi-html-0.0.7.tgz",
      "integrity": "sha1-gTWEAhliqenm/QOflA0S9WynhZ4=",
      "dev": true
    },
    "ansi-regex": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
      "integrity": "sha1-w7M6te42DYbg5ijwRorn7yfWVN8="
    },
    "ansi-styles": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
      "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
      "requires": {
        "color-convert": "^1.9.0"
      }
    },
    "any-observable": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/any-observable/-/any-observable-0.3.0.tgz",
      "integrity": "sha512-/FQM1EDkTsf63Ub2C6O7GuYFDsSXUwsaZDurV0np41ocwq0jthUAYCmhBX9f+KwlaCgIuWyr/4WlUQUBfKfZog==",
      "dev": true
    },
    "anymatch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.1.tgz",
      "integrity": "sha512-mM8522psRCqzV+6LhomX5wgp25YVibjh8Wj23I5RPkPppSVSjyKD2A2mBJmWGa+KN7f2D6LNh9jkBCeyLktzjg==",
      "requires": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      }
    },
    "app-root-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/app-root-path/-/app-root-path-3.0.0.tgz",
      "integrity": "sha512-qMcx+Gy2UZynHjOHOIXPNvpf+9cjvk3cWrBBK7zg4gH9+clobJRb9NGzcT7mQTcV/6Gm/1WelUtqxVXnNlrwcw==",
      "dev": true
    },
    "append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha1-HjRA6RXwsSA9I3SOeO3XubW0PlY="
    },
    "aproba": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/aproba/-/aproba-1.2.0.tgz",
      "integrity": "sha512-Y9J6ZjXtoYh8RnXVCMOU/ttDmk1aBjunq9vO0ta5x85WDQiQfUF9sIPBITdbiiIVcBo03Hi3jMxigBtsddlXRw==",
      "dev": true
    },
    "arch": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/arch/-/arch-2.2.0.tgz",
      "integrity": "sha512-Of/R0wqp83cgHozfIYLbBMnej79U/SVGOOyuB3VVFv1NRM/PSFMK12x9KVtiYzJqmnU5WR2qp0Z5rHb7sWGnFQ==",
      "dev": true
    },
    "argparse": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz",
      "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==",
      "dev": true,
      "requires": {
        "sprintf-js": "~1.0.2"
      }
    },
    "aria-query": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/aria-query/-/aria-query-3.0.0.tgz",
      "integrity": "sha1-ZbP8wcoRVajJrmTW7uKX8V1RM8w=",
      "dev": true,
      "requires": {
        "ast-types-flow": "0.0.7",
        "commander": "^2.11.0"
      }
    },
    "arity-n": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/arity-n/-/arity-n-1.0.4.tgz",
      "integrity": "sha1-2edrEXM+CFacCEeuezmyhgswt0U=",
      "dev": true
    },
    "arr-diff": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/arr-diff/-/arr-diff-4.0.0.tgz",
      "integrity": "sha1-1kYQdP6/7HHn4VI1dhoyml3HxSA="
    },
    "arr-flatten": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/arr-flatten/-/arr-flatten-1.1.0.tgz",
      "integrity": "sha512-L3hKV5R/p5o81R7O02IGnwpDmkp6E982XhtbuwSe3O4qOtMMMtodicASA1Cny2U+aCXcNpml+m4dPsvsJ3jatg=="
    },
    "arr-union": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/arr-union/-/arr-union-3.1.0.tgz",
      "integrity": "sha1-45sJrqne+Gao8gbiiK9jkZuuOcQ="
    },
    "array-equal": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/array-equal/-/array-equal-1.0.0.tgz",
      "integrity": "sha1-jCpe8kcv2ep0KwTHenUJO6J1fJM=",
      "dev": true
    },
    "array-flatten": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-2.1.2.tgz",
      "integrity": "sha512-hNfzcOV8W4NdualtqBFPyVO+54DSJuZGY9qT4pRroB6S9e3iiido2ISIC5h9R2sPJ8H3FHCIiEnsv1lPXO3KtQ==",
      "dev": true
    },
    "array-union": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-1.0.2.tgz",
      "integrity": "sha1-mjRBDk9OPaI96jdb5b5w8kd47Dk=",
      "dev": true,
      "requires": {
        "array-uniq": "^1.0.1"
      }
    },
    "array-uniq": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/array-uniq/-/array-uniq-1.0.3.tgz",
      "integrity": "sha1-r2rId6Jcx/dOBYiUdThY39sk/bY=",
      "dev": true
    },
    "array-unique": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/array-unique/-/array-unique-0.3.2.tgz",
      "integrity": "sha1-qJS3XUvE9s1nnvMkSp/Y9Gri1Cg="
    },
    "arrify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz",
      "integrity": "sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=",
      "dev": true
    },
    "asap": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/asap/-/asap-2.0.6.tgz",
      "integrity": "sha1-5QNHYR1+aQlDIIu9r+vLwvuGbUY=",
      "dev": true
    },
    "asn1": {
      "version": "0.2.4",
      "resolved": "https://registry.npmjs.org/asn1/-/asn1-0.2.4.tgz",
      "integrity": "sha512-jxwzQpLQjSmWXgwaCZE9Nz+glAG01yF1QnWgbhGwHI5A6FRIEY6IVqtHhIepHqI7/kyEyQEagBC5mBEFlIYvdg==",
      "dev": true,
      "requires": {
        "safer-buffer": "~2.1.0"
      }
    },
    "asn1.js": {
      "version": "4.10.1",
      "resolved": "https://registry.npmjs.org/asn1.js/-/asn1.js-4.10.1.tgz",
      "integrity": "sha512-p32cOF5q0Zqs9uBiONKYLm6BClCoBCM5O9JfeUSlnQLBTxYdTK+pW+nXflm8UkKd2UYlEbYz5qEi0JuZR9ckSw==",
      "dev": true,
      "requires": {
        "bn.js": "^4.0.0",
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "assert": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/assert/-/assert-1.5.0.tgz",
      "integrity": "sha512-EDsgawzwoun2CZkCgtxJbv392v4nbk9XDD06zI+kQYoBM/3RBWLlEyJARDOmhAAosBjWACEkKL6S+lIZtcAubA==",
      "dev": true,
      "requires": {
        "object-assign": "^4.1.1",
        "util": "0.10.3"
      },
      "dependencies": {
        "inherits": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.1.tgz",
          "integrity": "sha1-sX0I0ya0Qj5Wjv9xn5GwscvfafE=",
          "dev": true
        },
        "util": {
          "version": "0.10.3",
          "resolved": "https://registry.npmjs.org/util/-/util-0.10.3.tgz",
          "integrity": "sha1-evsa/lCAUkZInj23/g7TeTNqwPk=",
          "dev": true,
          "requires": {
            "inherits": "2.0.1"
          }
        }
      }
    },
    "assert-plus": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/assert-plus/-/assert-plus-1.0.0.tgz",
      "integrity": "sha1-8S4PPF13sLHN2RRpQuTpbB5N1SU=",
      "dev": true
    },
    "assertion-error": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
      "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
      "dev": true
    },
    "assign-symbols": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/assign-symbols/-/assign-symbols-1.0.0.tgz",
      "integrity": "sha1-WWZ/QfrdTyDMvCu5a41Pf3jsA2c="
    },
    "ast-types-flow": {
      "version": "0.0.7",
      "resolved": "https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.7.tgz",
      "integrity": "sha1-9wtzXGvKGlycItmCw+Oef+ujva0=",
      "dev": true
    },
    "astral-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-1.0.0.tgz",
      "integrity": "sha512-+Ryf6g3BKoRc7jfp7ad8tM4TtMiaWvbF/1/sQcZPkkS7ag3D5nMBCe2UfOTONtAkaG0tO0ij3C5Lwmf1EiyjHg==",
      "dev": true
    },
    "async": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/async/-/async-2.6.3.tgz",
      "integrity": "sha512-zflvls11DCy+dQWzTW2dzuilv8Z5X/pjfmZOWba6TNIVDm+2UDaJmXSOXlasHKfNBs8oo3M0aT50fDEWfKZjXg==",
      "dev": true,
      "requires": {
        "lodash": "^4.17.14"
      }
    },
    "async-each": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/async-each/-/async-each-1.0.3.tgz",
      "integrity": "sha512-z/WhQ5FPySLdvREByI2vZiTWwCnF0moMJ1hK9YQwDTHKh6I7/uSckMetoRGb5UBZPC1z0jlw+n/XCgjeH7y1AQ==",
      "dev": true
    },
    "async-limiter": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/async-limiter/-/async-limiter-1.0.1.tgz",
      "integrity": "sha512-csOlWGAcRFJaI6m+F2WKdnMKr4HhdhFVBk0H/QbJFMCr+uO2kwohwXQPxw/9OCxp05r5ghVBFSyioixx3gfkNQ==",
      "dev": true
    },
    "asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha1-x57Zf380y48robyXkLzDZkdLS3k=",
      "dev": true
    },
    "at-least-node": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/at-least-node/-/at-least-node-1.0.0.tgz",
      "integrity": "sha512-+q/t7Ekv1EDY2l6Gda6LLiX14rU9TV20Wa3ofeQmwPFZbOMo9DXrLbOjFaaclkXKWidIaopwAObQDqwWtGUjqg==",
      "dev": true
    },
    "atob": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/atob/-/atob-2.1.2.tgz",
      "integrity": "sha512-Wm6ukoaOGJi/73p/cl2GvLjTI5JM1k/O14isD73YML8StrH/7/lRFgmg8nICZgD3bZZvjwCGxtMOD3wWNAu8cg=="
    },
    "autoprefixer": {
      "version": "9.8.0",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-9.8.0.tgz",
      "integrity": "sha512-D96ZiIHXbDmU02dBaemyAg53ez+6F5yZmapmgKcjm35yEe1uVDYI8hGW3VYoGRaG290ZFf91YxHrR518vC0u/A==",
      "dev": true,
      "requires": {
        "browserslist": "^4.12.0",
        "caniuse-lite": "^1.0.30001061",
        "chalk": "^2.4.2",
        "normalize-range": "^0.1.2",
        "num2fraction": "^1.2.2",
        "postcss": "^7.0.30",
        "postcss-value-parser": "^4.1.0"
      },
      "dependencies": {
        "caniuse-lite": {
          "version": "1.0.30001115",
          "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001115.tgz",
          "integrity": "sha512-NZrG0439ePYna44lJX8evHX2L7Z3/z3qjVLnHgbBb/duNEnGo348u+BQS5o4HTWcrb++100dHFrU36IesIrC1Q==",
          "dev": true
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "aws-sign2": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/aws-sign2/-/aws-sign2-0.7.0.tgz",
      "integrity": "sha1-tG6JCTSpWR8tL2+G1+ap8bP+dqg=",
      "dev": true
    },
    "aws4": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/aws4/-/aws4-1.9.1.tgz",
      "integrity": "sha512-wMHVg2EOHaMRxbzgFJ9gtjOOCrI80OHLG14rxi28XwOW8ux6IiEbRCGGGqCtdAIg4FQCbW20k9RsT4y3gJlFug==",
      "dev": true
    },
    "axios": {
      "version": "0.19.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-0.19.2.tgz",
      "integrity": "sha512-fjgm5MvRHLhx+osE2xoekY70AhARk3a6hkN+3Io1jc00jtquGvxYlKlsFUhmUET0V5te6CcZI7lcv2Ym61mjHA==",
      "requires": {
        "follow-redirects": "1.5.10"
      },
      "dependencies": {
        "debug": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.1.0.tgz",
          "integrity": "sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "follow-redirects": {
          "version": "1.5.10",
          "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.5.10.tgz",
          "integrity": "sha512-0V5l4Cizzvqt5D44aTXbFZz+FtyXV1vrDN6qrelxtfYQKW0KO0W2T/hkE8xvGa/540LkZlkaUjO4ailYTFtHVQ==",
          "requires": {
            "debug": "=3.1.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        }
      }
    },
    "axobject-query": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-2.0.2.tgz",
      "integrity": "sha512-MCeek8ZH7hKyO1rWUbKNQBbl4l2eY0ntk7OGi+q0RlafrCnfPxC06WZA+uebCfmYp4mNU9jRBP1AhGyf8+W3ww==",
      "dev": true,
      "requires": {
        "ast-types-flow": "0.0.7"
      }
    },
    "babel-code-frame": {
      "version": "6.26.0",
      "resolved": "https://registry.npmjs.org/babel-code-frame/-/babel-code-frame-6.26.0.tgz",
      "integrity": "sha1-Y/1D99weO7fONZR9uP42mj9Yx0s=",
      "requires": {
        "chalk": "^1.1.3",
        "esutils": "^2.0.2",
        "js-tokens": "^3.0.2"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
          "integrity": "sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4="
        },
        "chalk": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
          "integrity": "sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=",
          "requires": {
            "ansi-styles": "^2.2.1",
            "escape-string-regexp": "^1.0.2",
            "has-ansi": "^2.0.0",
            "strip-ansi": "^3.0.0",
            "supports-color": "^2.0.0"
          }
        },
        "js-tokens": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-3.0.2.tgz",
          "integrity": "sha1-mGbfOVECEw449/mWvOtlRDIJwls="
        },
        "supports-color": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
          "integrity": "sha1-U10EXOa2Nj+kARcIRimZXp3zJMc="
        }
      }
    },
    "babel-jest": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/babel-jest/-/babel-jest-25.5.1.tgz",
      "integrity": "sha512-9dA9+GmMjIzgPnYtkhBg73gOo/RHqPmLruP3BaGL4KEX3Dwz6pI8auSN8G8+iuEG90+GSswyKvslN+JYSaacaQ==",
      "dev": true,
      "requires": {
        "@jest/transform": "^25.5.1",
        "@jest/types": "^25.5.0",
        "@types/babel__core": "^7.1.7",
        "babel-plugin-istanbul": "^6.0.0",
        "babel-preset-jest": "^25.5.0",
        "chalk": "^3.0.0",
        "graceful-fs": "^4.2.4",
        "slash": "^3.0.0"
      },
      "dependencies": {
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        }
      }
    },
    "babel-loader": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/babel-loader/-/babel-loader-8.1.0.tgz",
      "integrity": "sha512-7q7nC1tYOrqvUrN3LQK4GwSk/TQorZSOlO9C+RZDZpODgyN4ZlCqE5q9cDsyWOliN+aU9B4JX01xK9eJXowJLw==",
      "optional": true,
      "requires": {
        "find-cache-dir": "^2.1.0",
        "loader-utils": "^1.4.0",
        "mkdirp": "^0.5.3",
        "pify": "^4.0.1",
        "schema-utils": "^2.6.5"
      }
    },
    "babel-plugin-dynamic-import-node": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/babel-plugin-dynamic-import-node/-/babel-plugin-dynamic-import-node-2.3.3.tgz",
      "integrity": "sha512-jZVI+s9Zg3IqA/kdi0i6UDCybUI3aSBLnglhYbSSjKlV7yF1F/5LWv8MakQmvYpnbJDS6fcBL2KzHSxNCMtWSQ==",
      "requires": {
        "object.assign": "^4.1.0"
      }
    },
    "babel-plugin-istanbul": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-istanbul/-/babel-plugin-istanbul-6.0.0.tgz",
      "integrity": "sha512-AF55rZXpe7trmEylbaE1Gv54wn6rwU03aptvRoVIGP8YykoSxqdVLV1TfwflBCE/QtHmqtP8SWlTENqbK8GCSQ==",
      "dev": true,
      "requires": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@istanbuljs/load-nyc-config": "^1.0.0",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-instrument": "^4.0.0",
        "test-exclude": "^6.0.0"
      }
    },
    "babel-plugin-jest-hoist": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-25.5.0.tgz",
      "integrity": "sha512-u+/W+WAjMlvoocYGTwthAiQSxDcJAyHpQ6oWlHdFZaaN+Rlk8Q7iiwDPg2lN/FyJtAYnKjFxbn7xus4HCFkg5g==",
      "dev": true,
      "requires": {
        "@babel/template": "^7.3.3",
        "@babel/types": "^7.3.3",
        "@types/babel__traverse": "^7.0.6"
      }
    },
    "babel-preset-current-node-syntax": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/babel-preset-current-node-syntax/-/babel-preset-current-node-syntax-0.1.2.tgz",
      "integrity": "sha512-u/8cS+dEiK1SFILbOC8/rUI3ml9lboKuuMvZ/4aQnQmhecQAgPw5ew066C1ObnEAUmlx7dv/s2z52psWEtLNiw==",
      "dev": true,
      "requires": {
        "@babel/plugin-syntax-async-generators": "^7.8.4",
        "@babel/plugin-syntax-bigint": "^7.8.3",
        "@babel/plugin-syntax-class-properties": "^7.8.3",
        "@babel/plugin-syntax-json-strings": "^7.8.3",
        "@babel/plugin-syntax-logical-assignment-operators": "^7.8.3",
        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
        "@babel/plugin-syntax-numeric-separator": "^7.8.3",
        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
        "@babel/plugin-syntax-optional-chaining": "^7.8.3"
      }
    },
    "babel-preset-jest": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/babel-preset-jest/-/babel-preset-jest-25.5.0.tgz",
      "integrity": "sha512-8ZczygctQkBU+63DtSOKGh7tFL0CeCuz+1ieud9lJ1WPQ9O6A1a/r+LGn6Y705PA6whHQ3T1XuB/PmpfNYf8Fw==",
      "dev": true,
      "requires": {
        "babel-plugin-jest-hoist": "^25.5.0",
        "babel-preset-current-node-syntax": "^0.1.2"
      }
    },
    "balanced-match": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz",
      "integrity": "sha1-ibTRmasr7kneFk6gK4nORi1xt2c="
    },
    "base": {
      "version": "0.11.2",
      "resolved": "https://registry.npmjs.org/base/-/base-0.11.2.tgz",
      "integrity": "sha512-5T6P4xPgpp0YDFvSWwEZ4NoE3aM4QBQXDzmVbraCkFj8zHM+mba8SyqB5DbZWyR7mYHo6Y7BdQo3MoA4m0TeQg==",
      "requires": {
        "cache-base": "^1.0.1",
        "class-utils": "^0.3.5",
        "component-emitter": "^1.2.1",
        "define-property": "^1.0.0",
        "isobject": "^3.0.1",
        "mixin-deep": "^1.2.0",
        "pascalcase": "^0.1.1"
      },
      "dependencies": {
        "define-property": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
          "requires": {
            "is-descriptor": "^1.0.0"
          }
        },
        "is-accessor-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-data-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-descriptor": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
          "requires": {
            "is-accessor-descriptor": "^1.0.0",
            "is-data-descriptor": "^1.0.0",
            "kind-of": "^6.0.2"
          }
        }
      }
    },
    "base64-js": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.3.1.tgz",
      "integrity": "sha512-mLQ4i2QO1ytvGWFWmcngKO//JXAQueZvwEKtjgQFM4jIK0kU+ytMfplL8j+n5mspOfjHwoAg+9yhb7BwAHm36g==",
      "dev": true
    },
    "batch": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/batch/-/batch-0.6.1.tgz",
      "integrity": "sha1-3DQxT05nkxgJP8dgJyUl+UvyXBY=",
      "dev": true
    },
    "bcrypt-pbkdf": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz",
      "integrity": "sha1-pDAdOJtqQ/m2f/PKEaP2Y342Dp4=",
      "dev": true,
      "requires": {
        "tweetnacl": "^0.14.3"
      }
    },
    "big.js": {
      "version": "5.2.2",
      "resolved": "https://registry.npmjs.org/big.js/-/big.js-5.2.2.tgz",
      "integrity": "sha512-vyL2OymJxmarO8gxMr0mhChsO9QGwhynfuu4+MHTAW6czfq9humCB7rKpUjDd9YUiDPU4mzpyupFSvOClAwbmQ=="
    },
    "binary-extensions": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.0.0.tgz",
      "integrity": "sha512-Phlt0plgpIIBOGTT/ehfFnbNlfsDEiqmzE2KRXoX1bLIlir4X/MR+zSyBEkL05ffWgnRSf/DXv+WrUAVr93/ow=="
    },
    "bindings": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz",
      "integrity": "sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==",
      "dev": true,
      "optional": true,
      "requires": {
        "file-uri-to-path": "1.0.0"
      }
    },
    "blob-util": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/blob-util/-/blob-util-2.0.2.tgz",
      "integrity": "sha512-T7JQa+zsXXEa6/8ZhHcQEW1UFfVM49Ts65uBkFL6fz2QmrElqmbajIDJvuA0tEhRe5eIjpV9ZF+0RfZR9voJFQ==",
      "dev": true
    },
    "blocking-proxy": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/blocking-proxy/-/blocking-proxy-1.0.1.tgz",
      "integrity": "sha512-KE8NFMZr3mN2E0HcvCgRtX7DjhiIQrwle+nSVJVC/yqFb9+xznHl2ZcoBp2L9qzkI4t4cBFJ1efXF8Dwi132RA==",
      "dev": true,
      "requires": {
        "minimist": "^1.2.0"
      }
    },
    "bluebird": {
      "version": "3.7.2",
      "resolved": "https://registry.npmjs.org/bluebird/-/bluebird-3.7.2.tgz",
      "integrity": "sha512-XpNj6GDQzdfW+r2Wnn7xiSAd7TM3jzkxGXBGTtWKuSXv1xUV+azxAm8jdWZN06QTQk+2N2XB9jRDkvbmQmcRtg==",
      "dev": true
    },
    "bn.js": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.1.1.tgz",
      "integrity": "sha512-IUTD/REb78Z2eodka1QZyyEk66pciRcP6Sroka0aI3tG/iwIdYLrBD62RsubR7vqdt3WyX8p4jxeatzmRSphtA==",
      "dev": true
    },
    "body-parser": {
      "version": "1.19.0",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.19.0.tgz",
      "integrity": "sha512-dhEPs72UPbDnAQJ9ZKMNTP6ptJaionhP5cBb541nXPlW60Jepo9RV/a4fX4XWW9CuFNK22krhrj1+rgzifNCsw==",
      "requires": {
        "bytes": "3.1.0",
        "content-type": "~1.0.4",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "http-errors": "1.7.2",
        "iconv-lite": "0.4.24",
        "on-finished": "~2.3.0",
        "qs": "6.7.0",
        "raw-body": "2.4.0",
        "type-is": "~1.6.17"
      },
      "dependencies": {
        "bytes": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.0.tgz",
          "integrity": "sha512-zauLjrfCG+xvoyaqLoV8bLVXXNGC4JqlxFCutSDWA6fJrTo2ZuvLYTqZ7aHBLZSMOopbzwv8f+wZcVzfVTI2Dg=="
        },
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        },
        "qs": {
          "version": "6.7.0",
          "resolved": "https://registry.npmjs.org/qs/-/qs-6.7.0.tgz",
          "integrity": "sha512-VCdBRNFTX1fyE7Nb6FYoURo/SPe62QCaAyzJvUjwRaIsc+NePBEniHlvxFmmX56+HZphIGtV0XeCirBtpDrTyQ=="
        }
      }
    },
    "bonjour": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/bonjour/-/bonjour-3.5.0.tgz",
      "integrity": "sha1-jokKGD2O6aI5OzhExpGkK897yfU=",
      "dev": true,
      "requires": {
        "array-flatten": "^2.1.0",
        "deep-equal": "^1.0.1",
        "dns-equal": "^1.0.0",
        "dns-txt": "^2.0.2",
        "multicast-dns": "^6.0.1",
        "multicast-dns-service-types": "^1.1.0"
      }
    },
    "boolbase": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/boolbase/-/boolbase-1.0.0.tgz",
      "integrity": "sha1-aN/1++YMUes3cl6p4+0xDcwed24=",
      "dev": true
    },
    "brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "requires": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "braces": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
      "requires": {
        "fill-range": "^7.0.1"
      }
    },
    "brorand": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/brorand/-/brorand-1.1.0.tgz",
      "integrity": "sha1-EsJe/kCkXjwyPrhnWgoM5XsiNx8=",
      "dev": true
    },
    "browser-process-hrtime": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/browser-process-hrtime/-/browser-process-hrtime-1.0.0.tgz",
      "integrity": "sha512-9o5UecI3GhkpM6DrXr69PblIuWxPKk9Y0jHBRhdocZ2y7YECBFCsHm79Pr3OyR2AvjhDkabFJaDJMYRazHgsow==",
      "dev": true
    },
    "browser-resolve": {
      "version": "1.11.3",
      "resolved": "https://registry.npmjs.org/browser-resolve/-/browser-resolve-1.11.3.tgz",
      "integrity": "sha512-exDi1BYWB/6raKHmDTCicQfTkqwN5fioMFV4j8BsfMU4R2DK/QfZfK7kOVkmWCNANf0snkBzqGqAJBao9gZMdQ==",
      "dev": true,
      "requires": {
        "resolve": "1.1.7"
      },
      "dependencies": {
        "resolve": {
          "version": "1.1.7",
          "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.1.7.tgz",
          "integrity": "sha1-IDEU2CrSxe2ejgQRs5ModeiJ6Xs=",
          "dev": true
        }
      }
    },
    "browser-stdout": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
      "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
      "dev": true
    },
    "browserify-aes": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/browserify-aes/-/browserify-aes-1.2.0.tgz",
      "integrity": "sha512-+7CHXqGuspUn/Sl5aO7Ea0xWGAtETPXNSAjHo48JfLdPWcMng33Xe4znFvQweqc/uzk5zSOI3H52CYnjCfb5hA==",
      "dev": true,
      "requires": {
        "buffer-xor": "^1.0.3",
        "cipher-base": "^1.0.0",
        "create-hash": "^1.1.0",
        "evp_bytestokey": "^1.0.3",
        "inherits": "^2.0.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "browserify-cipher": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/browserify-cipher/-/browserify-cipher-1.0.1.tgz",
      "integrity": "sha512-sPhkz0ARKbf4rRQt2hTpAHqn47X3llLkUGn+xEJzLjwY8LRs2p0v7ljvI5EyoRO/mexrNunNECisZs+gw2zz1w==",
      "dev": true,
      "requires": {
        "browserify-aes": "^1.0.4",
        "browserify-des": "^1.0.0",
        "evp_bytestokey": "^1.0.0"
      }
    },
    "browserify-des": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/browserify-des/-/browserify-des-1.0.2.tgz",
      "integrity": "sha512-BioO1xf3hFwz4kc6iBhI3ieDFompMhrMlnDFC4/0/vd5MokpuAc3R+LYbwTA9A5Yc9pq9UYPqffKpW2ObuwX5A==",
      "dev": true,
      "requires": {
        "cipher-base": "^1.0.1",
        "des.js": "^1.0.0",
        "inherits": "^2.0.1",
        "safe-buffer": "^5.1.2"
      }
    },
    "browserify-rsa": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/browserify-rsa/-/browserify-rsa-4.0.1.tgz",
      "integrity": "sha1-IeCr+vbyApzy+vsTNWenAdQTVSQ=",
      "dev": true,
      "requires": {
        "bn.js": "^4.1.0",
        "randombytes": "^2.0.1"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "browserify-sign": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/browserify-sign/-/browserify-sign-4.1.0.tgz",
      "integrity": "sha512-VYxo7cDCeYUoBZ0ZCy4UyEUCP3smyBd4DRQM5nrFS1jJjPJjX7rP3oLRpPoWfkhQfyJ0I9ZbHbKafrFD/SGlrg==",
      "dev": true,
      "requires": {
        "bn.js": "^5.1.1",
        "browserify-rsa": "^4.0.1",
        "create-hash": "^1.2.0",
        "create-hmac": "^1.1.7",
        "elliptic": "^6.5.2",
        "inherits": "^2.0.4",
        "parse-asn1": "^5.1.5",
        "readable-stream": "^3.6.0"
      },
      "dependencies": {
        "readable-stream": {
          "version": "3.6.0",
          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
          "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
          "dev": true,
          "requires": {
            "inherits": "^2.0.3",
            "string_decoder": "^1.1.1",
            "util-deprecate": "^1.0.1"
          }
        }
      }
    },
    "browserify-zlib": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/browserify-zlib/-/browserify-zlib-0.2.0.tgz",
      "integrity": "sha512-Z942RysHXmJrhqk88FmKBVq/v5tqmSkDz7p54G/MGyjMnCFFnC79XWNbg+Vta8W6Wb2qtSZTSxIGkJrRpCFEiA==",
      "dev": true,
      "requires": {
        "pako": "~1.0.5"
      }
    },
    "browserslist": {
      "version": "4.12.0",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.12.0.tgz",
      "integrity": "sha512-UH2GkcEDSI0k/lRkuDSzFl9ZZ87skSy9w2XAn1MsZnL+4c4rqbBd3e82UWHbYDpztABrPBhZsTEeuxVfHppqDg==",
      "requires": {
        "caniuse-lite": "^1.0.30001043",
        "electron-to-chromium": "^1.3.413",
        "node-releases": "^1.1.53",
        "pkg-up": "^2.0.0"
      }
    },
    "browserstack": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/browserstack/-/browserstack-1.6.0.tgz",
      "integrity": "sha512-HJDJ0TSlmkwnt9RZ+v5gFpa1XZTBYTj0ywvLwJ3241J7vMw2jAsGNVhKHtmCOyg+VxeLZyaibO9UL71AsUeDIw==",
      "dev": true,
      "requires": {
        "https-proxy-agent": "^2.2.1"
      }
    },
    "bs-logger": {
      "version": "0.2.6",
      "resolved": "https://registry.npmjs.org/bs-logger/-/bs-logger-0.2.6.tgz",
      "integrity": "sha512-pd8DCoxmbgc7hyPKOvxtqNcjYoOsABPQdcCUjGp3d42VR2CX1ORhk2A87oqqu5R1kk+76nsxZupkmyd+MVtCog==",
      "dev": true,
      "requires": {
        "fast-json-stable-stringify": "2.x"
      }
    },
    "bser": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/bser/-/bser-2.1.1.tgz",
      "integrity": "sha512-gQxTNE/GAfIIrmHLUE3oJyp5FO6HRBfhjnw4/wMmA63ZGDJnWBmgY/lyQBpnDUkGmAhbSe39tx2d/iTOAfglwQ==",
      "dev": true,
      "requires": {
        "node-int64": "^0.4.0"
      }
    },
    "buffer": {
      "version": "4.9.2",
      "resolved": "https://registry.npmjs.org/buffer/-/buffer-4.9.2.tgz",
      "integrity": "sha512-xq+q3SRMOxGivLhBNaUdC64hDTQwejJ+H0T/NB1XMtTVEwNTrfFF3gAxiyW0Bu/xWEGhjVKgUcMhCrUy2+uCWg==",
      "dev": true,
      "requires": {
        "base64-js": "^1.0.2",
        "ieee754": "^1.1.4",
        "isarray": "^1.0.0"
      }
    },
    "buffer-crc32": {
      "version": "0.2.13",
      "resolved": "https://registry.npmjs.org/buffer-crc32/-/buffer-crc32-0.2.13.tgz",
      "integrity": "sha1-DTM+PwDqxQqhRUq9MO+MKl2ackI=",
      "dev": true
    },
    "buffer-from": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.1.tgz",
      "integrity": "sha512-MQcXEUbCKtEo7bhqEs6560Hyd4XaovZlO/k9V3hjVUF/zwW7KBVdSK4gIt/bzwS9MbR5qob+F5jusZsb0YQK2A=="
    },
    "buffer-indexof": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/buffer-indexof/-/buffer-indexof-1.1.1.tgz",
      "integrity": "sha512-4/rOEg86jivtPTeOUUT61jJO1Ya1TrR/OkqCSZDyq84WJh3LuuiphBYJN+fm5xufIk4XAFcEwte/8WzC8If/1g==",
      "dev": true
    },
    "buffer-xor": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/buffer-xor/-/buffer-xor-1.0.3.tgz",
      "integrity": "sha1-JuYe0UIvtw3ULm42cp7VHYVf6Nk=",
      "dev": true
    },
    "builtin-modules": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz",
      "integrity": "sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8=",
      "dev": true
    },
    "builtin-status-codes": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/builtin-status-codes/-/builtin-status-codes-3.0.0.tgz",
      "integrity": "sha1-hZgoeOIbmOHGZCXgPQF0eI9Wnug=",
      "dev": true
    },
    "builtins": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/builtins/-/builtins-1.0.3.tgz",
      "integrity": "sha1-y5T662HIaWRR2zZTThQi+U8K7og=",
      "dev": true
    },
    "busboy": {
      "version": "0.2.14",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-0.2.14.tgz",
      "integrity": "sha1-bCpiLvz0fFe7vh4qnDetNseSVFM=",
      "requires": {
        "dicer": "0.2.5",
        "readable-stream": "1.1.x"
      },
      "dependencies": {
        "isarray": {
          "version": "0.0.1",
          "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
          "integrity": "sha1-ihis/Kmo9Bd+Cav8YDiTmwXR7t8="
        },
        "readable-stream": {
          "version": "1.1.14",
          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-1.1.14.tgz",
          "integrity": "sha1-fPTFTvZI44EwhMY23SB54WbAgdk=",
          "requires": {
            "core-util-is": "~1.0.0",
            "inherits": "~2.0.1",
            "isarray": "0.0.1",
            "string_decoder": "~0.10.x"
          }
        },
        "string_decoder": {
          "version": "0.10.31",
          "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-0.10.31.tgz",
          "integrity": "sha1-YuIDvEF2bGwoyfyEMB2rHFMQ+pQ="
        }
      }
    },
    "bytes": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.0.0.tgz",
      "integrity": "sha1-0ygVQE1olpn4Wk6k+odV3ROpYEg=",
      "dev": true
    },
    "cacache": {
      "version": "12.0.4",
      "resolved": "https://registry.npmjs.org/cacache/-/cacache-12.0.4.tgz",
      "integrity": "sha512-a0tMB40oefvuInr4Cwb3GerbL9xTj1D5yg0T5xrjGCGyfvbxseIXX7BAO/u/hIXdafzOI5JC3wDwHyf24buOAQ==",
      "dev": true,
      "requires": {
        "bluebird": "^3.5.5",
        "chownr": "^1.1.1",
        "figgy-pudding": "^3.5.1",
        "glob": "^7.1.4",
        "graceful-fs": "^4.1.15",
        "infer-owner": "^1.0.3",
        "lru-cache": "^5.1.1",
        "mississippi": "^3.0.0",
        "mkdirp": "^0.5.1",
        "move-concurrently": "^1.0.1",
        "promise-inflight": "^1.0.1",
        "rimraf": "^2.6.3",
        "ssri": "^6.0.1",
        "unique-filename": "^1.1.1",
        "y18n": "^4.0.0"
      },
      "dependencies": {
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        },
        "ssri": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/ssri/-/ssri-6.0.1.tgz",
          "integrity": "sha512-3Wge10hNcT1Kur4PDFwEieXSCMCJs/7WvSACcrMYrNp+b8kDL1/0wJch5Ni2WrtwEa2IO8OsVfeKIciKCDx/QA==",
          "dev": true,
          "requires": {
            "figgy-pudding": "^3.5.1"
          }
        }
      }
    },
    "cache-base": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/cache-base/-/cache-base-1.0.1.tgz",
      "integrity": "sha512-AKcdTnFSWATd5/GCPRxr2ChwIJ85CeyrEyjRHlKxQ56d4XJMGym0uAiKn0xbLOGOl3+yRpOTi484dVCEc5AUzQ==",
      "requires": {
        "collection-visit": "^1.0.0",
        "component-emitter": "^1.2.1",
        "get-value": "^2.0.6",
        "has-value": "^1.0.0",
        "isobject": "^3.0.1",
        "set-value": "^2.0.0",
        "to-object-path": "^0.3.0",
        "union-value": "^1.0.0",
        "unset-value": "^1.0.0"
      }
    },
    "cachedir": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/cachedir/-/cachedir-2.3.0.tgz",
      "integrity": "sha512-A+Fezp4zxnit6FanDmv9EqXNAi3vt9DWp51/71UEhXukb7QUuvtv9344h91dyAxuTLoSYJFU299qzR3tzwPAhw==",
      "dev": true
    },
    "caller-callsite": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/caller-callsite/-/caller-callsite-2.0.0.tgz",
      "integrity": "sha1-hH4PzgoiN1CpoCfFSzNzGtMVQTQ=",
      "dev": true,
      "requires": {
        "callsites": "^2.0.0"
      }
    },
    "caller-path": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/caller-path/-/caller-path-2.0.0.tgz",
      "integrity": "sha1-Ro+DBE42mrIBD6xfBs7uFbsssfQ=",
      "dev": true,
      "requires": {
        "caller-callsite": "^2.0.0"
      }
    },
    "callsites": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-2.0.0.tgz",
      "integrity": "sha1-BuuE8A7qQT2oav/vrL/7Ngk7PFA=",
      "dev": true
    },
    "camelcase": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-5.3.1.tgz",
      "integrity": "sha512-L28STB170nwWS63UjtlEOE3dldQApaJXZkOI1uMFfzf3rRuPegHaHesyee+YxQ+W6SvRDQV6UrdOdRiR153wJg==",
      "dev": true
    },
    "caniuse-api": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/caniuse-api/-/caniuse-api-3.0.0.tgz",
      "integrity": "sha512-bsTwuIg/BZZK/vreVTYYbSWoe2F+71P7K5QGEX+pT250DZbfU1MQ5prOKpPR+LL6uWKK3KMwMCAS74QB3Um1uw==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "caniuse-lite": "^1.0.0",
        "lodash.memoize": "^4.1.2",
        "lodash.uniq": "^4.5.0"
      }
    },
    "caniuse-lite": {
      "version": "1.0.30001051",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001051.tgz",
      "integrity": "sha512-sw8UUnTlRevawTMZKN7vpfwSjCBVoiMPlYd8oT2VwNylyPCBdMAUmLGUApnYYTtIm5JXsQegUAY7GPHqgfDzjw=="
    },
    "canonical-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/canonical-path/-/canonical-path-1.0.0.tgz",
      "integrity": "sha512-feylzsbDxi1gPZ1IjystzIQZagYYLvfKrSuygUCgf7z6x790VEzze5QEkdSV1U58RA7Hi0+v6fv4K54atOzATg==",
      "dev": true
    },
    "capture-exit": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/capture-exit/-/capture-exit-2.0.0.tgz",
      "integrity": "sha512-PiT/hQmTonHhl/HFGN+Lx3JJUznrVYJ3+AQsnthneZbvW7x+f08Tk7yLJTLEOUvBTbduLeeBkxEaYXUOUrRq6g==",
      "dev": true,
      "requires": {
        "rsvp": "^4.8.4"
      }
    },
    "caseless": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/caseless/-/caseless-0.12.0.tgz",
      "integrity": "sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw=",
      "dev": true
    },
    "chai": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/chai/-/chai-4.2.0.tgz",
      "integrity": "sha512-XQU3bhBukrOsQCuwZndwGcCVQHyZi53fQ6Ys1Fym7E4olpIqqZZhhoFJoaKVvV17lWQoXYwgWN2nF5crA8J2jw==",
      "dev": true,
      "requires": {
        "assertion-error": "^1.1.0",
        "check-error": "^1.0.2",
        "deep-eql": "^3.0.1",
        "get-func-name": "^2.0.0",
        "pathval": "^1.1.0",
        "type-detect": "^4.0.5"
      }
    },
    "chalk": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-3.0.0.tgz",
      "integrity": "sha512-4D3B6Wf41KOYRFdszmDqMCGq5VV/uMAB273JILmO+3jAlh8X4qDtdtgCR3fxtbLEMzSx22QdhnDcJvu2u1fVwg==",
      "requires": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "requires": {
            "color-name": "~1.1.4"
          }
        }
      }
    },
    "chardet": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/chardet/-/chardet-0.7.0.tgz",
      "integrity": "sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==",
      "dev": true
    },
    "check-error": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz",
      "integrity": "sha1-V00xLt2Iu13YkS6Sht1sCu1KrII=",
      "dev": true
    },
    "check-more-types": {
      "version": "2.24.0",
      "resolved": "https://registry.npmjs.org/check-more-types/-/check-more-types-2.24.0.tgz",
      "integrity": "sha1-FCD/sQ/URNz8ebQ4kbv//TKoRgA=",
      "dev": true
    },
    "chokidar": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.4.0.tgz",
      "integrity": "sha512-aXAaho2VJtisB/1fg1+3nlLJqGOuewTzQpd/Tz0yTg2R0e4IGtshYvtjowyEumcBv2z+y4+kc75Mz7j5xJskcQ==",
      "requires": {
        "anymatch": "~3.1.1",
        "braces": "~3.0.2",
        "fsevents": "~2.1.2",
        "glob-parent": "~5.1.0",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.4.0"
      }
    },
    "chownr": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-1.1.4.tgz",
      "integrity": "sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==",
      "dev": true
    },
    "chrome-trace-event": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/chrome-trace-event/-/chrome-trace-event-1.0.2.tgz",
      "integrity": "sha512-9e/zx1jw7B4CO+c/RXoCsfg/x1AfUBioy4owYH0bJprEYAx5hRFLRhWBqHAG57D0ZM4H7vxbP7bPe0VwhQRYDQ==",
      "dev": true,
      "requires": {
        "tslib": "^1.9.0"
      }
    },
    "ci-info": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ci-info/-/ci-info-2.0.0.tgz",
      "integrity": "sha512-5tK7EtrZ0N+OLFMthtqOj4fI2Jeb88C4CAZPu25LDVUgXJ0A3Js4PMGqrn0JU1W0Mh1/Z8wZzYPxqUrXeBboCQ==",
      "dev": true
    },
    "cipher-base": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/cipher-base/-/cipher-base-1.0.4.tgz",
      "integrity": "sha512-Kkht5ye6ZGmwv40uUDZztayT2ThLQGfnj/T71N/XzeZeo3nf8foyW7zGTsPYkEya3m5f3cAypH+qe7YOrM1U2Q==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "circular-dependency-plugin": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/circular-dependency-plugin/-/circular-dependency-plugin-5.2.0.tgz",
      "integrity": "sha512-7p4Kn/gffhQaavNfyDFg7LS5S/UT1JAjyGd4UqR2+jzoYF02eDkj0Ec3+48TsIa4zghjLY87nQHIh/ecK9qLdw==",
      "dev": true
    },
    "class-utils": {
      "version": "0.3.6",
      "resolved": "https://registry.npmjs.org/class-utils/-/class-utils-0.3.6.tgz",
      "integrity": "sha512-qOhPa/Fj7s6TY8H8esGu5QNpMMQxz79h+urzrNYN6mn+9BnxlDGf5QZ+XeCDsxSjPqsSR56XOZOJmpeurnLMeg==",
      "requires": {
        "arr-union": "^3.1.0",
        "define-property": "^0.2.5",
        "isobject": "^3.0.0",
        "static-extend": "^0.1.1"
      },
      "dependencies": {
        "define-property": {
          "version": "0.2.5",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
          "requires": {
            "is-descriptor": "^0.1.0"
          }
        }
      }
    },
    "clean-stack": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
      "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
      "dev": true
    },
    "cli-color": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/cli-color/-/cli-color-2.0.0.tgz",
      "integrity": "sha512-a0VZ8LeraW0jTuCkuAGMNufareGHhyZU9z8OGsW0gXd1hZGi1SRuNRXdbGkraBBKnhyUhyebFWnRbp+dIn0f0A==",
      "requires": {
        "ansi-regex": "^2.1.1",
        "d": "^1.0.1",
        "es5-ext": "^0.10.51",
        "es6-iterator": "^2.0.3",
        "memoizee": "^0.4.14",
        "timers-ext": "^0.1.7"
      }
    },
    "cli-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
      "requires": {
        "restore-cursor": "^3.1.0"
      }
    },
    "cli-spinners": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/cli-spinners/-/cli-spinners-2.4.0.tgz",
      "integrity": "sha512-sJAofoarcm76ZGpuooaO0eDy8saEy+YoZBLjC4h8srt4jeBnkYeOgqxgsJQTpyt2LjI5PTfLJHSL+41Yu4fEJA=="
    },
    "cli-table3": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/cli-table3/-/cli-table3-0.6.0.tgz",
      "integrity": "sha512-gnB85c3MGC7Nm9I/FkiasNBOKjOiO1RNuXXarQms37q4QMpWdlbBgD/VnOStA2faG1dpXMv31RFApjX1/QdgWQ==",
      "dev": true,
      "requires": {
        "colors": "^1.1.2",
        "object-assign": "^4.1.0",
        "string-width": "^4.2.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.2",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz",
          "integrity": "sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "cli-truncate": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-0.2.1.tgz",
      "integrity": "sha1-nxXPuwcFAFNpIWxiasfQWrkN1XQ=",
      "dev": true,
      "requires": {
        "slice-ansi": "0.0.4",
        "string-width": "^1.0.1"
      },
      "dependencies": {
        "is-fullwidth-code-point": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz",
          "integrity": "sha1-754xOG8DGn8NZDr4L95QxFfvAMs=",
          "dev": true,
          "requires": {
            "number-is-nan": "^1.0.0"
          }
        },
        "slice-ansi": {
          "version": "0.0.4",
          "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-0.0.4.tgz",
          "integrity": "sha1-7b+JA/ZvfOL46v1s7tZeJkyDGzU=",
          "dev": true
        },
        "string-width": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-1.0.2.tgz",
          "integrity": "sha1-EYvfW4zcUaKn5w0hHgfisLmxB9M=",
          "dev": true,
          "requires": {
            "code-point-at": "^1.0.0",
            "is-fullwidth-code-point": "^1.0.0",
            "strip-ansi": "^3.0.0"
          }
        }
      }
    },
    "cli-width": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/cli-width/-/cli-width-2.2.1.tgz",
      "integrity": "sha512-GRMWDxpOB6Dgk2E5Uo+3eEBvtOOlimMmpbFiKuLFnQzYDavtLFY3K5ona41jgN/WdRZtG7utuVSVTL4HbZHGkw==",
      "dev": true
    },
    "cliui": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/cliui/-/cliui-6.0.0.tgz",
      "integrity": "sha512-t6wbgtoCXvAzst7QgXxJYqPt0usEfbgQdftEPbLL/cvv6HPE5VgvqCuAIDR0NgU52ds6rFwqrgakNLrHEjCbrQ==",
      "dev": true,
      "requires": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.0",
        "wrap-ansi": "^6.2.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "clone": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/clone/-/clone-2.1.2.tgz",
      "integrity": "sha1-G39Ln1kfHo+DZwQBYANFoCiHQ18=",
      "dev": true
    },
    "clone-deep": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/clone-deep/-/clone-deep-4.0.1.tgz",
      "integrity": "sha512-neHB9xuzh/wk0dIHweyAXv2aPGZIVk3pLMe+/RNzINf17fe0OG96QroktYAUm7SM1PBnzTabaLboqqxDyMU+SQ==",
      "dev": true,
      "requires": {
        "is-plain-object": "^2.0.4",
        "kind-of": "^6.0.2",
        "shallow-clone": "^3.0.0"
      }
    },
    "co": {
      "version": "4.6.0",
      "resolved": "https://registry.npmjs.org/co/-/co-4.6.0.tgz",
      "integrity": "sha1-bqa989hTrlTMuOR7+gvz+QMfsYQ=",
      "dev": true
    },
    "coa": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/coa/-/coa-2.0.2.tgz",
      "integrity": "sha512-q5/jG+YQnSy4nRTV4F7lPepBJZ8qBNJJDBuJdoejDyLXgmL7IEo+Le2JDZudFTFt7mrCqIRaSjws4ygRCTCAXA==",
      "dev": true,
      "requires": {
        "@types/q": "^1.5.1",
        "chalk": "^2.4.1",
        "q": "^1.1.2"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "code-point-at": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/code-point-at/-/code-point-at-1.1.0.tgz",
      "integrity": "sha1-DQcLTQQ6W+ozovGkDi7bPZpMz3c=",
      "dev": true
    },
    "codelyzer": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/codelyzer/-/codelyzer-6.0.0.tgz",
      "integrity": "sha512-edJIQCIcxD9DhVSyBEdJ38AbLikm515Wl91t5RDGNT88uA6uQdTm4phTWfn9JhzAI8kXNUcfYyAE90lJElpGtA==",
      "dev": true,
      "requires": {
        "@angular/compiler": "9.0.0",
        "@angular/core": "9.0.0",
        "app-root-path": "^3.0.0",
        "aria-query": "^3.0.0",
        "axobject-query": "2.0.2",
        "css-selector-tokenizer": "^0.7.1",
        "cssauron": "^1.4.0",
        "damerau-levenshtein": "^1.0.4",
        "rxjs": "^6.5.3",
        "semver-dsl": "^1.0.1",
        "source-map": "^0.5.7",
        "sprintf-js": "^1.1.2",
        "tslib": "^1.10.0",
        "zone.js": "~0.10.3"
      },
      "dependencies": {
        "@angular/compiler": {
          "version": "9.0.0",
          "resolved": "https://registry.npmjs.org/@angular/compiler/-/compiler-9.0.0.tgz",
          "integrity": "sha512-ctjwuntPfZZT2mNj2NDIVu51t9cvbhl/16epc5xEwyzyDt76pX9UgwvY+MbXrf/C/FWwdtmNtfP698BKI+9leQ==",
          "dev": true
        },
        "@angular/core": {
          "version": "9.0.0",
          "resolved": "https://registry.npmjs.org/@angular/core/-/core-9.0.0.tgz",
          "integrity": "sha512-6Pxgsrf0qF9iFFqmIcWmjJGkkCaCm6V5QNnxMy2KloO3SDq6QuMVRbN9RtC8Urmo25LP+eZ6ZgYqFYpdD8Hd9w==",
          "dev": true
        },
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
          "dev": true
        },
        "sprintf-js": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.1.2.tgz",
          "integrity": "sha512-VE0SOVEHCk7Qc8ulkWw3ntAzXuqf7S2lvwQaDLRnUeIEaKNQJzV6BwmLKhOqT61aGhfUMrXeaBk+oDGCzvhcug==",
          "dev": true
        }
      }
    },
    "collect-v8-coverage": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/collect-v8-coverage/-/collect-v8-coverage-1.0.1.tgz",
      "integrity": "sha512-iBPtljfCNcTKNAto0KEtDfZ3qzjJvqE3aTGZsbhjSBlorqpXJlaWWtPO35D+ZImoC3KWejX64o+yPGxhWSTzfg==",
      "dev": true
    },
    "collection-visit": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/collection-visit/-/collection-visit-1.0.0.tgz",
      "integrity": "sha1-S8A3PBZLwykbTTaMgpzxqApZ3KA=",
      "requires": {
        "map-visit": "^1.0.0",
        "object-visit": "^1.0.0"
      }
    },
    "color": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/color/-/color-3.1.2.tgz",
      "integrity": "sha512-vXTJhHebByxZn3lDvDJYw4lR5+uB3vuoHsuYA5AKuxRVn5wzzIfQKGLBmgdVRHKTJYeK5rvJcHnrd0Li49CFpg==",
      "dev": true,
      "requires": {
        "color-convert": "^1.9.1",
        "color-string": "^1.5.2"
      }
    },
    "color-convert": {
      "version": "1.9.3",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
      "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
      "requires": {
        "color-name": "1.1.3"
      },
      "dependencies": {
        "color-name": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
          "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU="
        }
      }
    },
    "color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA=="
    },
    "color-string": {
      "version": "1.5.3",
      "resolved": "https://registry.npmjs.org/color-string/-/color-string-1.5.3.tgz",
      "integrity": "sha512-dC2C5qeWoYkxki5UAXapdjqO672AM4vZuPGRQfO8b5HKuKGBbKWpITyDYN7TOFKvRW7kOgAn3746clDBMDJyQw==",
      "dev": true,
      "requires": {
        "color-name": "^1.0.0",
        "simple-swizzle": "^0.2.2"
      }
    },
    "colors": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/colors/-/colors-1.4.0.tgz",
      "integrity": "sha512-a+UqTh4kgZg/SlGvfbzDHpgRu7AAQOmmqRHJnxhRZICKFUT91brVhNNt58CMWU9PsBbv3PDCZUHbVxuDiH2mtA==",
      "dev": true,
      "optional": true
    },
    "combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dev": true,
      "requires": {
        "delayed-stream": "~1.0.0"
      }
    },
    "commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "dev": true
    },
    "common-tags": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/common-tags/-/common-tags-1.8.0.tgz",
      "integrity": "sha512-6P6g0uetGpW/sdyUy/iQQCbFF0kWVMSIVSyYz7Zgjcgh8mgw8PQzDNZeyZ5DQ2gM7LBoZPHmnjz8rUthkBG5tw==",
      "dev": true
    },
    "commondir": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/commondir/-/commondir-1.0.1.tgz",
      "integrity": "sha1-3dgA2gxmEnOTzKWVDqloo6rxJTs="
    },
    "component-emitter": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.0.tgz",
      "integrity": "sha512-Rd3se6QB+sO1TwqZjscQrurpEPIfO0/yYnSin6Q/rD3mOutHvUrCAhJub3r90uNb+SESBuE0QYoB90YdfatsRg=="
    },
    "compose-function": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/compose-function/-/compose-function-3.0.3.tgz",
      "integrity": "sha1-ntZ18TzFRQHTCVCkhv9qe6OrGF8=",
      "dev": true,
      "requires": {
        "arity-n": "^1.0.4"
      }
    },
    "compressible": {
      "version": "2.0.18",
      "resolved": "https://registry.npmjs.org/compressible/-/compressible-2.0.18.tgz",
      "integrity": "sha512-AF3r7P5dWxL8MxyITRMlORQNaOA2IkAFaTr4k7BUumjPtRpGDTZpl0Pb1XCO6JeDCBdp126Cgs9sMxqSjgYyRg==",
      "dev": true,
      "requires": {
        "mime-db": ">= 1.43.0 < 2"
      }
    },
    "compression": {
      "version": "1.7.4",
      "resolved": "https://registry.npmjs.org/compression/-/compression-1.7.4.tgz",
      "integrity": "sha512-jaSIDzP9pZVS4ZfQ+TzvtiWhdpFhE2RDHz8QJkpX9SIpLq88VueF5jJw6t+6CUQcAoA6t+x89MLrWAqpfDE8iQ==",
      "dev": true,
      "requires": {
        "accepts": "~1.3.5",
        "bytes": "3.0.0",
        "compressible": "~2.0.16",
        "debug": "2.6.9",
        "on-headers": "~1.0.2",
        "safe-buffer": "5.1.2",
        "vary": "~1.1.2"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        },
        "safe-buffer": {
          "version": "5.1.2",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
          "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
          "dev": true
        }
      }
    },
    "concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s="
    },
    "concat-stream": {
      "version": "1.6.2",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz",
      "integrity": "sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==",
      "requires": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^2.2.2",
        "typedarray": "^0.0.6"
      }
    },
    "connect-history-api-fallback": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/connect-history-api-fallback/-/connect-history-api-fallback-1.6.0.tgz",
      "integrity": "sha512-e54B99q/OUoH64zYYRf3HBP5z24G38h5D3qXu23JGRoigpX5Ss4r9ZnDk3g0Z8uQC2x2lPaJ+UlWBc1ZWBWdLg==",
      "dev": true
    },
    "consola": {
      "version": "2.15.0",
      "resolved": "https://registry.npmjs.org/consola/-/consola-2.15.0.tgz",
      "integrity": "sha512-vlcSGgdYS26mPf7qNi+dCisbhiyDnrN1zaRbw3CSuc2wGOMEGGPsp46PdRG5gqXwgtJfjxDkxRNAgRPr1B77vQ=="
    },
    "console-browserify": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/console-browserify/-/console-browserify-1.2.0.tgz",
      "integrity": "sha512-ZMkYO/LkF17QvCPqM0gxw8yUzigAOZOSWSHg91FH6orS7vcEj5dVZTidN2fQ14yBSdg97RqhSNwLUXInd52OTA==",
      "dev": true
    },
    "constants-browserify": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/constants-browserify/-/constants-browserify-1.0.0.tgz",
      "integrity": "sha1-wguW2MYXdIqvHBYCF2DNJ/y4y3U=",
      "dev": true
    },
    "content-disposition": {
      "version": "0.5.3",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.3.tgz",
      "integrity": "sha512-ExO0774ikEObIAEV9kDo50o+79VCUdEB6n6lzKgGwupcVeRlhrj3qGAfwq8G6uBJjkqLrhT0qEYFcWng8z1z0g==",
      "requires": {
        "safe-buffer": "5.1.2"
      },
      "dependencies": {
        "safe-buffer": {
          "version": "5.1.2",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
          "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
        }
      }
    },
    "content-type": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
      "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA=="
    },
    "convert-source-map": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.7.0.tgz",
      "integrity": "sha512-4FJkXzKXEDB1snCFZlLP4gpC3JILicCpGbzG9f9G7tGqGCzETQ2hWPrcinA9oU4wtf2biUaEH5065UnMeR33oA==",
      "requires": {
        "safe-buffer": "~5.1.1"
      },
      "dependencies": {
        "safe-buffer": {
          "version": "5.1.2",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
          "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
        }
      }
    },
    "cookie": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.0.tgz",
      "integrity": "sha512-+Hp8fLp57wnUSt0tY0tHEXh4voZRDnoIrZPqlo3DPiI4y9lwg/jqx+1Om94/W6ZaPDOUbnjOt/99w66zk+l1Xg=="
    },
    "cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha1-4wOogrNCzD7oylE6eZmXNNqzriw="
    },
    "copy-concurrently": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/copy-concurrently/-/copy-concurrently-1.0.5.tgz",
      "integrity": "sha512-f2domd9fsVDFtaFcbaRZuYXwtdmnzqbADSwhSWYxYB/Q8zsdUUFMXVRwXGDMWmbEzAn1kdRrtI1T/KTFOL4X2A==",
      "dev": true,
      "requires": {
        "aproba": "^1.1.1",
        "fs-write-stream-atomic": "^1.0.8",
        "iferr": "^0.1.5",
        "mkdirp": "^0.5.1",
        "rimraf": "^2.5.4",
        "run-queue": "^1.0.0"
      },
      "dependencies": {
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        }
      }
    },
    "copy-descriptor": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/copy-descriptor/-/copy-descriptor-0.1.1.tgz",
      "integrity": "sha1-Z29us8OZl8LuGsOpJP1hJHSPV40="
    },
    "copy-webpack-plugin": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/copy-webpack-plugin/-/copy-webpack-plugin-5.1.1.tgz",
      "integrity": "sha512-P15M5ZC8dyCjQHWwd4Ia/dm0SgVvZJMYeykVIVYXbGyqO4dWB5oyPHp9i7wjwo5LhtlhKbiBCdS2NvM07Wlybg==",
      "dev": true,
      "requires": {
        "cacache": "^12.0.3",
        "find-cache-dir": "^2.1.0",
        "glob-parent": "^3.1.0",
        "globby": "^7.1.1",
        "is-glob": "^4.0.1",
        "loader-utils": "^1.2.3",
        "minimatch": "^3.0.4",
        "normalize-path": "^3.0.0",
        "p-limit": "^2.2.1",
        "schema-utils": "^1.0.0",
        "serialize-javascript": "^2.1.2",
        "webpack-log": "^2.0.0"
      },
      "dependencies": {
        "glob-parent": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-3.1.0.tgz",
          "integrity": "sha1-nmr2KZ2NO9K9QEMIMr0RPfkGxa4=",
          "dev": true,
          "requires": {
            "is-glob": "^3.1.0",
            "path-dirname": "^1.0.0"
          },
          "dependencies": {
            "is-glob": {
              "version": "3.1.0",
              "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-3.1.0.tgz",
              "integrity": "sha1-e6WuJCF4BKxwcHuWkiVnSGzD6Eo=",
              "dev": true,
              "requires": {
                "is-extglob": "^2.1.0"
              }
            }
          }
        },
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        }
      }
    },
    "core-js": {
      "version": "2.6.11",
      "resolved": "https://registry.npmjs.org/core-js/-/core-js-2.6.11.tgz",
      "integrity": "sha512-5wjnpaT/3dV+XB4borEsnAYQchn00XSgTAWKDkEqv+K8KevjbzmofK6hfJ9TZIlpj2N0xQpazy7PiRQiWHqzWg=="
    },
    "core-js-compat": {
      "version": "3.6.5",
      "resolved": "https://registry.npmjs.org/core-js-compat/-/core-js-compat-3.6.5.tgz",
      "integrity": "sha512-7ItTKOhOZbznhXAQ2g/slGg1PJV5zDO/WdkTwi7UEOJmkvsE32PWvx6mKtDjiMpjnR2CNf6BAD6sSxIlv7ptng==",
      "requires": {
        "browserslist": "^4.8.5",
        "semver": "7.0.0"
      },
      "dependencies": {
        "semver": {
          "version": "7.0.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.0.0.tgz",
          "integrity": "sha512-+GB6zVA9LWh6zovYQLALHwv5rb2PHGlJi3lfiqIHxR0uuwCgefcOJc59v9fv1w8GbStwxuuqqAjI9NMAOOgq1A=="
        }
      }
    },
    "core-util-is": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.2.tgz",
      "integrity": "sha1-tf1UIgqivFq1eqtxQMlAdUUDwac="
    },
    "cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "requires": {
        "object-assign": "^4",
        "vary": "^1"
      }
    },
    "cosmiconfig": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-5.2.1.tgz",
      "integrity": "sha512-H65gsXo1SKjf8zmrJ67eJk8aIRKV5ff2D4uKZIBZShbhGSpEmsQOPW/SKMKYhSTrqR7ufy6RP69rPogdaPh/kA==",
      "dev": true,
      "requires": {
        "import-fresh": "^2.0.0",
        "is-directory": "^0.3.1",
        "js-yaml": "^3.13.1",
        "parse-json": "^4.0.0"
      }
    },
    "create-ecdh": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/create-ecdh/-/create-ecdh-4.0.3.tgz",
      "integrity": "sha512-GbEHQPMOswGpKXM9kCWVrremUcBmjteUaQ01T9rkKCPDXfUHX0IoP9LpHYo2NPFampa4e+/pFDc3jQdxrxQLaw==",
      "dev": true,
      "requires": {
        "bn.js": "^4.1.0",
        "elliptic": "^6.0.0"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "create-hash": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/create-hash/-/create-hash-1.2.0.tgz",
      "integrity": "sha512-z00bCGNHDG8mHAkP7CtT1qVu+bFQUPjYq/4Iv3C3kWjTFV10zIjfSoeqXo9Asws8gwSHDGj/hl2u4OGIjapeCg==",
      "dev": true,
      "requires": {
        "cipher-base": "^1.0.1",
        "inherits": "^2.0.1",
        "md5.js": "^1.3.4",
        "ripemd160": "^2.0.1",
        "sha.js": "^2.4.0"
      }
    },
    "create-hmac": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/create-hmac/-/create-hmac-1.1.7.tgz",
      "integrity": "sha512-MJG9liiZ+ogc4TzUwuvbER1JRdgvUFSB5+VR/g5h82fGaIRWMWddtKBHi7/sVhfjQZ6SehlyhvQYrcYkaUIpLg==",
      "dev": true,
      "requires": {
        "cipher-base": "^1.0.3",
        "create-hash": "^1.1.0",
        "inherits": "^2.0.1",
        "ripemd160": "^2.0.0",
        "safe-buffer": "^5.0.1",
        "sha.js": "^2.4.8"
      }
    },
    "cross-spawn": {
      "version": "6.0.5",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-6.0.5.tgz",
      "integrity": "sha512-eTVLrBSt7fjbDygz805pMnstIs2VTBNkRm0qxZd+M7A5XDdxVRWO5MxGBXZhjY4cqLYLdtrGqRf8mBPmzwSpWQ==",
      "dev": true,
      "requires": {
        "nice-try": "^1.0.4",
        "path-key": "^2.0.1",
        "semver": "^5.5.0",
        "shebang-command": "^1.2.0",
        "which": "^1.2.9"
      }
    },
    "crypto-browserify": {
      "version": "3.12.0",
      "resolved": "https://registry.npmjs.org/crypto-browserify/-/crypto-browserify-3.12.0.tgz",
      "integrity": "sha512-fz4spIh+znjO2VjL+IdhEpRJ3YN6sMzITSBijk6FK2UvTqruSQW+/cCZTSNsMiZNvUeq0CqurF+dAbyiGOY6Wg==",
      "dev": true,
      "requires": {
        "browserify-cipher": "^1.0.0",
        "browserify-sign": "^4.0.0",
        "create-ecdh": "^4.0.0",
        "create-hash": "^1.1.0",
        "create-hmac": "^1.1.0",
        "diffie-hellman": "^5.0.0",
        "inherits": "^2.0.1",
        "pbkdf2": "^3.0.3",
        "public-encrypt": "^4.0.0",
        "randombytes": "^2.0.0",
        "randomfill": "^1.0.3"
      }
    },
    "css": {
      "version": "2.2.4",
      "resolved": "https://registry.npmjs.org/css/-/css-2.2.4.tgz",
      "integrity": "sha512-oUnjmWpy0niI3x/mPL8dVEI1l7MnG3+HHyRPHf+YFSbK+svOhXpmSOcDURUh2aOCgl2grzrOPt1nHLuCVFULLw==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.3",
        "source-map": "^0.6.1",
        "source-map-resolve": "^0.5.2",
        "urix": "^0.1.0"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "css-color-names": {
      "version": "0.0.4",
      "resolved": "https://registry.npmjs.org/css-color-names/-/css-color-names-0.0.4.tgz",
      "integrity": "sha1-gIrcLnnPhHOAabZGyyDsJ762KeA=",
      "dev": true
    },
    "css-declaration-sorter": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/css-declaration-sorter/-/css-declaration-sorter-4.0.1.tgz",
      "integrity": "sha512-BcxQSKTSEEQUftYpBVnsH4SF05NTuBokb19/sBt6asXGKZ/6VP7PLG1CBCkFDYOnhXhPh0jMhO6xZ71oYHXHBA==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.1",
        "timsort": "^0.3.0"
      }
    },
    "css-loader": {
      "version": "3.5.3",
      "resolved": "https://registry.npmjs.org/css-loader/-/css-loader-3.5.3.tgz",
      "integrity": "sha512-UEr9NH5Lmi7+dguAm+/JSPovNjYbm2k3TK58EiwQHzOHH5Jfq1Y+XoP2bQO6TMn7PptMd0opxxedAWcaSTRKHw==",
      "dev": true,
      "requires": {
        "camelcase": "^5.3.1",
        "cssesc": "^3.0.0",
        "icss-utils": "^4.1.1",
        "loader-utils": "^1.2.3",
        "normalize-path": "^3.0.0",
        "postcss": "^7.0.27",
        "postcss-modules-extract-imports": "^2.0.0",
        "postcss-modules-local-by-default": "^3.0.2",
        "postcss-modules-scope": "^2.2.0",
        "postcss-modules-values": "^3.0.0",
        "postcss-value-parser": "^4.0.3",
        "schema-utils": "^2.6.6",
        "semver": "^6.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "css-parse": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/css-parse/-/css-parse-2.0.0.tgz",
      "integrity": "sha1-pGjuZnwW2BzPBcWMONKpfHgNv9Q=",
      "dev": true,
      "requires": {
        "css": "^2.0.0"
      }
    },
    "css-select": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/css-select/-/css-select-2.1.0.tgz",
      "integrity": "sha512-Dqk7LQKpwLoH3VovzZnkzegqNSuAziQyNZUcrdDM401iY+R5NkGBXGmtO05/yaXQziALuPogeG0b7UAgjnTJTQ==",
      "dev": true,
      "requires": {
        "boolbase": "^1.0.0",
        "css-what": "^3.2.1",
        "domutils": "^1.7.0",
        "nth-check": "^1.0.2"
      }
    },
    "css-select-base-adapter": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/css-select-base-adapter/-/css-select-base-adapter-0.1.1.tgz",
      "integrity": "sha512-jQVeeRG70QI08vSTwf1jHxp74JoZsr2XSgETae8/xC8ovSnL2WF87GTLO86Sbwdt2lK4Umg4HnnwMO4YF3Ce7w==",
      "dev": true
    },
    "css-selector-tokenizer": {
      "version": "0.7.3",
      "resolved": "https://registry.npmjs.org/css-selector-tokenizer/-/css-selector-tokenizer-0.7.3.tgz",
      "integrity": "sha512-jWQv3oCEL5kMErj4wRnK/OPoBi0D+P1FR2cDCKYPaMeD2eW3/mttav8HT4hT1CKopiJI/psEULjkClhvJo4Lvg==",
      "dev": true,
      "requires": {
        "cssesc": "^3.0.0",
        "fastparse": "^1.1.2"
      }
    },
    "css-tree": {
      "version": "1.0.0-alpha.37",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-1.0.0-alpha.37.tgz",
      "integrity": "sha512-DMxWJg0rnz7UgxKT0Q1HU/L9BeJI0M6ksor0OgqOnF+aRCDWg/N2641HmVyU9KVIu0OVVWOb2IpC9A+BJRnejg==",
      "dev": true,
      "requires": {
        "mdn-data": "2.0.4",
        "source-map": "^0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "css-what": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/css-what/-/css-what-3.3.0.tgz",
      "integrity": "sha512-pv9JPyatiPaQ6pf4OvD/dbfm0o5LviWmwxNWzblYf/1u9QZd0ihV+PMwy5jdQWQ3349kZmKEx9WXuSka2dM4cg==",
      "dev": true
    },
    "cssauron": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/cssauron/-/cssauron-1.4.0.tgz",
      "integrity": "sha1-pmAt/34EqDBtwNuaVR6S6LVmKtg=",
      "dev": true,
      "requires": {
        "through": "X.X.X"
      }
    },
    "cssesc": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/cssesc/-/cssesc-3.0.0.tgz",
      "integrity": "sha512-/Tb/JcjK111nNScGob5MNtsntNM1aCNUDipB/TkwZFhyDrrE47SOx/18wF2bbjgc3ZzCSKW1T5nt5EbFoAz/Vg==",
      "dev": true
    },
    "cssnano": {
      "version": "4.1.10",
      "resolved": "https://registry.npmjs.org/cssnano/-/cssnano-4.1.10.tgz",
      "integrity": "sha512-5wny+F6H4/8RgNlaqab4ktc3e0/blKutmq8yNlBFXA//nSFFAqAngjNVRzUvCgYROULmZZUoosL/KSoZo5aUaQ==",
      "dev": true,
      "requires": {
        "cosmiconfig": "^5.0.0",
        "cssnano-preset-default": "^4.0.7",
        "is-resolvable": "^1.0.0",
        "postcss": "^7.0.0"
      }
    },
    "cssnano-preset-default": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/cssnano-preset-default/-/cssnano-preset-default-4.0.7.tgz",
      "integrity": "sha512-x0YHHx2h6p0fCl1zY9L9roD7rnlltugGu7zXSKQx6k2rYw0Hi3IqxcoAGF7u9Q5w1nt7vK0ulxV8Lo+EvllGsA==",
      "dev": true,
      "requires": {
        "css-declaration-sorter": "^4.0.1",
        "cssnano-util-raw-cache": "^4.0.1",
        "postcss": "^7.0.0",
        "postcss-calc": "^7.0.1",
        "postcss-colormin": "^4.0.3",
        "postcss-convert-values": "^4.0.1",
        "postcss-discard-comments": "^4.0.2",
        "postcss-discard-duplicates": "^4.0.2",
        "postcss-discard-empty": "^4.0.1",
        "postcss-discard-overridden": "^4.0.1",
        "postcss-merge-longhand": "^4.0.11",
        "postcss-merge-rules": "^4.0.3",
        "postcss-minify-font-values": "^4.0.2",
        "postcss-minify-gradients": "^4.0.2",
        "postcss-minify-params": "^4.0.2",
        "postcss-minify-selectors": "^4.0.2",
        "postcss-normalize-charset": "^4.0.1",
        "postcss-normalize-display-values": "^4.0.2",
        "postcss-normalize-positions": "^4.0.2",
        "postcss-normalize-repeat-style": "^4.0.2",
        "postcss-normalize-string": "^4.0.2",
        "postcss-normalize-timing-functions": "^4.0.2",
        "postcss-normalize-unicode": "^4.0.1",
        "postcss-normalize-url": "^4.0.1",
        "postcss-normalize-whitespace": "^4.0.2",
        "postcss-ordered-values": "^4.1.2",
        "postcss-reduce-initial": "^4.0.3",
        "postcss-reduce-transforms": "^4.0.2",
        "postcss-svgo": "^4.0.2",
        "postcss-unique-selectors": "^4.0.1"
      }
    },
    "cssnano-util-get-arguments": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/cssnano-util-get-arguments/-/cssnano-util-get-arguments-4.0.0.tgz",
      "integrity": "sha1-7ToIKZ8h11dBsg87gfGU7UnMFQ8=",
      "dev": true
    },
    "cssnano-util-get-match": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/cssnano-util-get-match/-/cssnano-util-get-match-4.0.0.tgz",
      "integrity": "sha1-wOTKB/U4a7F+xeUiULT1lhNlFW0=",
      "dev": true
    },
    "cssnano-util-raw-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/cssnano-util-raw-cache/-/cssnano-util-raw-cache-4.0.1.tgz",
      "integrity": "sha512-qLuYtWK2b2Dy55I8ZX3ky1Z16WYsx544Q0UWViebptpwn/xDBmog2TLg4f+DBMg1rJ6JDWtn96WHbOKDWt1WQA==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "cssnano-util-same-parent": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/cssnano-util-same-parent/-/cssnano-util-same-parent-4.0.1.tgz",
      "integrity": "sha512-WcKx5OY+KoSIAxBW6UBBRay1U6vkYheCdjyVNDm85zt5K9mHoGOfsOsqIszfAqrQQFIIKgjh2+FDgIj/zsl21Q==",
      "dev": true
    },
    "csso": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/csso/-/csso-4.0.3.tgz",
      "integrity": "sha512-NL3spysxUkcrOgnpsT4Xdl2aiEiBG6bXswAABQVHcMrfjjBisFOKwLDOmf4wf32aPdcJws1zds2B0Rg+jqMyHQ==",
      "dev": true,
      "requires": {
        "css-tree": "1.0.0-alpha.39"
      },
      "dependencies": {
        "css-tree": {
          "version": "1.0.0-alpha.39",
          "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-1.0.0-alpha.39.tgz",
          "integrity": "sha512-7UvkEYgBAHRG9Nt980lYxjsTrCyHFN53ky3wVsDkiMdVqylqRt+Zc+jm5qw7/qyOvN2dHSYtX0e4MbCCExSvnA==",
          "dev": true,
          "requires": {
            "mdn-data": "2.0.6",
            "source-map": "^0.6.1"
          }
        },
        "mdn-data": {
          "version": "2.0.6",
          "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.0.6.tgz",
          "integrity": "sha512-rQvjv71olwNHgiTbfPZFkJtjNMciWgswYeciZhtvWLO8bmX3TnhyA62I6sTWOyZssWHJJjY6/KiWwqQsWWsqOA==",
          "dev": true
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "cssom": {
      "version": "0.4.4",
      "resolved": "https://registry.npmjs.org/cssom/-/cssom-0.4.4.tgz",
      "integrity": "sha512-p3pvU7r1MyyqbTk+WbNJIgJjG2VmTIaB10rI93LzVPrmDJKkzKYMtxxyAvQXR/NS6otuzveI7+7BBq3SjBS2mw==",
      "dev": true
    },
    "cssstyle": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/cssstyle/-/cssstyle-2.3.0.tgz",
      "integrity": "sha512-AZL67abkUzIuvcHqk7c09cezpGNcxUxU4Ioi/05xHk4DQeTkWmGYftIE6ctU6AEt+Gn4n1lDStOtj7FKycP71A==",
      "dev": true,
      "requires": {
        "cssom": "~0.3.6"
      },
      "dependencies": {
        "cssom": {
          "version": "0.3.8",
          "resolved": "https://registry.npmjs.org/cssom/-/cssom-0.3.8.tgz",
          "integrity": "sha512-b0tGHbfegbhPJpxpiBPU2sCkigAqtM9O121le6bbOlgyV+NyGyCmVfJ6QW9eRjz8CpNfWEOYBIMIGRYkLwsIYg==",
          "dev": true
        }
      }
    },
    "cyclist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/cyclist/-/cyclist-1.0.1.tgz",
      "integrity": "sha1-WW6WmP0MgOEgOMK4LW6xs1tiJNk=",
      "dev": true
    },
    "cypress": {
      "version": "6.9.1",
      "resolved": "https://registry.npmjs.org/cypress/-/cypress-6.9.1.tgz",
      "integrity": "sha512-/RVx6sOhsyTR9sd9v0BHI4tnDZAhsH9rNat7CIKCUEr5VPWxyfGH0EzK4IHhAqAH8vjFcD4U14tPiJXshoUrmQ==",
      "dev": true,
      "requires": {
        "@cypress/listr-verbose-renderer": "^0.4.1",
        "@cypress/request": "^2.88.5",
        "@cypress/xvfb": "^1.2.4",
        "@types/node": "12.12.50",
        "@types/sinonjs__fake-timers": "^6.0.1",
        "@types/sizzle": "^2.3.2",
        "arch": "^2.1.2",
        "blob-util": "2.0.2",
        "bluebird": "^3.7.2",
        "cachedir": "^2.3.0",
        "chalk": "^4.1.0",
        "check-more-types": "^2.24.0",
        "cli-table3": "~0.6.0",
        "commander": "^5.1.0",
        "common-tags": "^1.8.0",
        "dayjs": "^1.9.3",
        "debug": "4.3.2",
        "eventemitter2": "^6.4.2",
        "execa": "^4.0.2",
        "executable": "^4.1.1",
        "extract-zip": "^1.7.0",
        "fs-extra": "^9.0.1",
        "getos": "^3.2.1",
        "is-ci": "^2.0.0",
        "is-installed-globally": "^0.3.2",
        "lazy-ass": "^1.6.0",
        "listr": "^0.14.3",
        "lodash": "^4.17.19",
        "log-symbols": "^4.0.0",
        "minimist": "^1.2.5",
        "moment": "^2.29.1",
        "ospath": "^1.2.2",
        "pretty-bytes": "^5.4.1",
        "ramda": "~0.27.1",
        "request-progress": "^3.0.0",
        "supports-color": "^7.2.0",
        "tmp": "~0.2.1",
        "untildify": "^4.0.0",
        "url": "^0.11.0",
        "yauzl": "^2.10.0"
      },
      "dependencies": {
        "@types/node": {
          "version": "12.12.50",
          "resolved": "https://registry.npmjs.org/@types/node/-/node-12.12.50.tgz",
          "integrity": "sha512-5ImO01Fb8YsEOYpV+aeyGYztcYcjGsBvN4D7G5r1ef2cuQOpymjWNQi5V0rKHE6PC2ru3HkoUr/Br2/8GUA84w==",
          "dev": true
        },
        "ansi-styles": {
          "version": "4.3.0",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
          "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
          "dev": true,
          "requires": {
            "color-convert": "^2.0.1"
          }
        },
        "chalk": {
          "version": "4.1.1",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.1.tgz",
          "integrity": "sha512-diHzdDKxcU+bAsUboHLPEDQiw0qEe0qd7SYUn3HgcFlWgbDcfLGswOHYeGrHKzG9z6UYf01d9VFMfZxPM1xZSg==",
          "dev": true,
          "requires": {
            "ansi-styles": "^4.1.0",
            "supports-color": "^7.1.0"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        },
        "commander": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/commander/-/commander-5.1.0.tgz",
          "integrity": "sha512-P0CysNDQ7rtVw4QIQtm+MRxV66vKFSvlsQvGYXZWR3qFU0jlMKHZZZgw8e+8DSah4UDKMqnknRDQz+xuQXQ/Zg==",
          "dev": true
        },
        "cross-spawn": {
          "version": "7.0.3",
          "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
          "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
          "dev": true,
          "requires": {
            "path-key": "^3.1.0",
            "shebang-command": "^2.0.0",
            "which": "^2.0.1"
          }
        },
        "debug": {
          "version": "4.3.2",
          "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.2.tgz",
          "integrity": "sha512-mOp8wKcvj7XxC78zLgw/ZA+6TSgkoE2C/ienthhRD298T7UNwAg9diBpLRxC0mOezLl4B0xV7M0cCO6P/O0Xhw==",
          "dev": true,
          "requires": {
            "ms": "2.1.2"
          }
        },
        "execa": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/execa/-/execa-4.1.0.tgz",
          "integrity": "sha512-j5W0//W7f8UxAn8hXVnwG8tLwdiUy4FJLcSupCg6maBYZDpyBvTApK7KyuI4bKj8KOh1r2YH+6ucuYtJv1bTZA==",
          "dev": true,
          "requires": {
            "cross-spawn": "^7.0.0",
            "get-stream": "^5.0.0",
            "human-signals": "^1.1.1",
            "is-stream": "^2.0.0",
            "merge-stream": "^2.0.0",
            "npm-run-path": "^4.0.0",
            "onetime": "^5.1.0",
            "signal-exit": "^3.0.2",
            "strip-final-newline": "^2.0.0"
          }
        },
        "fs-extra": {
          "version": "9.1.0",
          "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-9.1.0.tgz",
          "integrity": "sha512-hcg3ZmepS30/7BSFqRvoo3DOMQu7IjqxO5nCDt+zM9XWjb33Wg7ziNT+Qvqbuc3+gWpzO02JubVyk2G4Zvo1OQ==",
          "dev": true,
          "requires": {
            "at-least-node": "^1.0.0",
            "graceful-fs": "^4.2.0",
            "jsonfile": "^6.0.1",
            "universalify": "^2.0.0"
          }
        },
        "get-stream": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-5.2.0.tgz",
          "integrity": "sha512-nBF+F1rAZVCu/p7rjzgA+Yb4lfYXrpl7a6VmJrU8wF9I1CKvP/QwPNZHnOlwbTkY6dvtFIzFMSyQXbLoTQPRpA==",
          "dev": true,
          "requires": {
            "pump": "^3.0.0"
          }
        },
        "has-flag": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
          "dev": true
        },
        "is-stream": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.0.tgz",
          "integrity": "sha512-XCoy+WlUr7d1+Z8GgSuXmpuUFC9fOhRXglJMx+dwLKTkL44Cjd4W1Z5P+BQZpr+cR93aGP4S/s7Ftw6Nd/kiEw==",
          "dev": true
        },
        "jsonfile": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-6.1.0.tgz",
          "integrity": "sha512-5dgndWOriYSm5cnYaJNhalLNDKOqFwyDB/rr1E9ZsGciGvKPs8R2xYGCacuf3z6K1YKDz182fd+fY3cn3pMqXQ==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.6",
            "universalify": "^2.0.0"
          }
        },
        "log-symbols": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
          "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
          "dev": true,
          "requires": {
            "chalk": "^4.1.0",
            "is-unicode-supported": "^0.1.0"
          }
        },
        "npm-run-path": {
          "version": "4.0.1",
          "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
          "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
          "dev": true,
          "requires": {
            "path-key": "^3.0.0"
          }
        },
        "path-key": {
          "version": "3.1.1",
          "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
          "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
          "dev": true
        },
        "shebang-command": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
          "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
          "dev": true,
          "requires": {
            "shebang-regex": "^3.0.0"
          }
        },
        "shebang-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
          "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
          "dev": true
        },
        "supports-color": {
          "version": "7.2.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
          "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
          "dev": true,
          "requires": {
            "has-flag": "^4.0.0"
          }
        },
        "tmp": {
          "version": "0.2.1",
          "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.2.1.tgz",
          "integrity": "sha512-76SUhtfqR2Ijn+xllcI5P1oyannHNHByD80W1q447gU3mp9G9PSpGdWmjUOHRDPiHYacIk66W7ubDTuPF3BEtQ==",
          "dev": true,
          "requires": {
            "rimraf": "^3.0.0"
          }
        },
        "universalify": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/universalify/-/universalify-2.0.0.tgz",
          "integrity": "sha512-hAZsKq7Yy11Zu1DE0OzWjw7nnLZmJZYTDZZyEFHZdUhV8FkH5MCfoU1XMaxXovpyW5nq5scPqq0ZDP9Zyl04oQ==",
          "dev": true
        },
        "which": {
          "version": "2.0.2",
          "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
          "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
          "dev": true,
          "requires": {
            "isexe": "^2.0.0"
          }
        }
      }
    },
    "d": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/d/-/d-1.0.1.tgz",
      "integrity": "sha512-m62ShEObQ39CfralilEQRjH6oAMtNCV1xJyEx5LpRYUVN+EviphDgUc/F3hnYbADmkiNs67Y+3ylmlG7Lnu+FA==",
      "requires": {
        "es5-ext": "^0.10.50",
        "type": "^1.0.1"
      }
    },
    "damerau-levenshtein": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.6.tgz",
      "integrity": "sha512-JVrozIeElnj3QzfUIt8tB8YMluBJom4Vw9qTPpjGYQ9fYlB3D/rb6OordUxf3xeFB35LKWs0xqcO5U6ySvBtug==",
      "dev": true
    },
    "dashdash": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/dashdash/-/dashdash-1.14.1.tgz",
      "integrity": "sha1-hTz6D3y+L+1d4gMmuN1YEDX24vA=",
      "dev": true,
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "data-urls": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-1.1.0.tgz",
      "integrity": "sha512-YTWYI9se1P55u58gL5GkQHW4P6VJBJ5iBT+B5a7i2Tjadhv52paJG0qHX4A0OR6/t52odI64KP2YvFpkDOi3eQ==",
      "dev": true,
      "requires": {
        "abab": "^2.0.0",
        "whatwg-mimetype": "^2.2.0",
        "whatwg-url": "^7.0.0"
      }
    },
    "date-fns": {
      "version": "1.30.1",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-1.30.1.tgz",
      "integrity": "sha512-hBSVCvSmWC+QypYObzwGOd9wqdDpOt+0wl0KbU+R+uuZBS1jN8VsD1ss3irQDknRj5NvxiTF6oj/nDRnN/UQNw==",
      "dev": true
    },
    "dayjs": {
      "version": "1.10.4",
      "resolved": "https://registry.npmjs.org/dayjs/-/dayjs-1.10.4.tgz",
      "integrity": "sha512-RI/Hh4kqRc1UKLOAf/T5zdMMX5DQIlDxwUe3wSyMMnEbGunnpENCdbUgM+dW7kXidZqCttBrmw7BhN4TMddkCw==",
      "dev": true
    },
    "debug": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.1.1.tgz",
      "integrity": "sha512-pYAIzeRo8J6KPEaJ0VWOh5Pzkbw/RetuzehGM7QRRX5he4fPHx2rdKMB256ehJCkX+XRQm16eZLqLNS8RSZXZw==",
      "requires": {
        "ms": "^2.1.1"
      }
    },
    "debuglog": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/debuglog/-/debuglog-1.0.1.tgz",
      "integrity": "sha1-qiT/uaw9+aI1GDfPstJ5NgzXhJI=",
      "dev": true
    },
    "decamelize": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-1.2.0.tgz",
      "integrity": "sha1-9lNNFRSCabIDUue+4m9QH5oZEpA=",
      "dev": true
    },
    "decode-uri-component": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/decode-uri-component/-/decode-uri-component-0.2.0.tgz",
      "integrity": "sha1-6zkTMzRYd1y4TNGh+uBiEGu4dUU="
    },
    "deep-eql": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz",
      "integrity": "sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw==",
      "dev": true,
      "requires": {
        "type-detect": "^4.0.0"
      }
    },
    "deep-equal": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/deep-equal/-/deep-equal-1.1.1.tgz",
      "integrity": "sha512-yd9c5AdiqVcR+JjcwUQb9DkhJc8ngNr0MahEBGvDiJw8puWab2yZlh+nkasOnZP+EGTAP6rRp2JzJhJZzvNF8g==",
      "dev": true,
      "requires": {
        "is-arguments": "^1.0.4",
        "is-date-object": "^1.0.1",
        "is-regex": "^1.0.4",
        "object-is": "^1.0.1",
        "object-keys": "^1.1.1",
        "regexp.prototype.flags": "^1.2.0"
      }
    },
    "deep-is": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.3.tgz",
      "integrity": "sha1-s2nW+128E+7PUk+RsHD+7cNXzzQ=",
      "dev": true
    },
    "deepmerge": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/deepmerge/-/deepmerge-4.2.2.tgz",
      "integrity": "sha512-FJ3UgI4gIl+PHZm53knsuSFpE+nESMr7M4v9QcgB7S63Kj/6WqMiFQJpBBYz1Pt+66bZpP3Q7Lye0Oo9MPKEdg==",
      "dev": true
    },
    "default-gateway": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/default-gateway/-/default-gateway-4.2.0.tgz",
      "integrity": "sha512-h6sMrVB1VMWVrW13mSc6ia/DwYYw5MN6+exNu1OaJeFac5aSAvwM7lZ0NVfTABuSkQelr4h5oebg3KB1XPdjgA==",
      "dev": true,
      "requires": {
        "execa": "^1.0.0",
        "ip-regex": "^2.1.0"
      }
    },
    "defaults": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/defaults/-/defaults-1.0.3.tgz",
      "integrity": "sha1-xlYFHpgX2f8I7YgUd/P+QBnz730=",
      "requires": {
        "clone": "^1.0.2"
      },
      "dependencies": {
        "clone": {
          "version": "1.0.4",
          "resolved": "https://registry.npmjs.org/clone/-/clone-1.0.4.tgz",
          "integrity": "sha1-2jCcwmPfFZlMaIypAheco8fNfH4="
        }
      }
    },
    "define-properties": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/define-properties/-/define-properties-1.1.3.tgz",
      "integrity": "sha512-3MqfYKj2lLzdMSf8ZIZE/V+Zuy+BgD6f164e8K2w7dgnpKArBDerGYpM46IYYcjnkdPNMjPk9A6VFB8+3SKlXQ==",
      "requires": {
        "object-keys": "^1.0.12"
      }
    },
    "define-property": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/define-property/-/define-property-2.0.2.tgz",
      "integrity": "sha512-jwK2UV4cnPpbcG7+VRARKTZPUWowwXA8bzH5NP6ud0oeAxyYPuGZUAC7hMugpCdz4BeSZl2Dl9k66CHJ/46ZYQ==",
      "requires": {
        "is-descriptor": "^1.0.2",
        "isobject": "^3.0.1"
      },
      "dependencies": {
        "is-accessor-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-data-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-descriptor": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
          "requires": {
            "is-accessor-descriptor": "^1.0.0",
            "is-data-descriptor": "^1.0.0",
            "kind-of": "^6.0.2"
          }
        }
      }
    },
    "del": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/del/-/del-4.1.1.tgz",
      "integrity": "sha512-QwGuEUouP2kVwQenAsOof5Fv8K9t3D8Ca8NxcXKrIpEHjTXK5J2nXLdP+ALI1cgv8wj7KuwBhTwBkOZSJKM5XQ==",
      "dev": true,
      "requires": {
        "@types/glob": "^7.1.1",
        "globby": "^6.1.0",
        "is-path-cwd": "^2.0.0",
        "is-path-in-cwd": "^2.0.0",
        "p-map": "^2.0.0",
        "pify": "^4.0.1",
        "rimraf": "^2.6.3"
      },
      "dependencies": {
        "globby": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/globby/-/globby-6.1.0.tgz",
          "integrity": "sha1-9abXDoOV4hyFj7BInWTfAkJNUGw=",
          "dev": true,
          "requires": {
            "array-union": "^1.0.1",
            "glob": "^7.0.3",
            "object-assign": "^4.0.1",
            "pify": "^2.0.0",
            "pinkie-promise": "^2.0.0"
          },
          "dependencies": {
            "pify": {
              "version": "2.3.0",
              "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
              "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
              "dev": true
            }
          }
        },
        "p-map": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/p-map/-/p-map-2.1.0.tgz",
          "integrity": "sha512-y3b8Kpd8OAN444hxfBbFfj1FY/RjtTd8tzYwhUqNYXx0fXx2iX4maP4Qr6qhIKbQXI02wTLAda4fYUbDagTUFw==",
          "dev": true
        },
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        }
      }
    },
    "delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha1-3zrhmayt+31ECqrgsp4icrJOxhk=",
      "dev": true
    },
    "depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
    },
    "dependency-graph": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/dependency-graph/-/dependency-graph-0.7.2.tgz",
      "integrity": "sha512-KqtH4/EZdtdfWX0p6MGP9jljvxSY6msy/pRUD4jgNwVpv3v1QmNLlsB3LDSSUg79BRVSn7jI1QPRtArGABovAQ==",
      "dev": true
    },
    "des.js": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/des.js/-/des.js-1.0.1.tgz",
      "integrity": "sha512-Q0I4pfFrv2VPd34/vfLrFOoRmlYj3OV50i7fskps1jZWK1kApMWWT9G6RRUeYedLcBDIhnSDaUvJMb3AhUlaEA==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0"
      }
    },
    "destroy": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.0.4.tgz",
      "integrity": "sha1-l4hXRCxEdJ5CBmE+N5RiBYJqvYA="
    },
    "detect-newline": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/detect-newline/-/detect-newline-3.1.0.tgz",
      "integrity": "sha512-TLz+x/vEXm/Y7P7wn1EJFNLxYpUD4TgMosxY6fAVJUnJMbupHBOncxyWUG9OpTaH9EBD7uFI5LfEgmMOc54DsA==",
      "dev": true
    },
    "detect-node": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-node/-/detect-node-2.0.4.tgz",
      "integrity": "sha512-ZIzRpLJrOj7jjP2miAtgqIfmzbxa4ZOr5jJc601zklsfEx9oTzmmj2nVpIPRpNlRTIh8lc1kyViIY7BWSGNmKw==",
      "dev": true
    },
    "dezalgo": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.3.tgz",
      "integrity": "sha1-f3Qt4Gb8dIvI24IFad3c5Jvw1FY=",
      "dev": true,
      "requires": {
        "asap": "^2.0.0",
        "wrappy": "1"
      }
    },
    "dicer": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/dicer/-/dicer-0.2.5.tgz",
      "integrity": "sha1-WZbAhrszIYyBLAkL3cCc0S+stw8=",
      "requires": {
        "readable-stream": "1.1.x",
        "streamsearch": "0.1.2"
      },
      "dependencies": {
        "isarray": {
          "version": "0.0.1",
          "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
          "integrity": "sha1-ihis/Kmo9Bd+Cav8YDiTmwXR7t8="
        },
        "readable-stream": {
          "version": "1.1.14",
          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-1.1.14.tgz",
          "integrity": "sha1-fPTFTvZI44EwhMY23SB54WbAgdk=",
          "requires": {
            "core-util-is": "~1.0.0",
            "inherits": "~2.0.1",
            "isarray": "0.0.1",
            "string_decoder": "~0.10.x"
          }
        },
        "string_decoder": {
          "version": "0.10.31",
          "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-0.10.31.tgz",
          "integrity": "sha1-YuIDvEF2bGwoyfyEMB2rHFMQ+pQ="
        }
      }
    },
    "diff": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/diff/-/diff-3.5.0.tgz",
      "integrity": "sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==",
      "dev": true
    },
    "diff-sequences": {
      "version": "25.2.6",
      "resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-25.2.6.tgz",
      "integrity": "sha512-Hq8o7+6GaZeoFjtpgvRBUknSXNeJiCx7V9Fr94ZMljNiCr9n9L8H8aJqgWOQiDDGdyn29fRNcDdRVJ5fdyihfg==",
      "dev": true
    },
    "diffie-hellman": {
      "version": "5.0.3",
      "resolved": "https://registry.npmjs.org/diffie-hellman/-/diffie-hellman-5.0.3.tgz",
      "integrity": "sha512-kqag/Nl+f3GwyK25fhUMYj81BUOrZ9IuJsjIcDE5icNM9FJHAVm3VcUDxdLPoQtTuUylWm6ZIknYJwwaPxsUzg==",
      "dev": true,
      "requires": {
        "bn.js": "^4.1.0",
        "miller-rabin": "^4.0.0",
        "randombytes": "^2.0.0"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "dir-glob": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-2.2.2.tgz",
      "integrity": "sha512-f9LBi5QWzIW3I6e//uxZoLBlUt9kcp66qo0sSCxL6YZKc75R1c4MFCoe/LaZiBGmgujvQdxc5Bn3QhfyvK5Hsw==",
      "dev": true,
      "requires": {
        "path-type": "^3.0.0"
      }
    },
    "dns-equal": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/dns-equal/-/dns-equal-1.0.0.tgz",
      "integrity": "sha1-s55/HabrCnW6nBcySzR1PEfgZU0=",
      "dev": true
    },
    "dns-packet": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/dns-packet/-/dns-packet-1.3.1.tgz",
      "integrity": "sha512-0UxfQkMhYAUaZI+xrNZOz/as5KgDU0M/fQ9b6SpkyLbk3GEswDi6PADJVaYJradtRVsRIlF1zLyOodbcTCDzUg==",
      "dev": true,
      "requires": {
        "ip": "^1.1.0",
        "safe-buffer": "^5.0.1"
      }
    },
    "dns-txt": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/dns-txt/-/dns-txt-2.0.2.tgz",
      "integrity": "sha1-uR2Ab10nGI5Ks+fRB9iBocxGQrY=",
      "dev": true,
      "requires": {
        "buffer-indexof": "^1.0.0"
      }
    },
    "doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "requires": {
        "esutils": "^2.0.2"
      }
    },
    "dom-serializer": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/dom-serializer/-/dom-serializer-0.2.2.tgz",
      "integrity": "sha512-2/xPb3ORsQ42nHYiSunXkDjPLBaEj/xTwUO4B7XCZQTRk7EBtTOPaygh10YAAh2OI1Qrp6NWfpAhzswj0ydt9g==",
      "dev": true,
      "requires": {
        "domelementtype": "^2.0.1",
        "entities": "^2.0.0"
      },
      "dependencies": {
        "domelementtype": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-2.0.1.tgz",
          "integrity": "sha512-5HOHUDsYZWV8FGWN0Njbr/Rn7f/eWSQi1v7+HsUVwXgn8nWWlL64zKDkS0n8ZmQ3mlWOMuXOnR+7Nx/5tMO5AQ==",
          "dev": true
        }
      }
    },
    "domain-browser": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/domain-browser/-/domain-browser-1.2.0.tgz",
      "integrity": "sha512-jnjyiM6eRyZl2H+W8Q/zLMA481hzi0eszAaBUzIVnmYVDBbnLxVNnfu1HgEBvCbL+71FrxMl3E6lpKH7Ge3OXA==",
      "dev": true
    },
    "domelementtype": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/domelementtype/-/domelementtype-1.3.1.tgz",
      "integrity": "sha512-BSKB+TSpMpFI/HOxCNr1O8aMOTZ8hT3pM3GQ0w/mWRmkhEDSFJkkyzz4XQsBV44BChwGkrDfMyjVD0eA2aFV3w==",
      "dev": true
    },
    "domexception": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/domexception/-/domexception-1.0.1.tgz",
      "integrity": "sha512-raigMkn7CJNNo6Ihro1fzG7wr3fHuYVytzquZKX5n0yizGsTcYgzdIUwj1X9pK0VvjeihV+XiclP+DjwbsSKug==",
      "dev": true,
      "requires": {
        "webidl-conversions": "^4.0.2"
      }
    },
    "domutils": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/domutils/-/domutils-1.7.0.tgz",
      "integrity": "sha512-Lgd2XcJ/NjEw+7tFvfKxOzCYKZsdct5lczQ2ZaQY8Djz7pfAD3Gbp8ySJWtreII/vDlMVmxwa6pHmdxIYgttDg==",
      "dev": true,
      "requires": {
        "dom-serializer": "0",
        "domelementtype": "1"
      }
    },
    "dot-prop": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/dot-prop/-/dot-prop-5.2.0.tgz",
      "integrity": "sha512-uEUyaDKoSQ1M4Oq8l45hSE26SnTxL6snNnqvK/VWx5wJhmff5z0FUVJDKDanor/6w3kzE3i7XZOk+7wC0EXr1A==",
      "dev": true,
      "requires": {
        "is-obj": "^2.0.0"
      }
    },
    "dotenv": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-6.2.0.tgz",
      "integrity": "sha512-HygQCKUBSFl8wKQZBSemMywRWcEDNidvNbjGVyZu3nbZ8qq9ubiPoGLMdRDpfSrpkkm9BXYFkpKxxFX38o/76w==",
      "dev": true
    },
    "duplexify": {
      "version": "3.7.1",
      "resolved": "https://registry.npmjs.org/duplexify/-/duplexify-3.7.1.tgz",
      "integrity": "sha512-07z8uv2wMyS51kKhD1KsdXJg5WQ6t93RneqRxUHnskXVtlYYkLqM0gqStQZ3pj073g687jPCHrqNfCzawLYh5g==",
      "dev": true,
      "requires": {
        "end-of-stream": "^1.0.0",
        "inherits": "^2.0.1",
        "readable-stream": "^2.0.0",
        "stream-shift": "^1.0.0"
      }
    },
    "ecc-jsbn": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
      "integrity": "sha1-OoOpBOVDUyh4dMVkt1SThoSamMk=",
      "dev": true,
      "requires": {
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.1.0"
      }
    },
    "ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0="
    },
    "electron-to-chromium": {
      "version": "1.3.428",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.3.428.tgz",
      "integrity": "sha512-u3+5jEfgLKq/hGO96YfAoOAM1tgFnRDTCD5mLuev44tttcXix+INtVegAkmGzUcfDsnzkPt51XXurXZLLwXt0w=="
    },
    "elegant-spinner": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/elegant-spinner/-/elegant-spinner-1.0.1.tgz",
      "integrity": "sha1-2wQ1IcldfjA/2PNFvtwzSc+wcp4=",
      "dev": true
    },
    "elliptic": {
      "version": "6.5.3",
      "resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.3.tgz",
      "integrity": "sha512-IMqzv5wNQf+E6aHeIqATs0tOLeOTwj1QKbRcS3jBbYkl5oLAserA8yJTT7/VyHUYG91PRmPyeQDObKLPpeS4dw==",
      "dev": true,
      "requires": {
        "bn.js": "^4.4.0",
        "brorand": "^1.0.1",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.0",
        "inherits": "^2.0.1",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.0"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.9",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.9.tgz",
          "integrity": "sha512-E6QoYqCKZfgatHTdHzs1RRKP7ip4vvm+EyRUeE2RF0NblwVvb0p6jSVeNTOFxPn26QXN2o6SMfNxKp6kU8zQaw==",
          "dev": true
        }
      }
    },
    "emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true
    },
    "emojis-list": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-3.0.0.tgz",
      "integrity": "sha512-/kyM18EfinwXZbno9FyUGeFh87KC8HRQBQGildHZbEuRyWFOmv1U10o9BBp8XVZDVNNuQKyIGIu5ZYAAXJ0V2Q=="
    },
    "encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k="
    },
    "encoding": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/encoding/-/encoding-0.1.13.tgz",
      "integrity": "sha512-ETBauow1T35Y/WZMkio9jiM0Z5xjHHmJ4XmjZOq1l/dXz3lr2sRn87nJy20RupqSh1F2m3HHPSp8ShIPQJrJ3A==",
      "dev": true,
      "requires": {
        "iconv-lite": "^0.6.2"
      },
      "dependencies": {
        "iconv-lite": {
          "version": "0.6.2",
          "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.2.tgz",
          "integrity": "sha512-2y91h5OpQlolefMPmUlivelittSWy0rP+oYVpn6A7GwVHNE8AWzoYOBNmlwks3LobaJxgHCYZAnyNo2GgpNRNQ==",
          "dev": true,
          "requires": {
            "safer-buffer": ">= 2.1.2 < 3.0.0"
          }
        }
      }
    },
    "end-of-stream": {
      "version": "1.4.4",
      "resolved": "https://registry.npmjs.org/end-of-stream/-/end-of-stream-1.4.4.tgz",
      "integrity": "sha512-+uw1inIHVPQoaVuHzRyXd21icM+cnt4CzD5rW+NC1wjOUSTOs+Te7FOv7AhN7vS9x/oIyhLP5PR1H+phQAHu5Q==",
      "dev": true,
      "requires": {
        "once": "^1.4.0"
      }
    },
    "enhanced-resolve": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-4.1.1.tgz",
      "integrity": "sha512-98p2zE+rL7/g/DzMHMTF4zZlCgeVdJ7yr6xzEpJRYwFYrGi9ANdn5DnJURg6RpBkyk60XYDnWIv51VfIhfNGuA==",
      "requires": {
        "graceful-fs": "^4.1.2",
        "memory-fs": "^0.5.0",
        "tapable": "^1.0.0"
      },
      "dependencies": {
        "memory-fs": {
          "version": "0.5.0",
          "resolved": "https://registry.npmjs.org/memory-fs/-/memory-fs-0.5.0.tgz",
          "integrity": "sha512-jA0rdU5KoQMC0e6ppoNRtpp6vjFq6+NY7r8hywnC7V+1Xj/MtHwGIbB1QaK/dunyjWteJzmkpd7ooeWg10T7GA==",
          "requires": {
            "errno": "^0.1.3",
            "readable-stream": "^2.0.1"
          }
        }
      }
    },
    "entities": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/entities/-/entities-2.0.3.tgz",
      "integrity": "sha512-MyoZ0jgnLvB2X3Lg5HqpFmn1kybDiIfEQmKzTb5apr51Rb+T3KdmMiqa70T+bhGnyv7bQ6WMj2QMHpGMmlrUYQ==",
      "dev": true
    },
    "err-code": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/err-code/-/err-code-1.1.2.tgz",
      "integrity": "sha1-BuARbTAo9q70gGhJ6w6mp0iuaWA=",
      "dev": true
    },
    "errno": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/errno/-/errno-0.1.7.tgz",
      "integrity": "sha512-MfrRBDWzIWifgq6tJj60gkAwtLNb6sQPlcFrSOflcP1aFmmruKQ2wRnze/8V6kgyz7H3FF8Npzv78mZ7XLLflg==",
      "requires": {
        "prr": "~1.0.1"
      }
    },
    "error-ex": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.2.tgz",
      "integrity": "sha512-7dFHNmqeFSEt2ZBsCriorKnn3Z2pj+fd9kmI6QoWw4//DL+icEBfc0U7qJCisqrTsKTjw4fNFy2pW9OqStD84g==",
      "dev": true,
      "requires": {
        "is-arrayish": "^0.2.1"
      }
    },
    "es-abstract": {
      "version": "1.17.5",
      "resolved": "https://registry.npmjs.org/es-abstract/-/es-abstract-1.17.5.tgz",
      "integrity": "sha512-BR9auzDbySxOcfog0tLECW8l28eRGpDpU3Dm3Hp4q/N+VtLTmyj4EUN088XZWQDW/hzj6sYRDXeOFsaAODKvpg==",
      "dev": true,
      "requires": {
        "es-to-primitive": "^1.2.1",
        "function-bind": "^1.1.1",
        "has": "^1.0.3",
        "has-symbols": "^1.0.1",
        "is-callable": "^1.1.5",
        "is-regex": "^1.0.5",
        "object-inspect": "^1.7.0",
        "object-keys": "^1.1.1",
        "object.assign": "^4.1.0",
        "string.prototype.trimleft": "^2.1.1",
        "string.prototype.trimright": "^2.1.1"
      }
    },
    "es-to-primitive": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz",
      "integrity": "sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==",
      "dev": true,
      "requires": {
        "is-callable": "^1.1.4",
        "is-date-object": "^1.0.1",
        "is-symbol": "^1.0.2"
      }
    },
    "es5-ext": {
      "version": "0.10.53",
      "resolved": "https://registry.npmjs.org/es5-ext/-/es5-ext-0.10.53.tgz",
      "integrity": "sha512-Xs2Stw6NiNHWypzRTY1MtaG/uJlwCk8kH81920ma8mvN8Xq1gsfhZvpkImLQArw8AHnv8MT2I45J3c0R8slE+Q==",
      "requires": {
        "es6-iterator": "~2.0.3",
        "es6-symbol": "~3.1.3",
        "next-tick": "~1.0.0"
      }
    },
    "es6-iterator": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/es6-iterator/-/es6-iterator-2.0.3.tgz",
      "integrity": "sha1-p96IkUGgWpSwhUQDstCg+/qY87c=",
      "requires": {
        "d": "1",
        "es5-ext": "^0.10.35",
        "es6-symbol": "^3.1.1"
      }
    },
    "es6-promise": {
      "version": "4.2.8",
      "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
      "integrity": "sha512-HJDGx5daxeIvxdBxvG2cb9g4tEvwIk3i8+nhX0yGrYmZUzbkdg8QbDevheDB8gd0//uPj4c1EQua8Q+MViT0/w==",
      "dev": true
    },
    "es6-promisify": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/es6-promisify/-/es6-promisify-5.0.0.tgz",
      "integrity": "sha1-UQnWLz5W6pZ8S2NQWu8IKRyKUgM=",
      "dev": true,
      "requires": {
        "es6-promise": "^4.0.3"
      }
    },
    "es6-symbol": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/es6-symbol/-/es6-symbol-3.1.3.tgz",
      "integrity": "sha512-NJ6Yn3FuDinBaBRWl/q5X/s4koRHBrgKAu+yGI6JCBeiu3qrcbJhwT2GeR/EXVfylRk8dpQVJoLEFhK+Mu31NA==",
      "requires": {
        "d": "^1.0.1",
        "ext": "^1.1.2"
      }
    },
    "es6-weak-map": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/es6-weak-map/-/es6-weak-map-2.0.3.tgz",
      "integrity": "sha512-p5um32HOTO1kP+w7PRnB+5lQ43Z6muuMuIMffvDN8ZB4GcnjLBV6zGStpbASIMk4DCAvEaamhe2zhyCb/QXXsA==",
      "requires": {
        "d": "1",
        "es5-ext": "^0.10.46",
        "es6-iterator": "^2.0.3",
        "es6-symbol": "^3.1.1"
      }
    },
    "escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg="
    },
    "escape-string-regexp": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
      "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ="
    },
    "escodegen": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/escodegen/-/escodegen-1.14.1.tgz",
      "integrity": "sha512-Bmt7NcRySdIfNPfU2ZoXDrrXsG9ZjvDxcAlMfDUgRBjLOWTuIACXPBFJH7Z+cLb40JeQco5toikyc9t9P8E9SQ==",
      "dev": true,
      "requires": {
        "esprima": "^4.0.1",
        "estraverse": "^4.2.0",
        "esutils": "^2.0.2",
        "optionator": "^0.8.1",
        "source-map": "~0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true,
          "optional": true
        }
      }
    },
    "eslint": {
      "version": "6.8.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-6.8.0.tgz",
      "integrity": "sha512-K+Iayyo2LtyYhDSYwz5D5QdWw0hCacNzyq1Y821Xna2xSJj7cijoLLYmLxTQgcgZ9mC61nryMy9S7GRbYpI5Ig==",
      "dev": true,
      "requires": {
        "@babel/code-frame": "^7.0.0",
        "ajv": "^6.10.0",
        "chalk": "^2.1.0",
        "cross-spawn": "^6.0.5",
        "debug": "^4.0.1",
        "doctrine": "^3.0.0",
        "eslint-scope": "^5.0.0",
        "eslint-utils": "^1.4.3",
        "eslint-visitor-keys": "^1.1.0",
        "espree": "^6.1.2",
        "esquery": "^1.0.1",
        "esutils": "^2.0.2",
        "file-entry-cache": "^5.0.1",
        "functional-red-black-tree": "^1.0.1",
        "glob-parent": "^5.0.0",
        "globals": "^12.1.0",
        "ignore": "^4.0.6",
        "import-fresh": "^3.0.0",
        "imurmurhash": "^0.1.4",
        "inquirer": "^7.0.0",
        "is-glob": "^4.0.0",
        "js-yaml": "^3.13.1",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.3.0",
        "lodash": "^4.17.14",
        "minimatch": "^3.0.4",
        "mkdirp": "^0.5.1",
        "natural-compare": "^1.4.0",
        "optionator": "^0.8.3",
        "progress": "^2.0.0",
        "regexpp": "^2.0.1",
        "semver": "^6.1.2",
        "strip-ansi": "^5.2.0",
        "strip-json-comments": "^3.0.1",
        "table": "^5.2.3",
        "text-table": "^0.2.0",
        "v8-compile-cache": "^2.0.3"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "eslint-scope": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.0.0.tgz",
          "integrity": "sha512-oYrhJW7S0bxAFDvWqzvMPRm6pcgcnWc4QnofCAqRTRfQC0JcwenzGglTtsLyIuuWFfkqDG9vz67cnttSd53djw==",
          "dev": true,
          "requires": {
            "esrecurse": "^4.1.0",
            "estraverse": "^4.1.1"
          }
        },
        "globals": {
          "version": "12.4.0",
          "resolved": "https://registry.npmjs.org/globals/-/globals-12.4.0.tgz",
          "integrity": "sha512-BWICuzzDvDoH54NHKCseDanAhE3CeDorgDL5MT6LMXXj2WCnd9UC2szdk4AWLfjdgNBCXLUanXYcpBBKOSWGwg==",
          "dev": true,
          "requires": {
            "type-fest": "^0.8.1"
          }
        },
        "ignore": {
          "version": "4.0.6",
          "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz",
          "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==",
          "dev": true
        },
        "import-fresh": {
          "version": "3.2.1",
          "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.2.1.tgz",
          "integrity": "sha512-6e1q1cnWP2RXD9/keSkxHScg508CdXqXWgWBaETNhyuBFz+kUZlKboh+ISK+bU++DmbHimVBrOz/zzPe0sZ3sQ==",
          "dev": true,
          "requires": {
            "parent-module": "^1.0.0",
            "resolve-from": "^4.0.0"
          }
        },
        "resolve-from": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
          "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
          "dev": true
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        },
        "strip-json-comments": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.0.tgz",
          "integrity": "sha512-e6/d0eBu7gHtdCqFt0xJr642LdToM5/cN4Qb9DbHjVx1CP5RyeM+zH7pbecEmDv/lBqb0QH+6Uqq75rxFPkM0w==",
          "dev": true
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "type-fest": {
          "version": "0.8.1",
          "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.8.1.tgz",
          "integrity": "sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==",
          "dev": true
        }
      }
    },
    "eslint-config-prettier": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-6.0.0.tgz",
      "integrity": "sha512-vDrcCFE3+2ixNT5H83g28bO/uYAwibJxerXPj+E7op4qzBCsAV36QfvdAyVOoNxKAH2Os/e01T/2x++V0LPukA==",
      "dev": true,
      "requires": {
        "get-stdin": "^6.0.0"
      }
    },
    "eslint-plugin-cypress": {
      "version": "2.11.2",
      "resolved": "https://registry.npmjs.org/eslint-plugin-cypress/-/eslint-plugin-cypress-2.11.2.tgz",
      "integrity": "sha512-1SergF1sGbVhsf7MYfOLiBhdOg6wqyeV9pXUAIDIffYTGMN3dTBQS9nFAzhLsHhO+Bn0GaVM1Ecm71XUidQ7VA==",
      "dev": true,
      "requires": {
        "globals": "^11.12.0"
      }
    },
    "eslint-scope": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-4.0.3.tgz",
      "integrity": "sha512-p7VutNr1O/QrxysMo3E45FjYDTeXBy0iTltPFNSqKAIfjDSXC+4dj+qfyuD8bfAXrW/y6lW3O76VaYNPKfpKrg==",
      "dev": true,
      "requires": {
        "esrecurse": "^4.1.0",
        "estraverse": "^4.1.1"
      }
    },
    "eslint-utils": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-1.4.3.tgz",
      "integrity": "sha512-fbBN5W2xdY45KulGXmLHZ3c3FHfVYmKg0IrAKGOkT/464PQsx2UeIzfz1RmEci+KLm1bBaAzZAh8+/E+XAeZ8Q==",
      "dev": true,
      "requires": {
        "eslint-visitor-keys": "^1.1.0"
      }
    },
    "eslint-visitor-keys": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.1.0.tgz",
      "integrity": "sha512-8y9YjtM1JBJU/A9Kc+SbaOV4y29sSWckBwMHa+FGtVj5gN/sbnKDf6xJUl+8g7FAij9LVaP8C24DUiH/f/2Z9A==",
      "dev": true
    },
    "espree": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/espree/-/espree-6.2.1.tgz",
      "integrity": "sha512-ysCxRQY3WaXJz9tdbWOwuWr5Y/XrPTGX9Kiz3yoUXwW0VZ4w30HTkQLaGx/+ttFjF8i+ACbArnB4ce68a9m5hw==",
      "dev": true,
      "requires": {
        "acorn": "^7.1.1",
        "acorn-jsx": "^5.2.0",
        "eslint-visitor-keys": "^1.1.0"
      },
      "dependencies": {
        "acorn": {
          "version": "7.1.1",
          "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.1.1.tgz",
          "integrity": "sha512-add7dgA5ppRPxCFJoAGfMDi7PIBXq1RtGo7BhbLaxwrXPOmw8gq48Y9ozT01hUKy9byMjlR20EJhu5zlkErEkg==",
          "dev": true
        }
      }
    },
    "esprima": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
      "dev": true
    },
    "esquery": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.3.1.tgz",
      "integrity": "sha512-olpvt9QG0vniUBZspVRN6lwB7hOZoTRtT+jzR+tS4ffYx2mzbw+z0XCOk44aaLYKApNX5nMm+E+P6o25ip/DHQ==",
      "dev": true,
      "requires": {
        "estraverse": "^5.1.0"
      },
      "dependencies": {
        "estraverse": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.1.0.tgz",
          "integrity": "sha512-FyohXK+R0vE+y1nHLoBM7ZTyqRpqAlhdZHCWIWEviFLiGB8b04H6bQs8G+XTthacvT8VuwvteiP7RJSxMs8UEw==",
          "dev": true
        }
      }
    },
    "esrecurse": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.2.1.tgz",
      "integrity": "sha512-64RBB++fIOAXPw3P9cy89qfMlvZEXZkqqJkjqqXIvzP5ezRZjW+lPWjw35UX/3EhUPFYbg5ER4JYgDw4007/DQ==",
      "dev": true,
      "requires": {
        "estraverse": "^4.1.0"
      }
    },
    "estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
      "dev": true
    },
    "esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g=="
    },
    "etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha1-Qa4u62XvpiJorr/qg6x9eSmbCIc="
    },
    "event-emitter": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/event-emitter/-/event-emitter-0.3.5.tgz",
      "integrity": "sha1-34xp7vFkeSPHFXuc6DhAYQsCzDk=",
      "requires": {
        "d": "1",
        "es5-ext": "~0.10.14"
      }
    },
    "eventemitter2": {
      "version": "6.4.4",
      "resolved": "https://registry.npmjs.org/eventemitter2/-/eventemitter2-6.4.4.tgz",
      "integrity": "sha512-HLU3NDY6wARrLCEwyGKRBvuWYyvW6mHYv72SJJAH3iJN3a6eVUvkjFkcxah1bcTgGVBBrFdIopBJPhCQFMLyXw==",
      "dev": true
    },
    "eventemitter3": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.4.tgz",
      "integrity": "sha512-rlaVLnVxtxvoyLsQQFBx53YmXHDxRIzzTLbdfxqi4yocpSjAxXwkU0cScM5JgSKMqEhrZpnvQ2D9gjylR0AimQ==",
      "dev": true
    },
    "events": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/events/-/events-3.1.0.tgz",
      "integrity": "sha512-Rv+u8MLHNOdMjTAFeT3nCjHn2aGlx435FP/sDHNaRhDEMwyI/aB22Kj2qIN8R0cw3z28psEQLYwxVKLsKrMgWg==",
      "dev": true
    },
    "eventsource": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/eventsource/-/eventsource-1.0.7.tgz",
      "integrity": "sha512-4Ln17+vVT0k8aWq+t/bF5arcS3EpT9gYtW66EPacdj/mAFevznsnyoHLPy2BA8gbIQeIHoPsvwmfBftfcG//BQ==",
      "dev": true,
      "requires": {
        "original": "^1.0.0"
      }
    },
    "evp_bytestokey": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/evp_bytestokey/-/evp_bytestokey-1.0.3.tgz",
      "integrity": "sha512-/f2Go4TognH/KvCISP7OUsHn85hT9nUkxxA9BEWxFn+Oj9o8ZNLm/40hdlgSLyuOimsrTKLUMEorQexp/aPQeA==",
      "dev": true,
      "requires": {
        "md5.js": "^1.3.4",
        "safe-buffer": "^5.1.1"
      }
    },
    "exec-sh": {
      "version": "0.3.4",
      "resolved": "https://registry.npmjs.org/exec-sh/-/exec-sh-0.3.4.tgz",
      "integrity": "sha512-sEFIkc61v75sWeOe72qyrqg2Qg0OuLESziUDk/O/z2qgS15y2gWVFrI6f2Qn/qw/0/NCfCEsmNA4zOjkwEZT1A==",
      "dev": true
    },
    "execa": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/execa/-/execa-1.0.0.tgz",
      "integrity": "sha512-adbxcyWV46qiHyvSp50TKt05tB4tK3HcmF7/nxfAdhnox83seTDbwnaqKO4sXRy7roHAIFqJP/Rw/AuEbX61LA==",
      "dev": true,
      "requires": {
        "cross-spawn": "^6.0.0",
        "get-stream": "^4.0.0",
        "is-stream": "^1.1.0",
        "npm-run-path": "^2.0.0",
        "p-finally": "^1.0.0",
        "signal-exit": "^3.0.0",
        "strip-eof": "^1.0.0"
      }
    },
    "executable": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/executable/-/executable-4.1.1.tgz",
      "integrity": "sha512-8iA79xD3uAch729dUG8xaaBBFGaEa0wdD2VkYLFHwlqosEj/jT66AzcreRDSgV7ehnNLBW2WR5jIXwGKjVdTLg==",
      "dev": true,
      "requires": {
        "pify": "^2.2.0"
      },
      "dependencies": {
        "pify": {
          "version": "2.3.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
          "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
          "dev": true
        }
      }
    },
    "exit": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/exit/-/exit-0.1.2.tgz",
      "integrity": "sha1-BjJjj42HfMghB9MKD/8aF8uhzQw=",
      "dev": true
    },
    "exit-hook": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/exit-hook/-/exit-hook-1.1.1.tgz",
      "integrity": "sha1-8FyiM7SMBdVP/wd2XfhQfpXAL/g=",
      "dev": true
    },
    "expand-brackets": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/expand-brackets/-/expand-brackets-2.1.4.tgz",
      "integrity": "sha1-t3c14xXOMPa27/D4OwQVGiJEliI=",
      "requires": {
        "debug": "^2.3.3",
        "define-property": "^0.2.5",
        "extend-shallow": "^2.0.1",
        "posix-character-classes": "^0.1.0",
        "regex-not": "^1.0.0",
        "snapdragon": "^0.8.1",
        "to-regex": "^3.0.1"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "define-property": {
          "version": "0.2.5",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
          "requires": {
            "is-descriptor": "^0.1.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        }
      }
    },
    "expect": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/expect/-/expect-25.5.0.tgz",
      "integrity": "sha512-w7KAXo0+6qqZZhovCaBVPSIqQp7/UTcx4M9uKt2m6pd2VB1voyC8JizLRqeEqud3AAVP02g+hbErDu5gu64tlA==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "ansi-styles": "^4.0.0",
        "jest-get-type": "^25.2.6",
        "jest-matcher-utils": "^25.5.0",
        "jest-message-util": "^25.5.0",
        "jest-regex-util": "^25.2.6"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "dev": true,
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        }
      }
    },
    "express": {
      "version": "4.17.1",
      "resolved": "https://registry.npmjs.org/express/-/express-4.17.1.tgz",
      "integrity": "sha512-mHJ9O79RqluphRrcw2X/GTh3k9tVv8YcoyY4Kkh4WDMUYKRZUq0h1o0w2rrrxBqM7VoeUVqgb27xlEMXTnYt4g==",
      "requires": {
        "accepts": "~1.3.7",
        "array-flatten": "1.1.1",
        "body-parser": "1.19.0",
        "content-disposition": "0.5.3",
        "content-type": "~1.0.4",
        "cookie": "0.4.0",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "~1.1.2",
        "fresh": "0.5.2",
        "merge-descriptors": "1.0.1",
        "methods": "~1.1.2",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.7",
        "proxy-addr": "~2.0.5",
        "qs": "6.7.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.1.2",
        "send": "0.17.1",
        "serve-static": "1.14.1",
        "setprototypeof": "1.1.1",
        "statuses": "~1.5.0",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "dependencies": {
        "array-flatten": {
          "version": "1.1.1",
          "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
          "integrity": "sha1-ml9pkFGx5wczKPKgCJaLZOopVdI="
        },
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        },
        "qs": {
          "version": "6.7.0",
          "resolved": "https://registry.npmjs.org/qs/-/qs-6.7.0.tgz",
          "integrity": "sha512-VCdBRNFTX1fyE7Nb6FYoURo/SPe62QCaAyzJvUjwRaIsc+NePBEniHlvxFmmX56+HZphIGtV0XeCirBtpDrTyQ=="
        },
        "safe-buffer": {
          "version": "5.1.2",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
          "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
        }
      }
    },
    "ext": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/ext/-/ext-1.4.0.tgz",
      "integrity": "sha512-Key5NIsUxdqKg3vIsdw9dSuXpPCQ297y6wBjL30edxwPgt2E44WcWBZey/ZvUc6sERLTxKdyCu4gZFmUbk1Q7A==",
      "requires": {
        "type": "^2.0.0"
      },
      "dependencies": {
        "type": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/type/-/type-2.0.0.tgz",
          "integrity": "sha512-KBt58xCHry4Cejnc2ISQAF7QY+ORngsWfxezO68+12hKV6lQY8P/psIkcbjeHWn7MqcgciWJyCCevFMJdIXpow=="
        }
      }
    },
    "extend": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
      "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
      "dev": true
    },
    "extend-shallow": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
      "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
      "requires": {
        "is-extendable": "^0.1.0"
      }
    },
    "external-editor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/external-editor/-/external-editor-3.1.0.tgz",
      "integrity": "sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==",
      "dev": true,
      "requires": {
        "chardet": "^0.7.0",
        "iconv-lite": "^0.4.24",
        "tmp": "^0.0.33"
      }
    },
    "extglob": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/extglob/-/extglob-2.0.4.tgz",
      "integrity": "sha512-Nmb6QXkELsuBr24CJSkilo6UHHgbekK5UiZgfE6UHD3Eb27YC6oD+bhcT+tJ6cl8dmsgdQxnWlcry8ksBIBLpw==",
      "requires": {
        "array-unique": "^0.3.2",
        "define-property": "^1.0.0",
        "expand-brackets": "^2.1.4",
        "extend-shallow": "^2.0.1",
        "fragment-cache": "^0.2.1",
        "regex-not": "^1.0.0",
        "snapdragon": "^0.8.1",
        "to-regex": "^3.0.1"
      },
      "dependencies": {
        "define-property": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
          "requires": {
            "is-descriptor": "^1.0.0"
          }
        },
        "is-accessor-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-data-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-descriptor": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
          "requires": {
            "is-accessor-descriptor": "^1.0.0",
            "is-data-descriptor": "^1.0.0",
            "kind-of": "^6.0.2"
          }
        }
      }
    },
    "extract-zip": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/extract-zip/-/extract-zip-1.7.0.tgz",
      "integrity": "sha512-xoh5G1W/PB0/27lXgMQyIhP5DSY/LhoCsOyZgb+6iMmRtCwVBo55uKaMoEYrDCKQhWvqEip5ZPKAc6eFNyf/MA==",
      "dev": true,
      "requires": {
        "concat-stream": "^1.6.2",
        "debug": "^2.6.9",
        "mkdirp": "^0.5.4",
        "yauzl": "^2.10.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        }
      }
    },
    "extsprintf": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/extsprintf/-/extsprintf-1.3.0.tgz",
      "integrity": "sha1-lpGEQOMEGnpBT4xS48V06zw+HgU=",
      "dev": true
    },
    "fast-deep-equal": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.1.tgz",
      "integrity": "sha512-8UEa58QDLauDNfpbrX55Q9jrGHThw2ZMdOky5Gl1CDtVeJDPVrG4Jxx1N8jw2gkWaff5UUuX1KJd+9zGe2B+ZA=="
    },
    "fast-glob": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.4.tgz",
      "integrity": "sha512-kr/Oo6PX51265qeuCYsyGypiO5uJFgBS0jksyG7FUeCyQzNwYnzrNIMR1NXfkZXsMYXYLRAHgISHBz8gQcxKHQ==",
      "dev": true,
      "requires": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.0",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.2",
        "picomatch": "^2.2.1"
      },
      "dependencies": {
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        }
      }
    },
    "fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
    },
    "fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha1-PYpcZog6FqMMqGQ+hR8Zuqd5eRc=",
      "dev": true
    },
    "fast-safe-stringify": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.0.7.tgz",
      "integrity": "sha512-Utm6CdzT+6xsDk2m8S6uL8VHxNwI6Jub+e9NYTcAms28T84pTa25GJQV9j0CY0N1rM8hK4x6grpF2BQf+2qwVA=="
    },
    "fastparse": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/fastparse/-/fastparse-1.1.2.tgz",
      "integrity": "sha512-483XLLxTVIwWK3QTrMGRqUfUpoOs/0hbQrl2oz4J0pAcm3A3bu84wxTFqGqkJzewCLdME38xJLJAxBABfQT8sQ==",
      "dev": true
    },
    "fastq": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.8.0.tgz",
      "integrity": "sha512-SMIZoZdLh/fgofivvIkmknUXyPnvxRE3DhtZ5Me3Mrsk5gyPL42F0xr51TdRXskBxHfMp+07bcYzfsYEsSQA9Q==",
      "dev": true,
      "requires": {
        "reusify": "^1.0.4"
      }
    },
    "faye-websocket": {
      "version": "0.10.0",
      "resolved": "https://registry.npmjs.org/faye-websocket/-/faye-websocket-0.10.0.tgz",
      "integrity": "sha1-TkkvjQTftviQA1B/btvy1QHnxvQ=",
      "dev": true,
      "requires": {
        "websocket-driver": ">=0.5.1"
      }
    },
    "fb-watchman": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/fb-watchman/-/fb-watchman-2.0.1.tgz",
      "integrity": "sha512-DkPJKQeY6kKwmuMretBhr7G6Vodr7bFwDYTXIkfG1gjvNpaxBTQV3PbXg6bR1c1UP4jPOX0jHUbbHANL9vRjVg==",
      "dev": true,
      "requires": {
        "bser": "2.1.1"
      }
    },
    "fd-slicer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/fd-slicer/-/fd-slicer-1.1.0.tgz",
      "integrity": "sha1-JcfInLH5B3+IkbvmHY85Dq4lbx4=",
      "dev": true,
      "requires": {
        "pend": "~1.2.0"
      }
    },
    "figgy-pudding": {
      "version": "3.5.2",
      "resolved": "https://registry.npmjs.org/figgy-pudding/-/figgy-pudding-3.5.2.tgz",
      "integrity": "sha512-0btnI/H8f2pavGMN8w40mlSKOfTK2SVJmBfBeVIj3kNw0swwgzyRq0d5TJVOwodFmtvpPeWPN/MCcfuWF0Ezbw==",
      "dev": true
    },
    "figures": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/figures/-/figures-3.2.0.tgz",
      "integrity": "sha512-yaduQFRKLXYOGgEn6AZau90j3ggSOyiqXU0F9JZfeXYhNa+Jk4X+s45A2zg5jns87GAFa34BBm2kXw4XpNcbdg==",
      "dev": true,
      "requires": {
        "escape-string-regexp": "^1.0.5"
      }
    },
    "file-entry-cache": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-5.0.1.tgz",
      "integrity": "sha512-bCg29ictuBaKUwwArK4ouCaqDgLZcysCFLmM/Yn/FDoqndh/9vNuQfXRDvTuXKLxfD/JtZQGKFT8MGcJBK644g==",
      "dev": true,
      "requires": {
        "flat-cache": "^2.0.1"
      }
    },
    "file-loader": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/file-loader/-/file-loader-6.0.0.tgz",
      "integrity": "sha512-/aMOAYEFXDdjG0wytpTL5YQLfZnnTmLNjn+AIrJ/6HVnTfDqLsVKUUwkDf4I4kgex36BvjuXEn/TX9B/1ESyqQ==",
      "dev": true,
      "requires": {
        "loader-utils": "^2.0.0",
        "schema-utils": "^2.6.5"
      },
      "dependencies": {
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        }
      }
    },
    "file-uri-to-path": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz",
      "integrity": "sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==",
      "dev": true,
      "optional": true
    },
    "fill-range": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
      "requires": {
        "to-regex-range": "^5.0.1"
      }
    },
    "finalhandler": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.2.tgz",
      "integrity": "sha512-aAWcW57uxVNrQZqFXjITpW3sIUQmHGG3qSb9mUah9MgMC4NeWhNOlNjXEYq3HjRAvL6arUviZGGJsBg6z0zsWA==",
      "requires": {
        "debug": "2.6.9",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "on-finished": "~2.3.0",
        "parseurl": "~1.3.3",
        "statuses": "~1.5.0",
        "unpipe": "~1.0.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        }
      }
    },
    "find-cache-dir": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-2.1.0.tgz",
      "integrity": "sha512-Tq6PixE0w/VMFfCgbONnkiQIVol/JJL7nRMi20fqzA4NRs9AfeqMGeRdPi3wIhYkxjeBaWh2rxwapn5Tu3IqOQ==",
      "requires": {
        "commondir": "^1.0.1",
        "make-dir": "^2.0.0",
        "pkg-dir": "^3.0.0"
      },
      "dependencies": {
        "make-dir": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-2.1.0.tgz",
          "integrity": "sha512-LS9X+dc8KLxXCb8dni79fLIIUA5VyZoyjSMCwTluaXA0o27cCK0bhXkpgw+sTXVpPy/lSO57ilRixqk0vDmtRA==",
          "requires": {
            "pify": "^4.0.1",
            "semver": "^5.6.0"
          }
        }
      }
    },
    "find-up": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-4.1.0.tgz",
      "integrity": "sha512-PpOwAdQ/YlXQ2vj8a3h8IipDuYRi3wceVQQGYWxNINccq40Anw7BlsEXCMbt1Zt+OLA6Fq9suIpIWD0OsnISlw==",
      "dev": true,
      "requires": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      },
      "dependencies": {
        "path-exists": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
          "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
          "dev": true
        }
      }
    },
    "flat": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/flat/-/flat-4.1.0.tgz",
      "integrity": "sha512-Px/TiLIznH7gEDlPXcUD4KnBusa6kR6ayRUVcnEAbreRIuhkqow/mun59BuRXwoYk7ZQOLW1ZM05ilIvK38hFw==",
      "dev": true,
      "requires": {
        "is-buffer": "~2.0.3"
      },
      "dependencies": {
        "is-buffer": {
          "version": "2.0.4",
          "resolved": "https://registry.npmjs.org/is-buffer/-/is-buffer-2.0.4.tgz",
          "integrity": "sha512-Kq1rokWXOPXWuaMAqZiJW4XxsmD9zGx9q4aePabbn3qCRGedtH7Cm+zV8WETitMfu1wdh+Rvd6w5egwSngUX2A==",
          "dev": true
        }
      }
    },
    "flat-cache": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-2.0.1.tgz",
      "integrity": "sha512-LoQe6yDuUMDzQAEH8sgmh4Md6oZnc/7PjtwjNFSzveXqSHt6ka9fPBuso7IGf9Rz4uqnSnWiFH2B/zj24a5ReA==",
      "dev": true,
      "requires": {
        "flatted": "^2.0.0",
        "rimraf": "2.6.3",
        "write": "1.0.3"
      },
      "dependencies": {
        "rimraf": {
          "version": "2.6.3",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.6.3.tgz",
          "integrity": "sha512-mwqeW5XsA2qAejG46gYdENaxXjx9onRNCfn7L0duuP4hCuTIi/QO7PDK07KJfp1d+izWPrzEJDcSqBa0OZQriA==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        }
      }
    },
    "flatted": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-2.0.2.tgz",
      "integrity": "sha512-r5wGx7YeOwNWNlCA0wQ86zKyDLMQr+/RB8xy74M4hTphfmjlijTSSXGuH8rnvKZnfT9i+75zmd8jcKdMR4O6jA==",
      "dev": true
    },
    "flush-write-stream": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/flush-write-stream/-/flush-write-stream-1.1.1.tgz",
      "integrity": "sha512-3Z4XhFZ3992uIq0XOqb9AreonueSYphE6oYbpt5+3u06JWklbsPkNv3ZKkP9Bz/r+1MWCaMoSQ28P85+1Yc77w==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.3",
        "readable-stream": "^2.3.6"
      }
    },
    "follow-redirects": {
      "version": "1.11.0",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.11.0.tgz",
      "integrity": "sha512-KZm0V+ll8PfBrKwMzdo5D13b1bur9Iq9Zd/RMmAoQQcl2PxxFml8cxXPaaPYVbV0RjNjq1CU7zIzAOqtUPudmA==",
      "dev": true,
      "requires": {
        "debug": "^3.0.0"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        }
      }
    },
    "for-in": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/for-in/-/for-in-1.0.2.tgz",
      "integrity": "sha1-gQaNKVqBQuwKxybG4iAMMPttXoA="
    },
    "forever-agent": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/forever-agent/-/forever-agent-0.6.1.tgz",
      "integrity": "sha1-+8cfDEGt6zf5bFd60e1C2P2sypE=",
      "dev": true
    },
    "fork-ts-checker-webpack-plugin": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/fork-ts-checker-webpack-plugin/-/fork-ts-checker-webpack-plugin-3.1.1.tgz",
      "integrity": "sha512-DuVkPNrM12jR41KM2e+N+styka0EgLkTnXmNcXdgOM37vtGeY+oCBK/Jx0hzSeEU6memFCtWb4htrHPMDfwwUQ==",
      "requires": {
        "babel-code-frame": "^6.22.0",
        "chalk": "^2.4.1",
        "chokidar": "^3.3.0",
        "micromatch": "^3.1.10",
        "minimatch": "^3.0.4",
        "semver": "^5.6.0",
        "tapable": "^1.0.0",
        "worker-rpc": "^0.1.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "form-data": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-2.3.3.tgz",
      "integrity": "sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==",
      "dev": true,
      "requires": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.6",
        "mime-types": "^2.1.12"
      }
    },
    "forwarded": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.1.2.tgz",
      "integrity": "sha1-mMI9qxF1ZXuMBXPozszZGw/xjIQ="
    },
    "fragment-cache": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/fragment-cache/-/fragment-cache-0.2.1.tgz",
      "integrity": "sha1-QpD60n8T6Jvn8zeZxrxaCr//DRk=",
      "requires": {
        "map-cache": "^0.2.2"
      }
    },
    "fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha1-PYyt2Q2XZWn6g1qx+OSyOhBWBac="
    },
    "from2": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/from2/-/from2-2.3.0.tgz",
      "integrity": "sha1-i/tVAr3kpNNs/e6gB/zKIdfjgq8=",
      "dev": true,
      "requires": {
        "inherits": "^2.0.1",
        "readable-stream": "^2.0.0"
      }
    },
    "fs-extra": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-4.0.2.tgz",
      "integrity": "sha1-+RcExT0bRh+JNFKwwwfZmXZHq2s=",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.2",
        "jsonfile": "^4.0.0",
        "universalify": "^0.1.0"
      }
    },
    "fs-minipass": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
      "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
      "dev": true,
      "requires": {
        "minipass": "^3.0.0"
      }
    },
    "fs-write-stream-atomic": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/fs-write-stream-atomic/-/fs-write-stream-atomic-1.0.10.tgz",
      "integrity": "sha1-tH31NJPvkR33VzHnCp3tAYnbQMk=",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.2",
        "iferr": "^0.1.5",
        "imurmurhash": "^0.1.4",
        "readable-stream": "1 || 2"
      }
    },
    "fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
      "dev": true
    },
    "fsevents": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.1.3.tgz",
      "integrity": "sha512-Auw9a4AxqWpa9GUfj370BMPzzyncfBABW8Mab7BGWBYDj4Isgq+cDKtx0i6u9jcX9pQDnswsaaOTgTmA5pEjuQ==",
      "optional": true
    },
    "function-bind": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
    },
    "functional-red-black-tree": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz",
      "integrity": "sha1-GwqzvVU7Kg1jmdKcDj6gslIHgyc=",
      "dev": true
    },
    "genfun": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/genfun/-/genfun-5.0.0.tgz",
      "integrity": "sha512-KGDOARWVga7+rnB3z9Sd2Letx515owfk0hSxHGuqjANb1M+x2bGZGqHLiozPsYMdM2OubeMni/Hpwmjq6qIUhA==",
      "dev": true
    },
    "gensync": {
      "version": "1.0.0-beta.1",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.1.tgz",
      "integrity": "sha512-r8EC6NO1sngH/zdD9fiRDLdcgnbayXah+mLgManTaIZJqEC1MZstmnox8KpnI2/fxQwrp5OpCOYWLp4rBl4Jcg=="
    },
    "get-caller-file": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
      "dev": true
    },
    "get-func-name": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.0.tgz",
      "integrity": "sha1-6td0q+5y4gQJQzoGY2YCPdaIekE=",
      "dev": true
    },
    "get-stdin": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/get-stdin/-/get-stdin-6.0.0.tgz",
      "integrity": "sha512-jp4tHawyV7+fkkSKyvjuLZswblUtz+SQKzSWnBbii16BuZksJlU1wuBYXY75r+duh/llF1ur6oNwi+2ZzjKZ7g==",
      "dev": true
    },
    "get-stream": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-4.1.0.tgz",
      "integrity": "sha512-GMat4EJ5161kIy2HevLlr4luNjBgvmj413KaQA7jt4V8B4RDsfpHk7WQ9GVqfYyyx8OS/L66Kox+rJRNklLK7w==",
      "dev": true,
      "requires": {
        "pump": "^3.0.0"
      }
    },
    "get-value": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/get-value/-/get-value-2.0.6.tgz",
      "integrity": "sha1-3BXKHGcjh8p2vTesCjlbogQqLCg="
    },
    "getos": {
      "version": "3.2.1",
      "resolved": "https://registry.npmjs.org/getos/-/getos-3.2.1.tgz",
      "integrity": "sha512-U56CfOK17OKgTVqozZjUKNdkfEv6jk5WISBJ8SHoagjE6L69zOwl3Z+O8myjY9MEW3i2HPWQBt/LTbCgcC973Q==",
      "dev": true,
      "requires": {
        "async": "^3.2.0"
      },
      "dependencies": {
        "async": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/async/-/async-3.2.0.tgz",
          "integrity": "sha512-TR2mEZFVOj2pLStYxLht7TyfuRzaydfpxr3k9RpHIzMgw7A64dzsdqCxH1WJyQdoe8T10nDXd9wnEigmiuHIZw==",
          "dev": true
        }
      }
    },
    "getpass": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/getpass/-/getpass-0.1.7.tgz",
      "integrity": "sha1-Xv+OPmhNVprkyysSgmBOi6YhSfo=",
      "dev": true,
      "requires": {
        "assert-plus": "^1.0.0"
      }
    },
    "glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "dev": true,
      "requires": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      }
    },
    "glob-parent": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.1.tgz",
      "integrity": "sha512-FnI+VGOpnlGHWZxthPGR+QhR78fuiK0sNLkHQv+bL9fQi57lNNdquIbna/WrfROrolq8GK5Ek6BiMwqL/voRYQ==",
      "requires": {
        "is-glob": "^4.0.1"
      }
    },
    "global-dirs": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/global-dirs/-/global-dirs-2.1.0.tgz",
      "integrity": "sha512-MG6kdOUh/xBnyo9cJFeIKkLEc1AyFq42QTU4XiX51i2NEdxLxLWXIjEjmqKeSuKR7pAZjTqUVoT2b2huxVLgYQ==",
      "dev": true,
      "requires": {
        "ini": "1.3.7"
      },
      "dependencies": {
        "ini": {
          "version": "1.3.7",
          "resolved": "https://registry.npmjs.org/ini/-/ini-1.3.7.tgz",
          "integrity": "sha512-iKpRpXP+CrP2jyrxvg1kMUpXDyRUFDWurxbnVT1vQPx+Wz9uCYsMIqYuSBLV+PAaZG/d7kRLKRFc9oDMsH+mFQ==",
          "dev": true
        }
      }
    },
    "globals": {
      "version": "11.12.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
      "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA=="
    },
    "globby": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/globby/-/globby-7.1.1.tgz",
      "integrity": "sha1-+yzP+UAfhgCUXfral0QMypcrhoA=",
      "dev": true,
      "requires": {
        "array-union": "^1.0.1",
        "dir-glob": "^2.0.0",
        "glob": "^7.1.2",
        "ignore": "^3.3.5",
        "pify": "^3.0.0",
        "slash": "^1.0.0"
      },
      "dependencies": {
        "pify": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=",
          "dev": true
        }
      }
    },
    "graceful-fs": {
      "version": "4.2.4",
      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.4.tgz",
      "integrity": "sha512-WjKPNJF79dtJAVniUlGGWHYGz2jWxT6VhN/4m1NdkbZ2nOsEF+cI1Edgql5zCRhs/VsQYRvrXctxktVXZUkixw=="
    },
    "growl": {
      "version": "1.10.5",
      "resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
      "integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==",
      "dev": true
    },
    "growly": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/growly/-/growly-1.3.0.tgz",
      "integrity": "sha1-8QdIy+dq+WS3yWyTxrzCivEgwIE=",
      "dev": true,
      "optional": true
    },
    "handle-thing": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/handle-thing/-/handle-thing-2.0.1.tgz",
      "integrity": "sha512-9Qn4yBxelxoh2Ow62nP+Ka/kMnOXRi8BXnRaUwezLNhqelnN49xKz4F/dPP8OYLxLxq6JDtZb2i9XznUQbNPTg==",
      "dev": true
    },
    "har-schema": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/har-schema/-/har-schema-2.0.0.tgz",
      "integrity": "sha1-qUwiJOvKwEeCoNkDVSHyRzW37JI=",
      "dev": true
    },
    "har-validator": {
      "version": "5.1.3",
      "resolved": "https://registry.npmjs.org/har-validator/-/har-validator-5.1.3.tgz",
      "integrity": "sha512-sNvOCzEQNr/qrvJgc3UG/kD4QtlHycrzwS+6mfTrrSq97BvaYcPZZI1ZSqGSPR73Cxn4LKTD4PttRwfU7jWq5g==",
      "dev": true,
      "requires": {
        "ajv": "^6.5.5",
        "har-schema": "^2.0.0"
      }
    },
    "has": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
      "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
      "dev": true,
      "requires": {
        "function-bind": "^1.1.1"
      }
    },
    "has-ansi": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz",
      "integrity": "sha1-NPUEnOHs3ysGSa8+8k5F7TVBbZE=",
      "requires": {
        "ansi-regex": "^2.0.0"
      }
    },
    "has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0="
    },
    "has-symbols": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.1.tgz",
      "integrity": "sha512-PLcsoqu++dmEIZB+6totNFKq/7Do+Z0u4oT0zKOJNl3lYK6vGwwu2hjHs+68OEZbTjiUE9bgOABXbP/GvrS0Kg=="
    },
    "has-value": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/has-value/-/has-value-1.0.0.tgz",
      "integrity": "sha1-GLKB2lhbHFxR3vJMkw7SmgvmsXc=",
      "requires": {
        "get-value": "^2.0.6",
        "has-values": "^1.0.0",
        "isobject": "^3.0.0"
      }
    },
    "has-values": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/has-values/-/has-values-1.0.0.tgz",
      "integrity": "sha1-lbC2P+whRmGab+V/51Yo1aOe/k8=",
      "requires": {
        "is-number": "^3.0.0",
        "kind-of": "^4.0.0"
      },
      "dependencies": {
        "kind-of": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-4.0.0.tgz",
          "integrity": "sha1-IIE989cSkosgc3hpGkUGb65y3Vc=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "hash-base": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/hash-base/-/hash-base-3.1.0.tgz",
      "integrity": "sha512-1nmYp/rhMDiE7AYkDw+lLwlAzz0AntGIe51F3RfFfEqyQ3feY2eI/NcwC6umIQVOASPMsWJLJScWKSSvzL9IVA==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.4",
        "readable-stream": "^3.6.0",
        "safe-buffer": "^5.2.0"
      },
      "dependencies": {
        "readable-stream": {
          "version": "3.6.0",
          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
          "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
          "dev": true,
          "requires": {
            "inherits": "^2.0.3",
            "string_decoder": "^1.1.1",
            "util-deprecate": "^1.0.1"
          }
        }
      }
    },
    "hash.js": {
      "version": "1.1.7",
      "resolved": "https://registry.npmjs.org/hash.js/-/hash.js-1.1.7.tgz",
      "integrity": "sha512-taOaskGt4z4SOANNseOviYDvjEJinIkRgmp7LbKP2YTTmVxWBl87s/uzK9r+44BclBSp2X7K1hqeNfz9JbBeXA==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.3",
        "minimalistic-assert": "^1.0.1"
      }
    },
    "he": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
      "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
      "dev": true
    },
    "hex-color-regex": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/hex-color-regex/-/hex-color-regex-1.1.0.tgz",
      "integrity": "sha512-l9sfDFsuqtOqKDsQdqrMRk0U85RZc0RtOR9yPI7mRVOa4FsR/BVnZ0shmQRM96Ji99kYZP/7hn1cedc1+ApsTQ==",
      "dev": true
    },
    "hmac-drbg": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/hmac-drbg/-/hmac-drbg-1.0.1.tgz",
      "integrity": "sha1-0nRXAQJabHdabFRXk+1QL8DGSaE=",
      "dev": true,
      "requires": {
        "hash.js": "^1.0.3",
        "minimalistic-assert": "^1.0.0",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    },
    "hosted-git-info": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-3.0.5.tgz",
      "integrity": "sha512-i4dpK6xj9BIpVOTboXIlKG9+8HMKggcrMX7WA24xZtKwX0TPelq/rbaS5rCKeNX8sJXZJGdSxpnEGtta+wismQ==",
      "dev": true,
      "requires": {
        "lru-cache": "^6.0.0"
      },
      "dependencies": {
        "lru-cache": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
          "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
          "dev": true,
          "requires": {
            "yallist": "^4.0.0"
          }
        }
      }
    },
    "hpack.js": {
      "version": "2.1.6",
      "resolved": "https://registry.npmjs.org/hpack.js/-/hpack.js-2.1.6.tgz",
      "integrity": "sha1-h3dMCUnlE/QuhFdbPEVoH63ioLI=",
      "dev": true,
      "requires": {
        "inherits": "^2.0.1",
        "obuf": "^1.0.0",
        "readable-stream": "^2.0.1",
        "wbuf": "^1.1.0"
      }
    },
    "hsl-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/hsl-regex/-/hsl-regex-1.0.0.tgz",
      "integrity": "sha1-1JMwx4ntgZ4nakwNJy3/owsY/m4=",
      "dev": true
    },
    "hsla-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/hsla-regex/-/hsla-regex-1.0.0.tgz",
      "integrity": "sha1-wc56MWjIxmFAM6S194d/OyJfnDg=",
      "dev": true
    },
    "html-comment-regex": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/html-comment-regex/-/html-comment-regex-1.1.2.tgz",
      "integrity": "sha512-P+M65QY2JQ5Y0G9KKdlDpo0zK+/OHptU5AaBwUfAIDJZk1MYf32Frm84EcOytfJE0t5JvkAnKlmjsXDnWzCJmQ==",
      "dev": true
    },
    "html-encoding-sniffer": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-1.0.2.tgz",
      "integrity": "sha512-71lZziiDnsuabfdYiUeWdCVyKuqwWi23L8YeIgV9jSSZHCtb6wB1BKWooH7L3tn4/FuZJMVWyNaIDr4RGmaSYw==",
      "dev": true,
      "requires": {
        "whatwg-encoding": "^1.0.1"
      }
    },
    "html-entities": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/html-entities/-/html-entities-1.3.1.tgz",
      "integrity": "sha512-rhE/4Z3hIhzHAUKbW8jVcCyuT5oJCXXqhN/6mXXVCpzTmvJnoH2HL/bt3EZ6p55jbFJBeAe1ZNpL5BugLujxNA==",
      "dev": true
    },
    "html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true
    },
    "http-cache-semantics": {
      "version": "3.8.1",
      "resolved": "https://registry.npmjs.org/http-cache-semantics/-/http-cache-semantics-3.8.1.tgz",
      "integrity": "sha512-5ai2iksyV8ZXmnZhHH4rWPoxxistEexSi5936zIQ1bnNTW5VnA85B6P/VpXiRM017IgRvb2kKo1a//y+0wSp3w==",
      "dev": true
    },
    "http-deceiver": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/http-deceiver/-/http-deceiver-1.2.7.tgz",
      "integrity": "sha1-+nFolEq5pRnTN8sL7HKE3D5yPYc=",
      "dev": true
    },
    "http-errors": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.7.2.tgz",
      "integrity": "sha512-uUQBt3H/cSIVfch6i1EuPNy/YsRSOUBXTVfZ+yR7Zjez3qjBz6i9+i4zjNaoqcoFVI4lQJ5plg63TvGfRSDCRg==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.3",
        "setprototypeof": "1.1.1",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.0"
      },
      "dependencies": {
        "inherits": {
          "version": "2.0.3",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
          "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4="
        }
      }
    },
    "http-parser-js": {
      "version": "0.4.10",
      "resolved": "https://registry.npmjs.org/http-parser-js/-/http-parser-js-0.4.10.tgz",
      "integrity": "sha1-ksnBN0w1CF912zWexWzCV8u5P6Q=",
      "dev": true
    },
    "http-proxy": {
      "version": "1.18.1",
      "resolved": "https://registry.npmjs.org/http-proxy/-/http-proxy-1.18.1.tgz",
      "integrity": "sha512-7mz/721AbnJwIVbnaSv1Cz3Am0ZLT/UBwkC92VlxhXv/k/BBQfM2fXElQNC27BVGr0uwUpplYPQM9LnaBMR5NQ==",
      "dev": true,
      "requires": {
        "eventemitter3": "^4.0.0",
        "follow-redirects": "^1.0.0",
        "requires-port": "^1.0.0"
      }
    },
    "http-proxy-agent": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-2.1.0.tgz",
      "integrity": "sha512-qwHbBLV7WviBl0rQsOzH6o5lwyOIvwp/BdFnvVxXORldu5TmjFfjzBcWUWS5kWAZhmv+JtiDhSuQCp4sBfbIgg==",
      "dev": true,
      "requires": {
        "agent-base": "4",
        "debug": "3.1.0"
      },
      "dependencies": {
        "debug": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.1.0.tgz",
          "integrity": "sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        }
      }
    },
    "http-proxy-middleware": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/http-proxy-middleware/-/http-proxy-middleware-0.19.1.tgz",
      "integrity": "sha512-yHYTgWMQO8VvwNS22eLLloAkvungsKdKTLO8AJlftYIKNfJr3GK3zK0ZCfzDDGUBttdGc8xFy1mCitvNKQtC3Q==",
      "dev": true,
      "requires": {
        "http-proxy": "^1.17.0",
        "is-glob": "^4.0.0",
        "lodash": "^4.17.11",
        "micromatch": "^3.1.10"
      }
    },
    "http-signature": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/http-signature/-/http-signature-1.2.0.tgz",
      "integrity": "sha1-muzZJRFHcvPZW2WmCruPfBj7rOE=",
      "dev": true,
      "requires": {
        "assert-plus": "^1.0.0",
        "jsprim": "^1.2.2",
        "sshpk": "^1.7.0"
      }
    },
    "https-browserify": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/https-browserify/-/https-browserify-1.0.0.tgz",
      "integrity": "sha1-7AbBDgo0wPL68Zn3/X/Hj//QPHM=",
      "dev": true
    },
    "https-proxy-agent": {
      "version": "2.2.4",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-2.2.4.tgz",
      "integrity": "sha512-OmvfoQ53WLjtA9HeYP9RNrWMJzzAz1JGaSFr1nijg0PVR1JaD/xbJq1mdEIIlxGpXp9eSe/O2LgU9DJmTPd0Eg==",
      "dev": true,
      "requires": {
        "agent-base": "^4.3.0",
        "debug": "^3.1.0"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        }
      }
    },
    "human-signals": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-1.1.1.tgz",
      "integrity": "sha512-SEQu7vl8KjNL2eoGBLF3+wAjpsNfA9XMlXAYj/3EdaNfAlxKthD1xjEQfGOUhllCGGJVNY34bRr6lPINhNjyZw==",
      "dev": true
    },
    "humanize-ms": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/humanize-ms/-/humanize-ms-1.2.1.tgz",
      "integrity": "sha1-xG4xWaKT9riW2ikxbYtv6Lt5u+0=",
      "dev": true,
      "requires": {
        "ms": "^2.0.0"
      }
    },
    "iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "requires": {
        "safer-buffer": ">= 2.1.2 < 3"
      }
    },
    "icss-utils": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/icss-utils/-/icss-utils-4.1.1.tgz",
      "integrity": "sha512-4aFq7wvWyMHKgxsH8QQtGpvbASCf+eM3wPRLI6R+MgAnTCZ6STYsRvttLvRWK0Nfif5piF394St3HeJDaljGPA==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.14"
      }
    },
    "ieee754": {
      "version": "1.1.13",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.1.13.tgz",
      "integrity": "sha512-4vf7I2LYV/HaWerSo3XmlMkp5eZ83i+/CDluXi/IGTs/O1sejBNhTtnxzmRZfvOUqj7lZjqHkeTvpgSFDlWZTg==",
      "dev": true
    },
    "iferr": {
      "version": "0.1.5",
      "resolved": "https://registry.npmjs.org/iferr/-/iferr-0.1.5.tgz",
      "integrity": "sha1-xg7taebY/bazEEofy8ocGS3FtQE=",
      "dev": true
    },
    "ignore": {
      "version": "3.3.10",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-3.3.10.tgz",
      "integrity": "sha512-Pgs951kaMm5GXP7MOvxERINe3gsaVjUWFm+UZPSq9xYriQAksyhg0csnS0KXSNRD5NmNdapXEpjxG49+AKh/ug==",
      "dev": true
    },
    "ignore-walk": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/ignore-walk/-/ignore-walk-3.0.3.tgz",
      "integrity": "sha512-m7o6xuOaT1aqheYHKf8W6J5pYH85ZI9w077erOzLje3JsB1gkafkAhHHY19dqjulgIZHFm32Cp5uNZgcQqdJKw==",
      "dev": true,
      "requires": {
        "minimatch": "^3.0.4"
      }
    },
    "image-size": {
      "version": "0.5.5",
      "resolved": "https://registry.npmjs.org/image-size/-/image-size-0.5.5.tgz",
      "integrity": "sha1-Cd/Uq50g4p6xw+gLiZA3jfnjy5w=",
      "dev": true,
      "optional": true
    },
    "immediate": {
      "version": "3.0.6",
      "resolved": "https://registry.npmjs.org/immediate/-/immediate-3.0.6.tgz",
      "integrity": "sha1-nbHb0Pr43m++D13V5Wu2BigN5ps=",
      "dev": true
    },
    "import-cwd": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/import-cwd/-/import-cwd-2.1.0.tgz",
      "integrity": "sha1-qmzzbnInYShcs3HsZRn1PiQ1sKk=",
      "dev": true,
      "requires": {
        "import-from": "^2.1.0"
      }
    },
    "import-fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-2.0.0.tgz",
      "integrity": "sha1-2BNVwVYS04bGH53dOSLUMEgipUY=",
      "dev": true,
      "requires": {
        "caller-path": "^2.0.0",
        "resolve-from": "^3.0.0"
      }
    },
    "import-from": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/import-from/-/import-from-2.1.0.tgz",
      "integrity": "sha1-M1238qev/VOqpHHUuAId7ja387E=",
      "dev": true,
      "requires": {
        "resolve-from": "^3.0.0"
      }
    },
    "import-local": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/import-local/-/import-local-2.0.0.tgz",
      "integrity": "sha512-b6s04m3O+s3CGSbqDIyP4R6aAwAeYlVq9+WUWep6iHa8ETRf9yei1U48C5MmfJmV9AiLYYBKPMq/W+/WRpQmCQ==",
      "dev": true,
      "requires": {
        "pkg-dir": "^3.0.0",
        "resolve-cwd": "^2.0.0"
      }
    },
    "imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o="
    },
    "indent-string": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
      "dev": true
    },
    "indexes-of": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/indexes-of/-/indexes-of-1.0.1.tgz",
      "integrity": "sha1-8w9xbI4r00bHtn0985FVZqfAVgc=",
      "dev": true
    },
    "infer-owner": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/infer-owner/-/infer-owner-1.0.4.tgz",
      "integrity": "sha512-IClj+Xz94+d7irH5qRyfJonOdfTzuDaifE6ZPWfx0N0+/ATZCbuTPq2prFl526urkQd90WyUKIh1DfBQ2hMz9A==",
      "dev": true
    },
    "inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
      "dev": true,
      "requires": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "ini": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/ini/-/ini-1.3.5.tgz",
      "integrity": "sha512-RZY5huIKCMRWDUqZlEi72f/lmXKMvuszcMBduliQ3nnWbx9X/ZBQO7DijMEYS9EhHBb2qacRUMtC7svLwe0lcw==",
      "dev": true
    },
    "inquirer": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/inquirer/-/inquirer-7.1.0.tgz",
      "integrity": "sha512-5fJMWEmikSYu0nv/flMc475MhGbB7TSPd/2IpFV4I4rMklboCH2rQjYY5kKiYGHqUF9gvaambupcJFFG9dvReg==",
      "dev": true,
      "requires": {
        "ansi-escapes": "^4.2.1",
        "chalk": "^3.0.0",
        "cli-cursor": "^3.1.0",
        "cli-width": "^2.0.0",
        "external-editor": "^3.0.3",
        "figures": "^3.0.0",
        "lodash": "^4.17.15",
        "mute-stream": "0.0.8",
        "run-async": "^2.4.0",
        "rxjs": "^6.5.3",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0",
        "through": "^2.3.6"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "internal-ip": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/internal-ip/-/internal-ip-4.3.0.tgz",
      "integrity": "sha512-S1zBo1D6zcsyuC6PMmY5+55YMILQ9av8lotMx447Bq6SAgo/sDK6y6uUKmuYhW7eacnIhFfsPmCNYdDzsnnDCg==",
      "dev": true,
      "requires": {
        "default-gateway": "^4.2.0",
        "ipaddr.js": "^1.9.0"
      }
    },
    "invariant": {
      "version": "2.2.4",
      "resolved": "https://registry.npmjs.org/invariant/-/invariant-2.2.4.tgz",
      "integrity": "sha512-phJfQVBuaJM5raOpJjSfkiD6BpbCE4Ns//LaXl6wGYtUBY83nWS6Rf9tXm2e8VaK60JEjYldbPif/A2B1C2gNA==",
      "requires": {
        "loose-envify": "^1.0.0"
      }
    },
    "invert-kv": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/invert-kv/-/invert-kv-2.0.0.tgz",
      "integrity": "sha512-wPVv/y/QQ/Uiirj/vh3oP+1Ww+AWehmi1g5fFWGPF6IpCBCDVrhgHRMvrLfdYcwDh3QJbGXDW4JAuzxElLSqKA==",
      "dev": true
    },
    "ip": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/ip/-/ip-1.1.5.tgz",
      "integrity": "sha1-vd7XARQpCCjAoDnnLvJfWq7ENUo=",
      "dev": true
    },
    "ip-regex": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/ip-regex/-/ip-regex-2.1.0.tgz",
      "integrity": "sha1-+ni/XS5pE8kRzp+BnuUUa7bYROk=",
      "dev": true
    },
    "ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g=="
    },
    "is-absolute-url": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-absolute-url/-/is-absolute-url-2.1.0.tgz",
      "integrity": "sha1-UFMN+4T8yap9vnhS6Do3uTufKqY=",
      "dev": true
    },
    "is-accessor-descriptor": {
      "version": "0.1.6",
      "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-0.1.6.tgz",
      "integrity": "sha1-qeEss66Nh2cn7u84Q/igiXtcmNY=",
      "requires": {
        "kind-of": "^3.0.2"
      },
      "dependencies": {
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "is-arguments": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/is-arguments/-/is-arguments-1.0.4.tgz",
      "integrity": "sha512-xPh0Rmt8NE65sNzvyUmWgI1tz3mKq74lGA0mL8LYZcoIzKOzDh6HmrYm3d18k60nHerC8A9Km8kYu87zfSFnLA==",
      "dev": true
    },
    "is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha1-d8mYQFJ6qOyxqLppe4BkWnqSap0=",
      "dev": true
    },
    "is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "requires": {
        "binary-extensions": "^2.0.0"
      }
    },
    "is-buffer": {
      "version": "1.1.6",
      "resolved": "https://registry.npmjs.org/is-buffer/-/is-buffer-1.1.6.tgz",
      "integrity": "sha512-NcdALwpXkTm5Zvvbk7owOUSvVvBKDgKP5/ewfXEznmQFfs4ZRmanOeKBTjRVjka3QFoN6XJ+9F3USqfHqTaU5w=="
    },
    "is-callable": {
      "version": "1.1.5",
      "resolved": "https://registry.npmjs.org/is-callable/-/is-callable-1.1.5.tgz",
      "integrity": "sha512-ESKv5sMCJB2jnHTWZ3O5itG+O128Hsus4K4Qh1h2/cgn2vbgnLSVqfV46AeJA9D5EeeLa9w81KUXMtn34zhX+Q==",
      "dev": true
    },
    "is-ci": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-ci/-/is-ci-2.0.0.tgz",
      "integrity": "sha512-YfJT7rkpQB0updsdHLGWrvhBJfcfzNNawYDNIyQXJz0IViGf75O8EBPKSdvw2rF+LGCsX4FZ8tcr3b19LcZq4w==",
      "dev": true,
      "requires": {
        "ci-info": "^2.0.0"
      }
    },
    "is-color-stop": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-color-stop/-/is-color-stop-1.1.0.tgz",
      "integrity": "sha1-z/9HGu5N1cnhWFmPvhKWe1za00U=",
      "dev": true,
      "requires": {
        "css-color-names": "^0.0.4",
        "hex-color-regex": "^1.1.0",
        "hsl-regex": "^1.0.0",
        "hsla-regex": "^1.0.0",
        "rgb-regex": "^1.0.1",
        "rgba-regex": "^1.0.0"
      }
    },
    "is-data-descriptor": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-0.1.4.tgz",
      "integrity": "sha1-C17mSDiOLIYCgueT8YVv7D8wG1Y=",
      "requires": {
        "kind-of": "^3.0.2"
      },
      "dependencies": {
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "is-date-object": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.2.tgz",
      "integrity": "sha512-USlDT524woQ08aoZFzh3/Z6ch9Y/EWXEHQ/AaRN0SkKq4t2Jw2R2339tSXmwuVoY7LLlBCbOIlx2myP/L5zk0g==",
      "dev": true
    },
    "is-descriptor": {
      "version": "0.1.6",
      "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-0.1.6.tgz",
      "integrity": "sha512-avDYr0SB3DwO9zsMov0gKCESFYqCnE4hq/4z3TdUlukEy5t9C0YRq7HLrsN52NAcqXKaepeCD0n+B0arnVG3Hg==",
      "requires": {
        "is-accessor-descriptor": "^0.1.6",
        "is-data-descriptor": "^0.1.4",
        "kind-of": "^5.0.0"
      },
      "dependencies": {
        "kind-of": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-5.1.0.tgz",
          "integrity": "sha512-NGEErnH6F2vUuXDh+OlbcKW7/wOcfdRHaZ7VWtqCztfHri/++YKmP51OdWeGPuqCOba6kk2OTe5d02VmTB80Pw=="
        }
      }
    },
    "is-directory": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/is-directory/-/is-directory-0.3.1.tgz",
      "integrity": "sha1-YTObbyR1/Hcv2cnYP1yFddwVSuE=",
      "dev": true
    },
    "is-docker": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-docker/-/is-docker-2.0.0.tgz",
      "integrity": "sha512-pJEdRugimx4fBMra5z2/5iRdZ63OhYV0vr0Dwm5+xtW4D1FvRkB8hamMIhnWfyJeDdyr/aa7BDyNbtG38VxgoQ==",
      "dev": true
    },
    "is-extendable": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-0.1.1.tgz",
      "integrity": "sha1-YrEQ4omkcUGOPsNqYX1HLjAd/Ik="
    },
    "is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI="
    },
    "is-fullwidth-code-point": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-2.0.0.tgz",
      "integrity": "sha1-o7MKXE8ZkYMWeqq5O+764937ZU8=",
      "dev": true
    },
    "is-generator-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-generator-fn/-/is-generator-fn-2.1.0.tgz",
      "integrity": "sha512-cTIB4yPYL/Grw0EaSzASzg6bBy9gqCofvWN8okThAYIxKJZC+udlRAmGbM0XLeniEJSs8uEgHPGuHSe1XsOLSQ==",
      "dev": true
    },
    "is-glob": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz",
      "integrity": "sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==",
      "requires": {
        "is-extglob": "^2.1.1"
      }
    },
    "is-installed-globally": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/is-installed-globally/-/is-installed-globally-0.3.2.tgz",
      "integrity": "sha512-wZ8x1js7Ia0kecP/CHM/3ABkAmujX7WPvQk6uu3Fly/Mk44pySulQpnHG46OMjHGXApINnV4QhY3SWnECO2z5g==",
      "dev": true,
      "requires": {
        "global-dirs": "^2.0.1",
        "is-path-inside": "^3.0.1"
      },
      "dependencies": {
        "is-path-inside": {
          "version": "3.0.3",
          "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
          "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
          "dev": true
        }
      }
    },
    "is-interactive": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-interactive/-/is-interactive-1.0.0.tgz",
      "integrity": "sha512-2HvIEKRoqS62guEC+qBjpvRubdX910WCMuJTZ+I9yvqKU2/12eSL549HMwtabb4oupdj2sMP50k+XJfB/8JE6w=="
    },
    "is-number": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-3.0.0.tgz",
      "integrity": "sha1-JP1iAaR4LPUFYcgQJ2r8fRLXEZU=",
      "requires": {
        "kind-of": "^3.0.2"
      },
      "dependencies": {
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "is-obj": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/is-obj/-/is-obj-2.0.0.tgz",
      "integrity": "sha512-drqDG3cbczxxEJRoOXcOjtdp1J/lyp1mNn0xaznRs8+muBhgQcrnbspox5X5fOw0HnMnbfDzvnEMEtqDEJEo8w==",
      "dev": true
    },
    "is-observable": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-observable/-/is-observable-1.1.0.tgz",
      "integrity": "sha512-NqCa4Sa2d+u7BWc6CukaObG3Fh+CU9bvixbpcXYhy2VvYS7vVGIdAgnIS5Ks3A/cqk4rebLJ9s8zBstT2aKnIA==",
      "dev": true,
      "requires": {
        "symbol-observable": "^1.1.0"
      }
    },
    "is-path-cwd": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/is-path-cwd/-/is-path-cwd-2.2.0.tgz",
      "integrity": "sha512-w942bTcih8fdJPJmQHFzkS76NEP8Kzzvmw92cXsazb8intwLqPibPPdXf4ANdKV3rYMuuQYGIWtvz9JilB3NFQ==",
      "dev": true
    },
    "is-path-in-cwd": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-path-in-cwd/-/is-path-in-cwd-2.1.0.tgz",
      "integrity": "sha512-rNocXHgipO+rvnP6dk3zI20RpOtrAM/kzbB258Uw5BWr3TpXi861yzjo16Dn4hUox07iw5AyeMLHWsujkjzvRQ==",
      "dev": true,
      "requires": {
        "is-path-inside": "^2.1.0"
      }
    },
    "is-path-inside": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-2.1.0.tgz",
      "integrity": "sha512-wiyhTzfDWsvwAW53OBWF5zuvaOGlZ6PwYxAbPVDhpm+gM09xKQGjBq/8uYN12aDvMxnAnq3dxTyoSoRNmg5YFg==",
      "dev": true,
      "requires": {
        "path-is-inside": "^1.0.2"
      }
    },
    "is-plain-obj": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-1.1.0.tgz",
      "integrity": "sha1-caUMhCnfync8kqOQpKA7OfzVHT4=",
      "dev": true
    },
    "is-plain-object": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/is-plain-object/-/is-plain-object-2.0.4.tgz",
      "integrity": "sha512-h5PpgXkWitc38BBMYawTYMWJHFZJVnBquFE57xFpjB8pJFiF6gZ+bU+WyI/yqXiFR5mdLsgYNaPe8uao6Uv9Og==",
      "requires": {
        "isobject": "^3.0.1"
      }
    },
    "is-promise": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-2.2.2.tgz",
      "integrity": "sha512-+lP4/6lKUBfQjZ2pdxThZvLUAafmZb8OAxFb8XXtiQmS35INgr85hdOGoEs124ez1FCnZJt6jau/T+alh58QFQ=="
    },
    "is-regex": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/is-regex/-/is-regex-1.0.5.tgz",
      "integrity": "sha512-vlKW17SNq44owv5AQR3Cq0bQPEb8+kF3UKZ2fiZNOWtztYE5i0CzCZxFDwO58qAOWtxdBRVO/V5Qin1wjCqFYQ==",
      "dev": true,
      "requires": {
        "has": "^1.0.3"
      }
    },
    "is-resolvable": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-resolvable/-/is-resolvable-1.1.0.tgz",
      "integrity": "sha512-qgDYXFSR5WvEfuS5dMj6oTMEbrrSaM0CrFk2Yiq/gXnBvD9pMa2jGXxyhGLfvhZpuMZe18CJpFxAt3CRs42NMg==",
      "dev": true
    },
    "is-stream": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz",
      "integrity": "sha1-EtSj3U5o4Lec6428hBc66A2RykQ=",
      "dev": true
    },
    "is-svg": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-svg/-/is-svg-3.0.0.tgz",
      "integrity": "sha512-gi4iHK53LR2ujhLVVj+37Ykh9GLqYHX6JOVXbLAucaG/Cqw9xwdFOjDM2qeifLs1sF1npXXFvDu0r5HNgCMrzQ==",
      "dev": true,
      "requires": {
        "html-comment-regex": "^1.1.0"
      }
    },
    "is-symbol": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.3.tgz",
      "integrity": "sha512-OwijhaRSgqvhm/0ZdAcXNZt9lYdKFpcRDT5ULUuYXPoT794UNOdU+gpT6Rzo7b4V2HUl/op6GqY894AZwv9faQ==",
      "dev": true,
      "requires": {
        "has-symbols": "^1.0.1"
      }
    },
    "is-typedarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/is-typedarray/-/is-typedarray-1.0.0.tgz",
      "integrity": "sha1-5HnICFjfDBsR3dppQPlgEfzaSpo=",
      "dev": true
    },
    "is-unicode-supported": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
      "dev": true
    },
    "is-windows": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/is-windows/-/is-windows-1.0.2.tgz",
      "integrity": "sha512-eXK1UInq2bPmjyX6e3VHIzMLobc4J94i4AWn+Hpq3OU5KkrRC96OAcR3PRJ/pGu6m8TRnBHP9dkXQVsT/COVIA=="
    },
    "is-wsl": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-2.2.0.tgz",
      "integrity": "sha512-fKzAra0rGJUUBwGBgNkHZuToZcn+TtXHpeCgmkMJMMYx1sQDYaCSyjJBSCa2nH1DGm7s3n1oBnohoVTBaN7Lww==",
      "dev": true,
      "requires": {
        "is-docker": "^2.0.0"
      }
    },
    "isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha1-u5NdSFgsuhaMBoNJV6VKPgcSTxE="
    },
    "isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
      "dev": true
    },
    "isobject": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/isobject/-/isobject-3.0.1.tgz",
      "integrity": "sha1-TkMekrEalzFjaqH5yNHMvP2reN8="
    },
    "isstream": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/isstream/-/isstream-0.1.2.tgz",
      "integrity": "sha1-R+Y/evVa+m+S4VAOaQ64uFKcCZo=",
      "dev": true
    },
    "istanbul-lib-coverage": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.0.0.tgz",
      "integrity": "sha512-UiUIqxMgRDET6eR+o5HbfRYP1l0hqkWOs7vNxC/mggutCMUIhWMm8gAHb8tHlyfD3/l6rlgNA5cKdDzEAf6hEg==",
      "dev": true
    },
    "istanbul-lib-instrument": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-instrument/-/istanbul-lib-instrument-4.0.1.tgz",
      "integrity": "sha512-imIchxnodll7pvQBYOqUu88EufLCU56LMeFPZZM/fJZ1irYcYdqroaV+ACK1Ila8ls09iEYArp+nqyC6lW1Vfg==",
      "dev": true,
      "requires": {
        "@babel/core": "^7.7.5",
        "@babel/parser": "^7.7.5",
        "@babel/template": "^7.7.4",
        "@babel/traverse": "^7.7.4",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-coverage": "^3.0.0",
        "semver": "^6.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "istanbul-lib-report": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.0.tgz",
      "integrity": "sha512-wcdi+uAKzfiGT2abPpKZ0hSU1rGQjUQnLvtY5MpQ7QCTahD3VODhcu4wcfY1YtkGaDD5yuydOLINXsfbus9ROw==",
      "dev": true,
      "requires": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^3.0.0",
        "supports-color": "^7.1.0"
      }
    },
    "istanbul-lib-source-maps": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-4.0.0.tgz",
      "integrity": "sha512-c16LpFRkR8vQXyHZ5nLpY35JZtzj1PQY1iZmesUbf1FZHbIupcWfjgOXBY9YHkLEQ6puz1u4Dgj6qmU/DisrZg==",
      "dev": true,
      "requires": {
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0",
        "source-map": "^0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "istanbul-reports": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.0.2.tgz",
      "integrity": "sha512-9tZvz7AiR3PEDNGiV9vIouQ/EAcqMXFmkcA1CDFTwOB98OZVDL0PH9glHotf5Ugp6GCOTypfzGWI/OqjWNCRUw==",
      "dev": true,
      "requires": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      }
    },
    "iterare": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/iterare/-/iterare-1.2.1.tgz",
      "integrity": "sha512-RKYVTCjAnRthyJes037NX/IiqeidgN1xc3j1RjFfECFp28A1GVwK9nA+i0rJPaHqSZwygLzRnFlzUuHFoWWy+Q=="
    },
    "jasmine": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/jasmine/-/jasmine-2.8.0.tgz",
      "integrity": "sha1-awicChFXax8W3xG4AUbZHU6Lij4=",
      "dev": true,
      "requires": {
        "exit": "^0.1.2",
        "glob": "^7.0.6",
        "jasmine-core": "~2.8.0"
      }
    },
    "jasmine-core": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/jasmine-core/-/jasmine-core-2.8.0.tgz",
      "integrity": "sha1-vMl5rh+f0FcB5F5S5l06XWPxok4=",
      "dev": true
    },
    "jasmine-marbles": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/jasmine-marbles/-/jasmine-marbles-0.6.0.tgz",
      "integrity": "sha512-1uzgjEesEeCb+r+v46qn5x326TiGqk5SUZa+A3O+XnMCjG/pGcUOhL9Xsg5L7gLC6RFHyWGTkB5fei4rcvIOiQ==",
      "requires": {
        "lodash": "^4.5.0"
      }
    },
    "jasminewd2": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/jasminewd2/-/jasminewd2-2.2.0.tgz",
      "integrity": "sha1-43zwsX8ZnM4jvqcbIDk5Uka07E4=",
      "dev": true
    },
    "jest": {
      "version": "25.2.3",
      "resolved": "https://registry.npmjs.org/jest/-/jest-25.2.3.tgz",
      "integrity": "sha512-UbUmyGeZt0/sCIj/zsWOY0qFfQsx2qEFIZp0iEj8yVH6qASfR22fJOf12gFuSPsdSufam+llZBB0MdXWCg6EEQ==",
      "dev": true,
      "requires": {
        "@jest/core": "^25.2.3",
        "import-local": "^3.0.2",
        "jest-cli": "^25.2.3"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "dev": true,
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "cliui": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-6.0.0.tgz",
          "integrity": "sha512-t6wbgtoCXvAzst7QgXxJYqPt0usEfbgQdftEPbLL/cvv6HPE5VgvqCuAIDR0NgU52ds6rFwqrgakNLrHEjCbrQ==",
          "dev": true,
          "requires": {
            "string-width": "^4.2.0",
            "strip-ansi": "^6.0.0",
            "wrap-ansi": "^6.2.0"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        },
        "get-caller-file": {
          "version": "2.0.5",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
          "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
          "dev": true
        },
        "import-local": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/import-local/-/import-local-3.0.2.tgz",
          "integrity": "sha512-vjL3+w0oulAVZ0hBHnxa/Nm5TAurf9YLQJDhqRZyqb+VKGOB6LU8t9H1Nr5CIo16vh9XfJTOoHwU0B71S557gA==",
          "dev": true,
          "requires": {
            "pkg-dir": "^4.2.0",
            "resolve-cwd": "^3.0.0"
          }
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "jest-cli": {
          "version": "25.5.4",
          "resolved": "https://registry.npmjs.org/jest-cli/-/jest-cli-25.5.4.tgz",
          "integrity": "sha512-rG8uJkIiOUpnREh1768/N3n27Cm+xPFkSNFO91tgg+8o2rXeVLStz+vkXkGr4UtzH6t1SNbjwoiswd7p4AhHTw==",
          "dev": true,
          "requires": {
            "@jest/core": "^25.5.4",
            "@jest/test-result": "^25.5.0",
            "@jest/types": "^25.5.0",
            "chalk": "^3.0.0",
            "exit": "^0.1.2",
            "graceful-fs": "^4.2.4",
            "import-local": "^3.0.2",
            "is-ci": "^2.0.0",
            "jest-config": "^25.5.4",
            "jest-util": "^25.5.0",
            "jest-validate": "^25.5.0",
            "prompts": "^2.0.1",
            "realpath-native": "^2.0.0",
            "yargs": "^15.3.1"
          }
        },
        "pkg-dir": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
          "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
          "dev": true,
          "requires": {
            "find-up": "^4.0.0"
          }
        },
        "require-main-filename": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
          "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
          "dev": true
        },
        "resolve-cwd": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-3.0.0.tgz",
          "integrity": "sha512-OrZaX2Mb+rJCpH/6CpSqt9xFVpN++x01XnN2ie9g6P5/3xelLAkXWVADpdz1IHD/KFfEXyE6V0U01OQ3UO2rEg==",
          "dev": true,
          "requires": {
            "resolve-from": "^5.0.0"
          }
        },
        "resolve-from": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
          "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        },
        "wrap-ansi": {
          "version": "6.2.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
          "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
          "dev": true,
          "requires": {
            "ansi-styles": "^4.0.0",
            "string-width": "^4.1.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "yargs": {
          "version": "15.3.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-15.3.1.tgz",
          "integrity": "sha512-92O1HWEjw27sBfgmXiixJWT5hRBp2eobqXicLtPBIDBhYB+1HpwZlXmbW2luivBJHBzki+7VyCLRtAkScbTBQA==",
          "dev": true,
          "requires": {
            "cliui": "^6.0.0",
            "decamelize": "^1.2.0",
            "find-up": "^4.1.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^4.2.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^18.1.1"
          }
        },
        "yargs-parser": {
          "version": "18.1.3",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-18.1.3.tgz",
          "integrity": "sha512-o50j0JeToy/4K6OZcaQmW6lyXXKhq7csREXcDwk2omFPJEwUNOVtJKvmDr9EI1fAJZUyZcRF7kxGBWmRXudrCQ==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "jest-changed-files": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-changed-files/-/jest-changed-files-25.5.0.tgz",
      "integrity": "sha512-EOw9QEqapsDT7mKF162m8HFzRPbmP8qJQny6ldVOdOVBz3ACgPm/1nAn5fPQ/NDaYhX/AHkrGwwkCncpAVSXcw==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "execa": "^3.2.0",
        "throat": "^5.0.0"
      },
      "dependencies": {
        "cross-spawn": {
          "version": "7.0.2",
          "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.2.tgz",
          "integrity": "sha512-PD6G8QG3S4FK/XCGFbEQrDqO2AnMMsy0meR7lerlIOHAAbkuavGU/pOqprrlvfTNjvowivTeBsjebAL0NSoMxw==",
          "dev": true,
          "requires": {
            "path-key": "^3.1.0",
            "shebang-command": "^2.0.0",
            "which": "^2.0.1"
          }
        },
        "execa": {
          "version": "3.4.0",
          "resolved": "https://registry.npmjs.org/execa/-/execa-3.4.0.tgz",
          "integrity": "sha512-r9vdGQk4bmCuK1yKQu1KTwcT2zwfWdbdaXfCtAh+5nU/4fSX+JAb7vZGvI5naJrQlvONrEB20jeruESI69530g==",
          "dev": true,
          "requires": {
            "cross-spawn": "^7.0.0",
            "get-stream": "^5.0.0",
            "human-signals": "^1.1.1",
            "is-stream": "^2.0.0",
            "merge-stream": "^2.0.0",
            "npm-run-path": "^4.0.0",
            "onetime": "^5.1.0",
            "p-finally": "^2.0.0",
            "signal-exit": "^3.0.2",
            "strip-final-newline": "^2.0.0"
          }
        },
        "get-stream": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-5.1.0.tgz",
          "integrity": "sha512-EXr1FOzrzTfGeL0gQdeFEvOMm2mzMOglyiOXSTpPC+iAjAKftbr3jpCMWynogwYnM+eSj9sHGc6wjIcDvYiygw==",
          "dev": true,
          "requires": {
            "pump": "^3.0.0"
          }
        },
        "is-stream": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-2.0.0.tgz",
          "integrity": "sha512-XCoy+WlUr7d1+Z8GgSuXmpuUFC9fOhRXglJMx+dwLKTkL44Cjd4W1Z5P+BQZpr+cR93aGP4S/s7Ftw6Nd/kiEw==",
          "dev": true
        },
        "npm-run-path": {
          "version": "4.0.1",
          "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-4.0.1.tgz",
          "integrity": "sha512-S48WzZW777zhNIrn7gxOlISNAqi9ZC/uQFnRdbeIHhZhCA6UqpkOT8T1G7BvfdgP4Er8gF4sUbaS0i7QvIfCWw==",
          "dev": true,
          "requires": {
            "path-key": "^3.0.0"
          }
        },
        "p-finally": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/p-finally/-/p-finally-2.0.1.tgz",
          "integrity": "sha512-vpm09aKwq6H9phqRQzecoDpD8TmVyGw70qmWlyq5onxY7tqyTTFVvxMykxQSQKILBSFlbXpypIw2T1Ml7+DDtw==",
          "dev": true
        },
        "path-key": {
          "version": "3.1.1",
          "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
          "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
          "dev": true
        },
        "shebang-command": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
          "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
          "dev": true,
          "requires": {
            "shebang-regex": "^3.0.0"
          }
        },
        "shebang-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
          "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
          "dev": true
        },
        "which": {
          "version": "2.0.2",
          "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
          "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
          "dev": true,
          "requires": {
            "isexe": "^2.0.0"
          }
        }
      }
    },
    "jest-config": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/jest-config/-/jest-config-25.5.4.tgz",
      "integrity": "sha512-SZwR91SwcdK6bz7Gco8qL7YY2sx8tFJYzvg216DLihTWf+LKY/DoJXpM9nTzYakSyfblbqeU48p/p7Jzy05Atg==",
      "dev": true,
      "requires": {
        "@babel/core": "^7.1.0",
        "@jest/test-sequencer": "^25.5.4",
        "@jest/types": "^25.5.0",
        "babel-jest": "^25.5.1",
        "chalk": "^3.0.0",
        "deepmerge": "^4.2.2",
        "glob": "^7.1.1",
        "graceful-fs": "^4.2.4",
        "jest-environment-jsdom": "^25.5.0",
        "jest-environment-node": "^25.5.0",
        "jest-get-type": "^25.2.6",
        "jest-jasmine2": "^25.5.4",
        "jest-regex-util": "^25.2.6",
        "jest-resolve": "^25.5.1",
        "jest-util": "^25.5.0",
        "jest-validate": "^25.5.0",
        "micromatch": "^4.0.2",
        "pretty-format": "^25.5.0",
        "realpath-native": "^2.0.0"
      },
      "dependencies": {
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        }
      }
    },
    "jest-diff": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-diff/-/jest-diff-25.5.0.tgz",
      "integrity": "sha512-z1kygetuPiREYdNIumRpAHY6RXiGmp70YHptjdaxTWGmA085W3iCnXNx0DhflK3vwrKmrRWyY1wUpkPMVxMK7A==",
      "dev": true,
      "requires": {
        "chalk": "^3.0.0",
        "diff-sequences": "^25.2.6",
        "jest-get-type": "^25.2.6",
        "pretty-format": "^25.5.0"
      }
    },
    "jest-docblock": {
      "version": "25.3.0",
      "resolved": "https://registry.npmjs.org/jest-docblock/-/jest-docblock-25.3.0.tgz",
      "integrity": "sha512-aktF0kCar8+zxRHxQZwxMy70stc9R1mOmrLsT5VO3pIT0uzGRSDAXxSlz4NqQWpuLjPpuMhPRl7H+5FRsvIQAg==",
      "dev": true,
      "requires": {
        "detect-newline": "^3.0.0"
      }
    },
    "jest-each": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-each/-/jest-each-25.5.0.tgz",
      "integrity": "sha512-QBogUxna3D8vtiItvn54xXde7+vuzqRrEeaw8r1s+1TG9eZLVJE5ZkKoSUlqFwRjnlaA4hyKGiu9OlkFIuKnjA==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "jest-get-type": "^25.2.6",
        "jest-util": "^25.5.0",
        "pretty-format": "^25.5.0"
      }
    },
    "jest-environment-jsdom": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-environment-jsdom/-/jest-environment-jsdom-25.5.0.tgz",
      "integrity": "sha512-7Jr02ydaq4jaWMZLY+Skn8wL5nVIYpWvmeatOHL3tOcV3Zw8sjnPpx+ZdeBfc457p8jCR9J6YCc+Lga0oIy62A==",
      "dev": true,
      "requires": {
        "@jest/environment": "^25.5.0",
        "@jest/fake-timers": "^25.5.0",
        "@jest/types": "^25.5.0",
        "jest-mock": "^25.5.0",
        "jest-util": "^25.5.0",
        "jsdom": "^15.2.1"
      }
    },
    "jest-environment-node": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-environment-node/-/jest-environment-node-25.5.0.tgz",
      "integrity": "sha512-iuxK6rQR2En9EID+2k+IBs5fCFd919gVVK5BeND82fYeLWPqvRcFNPKu9+gxTwfB5XwBGBvZ0HFQa+cHtIoslA==",
      "dev": true,
      "requires": {
        "@jest/environment": "^25.5.0",
        "@jest/fake-timers": "^25.5.0",
        "@jest/types": "^25.5.0",
        "jest-mock": "^25.5.0",
        "jest-util": "^25.5.0",
        "semver": "^6.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "jest-get-type": {
      "version": "25.2.6",
      "resolved": "https://registry.npmjs.org/jest-get-type/-/jest-get-type-25.2.6.tgz",
      "integrity": "sha512-DxjtyzOHjObRM+sM1knti6or+eOgcGU4xVSb2HNP1TqO4ahsT+rqZg+nyqHWJSvWgKC5cG3QjGFBqxLghiF/Ig==",
      "dev": true
    },
    "jest-haste-map": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/jest-haste-map/-/jest-haste-map-25.5.1.tgz",
      "integrity": "sha512-dddgh9UZjV7SCDQUrQ+5t9yy8iEgKc1AKqZR9YDww8xsVOtzPQSMVLDChc21+g29oTRexb9/B0bIlZL+sWmvAQ==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "@types/graceful-fs": "^4.1.2",
        "anymatch": "^3.0.3",
        "fb-watchman": "^2.0.0",
        "fsevents": "^2.1.2",
        "graceful-fs": "^4.2.4",
        "jest-serializer": "^25.5.0",
        "jest-util": "^25.5.0",
        "jest-worker": "^25.5.0",
        "micromatch": "^4.0.2",
        "sane": "^4.0.3",
        "walker": "^1.0.7",
        "which": "^2.0.2"
      },
      "dependencies": {
        "jest-worker": {
          "version": "25.5.0",
          "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-25.5.0.tgz",
          "integrity": "sha512-/dsSmUkIy5EBGfv/IjjqmFxrNAUpBERfGs1oHROyD7yxjG/w+t0GOJDX8O1k32ySmd7+a5IhnJU2qQFcJ4n1vw==",
          "dev": true,
          "requires": {
            "merge-stream": "^2.0.0",
            "supports-color": "^7.0.0"
          }
        },
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        },
        "which": {
          "version": "2.0.2",
          "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
          "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
          "dev": true,
          "requires": {
            "isexe": "^2.0.0"
          }
        }
      }
    },
    "jest-jasmine2": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/jest-jasmine2/-/jest-jasmine2-25.5.4.tgz",
      "integrity": "sha512-9acbWEfbmS8UpdcfqnDO+uBUgKa/9hcRh983IHdM+pKmJPL77G0sWAAK0V0kr5LK3a8cSBfkFSoncXwQlRZfkQ==",
      "dev": true,
      "requires": {
        "@babel/traverse": "^7.1.0",
        "@jest/environment": "^25.5.0",
        "@jest/source-map": "^25.5.0",
        "@jest/test-result": "^25.5.0",
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "co": "^4.6.0",
        "expect": "^25.5.0",
        "is-generator-fn": "^2.0.0",
        "jest-each": "^25.5.0",
        "jest-matcher-utils": "^25.5.0",
        "jest-message-util": "^25.5.0",
        "jest-runtime": "^25.5.4",
        "jest-snapshot": "^25.5.1",
        "jest-util": "^25.5.0",
        "pretty-format": "^25.5.0",
        "throat": "^5.0.0"
      }
    },
    "jest-leak-detector": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-leak-detector/-/jest-leak-detector-25.5.0.tgz",
      "integrity": "sha512-rV7JdLsanS8OkdDpZtgBf61L5xZ4NnYLBq72r6ldxahJWWczZjXawRsoHyXzibM5ed7C2QRjpp6ypgwGdKyoVA==",
      "dev": true,
      "requires": {
        "jest-get-type": "^25.2.6",
        "pretty-format": "^25.5.0"
      }
    },
    "jest-matcher-utils": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-matcher-utils/-/jest-matcher-utils-25.5.0.tgz",
      "integrity": "sha512-VWI269+9JS5cpndnpCwm7dy7JtGQT30UHfrnM3mXl22gHGt/b7NkjBqXfbhZ8V4B7ANUsjK18PlSBmG0YH7gjw==",
      "dev": true,
      "requires": {
        "chalk": "^3.0.0",
        "jest-diff": "^25.5.0",
        "jest-get-type": "^25.2.6",
        "pretty-format": "^25.5.0"
      }
    },
    "jest-message-util": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-message-util/-/jest-message-util-25.5.0.tgz",
      "integrity": "sha512-ezddz3YCT/LT0SKAmylVyWWIGYoKHOFOFXx3/nA4m794lfVUskMcwhip6vTgdVrOtYdjeQeis2ypzes9mZb4EA==",
      "dev": true,
      "requires": {
        "@babel/code-frame": "^7.0.0",
        "@jest/types": "^25.5.0",
        "@types/stack-utils": "^1.0.1",
        "chalk": "^3.0.0",
        "graceful-fs": "^4.2.4",
        "micromatch": "^4.0.2",
        "slash": "^3.0.0",
        "stack-utils": "^1.0.1"
      },
      "dependencies": {
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        }
      }
    },
    "jest-mock": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-mock/-/jest-mock-25.5.0.tgz",
      "integrity": "sha512-eXWuTV8mKzp/ovHc5+3USJMYsTBhyQ+5A1Mak35dey/RG8GlM4YWVylZuGgVXinaW6tpvk/RSecmF37FKUlpXA==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0"
      }
    },
    "jest-pnp-resolver": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/jest-pnp-resolver/-/jest-pnp-resolver-1.2.1.tgz",
      "integrity": "sha512-pgFw2tm54fzgYvc/OHrnysABEObZCUNFnhjoRjaVOCN8NYc032/gVjPaHD4Aq6ApkSieWtfKAFQtmDKAmhupnQ==",
      "dev": true
    },
    "jest-preset-angular": {
      "version": "8.1.2",
      "resolved": "https://registry.npmjs.org/jest-preset-angular/-/jest-preset-angular-8.1.2.tgz",
      "integrity": "sha512-a6RPuWIUAnEBq3nsgwh6B+ZaJ1wYF7ChvNNBp4vS9lM9OG8r2waa4+OpIQDZJ9ptERDsPC2vjr6QY3R0ai9vcw==",
      "dev": true,
      "requires": {
        "pretty-format": "^25.0.0",
        "ts-jest": "^25.0.0"
      }
    },
    "jest-regex-util": {
      "version": "25.2.6",
      "resolved": "https://registry.npmjs.org/jest-regex-util/-/jest-regex-util-25.2.6.tgz",
      "integrity": "sha512-KQqf7a0NrtCkYmZZzodPftn7fL1cq3GQAFVMn5Hg8uKx/fIenLEobNanUxb7abQ1sjADHBseG/2FGpsv/wr+Qw==",
      "dev": true
    },
    "jest-resolve": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/jest-resolve/-/jest-resolve-25.5.1.tgz",
      "integrity": "sha512-Hc09hYch5aWdtejsUZhA+vSzcotf7fajSlPA6EZPE1RmPBAD39XtJhvHWFStid58iit4IPDLI/Da4cwdDmAHiQ==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "browser-resolve": "^1.11.3",
        "chalk": "^3.0.0",
        "graceful-fs": "^4.2.4",
        "jest-pnp-resolver": "^1.2.1",
        "read-pkg-up": "^7.0.1",
        "realpath-native": "^2.0.0",
        "resolve": "^1.17.0",
        "slash": "^3.0.0"
      },
      "dependencies": {
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        }
      }
    },
    "jest-resolve-dependencies": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/jest-resolve-dependencies/-/jest-resolve-dependencies-25.5.4.tgz",
      "integrity": "sha512-yFmbPd+DAQjJQg88HveObcGBA32nqNZ02fjYmtL16t1xw9bAttSn5UGRRhzMHIQbsep7znWvAvnD4kDqOFM0Uw==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "jest-regex-util": "^25.2.6",
        "jest-snapshot": "^25.5.1"
      }
    },
    "jest-runner": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/jest-runner/-/jest-runner-25.5.4.tgz",
      "integrity": "sha512-V/2R7fKZo6blP8E9BL9vJ8aTU4TH2beuqGNxHbxi6t14XzTb+x90B3FRgdvuHm41GY8ch4xxvf0ATH4hdpjTqg==",
      "dev": true,
      "requires": {
        "@jest/console": "^25.5.0",
        "@jest/environment": "^25.5.0",
        "@jest/test-result": "^25.5.0",
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.4",
        "jest-config": "^25.5.4",
        "jest-docblock": "^25.3.0",
        "jest-haste-map": "^25.5.1",
        "jest-jasmine2": "^25.5.4",
        "jest-leak-detector": "^25.5.0",
        "jest-message-util": "^25.5.0",
        "jest-resolve": "^25.5.1",
        "jest-runtime": "^25.5.4",
        "jest-util": "^25.5.0",
        "jest-worker": "^25.5.0",
        "source-map-support": "^0.5.6",
        "throat": "^5.0.0"
      },
      "dependencies": {
        "jest-worker": {
          "version": "25.5.0",
          "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-25.5.0.tgz",
          "integrity": "sha512-/dsSmUkIy5EBGfv/IjjqmFxrNAUpBERfGs1oHROyD7yxjG/w+t0GOJDX8O1k32ySmd7+a5IhnJU2qQFcJ4n1vw==",
          "dev": true,
          "requires": {
            "merge-stream": "^2.0.0",
            "supports-color": "^7.0.0"
          }
        }
      }
    },
    "jest-runtime": {
      "version": "25.5.4",
      "resolved": "https://registry.npmjs.org/jest-runtime/-/jest-runtime-25.5.4.tgz",
      "integrity": "sha512-RWTt8LeWh3GvjYtASH2eezkc8AehVoWKK20udV6n3/gC87wlTbE1kIA+opCvNWyyPeBs6ptYsc6nyHUb1GlUVQ==",
      "dev": true,
      "requires": {
        "@jest/console": "^25.5.0",
        "@jest/environment": "^25.5.0",
        "@jest/globals": "^25.5.2",
        "@jest/source-map": "^25.5.0",
        "@jest/test-result": "^25.5.0",
        "@jest/transform": "^25.5.1",
        "@jest/types": "^25.5.0",
        "@types/yargs": "^15.0.0",
        "chalk": "^3.0.0",
        "collect-v8-coverage": "^1.0.0",
        "exit": "^0.1.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.4",
        "jest-config": "^25.5.4",
        "jest-haste-map": "^25.5.1",
        "jest-message-util": "^25.5.0",
        "jest-mock": "^25.5.0",
        "jest-regex-util": "^25.2.6",
        "jest-resolve": "^25.5.1",
        "jest-snapshot": "^25.5.1",
        "jest-util": "^25.5.0",
        "jest-validate": "^25.5.0",
        "realpath-native": "^2.0.0",
        "slash": "^3.0.0",
        "strip-bom": "^4.0.0",
        "yargs": "^15.3.1"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "dev": true,
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "cliui": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-6.0.0.tgz",
          "integrity": "sha512-t6wbgtoCXvAzst7QgXxJYqPt0usEfbgQdftEPbLL/cvv6HPE5VgvqCuAIDR0NgU52ds6rFwqrgakNLrHEjCbrQ==",
          "dev": true,
          "requires": {
            "string-width": "^4.2.0",
            "strip-ansi": "^6.0.0",
            "wrap-ansi": "^6.2.0"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        },
        "get-caller-file": {
          "version": "2.0.5",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
          "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "require-main-filename": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
          "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
          "dev": true
        },
        "slash": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
          "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        },
        "strip-bom": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-4.0.0.tgz",
          "integrity": "sha512-3xurFv5tEgii33Zi8Jtp55wEIILR9eh34FAW00PZf+JnSsTmV/ioewSgQl97JHvgjoRGwPShsWm+IdrxB35d0w==",
          "dev": true
        },
        "wrap-ansi": {
          "version": "6.2.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
          "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
          "dev": true,
          "requires": {
            "ansi-styles": "^4.0.0",
            "string-width": "^4.1.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "yargs": {
          "version": "15.3.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-15.3.1.tgz",
          "integrity": "sha512-92O1HWEjw27sBfgmXiixJWT5hRBp2eobqXicLtPBIDBhYB+1HpwZlXmbW2luivBJHBzki+7VyCLRtAkScbTBQA==",
          "dev": true,
          "requires": {
            "cliui": "^6.0.0",
            "decamelize": "^1.2.0",
            "find-up": "^4.1.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^4.2.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^18.1.1"
          }
        },
        "yargs-parser": {
          "version": "18.1.3",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-18.1.3.tgz",
          "integrity": "sha512-o50j0JeToy/4K6OZcaQmW6lyXXKhq7csREXcDwk2omFPJEwUNOVtJKvmDr9EI1fAJZUyZcRF7kxGBWmRXudrCQ==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "jest-serializer": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-serializer/-/jest-serializer-25.5.0.tgz",
      "integrity": "sha512-LxD8fY1lByomEPflwur9o4e2a5twSQ7TaVNLlFUuToIdoJuBt8tzHfCsZ42Ok6LkKXWzFWf3AGmheuLAA7LcCA==",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.2.4"
      }
    },
    "jest-snapshot": {
      "version": "25.5.1",
      "resolved": "https://registry.npmjs.org/jest-snapshot/-/jest-snapshot-25.5.1.tgz",
      "integrity": "sha512-C02JE1TUe64p2v1auUJ2ze5vcuv32tkv9PyhEb318e8XOKF7MOyXdJ7kdjbvrp3ChPLU2usI7Rjxs97Dj5P0uQ==",
      "dev": true,
      "requires": {
        "@babel/types": "^7.0.0",
        "@jest/types": "^25.5.0",
        "@types/prettier": "^1.19.0",
        "chalk": "^3.0.0",
        "expect": "^25.5.0",
        "graceful-fs": "^4.2.4",
        "jest-diff": "^25.5.0",
        "jest-get-type": "^25.2.6",
        "jest-matcher-utils": "^25.5.0",
        "jest-message-util": "^25.5.0",
        "jest-resolve": "^25.5.1",
        "make-dir": "^3.0.0",
        "natural-compare": "^1.4.0",
        "pretty-format": "^25.5.0",
        "semver": "^6.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "jest-util": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-util/-/jest-util-25.5.0.tgz",
      "integrity": "sha512-KVlX+WWg1zUTB9ktvhsg2PXZVdkI1NBevOJSkTKYAyXyH4QSvh+Lay/e/v+bmaFfrkfx43xD8QTfgobzlEXdIA==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "chalk": "^3.0.0",
        "graceful-fs": "^4.2.4",
        "is-ci": "^2.0.0",
        "make-dir": "^3.0.0"
      }
    },
    "jest-validate": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-validate/-/jest-validate-25.5.0.tgz",
      "integrity": "sha512-okUFKqhZIpo3jDdtUXUZ2LxGUZJIlfdYBvZb1aczzxrlyMlqdnnws9MOxezoLGhSaFc2XYaHNReNQfj5zPIWyQ==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "camelcase": "^5.3.1",
        "chalk": "^3.0.0",
        "jest-get-type": "^25.2.6",
        "leven": "^3.1.0",
        "pretty-format": "^25.5.0"
      }
    },
    "jest-watcher": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/jest-watcher/-/jest-watcher-25.5.0.tgz",
      "integrity": "sha512-XrSfJnVASEl+5+bb51V0Q7WQx65dTSk7NL4yDdVjPnRNpM0hG+ncFmDYJo9O8jaSRcAitVbuVawyXCRoxGrT5Q==",
      "dev": true,
      "requires": {
        "@jest/test-result": "^25.5.0",
        "@jest/types": "^25.5.0",
        "ansi-escapes": "^4.2.1",
        "chalk": "^3.0.0",
        "jest-util": "^25.5.0",
        "string-length": "^3.1.0"
      }
    },
    "jest-worker": {
      "version": "26.0.0",
      "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-26.0.0.tgz",
      "integrity": "sha512-pPaYa2+JnwmiZjK9x7p9BoZht+47ecFCDFA/CJxspHzeDvQcfVBLWzCiWyo+EGrSiQMWZtCFo9iSvMZnAAo8vw==",
      "dev": true,
      "requires": {
        "merge-stream": "^2.0.0",
        "supports-color": "^7.0.0"
      }
    },
    "js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ=="
    },
    "js-yaml": {
      "version": "3.13.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.13.1.tgz",
      "integrity": "sha512-YfbcO7jXDdyj0DGxYVSlSeQNHbD7XPWvrVWeVUujrQEoZzWJIRrCPoyk6kL6IAjAG2IolMK4T0hNUe0HOUs5Jw==",
      "dev": true,
      "requires": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      }
    },
    "jsbn": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/jsbn/-/jsbn-0.1.1.tgz",
      "integrity": "sha1-peZUwuWi3rXyAdls77yoDA7y9RM=",
      "dev": true
    },
    "jsdom": {
      "version": "15.2.1",
      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-15.2.1.tgz",
      "integrity": "sha512-fAl1W0/7T2G5vURSyxBzrJ1LSdQn6Tr5UX/xD4PXDx/PDgwygedfW6El/KIj3xJ7FU61TTYnc/l/B7P49Eqt6g==",
      "dev": true,
      "requires": {
        "abab": "^2.0.0",
        "acorn": "^7.1.0",
        "acorn-globals": "^4.3.2",
        "array-equal": "^1.0.0",
        "cssom": "^0.4.1",
        "cssstyle": "^2.0.0",
        "data-urls": "^1.1.0",
        "domexception": "^1.0.1",
        "escodegen": "^1.11.1",
        "html-encoding-sniffer": "^1.0.2",
        "nwsapi": "^2.2.0",
        "parse5": "5.1.0",
        "pn": "^1.1.0",
        "request": "^2.88.0",
        "request-promise-native": "^1.0.7",
        "saxes": "^3.1.9",
        "symbol-tree": "^3.2.2",
        "tough-cookie": "^3.0.1",
        "w3c-hr-time": "^1.0.1",
        "w3c-xmlserializer": "^1.1.2",
        "webidl-conversions": "^4.0.2",
        "whatwg-encoding": "^1.0.5",
        "whatwg-mimetype": "^2.3.0",
        "whatwg-url": "^7.0.0",
        "ws": "^7.0.0",
        "xml-name-validator": "^3.0.0"
      },
      "dependencies": {
        "acorn": {
          "version": "7.1.1",
          "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.1.1.tgz",
          "integrity": "sha512-add7dgA5ppRPxCFJoAGfMDi7PIBXq1RtGo7BhbLaxwrXPOmw8gq48Y9ozT01hUKy9byMjlR20EJhu5zlkErEkg==",
          "dev": true
        },
        "parse5": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/parse5/-/parse5-5.1.0.tgz",
          "integrity": "sha512-fxNG2sQjHvlVAYmzBZS9YlDp6PTSSDwa98vkD4QgVDDCAo84z5X1t5XyJQ62ImdLXx5NdIIfihey6xpum9/gRQ==",
          "dev": true
        },
        "tough-cookie": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-3.0.1.tgz",
          "integrity": "sha512-yQyJ0u4pZsv9D4clxO69OEjLWYw+jbgspjTue4lTQZLfV0c5l1VmK2y1JK8E9ahdpltPOaAThPcp5nKPUgSnsg==",
          "dev": true,
          "requires": {
            "ip-regex": "^2.1.0",
            "psl": "^1.1.28",
            "punycode": "^2.1.1"
          }
        },
        "ws": {
          "version": "7.2.5",
          "resolved": "https://registry.npmjs.org/ws/-/ws-7.2.5.tgz",
          "integrity": "sha512-C34cIU4+DB2vMyAbmEKossWq2ZQDr6QEyuuCzWrM9zfw1sGc0mYiJ0UnG9zzNykt49C2Fi34hvr2vssFQRS6EA==",
          "dev": true
        }
      }
    },
    "jsesc": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-2.5.2.tgz",
      "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA=="
    },
    "json-parse-better-errors": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/json-parse-better-errors/-/json-parse-better-errors-1.0.2.tgz",
      "integrity": "sha512-mrqyZKfX5EhL7hvqcV6WG1yYjnjeuYDzDhhcAAUrq8Po85NBQBJP+ZDUT75qZQ98IkUoBqdkExkukOU7Ts2wrw==",
      "dev": true
    },
    "json-schema": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/json-schema/-/json-schema-0.2.3.tgz",
      "integrity": "sha1-tIDIkuWaLwWVTOcnvT8qTogvnhM=",
      "dev": true
    },
    "json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
    },
    "json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha1-nbe1lJatPzz+8wp1FC0tkwrXJlE=",
      "dev": true
    },
    "json-stringify-safe": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz",
      "integrity": "sha1-Epai1Y/UXxmg9s4B1lcB4sc1tus=",
      "dev": true
    },
    "json3": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/json3/-/json3-3.3.3.tgz",
      "integrity": "sha512-c7/8mbUsKigAbLkD5B010BK4D9LZm7A1pNItkEwiUZRpIN66exu/e7YQWysGun+TRKaJp8MhemM+VkfWv42aCA==",
      "dev": true
    },
    "json5": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.1.3.tgz",
      "integrity": "sha512-KXPvOm8K9IJKFM0bmdn8QXh7udDh1g/giieX0NLCaMnb4hEiVFqnop2ImTXCc5e0/oHz3LTqmHGtExn5hfMkOA==",
      "requires": {
        "minimist": "^1.2.5"
      }
    },
    "jsonfile": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-4.0.0.tgz",
      "integrity": "sha1-h3Gq4HmbZAdrdmQPygWPnBDjPss=",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.6"
      }
    },
    "jsonparse": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/jsonparse/-/jsonparse-1.3.1.tgz",
      "integrity": "sha1-P02uSpH6wxX3EGL4UhzCOfE2YoA=",
      "dev": true
    },
    "jsprim": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/jsprim/-/jsprim-1.4.1.tgz",
      "integrity": "sha1-MT5mvB5cwG5Di8G3SZwuXFastqI=",
      "dev": true,
      "requires": {
        "assert-plus": "1.0.0",
        "extsprintf": "1.3.0",
        "json-schema": "0.2.3",
        "verror": "1.10.0"
      }
    },
    "jszip": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/jszip/-/jszip-3.5.0.tgz",
      "integrity": "sha512-WRtu7TPCmYePR1nazfrtuF216cIVon/3GWOvHS9QR5bIwSbnxtdpma6un3jyGGNhHsKCSzn5Ypk+EkDRvTGiFA==",
      "dev": true,
      "requires": {
        "lie": "~3.3.0",
        "pako": "~1.0.2",
        "readable-stream": "~2.3.6",
        "set-immediate-shim": "~1.0.1"
      }
    },
    "just-extend": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/just-extend/-/just-extend-4.1.0.tgz",
      "integrity": "sha512-ApcjaOdVTJ7y4r08xI5wIqpvwS48Q0PBG4DJROcEkH1f8MdAiNFyFxz3xoL0LWAVwjrwPYZdVHHxhRHcx/uGLA==",
      "dev": true
    },
    "karma-source-map-support": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/karma-source-map-support/-/karma-source-map-support-1.4.0.tgz",
      "integrity": "sha512-RsBECncGO17KAoJCYXjv+ckIz+Ii9NCi+9enk+rq6XC81ezYkb4/RHE6CTXdA7IOJqoF3wcaLfVG0CPmE5ca6A==",
      "dev": true,
      "requires": {
        "source-map-support": "^0.5.5"
      }
    },
    "killable": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/killable/-/killable-1.0.1.tgz",
      "integrity": "sha512-LzqtLKlUwirEUyl/nicirVmNiPvYs7l5n8wOPP7fyJVpUPkvCnW/vuiXGpylGUlnPDnB7311rARzAt3Mhswpjg==",
      "dev": true
    },
    "kind-of": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-6.0.3.tgz",
      "integrity": "sha512-dcS1ul+9tmeD95T+x28/ehLgd9mENa3LsvDTtzm3vyBEO7RPptvAD+t44WVXaUjTBRcrpFeFlC8WCruUR456hw=="
    },
    "kleur": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/kleur/-/kleur-3.0.3.tgz",
      "integrity": "sha512-eTIzlVOSUR+JxdDFepEYcBMtZ9Qqdef+rnzWdRZuMbOywu5tO2w2N7rqjoANZ5k9vywhL6Br1VRjUIgTQx4E8w==",
      "dev": true
    },
    "lazy-ass": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/lazy-ass/-/lazy-ass-1.6.0.tgz",
      "integrity": "sha1-eZllXoZGwX8In90YfRUNMyTVRRM=",
      "dev": true
    },
    "lcid": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/lcid/-/lcid-2.0.0.tgz",
      "integrity": "sha512-avPEb8P8EGnwXKClwsNUgryVjllcRqtMYa49NTsbQagYuT1DcXnl1915oxWjoyGrXR6zH/Y0Zc96xWsPcoDKeA==",
      "dev": true,
      "requires": {
        "invert-kv": "^2.0.0"
      }
    },
    "less": {
      "version": "3.12.2",
      "resolved": "https://registry.npmjs.org/less/-/less-3.12.2.tgz",
      "integrity": "sha512-+1V2PCMFkL+OIj2/HrtrvZw0BC0sYLMICJfbQjuj/K8CEnlrFX6R5cKKgzzttsZDHyxQNL1jqMREjKN3ja/E3Q==",
      "dev": true,
      "requires": {
        "errno": "^0.1.1",
        "graceful-fs": "^4.1.2",
        "image-size": "~0.5.0",
        "make-dir": "^2.1.0",
        "mime": "^1.4.1",
        "native-request": "^1.0.5",
        "source-map": "~0.6.0",
        "tslib": "^1.10.0"
      },
      "dependencies": {
        "make-dir": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-2.1.0.tgz",
          "integrity": "sha512-LS9X+dc8KLxXCb8dni79fLIIUA5VyZoyjSMCwTluaXA0o27cCK0bhXkpgw+sTXVpPy/lSO57ilRixqk0vDmtRA==",
          "dev": true,
          "optional": true,
          "requires": {
            "pify": "^4.0.1",
            "semver": "^5.6.0"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true,
          "optional": true
        }
      }
    },
    "less-loader": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/less-loader/-/less-loader-6.1.0.tgz",
      "integrity": "sha512-/jLzOwLyqJ7Kt3xg5sHHkXtOyShWwFj410K9Si9WO+/h8rmYxxkSR0A3/hFEntWudE20zZnWMtpMYnLzqTVdUA==",
      "dev": true,
      "requires": {
        "clone": "^2.1.2",
        "less": "^3.11.1",
        "loader-utils": "^2.0.0",
        "schema-utils": "^2.6.6"
      },
      "dependencies": {
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        }
      }
    },
    "leven": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/leven/-/leven-3.1.0.tgz",
      "integrity": "sha512-qsda+H8jTaUaN/x5vzW2rzc+8Rw4TAQ/4KjB46IwK5VH+IlVeeeje/EoZRpiXvIqjFgK84QffqPztGI3VBLG1A=="
    },
    "levenary": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/levenary/-/levenary-1.1.1.tgz",
      "integrity": "sha512-mkAdOIt79FD6irqjYSs4rdbnlT5vRonMEvBVPVb3XmevfS8kgRXwfes0dhPdEtzTWD/1eNE/Bm/G1iRt6DcnQQ==",
      "requires": {
        "leven": "^3.1.0"
      }
    },
    "levn": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.3.0.tgz",
      "integrity": "sha1-OwmSTt+fCDwEkP3UwLxEIeBHZO4=",
      "dev": true,
      "requires": {
        "prelude-ls": "~1.1.2",
        "type-check": "~0.3.2"
      }
    },
    "license-webpack-plugin": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/license-webpack-plugin/-/license-webpack-plugin-2.2.0.tgz",
      "integrity": "sha512-XPsdL/0brSHf+7dXIlRqotnCQ58RX2au6otkOg4U3dm8uH+Ka/fW4iukEs95uXm+qKe/SBs+s1Ll/aQddKG+tg==",
      "dev": true,
      "requires": {
        "@types/webpack-sources": "^0.1.5",
        "webpack-sources": "^1.2.0"
      }
    },
    "lie": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/lie/-/lie-3.3.0.tgz",
      "integrity": "sha512-UaiMJzeWRlEujzAuw5LokY1L5ecNQYZKfmyZ9L7wDHb/p5etKaxXhohBcrw0EYby+G/NA52vRSN4N39dxHAIwQ==",
      "dev": true,
      "requires": {
        "immediate": "~3.0.5"
      }
    },
    "lines-and-columns": {
      "version": "1.1.6",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.1.6.tgz",
      "integrity": "sha1-HADHQ7QzzQpOgHWPe2SldEDZ/wA=",
      "dev": true
    },
    "listr": {
      "version": "0.14.3",
      "resolved": "https://registry.npmjs.org/listr/-/listr-0.14.3.tgz",
      "integrity": "sha512-RmAl7su35BFd/xoMamRjpIE4j3v+L28o8CT5YhAXQJm1fD+1l9ngXY8JAQRJ+tFK2i5njvi0iRUKV09vPwA0iA==",
      "dev": true,
      "requires": {
        "@samverschueren/stream-to-observable": "^0.3.0",
        "is-observable": "^1.1.0",
        "is-promise": "^2.1.0",
        "is-stream": "^1.1.0",
        "listr-silent-renderer": "^1.1.1",
        "listr-update-renderer": "^0.5.0",
        "listr-verbose-renderer": "^0.5.0",
        "p-map": "^2.0.0",
        "rxjs": "^6.3.3"
      }
    },
    "listr-silent-renderer": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/listr-silent-renderer/-/listr-silent-renderer-1.1.1.tgz",
      "integrity": "sha1-kktaN1cVN3C/Go4/v3S4u/P5JC4=",
      "dev": true
    },
    "listr-update-renderer": {
      "version": "0.5.0",
      "resolved": "https://registry.npmjs.org/listr-update-renderer/-/listr-update-renderer-0.5.0.tgz",
      "integrity": "sha512-tKRsZpKz8GSGqoI/+caPmfrypiaq+OQCbd+CovEC24uk1h952lVj5sC7SqyFUm+OaJ5HN/a1YLt5cit2FMNsFA==",
      "dev": true,
      "requires": {
        "chalk": "^1.1.3",
        "cli-truncate": "^0.2.1",
        "elegant-spinner": "^1.0.1",
        "figures": "^1.7.0",
        "indent-string": "^3.0.0",
        "log-symbols": "^1.0.2",
        "log-update": "^2.3.0",
        "strip-ansi": "^3.0.1"
      },
      "dependencies": {
        "ansi-styles": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
          "integrity": "sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=",
          "dev": true
        },
        "chalk": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
          "integrity": "sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=",
          "dev": true,
          "requires": {
            "ansi-styles": "^2.2.1",
            "escape-string-regexp": "^1.0.2",
            "has-ansi": "^2.0.0",
            "strip-ansi": "^3.0.0",
            "supports-color": "^2.0.0"
          }
        },
        "figures": {
          "version": "1.7.0",
          "resolved": "https://registry.npmjs.org/figures/-/figures-1.7.0.tgz",
          "integrity": "sha1-y+Hjr/zxzUS4DK3+0o3Hk6lwHS4=",
          "dev": true,
          "requires": {
            "escape-string-regexp": "^1.0.5",
            "object-assign": "^4.1.0"
          }
        },
        "indent-string": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-3.2.0.tgz",
          "integrity": "sha1-Sl/W0nzDMvN+VBmlBNu4NxBckok=",
          "dev": true
        },
        "log-symbols": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-1.0.2.tgz",
          "integrity": "sha1-N2/3tY6jCGoPCfrMdGF+ylAeGhg=",
          "dev": true,
          "requires": {
            "chalk": "^1.0.0"
          }
        },
        "supports-color": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
          "integrity": "sha1-U10EXOa2Nj+kARcIRimZXp3zJMc=",
          "dev": true
        }
      }
    },
    "listr-verbose-renderer": {
      "version": "0.5.0",
      "resolved": "https://registry.npmjs.org/listr-verbose-renderer/-/listr-verbose-renderer-0.5.0.tgz",
      "integrity": "sha512-04PDPqSlsqIOaaaGZ+41vq5FejI9auqTInicFRndCBgE3bXG8D6W1I+mWhk+1nqbHmyhla/6BUrd5OSiHwKRXw==",
      "dev": true,
      "requires": {
        "chalk": "^2.4.1",
        "cli-cursor": "^2.1.0",
        "date-fns": "^1.27.2",
        "figures": "^2.0.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "cli-cursor": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-2.1.0.tgz",
          "integrity": "sha1-s12sN2R5+sw+lHR9QdDQ9SOP/LU=",
          "dev": true,
          "requires": {
            "restore-cursor": "^2.0.0"
          }
        },
        "figures": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/figures/-/figures-2.0.0.tgz",
          "integrity": "sha1-OrGi0qYsi/tDGgyUy3l6L84nyWI=",
          "dev": true,
          "requires": {
            "escape-string-regexp": "^1.0.5"
          }
        },
        "mimic-fn": {
          "version": "1.2.0",
          "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.2.0.tgz",
          "integrity": "sha512-jf84uxzwiuiIVKiOLpfYk7N46TSy8ubTonmneY9vrpHNAnp0QBt2BxWV9dO3/j+BoVAb+a5G6YDPW3M5HOdMWQ==",
          "dev": true
        },
        "onetime": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/onetime/-/onetime-2.0.1.tgz",
          "integrity": "sha1-BnQoIw/WdEOyeUsiu6UotoZ5YtQ=",
          "dev": true,
          "requires": {
            "mimic-fn": "^1.0.0"
          }
        },
        "restore-cursor": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-2.0.0.tgz",
          "integrity": "sha1-n37ih/gv0ybU/RYpI9YhKe7g368=",
          "dev": true,
          "requires": {
            "onetime": "^2.0.0",
            "signal-exit": "^3.0.2"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "load-json-file": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/load-json-file/-/load-json-file-4.0.0.tgz",
      "integrity": "sha1-L19Fq5HjMhYjT9U62rZo607AmTs=",
      "dev": true,
      "requires": {
        "graceful-fs": "^4.1.2",
        "parse-json": "^4.0.0",
        "pify": "^3.0.0",
        "strip-bom": "^3.0.0"
      },
      "dependencies": {
        "pify": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=",
          "dev": true
        }
      }
    },
    "loader-runner": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/loader-runner/-/loader-runner-2.4.0.tgz",
      "integrity": "sha512-Jsmr89RcXGIwivFY21FcRrisYZfvLMTWx5kOLc+JTxtpBOG6xML0vzbc6SEQG2FO9/4Fc3wW4LVcB5DmGflaRw==",
      "dev": true
    },
    "loader-utils": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.4.0.tgz",
      "integrity": "sha512-qH0WSMBtn/oHuwjy/NucEgbx5dbxxnxup9s4PVXJUDHZBQY+s0NWA9rJf53RBnQZxfch7euUui7hpoAPvALZdA==",
      "requires": {
        "big.js": "^5.2.2",
        "emojis-list": "^3.0.0",
        "json5": "^1.0.1"
      },
      "dependencies": {
        "json5": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
          "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
          "requires": {
            "minimist": "^1.2.0"
          }
        }
      }
    },
    "locate-path": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-5.0.0.tgz",
      "integrity": "sha512-t7hw9pI+WvuwNJXwk5zVHpyhIqzg2qTlklJOf0mVxGSbe3Fp2VieZcduNYjaLDoy6p9uGpQEGWG87WpMKlNq8g==",
      "dev": true,
      "requires": {
        "p-locate": "^4.1.0"
      }
    },
    "lodash": {
      "version": "4.17.20",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.20.tgz",
      "integrity": "sha512-PlhdFcillOINfeV7Ni6oF1TAEayyZBoZ8bcshTHqOYJYlrqzRK5hagpagky5o4HfCzzd1TRkXPMFq6cKk9rGmA=="
    },
    "lodash.clonedeep": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.clonedeep/-/lodash.clonedeep-4.5.0.tgz",
      "integrity": "sha1-4j8/nE+Pvd6HJSnBBxhXoIblzO8=",
      "dev": true
    },
    "lodash.get": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz",
      "integrity": "sha1-LRd/ZS+jHpObRDjVNBSZ36OCXpk=",
      "dev": true
    },
    "lodash.memoize": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/lodash.memoize/-/lodash.memoize-4.1.2.tgz",
      "integrity": "sha1-vMbEmkKihA7Zl/Mj6tpezRguC/4=",
      "dev": true
    },
    "lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha1-DdOXEhPHxW34gJd9UEyI+0cal6w=",
      "dev": true
    },
    "lodash.sortby": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
      "integrity": "sha1-7dFMgk4sycHgsKG0K7UhBRakJDg=",
      "dev": true
    },
    "lodash.uniq": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.uniq/-/lodash.uniq-4.5.0.tgz",
      "integrity": "sha1-0CJTc662Uq3BvILklFM5qEJ1R3M=",
      "dev": true
    },
    "log-symbols": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-3.0.0.tgz",
      "integrity": "sha512-dSkNGuI7iG3mfvDzUuYZyvk5dD9ocYCYzNU6CYDE6+Xqd+gwme6Z00NS3dUh8mq/73HaEtT7m6W+yUPtU6BZnQ==",
      "requires": {
        "chalk": "^2.4.2"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "log-update": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/log-update/-/log-update-2.3.0.tgz",
      "integrity": "sha1-iDKP19HOeTiykoN0bwsbwSayRwg=",
      "dev": true,
      "requires": {
        "ansi-escapes": "^3.0.0",
        "cli-cursor": "^2.0.0",
        "wrap-ansi": "^3.0.1"
      },
      "dependencies": {
        "ansi-escapes": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-3.2.0.tgz",
          "integrity": "sha512-cBhpre4ma+U0T1oM5fXg7Dy1Jw7zzwv7lt/GoCpr+hDQJoYnKVPLL4dCvSEFMmQurOQvSrwT7SL/DAlhBI97RQ==",
          "dev": true
        },
        "ansi-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
          "dev": true
        },
        "cli-cursor": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-2.1.0.tgz",
          "integrity": "sha1-s12sN2R5+sw+lHR9QdDQ9SOP/LU=",
          "dev": true,
          "requires": {
            "restore-cursor": "^2.0.0"
          }
        },
        "mimic-fn": {
          "version": "1.2.0",
          "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-1.2.0.tgz",
          "integrity": "sha512-jf84uxzwiuiIVKiOLpfYk7N46TSy8ubTonmneY9vrpHNAnp0QBt2BxWV9dO3/j+BoVAb+a5G6YDPW3M5HOdMWQ==",
          "dev": true
        },
        "onetime": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/onetime/-/onetime-2.0.1.tgz",
          "integrity": "sha1-BnQoIw/WdEOyeUsiu6UotoZ5YtQ=",
          "dev": true,
          "requires": {
            "mimic-fn": "^1.0.0"
          }
        },
        "restore-cursor": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-2.0.0.tgz",
          "integrity": "sha1-n37ih/gv0ybU/RYpI9YhKe7g368=",
          "dev": true,
          "requires": {
            "onetime": "^2.0.0",
            "signal-exit": "^3.0.2"
          }
        },
        "strip-ansi": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^3.0.0"
          }
        },
        "wrap-ansi": {
          "version": "3.0.1",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-3.0.1.tgz",
          "integrity": "sha1-KIoE2H7aXChuBg3+jxNc6NAH+Lo=",
          "dev": true,
          "requires": {
            "string-width": "^2.1.1",
            "strip-ansi": "^4.0.0"
          }
        }
      }
    },
    "loglevel": {
      "version": "1.6.8",
      "resolved": "https://registry.npmjs.org/loglevel/-/loglevel-1.6.8.tgz",
      "integrity": "sha512-bsU7+gc9AJ2SqpzxwU3+1fedl8zAntbtC5XYlt3s2j1hJcn2PsXSmgN8TaLG/J1/2mod4+cE/3vNL70/c1RNCA==",
      "dev": true
    },
    "lolex": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/lolex/-/lolex-5.1.2.tgz",
      "integrity": "sha512-h4hmjAvHTmd+25JSwrtTIuwbKdwg5NzZVRMLn9saij4SZaepCrTCxPr35H/3bjwfMJtN+t3CX8672UIkglz28A==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1.7.0"
      }
    },
    "loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "requires": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      }
    },
    "lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "requires": {
        "yallist": "^3.0.2"
      },
      "dependencies": {
        "yallist": {
          "version": "3.1.1",
          "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
          "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
          "dev": true
        }
      }
    },
    "lru-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/lru-queue/-/lru-queue-0.1.0.tgz",
      "integrity": "sha1-Jzi9nw089PhEkMVzbEhpmsYyzaM=",
      "requires": {
        "es5-ext": "~0.10.2"
      }
    },
    "magic-string": {
      "version": "0.25.7",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.7.tgz",
      "integrity": "sha512-4CrMT5DOHTDk4HYDlzmwu4FVCcIYI8gauveasrdCu2IKIFOJ3f0v/8MDGJCDL9oD2ppz/Av1b0Nj345H9M+XIA==",
      "requires": {
        "sourcemap-codec": "^1.4.4"
      }
    },
    "make-dir": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-3.1.0.tgz",
      "integrity": "sha512-g3FeP20LNwhALb/6Cz6Dd4F2ngze0jz7tbzrD2wAV+o9FeNHe4rL+yK2md0J/fiSf1sa1ADhXqi5+oVwOM/eGw==",
      "dev": true,
      "requires": {
        "semver": "^6.0.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true
    },
    "make-fetch-happen": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/make-fetch-happen/-/make-fetch-happen-5.0.2.tgz",
      "integrity": "sha512-07JHC0r1ykIoruKO8ifMXu+xEU8qOXDFETylktdug6vJDACnP+HKevOu3PXyNPzFyTSlz8vrBYlBO1JZRe8Cag==",
      "dev": true,
      "requires": {
        "agentkeepalive": "^3.4.1",
        "cacache": "^12.0.0",
        "http-cache-semantics": "^3.8.1",
        "http-proxy-agent": "^2.1.0",
        "https-proxy-agent": "^2.2.3",
        "lru-cache": "^5.1.1",
        "mississippi": "^3.0.0",
        "node-fetch-npm": "^2.0.2",
        "promise-retry": "^1.1.1",
        "socks-proxy-agent": "^4.0.0",
        "ssri": "^6.0.0"
      },
      "dependencies": {
        "ssri": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/ssri/-/ssri-6.0.1.tgz",
          "integrity": "sha512-3Wge10hNcT1Kur4PDFwEieXSCMCJs/7WvSACcrMYrNp+b8kDL1/0wJch5Ni2WrtwEa2IO8OsVfeKIciKCDx/QA==",
          "dev": true,
          "requires": {
            "figgy-pudding": "^3.5.1"
          }
        }
      }
    },
    "makeerror": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/makeerror/-/makeerror-1.0.11.tgz",
      "integrity": "sha1-4BpckQnyr3lmDk6LlYd5AYT1qWw=",
      "dev": true,
      "requires": {
        "tmpl": "1.0.x"
      }
    },
    "mamacro": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/mamacro/-/mamacro-0.0.3.tgz",
      "integrity": "sha512-qMEwh+UujcQ+kbz3T6V+wAmO2U8veoq2w+3wY8MquqwVA3jChfwY+Tk52GZKDfACEPjuZ7r2oJLejwpt8jtwTA==",
      "dev": true
    },
    "map-age-cleaner": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/map-age-cleaner/-/map-age-cleaner-0.1.3.tgz",
      "integrity": "sha512-bJzx6nMoP6PDLPBFmg7+xRKeFZvFboMrGlxmNj9ClvX53KrmvM5bXFXEWjbz4cz1AFn+jWJ9z/DJSz7hrs0w3w==",
      "dev": true,
      "requires": {
        "p-defer": "^1.0.0"
      }
    },
    "map-cache": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/map-cache/-/map-cache-0.2.2.tgz",
      "integrity": "sha1-wyq9C9ZSXZsFFkW7TyasXcmKDb8="
    },
    "map-visit": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/map-visit/-/map-visit-1.0.0.tgz",
      "integrity": "sha1-7Nyo8TFE5mDxtb1B8S80edmN+48=",
      "requires": {
        "object-visit": "^1.0.0"
      }
    },
    "material-design-icons": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/material-design-icons/-/material-design-icons-3.0.1.tgz",
      "integrity": "sha1-mnHEh0chjrylHlGmbaaCA4zct78="
    },
    "md5.js": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/md5.js/-/md5.js-1.3.5.tgz",
      "integrity": "sha512-xitP+WxNPcTTOgnTJcrhM0xvdPepipPSf3I8EIpGKeFLjt3PlJLIDG3u8EX53ZIubkb+5U2+3rELYpEhHhzdkg==",
      "dev": true,
      "requires": {
        "hash-base": "^3.0.0",
        "inherits": "^2.0.1",
        "safe-buffer": "^5.1.2"
      }
    },
    "mdn-data": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.0.4.tgz",
      "integrity": "sha512-iV3XNKw06j5Q7mi6h+9vbx23Tv7JkjEVgKHW4pimwyDGWm0OIQntJJ+u1C6mg6mK1EaTv42XQ7w76yuzH7M2cA==",
      "dev": true
    },
    "media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g="
    },
    "mem": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/mem/-/mem-4.3.0.tgz",
      "integrity": "sha512-qX2bG48pTqYRVmDB37rn/6PT7LcR8T7oAX3bf99u1Tt1nzxYfxkgqDwUwolPlXweM0XzBOBFzSx4kfp7KP1s/w==",
      "dev": true,
      "requires": {
        "map-age-cleaner": "^0.1.1",
        "mimic-fn": "^2.0.0",
        "p-is-promise": "^2.0.0"
      }
    },
    "memoizee": {
      "version": "0.4.14",
      "resolved": "https://registry.npmjs.org/memoizee/-/memoizee-0.4.14.tgz",
      "integrity": "sha512-/SWFvWegAIYAO4NQMpcX+gcra0yEZu4OntmUdrBaWrJncxOqAziGFlHxc7yjKVK2uu3lpPW27P27wkR82wA8mg==",
      "requires": {
        "d": "1",
        "es5-ext": "^0.10.45",
        "es6-weak-map": "^2.0.2",
        "event-emitter": "^0.3.5",
        "is-promise": "^2.1",
        "lru-queue": "0.1",
        "next-tick": "1",
        "timers-ext": "^0.1.5"
      }
    },
    "memory-fs": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/memory-fs/-/memory-fs-0.4.1.tgz",
      "integrity": "sha1-OpoguEYlI+RHz7x+i7gO1me/xVI=",
      "dev": true,
      "requires": {
        "errno": "^0.1.3",
        "readable-stream": "^2.0.1"
      }
    },
    "memorystream": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/memorystream/-/memorystream-0.3.1.tgz",
      "integrity": "sha1-htcJCzDORV1j+64S3aUaR93K+bI=",
      "dev": true
    },
    "merge-descriptors": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
      "integrity": "sha1-sAqqVW3YtEVoFQ7J0blT8/kMu2E="
    },
    "merge-source-map": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/merge-source-map/-/merge-source-map-1.1.0.tgz",
      "integrity": "sha512-Qkcp7P2ygktpMPh2mCQZaf3jhN6D3Z/qVZHSdWvQ+2Ef5HgRAPBO57A77+ENm0CPx2+1Ce/MYKi3ymqdfuqibw==",
      "dev": true,
      "requires": {
        "source-map": "^0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "merge-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
      "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
      "dev": true
    },
    "merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true
    },
    "methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha1-VSmk1nZUE07cxSZmVoNbD4Ua/O4="
    },
    "microevent.ts": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/microevent.ts/-/microevent.ts-0.1.1.tgz",
      "integrity": "sha512-jo1OfR4TaEwd5HOrt5+tAZ9mqT4jmpNAusXtyfNzqVm9uiSYFZlKM1wYL4oU7azZW/PxQW53wM0S6OR1JHNa2g=="
    },
    "micromatch": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-3.1.10.tgz",
      "integrity": "sha512-MWikgl9n9M3w+bpsY3He8L+w9eF9338xRl8IAO5viDizwSzziFEyUzo2xrrloB64ADbTf8uA8vRqqttDTOmccg==",
      "requires": {
        "arr-diff": "^4.0.0",
        "array-unique": "^0.3.2",
        "braces": "^2.3.1",
        "define-property": "^2.0.2",
        "extend-shallow": "^3.0.2",
        "extglob": "^2.0.4",
        "fragment-cache": "^0.2.1",
        "kind-of": "^6.0.2",
        "nanomatch": "^1.2.9",
        "object.pick": "^1.3.0",
        "regex-not": "^1.0.0",
        "snapdragon": "^0.8.1",
        "to-regex": "^3.0.2"
      },
      "dependencies": {
        "braces": {
          "version": "2.3.2",
          "resolved": "https://registry.npmjs.org/braces/-/braces-2.3.2.tgz",
          "integrity": "sha512-aNdbnj9P8PjdXU4ybaWLK2IF3jc/EoDYbC7AazW6to3TRsfXxscC9UXOB5iDiEQrkyIbWp2SLQda4+QAa7nc3w==",
          "requires": {
            "arr-flatten": "^1.1.0",
            "array-unique": "^0.3.2",
            "extend-shallow": "^2.0.1",
            "fill-range": "^4.0.0",
            "isobject": "^3.0.1",
            "repeat-element": "^1.1.2",
            "snapdragon": "^0.8.1",
            "snapdragon-node": "^2.0.1",
            "split-string": "^3.0.2",
            "to-regex": "^3.0.1"
          },
          "dependencies": {
            "extend-shallow": {
              "version": "2.0.1",
              "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
              "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
              "requires": {
                "is-extendable": "^0.1.0"
              }
            }
          }
        },
        "extend-shallow": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
          "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
          "requires": {
            "assign-symbols": "^1.0.0",
            "is-extendable": "^1.0.1"
          },
          "dependencies": {
            "is-extendable": {
              "version": "1.0.1",
              "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
              "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
              "requires": {
                "is-plain-object": "^2.0.4"
              }
            }
          }
        },
        "fill-range": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-4.0.0.tgz",
          "integrity": "sha1-1USBHUKPmOsGpj3EAtJAPDKMOPc=",
          "requires": {
            "extend-shallow": "^2.0.1",
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1",
            "to-regex-range": "^2.1.0"
          },
          "dependencies": {
            "extend-shallow": {
              "version": "2.0.1",
              "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-2.0.1.tgz",
              "integrity": "sha1-Ua99YUrZqfYQ6huvu5idaxxWiQ8=",
              "requires": {
                "is-extendable": "^0.1.0"
              }
            }
          }
        },
        "to-regex-range": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-2.1.1.tgz",
          "integrity": "sha1-fIDBe53+vlmeJzZ+DU3VWQFB2zg=",
          "requires": {
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1"
          }
        }
      }
    },
    "miller-rabin": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/miller-rabin/-/miller-rabin-4.0.1.tgz",
      "integrity": "sha512-115fLhvZVqWwHPbClyntxEVfVDfl9DLLTuJvq3g2O/Oxi8AiNouAHvDSzHS0viUJc+V5vm3eq91Xwqn9dp4jRA==",
      "dev": true,
      "requires": {
        "bn.js": "^4.0.0",
        "brorand": "^1.0.1"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg=="
    },
    "mime-db": {
      "version": "1.44.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.44.0.tgz",
      "integrity": "sha512-/NOTfLrsPBVeH7YtFPgsVWveuL+4SjjYxaQ1xtM1KMFj7HdxlBlxeyNLzhyJVx7r4rZGJAZ/6lkKCitSc/Nmpg=="
    },
    "mime-types": {
      "version": "2.1.27",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.27.tgz",
      "integrity": "sha512-JIhqnCasI9yD+SsmkquHBxTSEuZdQX5BuQnS2Vc7puQQQ+8yiP5AY5uWhpdv4YL4VM5c6iliiYWPgJ/nJQLp7w==",
      "requires": {
        "mime-db": "1.44.0"
      }
    },
    "mimic-fn": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz",
      "integrity": "sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg=="
    },
    "mini-css-extract-plugin": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/mini-css-extract-plugin/-/mini-css-extract-plugin-0.9.0.tgz",
      "integrity": "sha512-lp3GeY7ygcgAmVIcRPBVhIkf8Us7FZjA+ILpal44qLdSu11wmjKQ3d9k15lfD7pO4esu9eUIAW7qiYIBppv40A==",
      "dev": true,
      "requires": {
        "loader-utils": "^1.1.0",
        "normalize-url": "1.9.1",
        "schema-utils": "^1.0.0",
        "webpack-sources": "^1.1.0"
      },
      "dependencies": {
        "normalize-url": {
          "version": "1.9.1",
          "resolved": "https://registry.npmjs.org/normalize-url/-/normalize-url-1.9.1.tgz",
          "integrity": "sha1-LMDWazHqIwNkWENuNiDYWVTGbDw=",
          "dev": true,
          "requires": {
            "object-assign": "^4.0.1",
            "prepend-http": "^1.0.0",
            "query-string": "^4.1.0",
            "sort-keys": "^1.0.0"
          }
        },
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        }
      }
    },
    "minimalistic-assert": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-assert/-/minimalistic-assert-1.0.1.tgz",
      "integrity": "sha512-UtJcAD4yEaGtjPezWuO9wC4nwUnVH/8/Im3yEHQP4b67cXlD/Qr9hdITCU1xDbSEXg2XKNaP8jsReV7vQd00/A==",
      "dev": true
    },
    "minimalistic-crypto-utils": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz",
      "integrity": "sha1-9sAMHAsIIkblxNmd+4x8CDsrWCo=",
      "dev": true
    },
    "minimatch": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz",
      "integrity": "sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==",
      "requires": {
        "brace-expansion": "^1.1.7"
      }
    },
    "minimist": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz",
      "integrity": "sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw=="
    },
    "minipass": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.1.1.tgz",
      "integrity": "sha512-UFqVihv6PQgwj8/yTGvl9kPz7xIAY+R5z6XYjRInD3Gk3qx6QGSD6zEcpeG4Dy/lQnv1J6zv8ejV90hyYIKf3w==",
      "dev": true,
      "requires": {
        "yallist": "^4.0.0"
      }
    },
    "minipass-collect": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/minipass-collect/-/minipass-collect-1.0.2.tgz",
      "integrity": "sha512-6T6lH0H8OG9kITm/Jm6tdooIbogG9e0tLgpY6mphXSm/A9u8Nq1ryBG+Qspiub9LjWlBPsPS3tWQ/Botq4FdxA==",
      "dev": true,
      "requires": {
        "minipass": "^3.0.0"
      }
    },
    "minipass-flush": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/minipass-flush/-/minipass-flush-1.0.5.tgz",
      "integrity": "sha512-JmQSYYpPUqX5Jyn1mXaRwOda1uQ8HP5KAT/oDSLCzt1BYRhQU0/hDtsB1ufZfEEzMZ9aAVmsBw8+FWsIXlClWw==",
      "dev": true,
      "requires": {
        "minipass": "^3.0.0"
      }
    },
    "minipass-pipeline": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/minipass-pipeline/-/minipass-pipeline-1.2.2.tgz",
      "integrity": "sha512-3JS5A2DKhD2g0Gg8x3yamO0pj7YeKGwVlDS90pF++kxptwx/F+B//roxf9SqYil5tQo65bijy+dAuAFZmYOouA==",
      "dev": true,
      "requires": {
        "minipass": "^3.0.0"
      }
    },
    "minizlib": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.0.tgz",
      "integrity": "sha512-EzTZN/fjSvifSX0SlqUERCN39o6T40AMarPbv0MrarSFtIITCBh7bi+dU8nxGFHuqs9jdIAeoYoKuQAAASsPPA==",
      "dev": true,
      "requires": {
        "minipass": "^3.0.0",
        "yallist": "^4.0.0"
      }
    },
    "mississippi": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/mississippi/-/mississippi-3.0.0.tgz",
      "integrity": "sha512-x471SsVjUtBRtcvd4BzKE9kFC+/2TeWgKCgw0bZcw1b9l2X3QX5vCWgF+KaZaYm87Ss//rHnWryupDrgLvmSkA==",
      "dev": true,
      "requires": {
        "concat-stream": "^1.5.0",
        "duplexify": "^3.4.2",
        "end-of-stream": "^1.1.0",
        "flush-write-stream": "^1.0.0",
        "from2": "^2.1.0",
        "parallel-transform": "^1.1.0",
        "pump": "^3.0.0",
        "pumpify": "^1.3.3",
        "stream-each": "^1.1.0",
        "through2": "^2.0.0"
      }
    },
    "mixin-deep": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/mixin-deep/-/mixin-deep-1.3.2.tgz",
      "integrity": "sha512-WRoDn//mXBiJ1H40rqa3vH0toePwSsGb45iInWlTySa+Uu4k3tYUSxa2v1KqAiLtvlrSzaExqS1gtk96A9zvEA==",
      "requires": {
        "for-in": "^1.0.2",
        "is-extendable": "^1.0.1"
      },
      "dependencies": {
        "is-extendable": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
          "requires": {
            "is-plain-object": "^2.0.4"
          }
        }
      }
    },
    "mkdirp": {
      "version": "0.5.5",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz",
      "integrity": "sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==",
      "requires": {
        "minimist": "^1.2.5"
      }
    },
    "mocha": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/mocha/-/mocha-7.1.2.tgz",
      "integrity": "sha512-o96kdRKMKI3E8U0bjnfqW4QMk12MwZ4mhdBTf+B5a1q9+aq2HRnj+3ZdJu0B/ZhJeK78MgYuv6L8d/rA5AeBJA==",
      "dev": true,
      "requires": {
        "ansi-colors": "3.2.3",
        "browser-stdout": "1.3.1",
        "chokidar": "3.3.0",
        "debug": "3.2.6",
        "diff": "3.5.0",
        "escape-string-regexp": "1.0.5",
        "find-up": "3.0.0",
        "glob": "7.1.3",
        "growl": "1.10.5",
        "he": "1.2.0",
        "js-yaml": "3.13.1",
        "log-symbols": "3.0.0",
        "minimatch": "3.0.4",
        "mkdirp": "0.5.5",
        "ms": "2.1.1",
        "node-environment-flags": "1.0.6",
        "object.assign": "4.1.0",
        "strip-json-comments": "2.0.1",
        "supports-color": "6.0.0",
        "which": "1.3.1",
        "wide-align": "1.1.3",
        "yargs": "13.3.2",
        "yargs-parser": "13.1.2",
        "yargs-unparser": "1.6.0"
      },
      "dependencies": {
        "ansi-colors": {
          "version": "3.2.3",
          "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-3.2.3.tgz",
          "integrity": "sha512-LEHHyuhlPY3TmuUYMh2oz89lTShfvgbmzaBcxve9t/9Wuy7Dwf4yoAKcND7KFT1HAQfqZ12qtc+DUrBMeKF9nw==",
          "dev": true
        },
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "chokidar": {
          "version": "3.3.0",
          "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.3.0.tgz",
          "integrity": "sha512-dGmKLDdT3Gdl7fBUe8XK+gAtGmzy5Fn0XkkWQuYxGIgWVPPse2CxFA5mtrlD0TOHaHjEUqkWNyP1XdHoJES/4A==",
          "dev": true,
          "requires": {
            "anymatch": "~3.1.1",
            "braces": "~3.0.2",
            "fsevents": "~2.1.1",
            "glob-parent": "~5.1.0",
            "is-binary-path": "~2.1.0",
            "is-glob": "~4.0.1",
            "normalize-path": "~3.0.0",
            "readdirp": "~3.2.0"
          }
        },
        "cliui": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-5.0.0.tgz",
          "integrity": "sha512-PYeGSEmmHM6zvoef2w8TPzlrnNpXIjTipYK780YswmIP9vjxmd6Y2a3CB2Ks6/AU8NHjZugXvo8w3oWM2qnwXA==",
          "dev": true,
          "requires": {
            "string-width": "^3.1.0",
            "strip-ansi": "^5.2.0",
            "wrap-ansi": "^5.1.0"
          }
        },
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        },
        "emoji-regex": {
          "version": "7.0.3",
          "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
          "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
          "dev": true
        },
        "find-up": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
          "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
          "dev": true,
          "requires": {
            "locate-path": "^3.0.0"
          }
        },
        "get-caller-file": {
          "version": "2.0.5",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
          "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
          "dev": true
        },
        "glob": {
          "version": "7.1.3",
          "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.3.tgz",
          "integrity": "sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==",
          "dev": true,
          "requires": {
            "fs.realpath": "^1.0.0",
            "inflight": "^1.0.4",
            "inherits": "2",
            "minimatch": "^3.0.4",
            "once": "^1.3.0",
            "path-is-absolute": "^1.0.0"
          }
        },
        "locate-path": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
          "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
          "dev": true,
          "requires": {
            "p-locate": "^3.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "ms": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.1.tgz",
          "integrity": "sha512-tgp+dl5cGk28utYktBsrFqA7HKgrhgPsg6Z/EfhWI4gl1Hwq8B/GmY/0oXZ6nF8hDVesS/FpnYaD/kOWhYQvyg==",
          "dev": true
        },
        "p-locate": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
          "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
          "dev": true,
          "requires": {
            "p-limit": "^2.0.0"
          }
        },
        "readdirp": {
          "version": "3.2.0",
          "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.2.0.tgz",
          "integrity": "sha512-crk4Qu3pmXwgxdSgGhgA/eXiJAPQiX4GMOZZMXnqKxHX7TaoL+3gQVo/WeuAiogr07DpnfjIMpXXa+PAIvwPGQ==",
          "dev": true,
          "requires": {
            "picomatch": "^2.0.4"
          }
        },
        "require-main-filename": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
          "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
          "dev": true
        },
        "string-width": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
          "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
          "dev": true,
          "requires": {
            "emoji-regex": "^7.0.1",
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^5.1.0"
          }
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        },
        "supports-color": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.0.0.tgz",
          "integrity": "sha512-on9Kwidc1IUQo+bQdhi8+Tijpo0e1SS6RoGo2guUwn5vdaxw8RXOF9Vb2ws+ihWOmh4JnCJOvaziZWP1VABaLg==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "wrap-ansi": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-5.1.0.tgz",
          "integrity": "sha512-QC1/iN/2/RPVJ5jYK8BGttj5z83LmSKmvbvrXPNCLZSEb32KKVDJDl/MOt2N01qU2H/FkzEa9PKto1BqDjtd7Q==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.0",
            "string-width": "^3.0.0",
            "strip-ansi": "^5.0.0"
          }
        },
        "yargs": {
          "version": "13.3.2",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-13.3.2.tgz",
          "integrity": "sha512-AX3Zw5iPruN5ie6xGRIDgqkT+ZhnRlZMLMHAs8tg7nRruy2Nb+i5o9bwghAogtM08q1dpr2LVoS8KSTMYpWXUw==",
          "dev": true,
          "requires": {
            "cliui": "^5.0.0",
            "find-up": "^3.0.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^3.0.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^13.1.2"
          }
        },
        "yargs-parser": {
          "version": "13.1.2",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-13.1.2.tgz",
          "integrity": "sha512-3lbsNRf/j+A4QuSZfDRA7HRSfWrzO0YjqTJd5kjAq37Zep1CEgaYmrH9Q3GwPiB9cHyd1Y1UwggGhJGoxipbzg==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "moment": {
      "version": "2.29.1",
      "resolved": "https://registry.npmjs.org/moment/-/moment-2.29.1.tgz",
      "integrity": "sha512-kHmoybcPV8Sqy59DwNDY3Jefr64lK/by/da0ViFcuA4DH0vQg5Q6Ze5VimxkfQNSC+Mls/Kx53s7TjP1RhFEDQ==",
      "dev": true
    },
    "move-concurrently": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/move-concurrently/-/move-concurrently-1.0.1.tgz",
      "integrity": "sha1-viwAX9oy4LKa8fBdfEszIUxwH5I=",
      "dev": true,
      "requires": {
        "aproba": "^1.1.1",
        "copy-concurrently": "^1.0.0",
        "fs-write-stream-atomic": "^1.0.8",
        "mkdirp": "^0.5.1",
        "rimraf": "^2.5.4",
        "run-queue": "^1.0.3"
      },
      "dependencies": {
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        }
      }
    },
    "move-file": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/move-file/-/move-file-2.0.0.tgz",
      "integrity": "sha512-cdkdhNCgbP5dvS4tlGxZbD+nloio9GIimP57EjqFhwLcMjnU+XJKAZzlmg/TN/AK1LuNAdTSvm3CPPP4Xkv0iQ==",
      "dev": true,
      "requires": {
        "path-exists": "^4.0.0"
      },
      "dependencies": {
        "path-exists": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
          "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
          "dev": true
        }
      }
    },
    "ms": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
      "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w=="
    },
    "multer": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-1.4.2.tgz",
      "integrity": "sha512-xY8pX7V+ybyUpbYMxtjM9KAiD9ixtg5/JkeKUTD6xilfDv0vzzOFcCp4Ljb1UU3tSOM3VTZtKo63OmzOrGi3Cg==",
      "requires": {
        "append-field": "^1.0.0",
        "busboy": "^0.2.11",
        "concat-stream": "^1.5.2",
        "mkdirp": "^0.5.1",
        "object-assign": "^4.1.1",
        "on-finished": "^2.3.0",
        "type-is": "^1.6.4",
        "xtend": "^4.0.0"
      }
    },
    "multicast-dns": {
      "version": "6.2.3",
      "resolved": "https://registry.npmjs.org/multicast-dns/-/multicast-dns-6.2.3.tgz",
      "integrity": "sha512-ji6J5enbMyGRHIAkAOu3WdV8nggqviKCEKtXcOqfphZZtQrmHKycfynJ2V7eVPUA4NhJ6V7Wf4TmGbTwKE9B6g==",
      "dev": true,
      "requires": {
        "dns-packet": "^1.3.1",
        "thunky": "^1.0.2"
      }
    },
    "multicast-dns-service-types": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/multicast-dns-service-types/-/multicast-dns-service-types-1.1.0.tgz",
      "integrity": "sha1-iZ8R2WhuXgXLkbNdXw5jt3PPyQE=",
      "dev": true
    },
    "mute-stream": {
      "version": "0.0.8",
      "resolved": "https://registry.npmjs.org/mute-stream/-/mute-stream-0.0.8.tgz",
      "integrity": "sha512-nnbWWOkoWyUsTjKrhgD0dcz22mdkSnpYqbEjIm2nhwhuxlSkpywJmBo8h0ZqJdkp73mb90SssHkN4rsRaBAfAA=="
    },
    "nan": {
      "version": "2.14.1",
      "resolved": "https://registry.npmjs.org/nan/-/nan-2.14.1.tgz",
      "integrity": "sha512-isWHgVjnFjh2x2yuJ/tj3JbwoHu3UC2dX5G/88Cm24yB6YopVgxvBObDY7n5xW6ExmFhJpSEQqFPvq9zaXc8Jw==",
      "dev": true,
      "optional": true
    },
    "nanomatch": {
      "version": "1.2.13",
      "resolved": "https://registry.npmjs.org/nanomatch/-/nanomatch-1.2.13.tgz",
      "integrity": "sha512-fpoe2T0RbHwBTBUOftAfBPaDEi06ufaUai0mE6Yn1kacc3SnTErfb/h+X94VXzI64rKFHYImXSvdwGGCmwOqCA==",
      "requires": {
        "arr-diff": "^4.0.0",
        "array-unique": "^0.3.2",
        "define-property": "^2.0.2",
        "extend-shallow": "^3.0.2",
        "fragment-cache": "^0.2.1",
        "is-windows": "^1.0.2",
        "kind-of": "^6.0.2",
        "object.pick": "^1.3.0",
        "regex-not": "^1.0.0",
        "snapdragon": "^0.8.1",
        "to-regex": "^3.0.1"
      },
      "dependencies": {
        "extend-shallow": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
          "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
          "requires": {
            "assign-symbols": "^1.0.0",
            "is-extendable": "^1.0.1"
          }
        },
        "is-extendable": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
          "requires": {
            "is-plain-object": "^2.0.4"
          }
        }
      }
    },
    "native-request": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/native-request/-/native-request-1.0.7.tgz",
      "integrity": "sha512-9nRjinI9bmz+S7dgNtf4A70+/vPhnd+2krGpy4SUlADuOuSa24IDkNaZ+R/QT1wQ6S8jBdi6wE7fLekFZNfUpQ==",
      "dev": true,
      "optional": true
    },
    "natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha1-Sr6/7tdUHywnrPspvbvRXI1bpPc=",
      "dev": true
    },
    "negotiator": {
      "version": "0.6.2",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.2.tgz",
      "integrity": "sha512-hZXc7K2e+PgeI1eDBe/10Ard4ekbfrrqG8Ep+8Jmf4JID2bNg7NvCPOZN+kfF574pFQI7mum2AUqDidoKqcTOw=="
    },
    "neo-async": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/neo-async/-/neo-async-2.6.1.tgz",
      "integrity": "sha512-iyam8fBuCUpWeKPGpaNMetEocMt364qkCsfL9JuhjXX6dRnguRVOfk2GZaDpPjcOKiiXCPINZC1GczQ7iTq3Zw==",
      "dev": true
    },
    "next-tick": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/next-tick/-/next-tick-1.0.0.tgz",
      "integrity": "sha1-yobR/ogoFpsBICCOPchCS524NCw="
    },
    "nice-try": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/nice-try/-/nice-try-1.0.5.tgz",
      "integrity": "sha512-1nh45deeb5olNY7eX82BkPO7SSxR5SSYJiPTrTdFUVYwAl8CKMA5N9PjTYkHiRjisVcxcQ1HXdLhx2qxxJzLNQ==",
      "dev": true
    },
    "nise": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/nise/-/nise-4.0.3.tgz",
      "integrity": "sha512-EGlhjm7/4KvmmE6B/UFsKh7eHykRl9VH+au8dduHLCyWUO/hr7+N+WtTvDUwc9zHuM1IaIJs/0lQ6Ag1jDkQSg==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1.7.0",
        "@sinonjs/fake-timers": "^6.0.0",
        "@sinonjs/text-encoding": "^0.7.1",
        "just-extend": "^4.0.2",
        "path-to-regexp": "^1.7.0"
      },
      "dependencies": {
        "isarray": {
          "version": "0.0.1",
          "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
          "integrity": "sha1-ihis/Kmo9Bd+Cav8YDiTmwXR7t8=",
          "dev": true
        },
        "path-to-regexp": {
          "version": "1.8.0",
          "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-1.8.0.tgz",
          "integrity": "sha512-n43JRhlUKUAlibEJhPeir1ncUID16QnEjNpwzNdO3Lm4ywrBpBZ5oLD0I6br9evr1Y9JTqwRtAh7JLoOzAQdVA==",
          "dev": true,
          "requires": {
            "isarray": "0.0.1"
          }
        }
      }
    },
    "node-environment-flags": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/node-environment-flags/-/node-environment-flags-1.0.6.tgz",
      "integrity": "sha512-5Evy2epuL+6TM0lCQGpFIj6KwiEsGh1SrHUhTbNX+sLbBtjidPZFAnVK9y5yU1+h//RitLbRHTIMyxQPtxMdHw==",
      "dev": true,
      "requires": {
        "object.getownpropertydescriptors": "^2.0.3",
        "semver": "^5.7.0"
      }
    },
    "node-fetch": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.0.tgz",
      "integrity": "sha512-8dG4H5ujfvFiqDmVu9fQ5bOHUC15JMjMY/Zumv26oOvvVJjM67KF8koCWIabKQ1GJIa9r2mMZscBq/TbdOcmNA=="
    },
    "node-fetch-npm": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/node-fetch-npm/-/node-fetch-npm-2.0.4.tgz",
      "integrity": "sha512-iOuIQDWDyjhv9qSDrj9aq/klt6F9z1p2otB3AV7v3zBDcL/x+OfGsvGQZZCcMZbUf4Ujw1xGNQkjvGnVT22cKg==",
      "dev": true,
      "requires": {
        "encoding": "^0.1.11",
        "json-parse-better-errors": "^1.0.0",
        "safe-buffer": "^5.1.1"
      }
    },
    "node-forge": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-0.9.0.tgz",
      "integrity": "sha512-7ASaDa3pD+lJ3WvXFsxekJQelBKRpne+GOVbLbtHYdd7pFspyeuJHnWfLplGf3SwKGbfs/aYl5V/JCIaHVUKKQ==",
      "dev": true
    },
    "node-int64": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/node-int64/-/node-int64-0.4.0.tgz",
      "integrity": "sha1-h6kGXNs1XTGC2PlM4RGIuCXGijs=",
      "dev": true
    },
    "node-libs-browser": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/node-libs-browser/-/node-libs-browser-2.2.1.tgz",
      "integrity": "sha512-h/zcD8H9kaDZ9ALUWwlBUDo6TKF8a7qBSCSEGfjTVIYeqsioSKaAX+BN7NgiMGp6iSIXZ3PxgCu8KS3b71YK5Q==",
      "dev": true,
      "requires": {
        "assert": "^1.1.1",
        "browserify-zlib": "^0.2.0",
        "buffer": "^4.3.0",
        "console-browserify": "^1.1.0",
        "constants-browserify": "^1.0.0",
        "crypto-browserify": "^3.11.0",
        "domain-browser": "^1.1.1",
        "events": "^3.0.0",
        "https-browserify": "^1.0.0",
        "os-browserify": "^0.3.0",
        "path-browserify": "0.0.1",
        "process": "^0.11.10",
        "punycode": "^1.2.4",
        "querystring-es3": "^0.2.0",
        "readable-stream": "^2.3.3",
        "stream-browserify": "^2.0.1",
        "stream-http": "^2.7.2",
        "string_decoder": "^1.0.0",
        "timers-browserify": "^2.0.4",
        "tty-browserify": "0.0.0",
        "url": "^0.11.0",
        "util": "^0.11.0",
        "vm-browserify": "^1.0.1"
      },
      "dependencies": {
        "punycode": {
          "version": "1.4.1",
          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.4.1.tgz",
          "integrity": "sha1-wNWmOycYgArY4esPpSachN1BhF4=",
          "dev": true
        }
      }
    },
    "node-localstorage": {
      "version": "2.1.6",
      "resolved": "https://registry.npmjs.org/node-localstorage/-/node-localstorage-2.1.6.tgz",
      "integrity": "sha512-yE7AycE5G2hU55d+F7Ona9nx97C+enJzWWx6jrsji7fuPZFJOvuW3X/LKKAcXRBcEIJPDOKt8ZiFWFmShR/irg==",
      "requires": {
        "write-file-atomic": "^1.1.4"
      },
      "dependencies": {
        "write-file-atomic": {
          "version": "1.3.4",
          "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-1.3.4.tgz",
          "integrity": "sha1-+Aek8LHZ6ROuekgRLmzDrxmRtF8=",
          "requires": {
            "graceful-fs": "^4.1.11",
            "imurmurhash": "^0.1.4",
            "slide": "^1.1.5"
          }
        }
      }
    },
    "node-modules-regexp": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/node-modules-regexp/-/node-modules-regexp-1.0.0.tgz",
      "integrity": "sha1-jZ2+KJZKSsVxLpExZCEHxx6Q7EA=",
      "dev": true
    },
    "node-notifier": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/node-notifier/-/node-notifier-6.0.0.tgz",
      "integrity": "sha512-SVfQ/wMw+DesunOm5cKqr6yDcvUTDl/yc97ybGHMrteNEY6oekXpNpS3lZwgLlwz0FLgHoiW28ZpmBHUDg37cw==",
      "dev": true,
      "optional": true,
      "requires": {
        "growly": "^1.3.0",
        "is-wsl": "^2.1.1",
        "semver": "^6.3.0",
        "shellwords": "^0.1.1",
        "which": "^1.3.1"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true,
          "optional": true
        }
      }
    },
    "node-releases": {
      "version": "1.1.54",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-1.1.54.tgz",
      "integrity": "sha512-tLzytKpgwKQr37yw9CEODjNM9lnmsNxzlv575GzOZ16AgMvPcJis/DgrJX4UEV1KIYoXk6XoVfY6YaMOPJESAQ=="
    },
    "normalize-package-data": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/normalize-package-data/-/normalize-package-data-2.5.0.tgz",
      "integrity": "sha512-/5CMN3T0R4XTj4DcGaexo+roZSdSFW/0AOOTROrjxzCG1wrWXEsGbRKevjlIL+ZDE4sZlJr5ED4YW0yqmkK+eA==",
      "dev": true,
      "requires": {
        "hosted-git-info": "^2.1.4",
        "resolve": "^1.10.0",
        "semver": "2 || 3 || 4 || 5",
        "validate-npm-package-license": "^3.0.1"
      },
      "dependencies": {
        "hosted-git-info": {
          "version": "2.8.8",
          "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.8.8.tgz",
          "integrity": "sha512-f/wzC2QaWBs7t9IYqB4T3sR1xviIViXJRJTWBlx2Gf3g0Xi5vI7Yy4koXQ1c9OYDGHN9sBy1DQ2AB8fqZBWhUg==",
          "dev": true
        }
      }
    },
    "normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA=="
    },
    "normalize-range": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/normalize-range/-/normalize-range-0.1.2.tgz",
      "integrity": "sha1-LRDAa9/TEuqXd2laTShDlFa3WUI=",
      "dev": true
    },
    "normalize-url": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/normalize-url/-/normalize-url-3.3.0.tgz",
      "integrity": "sha512-U+JJi7duF1o+u2pynbp2zXDW2/PADgC30f0GsHZtRh+HOcXHnw137TrNlyxxRvWW5fjKd3bcLHPxofWuCjaeZg==",
      "dev": true
    },
    "normalize.css": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/normalize.css/-/normalize.css-8.0.1.tgz",
      "integrity": "sha512-qizSNPO93t1YUuUhP22btGOo3chcvDFqFaj2TRybP0DMxkHOCTYwp3n34fel4a31ORXy4m1Xq0Gyqpb5m33qIg==",
      "dev": true
    },
    "npm-bundled": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/npm-bundled/-/npm-bundled-1.1.1.tgz",
      "integrity": "sha512-gqkfgGePhTpAEgUsGEgcq1rqPXA+tv/aVBlgEzfXwA1yiUJF7xtEt3CtVwOjNYQOVknDk0F20w58Fnm3EtG0fA==",
      "dev": true,
      "requires": {
        "npm-normalize-package-bin": "^1.0.1"
      }
    },
    "npm-install-checks": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/npm-install-checks/-/npm-install-checks-4.0.0.tgz",
      "integrity": "sha512-09OmyDkNLYwqKPOnbI8exiOZU2GVVmQp7tgez2BPi5OZC8M82elDAps7sxC4l//uSUtotWqoEIDwjRvWH4qz8w==",
      "dev": true,
      "requires": {
        "semver": "^7.1.1"
      },
      "dependencies": {
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        }
      }
    },
    "npm-normalize-package-bin": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/npm-normalize-package-bin/-/npm-normalize-package-bin-1.0.1.tgz",
      "integrity": "sha512-EPfafl6JL5/rU+ot6P3gRSCpPDW5VmIzX959Ob1+ySFUuuYHWHekXpwdUZcKP5C+DS4GEtdJluwBjnsNDl+fSA==",
      "dev": true
    },
    "npm-package-arg": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/npm-package-arg/-/npm-package-arg-8.0.1.tgz",
      "integrity": "sha512-/h5Fm6a/exByzFSTm7jAyHbgOqErl9qSNJDQF32Si/ZzgwT2TERVxRxn3Jurw1wflgyVVAxnFR4fRHPM7y1ClQ==",
      "dev": true,
      "requires": {
        "hosted-git-info": "^3.0.2",
        "semver": "^7.0.0",
        "validate-npm-package-name": "^3.0.0"
      },
      "dependencies": {
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        }
      }
    },
    "npm-packlist": {
      "version": "1.4.8",
      "resolved": "https://registry.npmjs.org/npm-packlist/-/npm-packlist-1.4.8.tgz",
      "integrity": "sha512-5+AZgwru5IevF5ZdnFglB5wNlHG1AOOuw28WhUq8/8emhBmLv6jX5by4WJCh7lW0uSYZYS6DXqIsyZVIXRZU9A==",
      "dev": true,
      "requires": {
        "ignore-walk": "^3.0.1",
        "npm-bundled": "^1.0.1",
        "npm-normalize-package-bin": "^1.0.1"
      }
    },
    "npm-pick-manifest": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/npm-pick-manifest/-/npm-pick-manifest-6.1.0.tgz",
      "integrity": "sha512-ygs4k6f54ZxJXrzT0x34NybRlLeZ4+6nECAIbr2i0foTnijtS1TJiyzpqtuUAJOps/hO0tNDr8fRV5g+BtRlTw==",
      "dev": true,
      "requires": {
        "npm-install-checks": "^4.0.0",
        "npm-package-arg": "^8.0.0",
        "semver": "^7.0.0"
      },
      "dependencies": {
        "semver": {
          "version": "7.3.2",
          "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.2.tgz",
          "integrity": "sha512-OrOb32TeeambH6UrhtShmF7CRDqhL6/5XpPNp2DuRH6+9QLw/orhp72j87v8Qa1ScDkvrrBNpZcDejAirJmfXQ==",
          "dev": true
        }
      }
    },
    "npm-registry-fetch": {
      "version": "4.0.7",
      "resolved": "https://registry.npmjs.org/npm-registry-fetch/-/npm-registry-fetch-4.0.7.tgz",
      "integrity": "sha512-cny9v0+Mq6Tjz+e0erFAB+RYJ/AVGzkjnISiobqP8OWj9c9FLoZZu8/SPSKJWE17F1tk4018wfjV+ZbIbqC7fQ==",
      "dev": true,
      "requires": {
        "JSONStream": "^1.3.4",
        "bluebird": "^3.5.1",
        "figgy-pudding": "^3.4.1",
        "lru-cache": "^5.1.1",
        "make-fetch-happen": "^5.0.0",
        "npm-package-arg": "^6.1.0",
        "safe-buffer": "^5.2.0"
      },
      "dependencies": {
        "hosted-git-info": {
          "version": "2.8.8",
          "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.8.8.tgz",
          "integrity": "sha512-f/wzC2QaWBs7t9IYqB4T3sR1xviIViXJRJTWBlx2Gf3g0Xi5vI7Yy4koXQ1c9OYDGHN9sBy1DQ2AB8fqZBWhUg==",
          "dev": true
        },
        "npm-package-arg": {
          "version": "6.1.1",
          "resolved": "https://registry.npmjs.org/npm-package-arg/-/npm-package-arg-6.1.1.tgz",
          "integrity": "sha512-qBpssaL3IOZWi5vEKUKW0cO7kzLeT+EQO9W8RsLOZf76KF9E/K9+wH0C7t06HXPpaH8WH5xF1MExLuCwbTqRUg==",
          "dev": true,
          "requires": {
            "hosted-git-info": "^2.7.1",
            "osenv": "^0.1.5",
            "semver": "^5.6.0",
            "validate-npm-package-name": "^3.0.0"
          }
        }
      }
    },
    "npm-run-all": {
      "version": "4.1.5",
      "resolved": "https://registry.npmjs.org/npm-run-all/-/npm-run-all-4.1.5.tgz",
      "integrity": "sha512-Oo82gJDAVcaMdi3nuoKFavkIHBRVqQ1qvMb+9LHk/cF4P6B2m8aP04hGf7oL6wZ9BuGwX1onlLhpuoofSyoQDQ==",
      "dev": true,
      "requires": {
        "ansi-styles": "^3.2.1",
        "chalk": "^2.4.1",
        "cross-spawn": "^6.0.5",
        "memorystream": "^0.3.1",
        "minimatch": "^3.0.4",
        "pidtree": "^0.3.0",
        "read-pkg": "^3.0.0",
        "shell-quote": "^1.6.1",
        "string.prototype.padend": "^3.0.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "npm-run-path": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-2.0.2.tgz",
      "integrity": "sha1-NakjLfo11wZ7TLLd8jV7GHFTbF8=",
      "dev": true,
      "requires": {
        "path-key": "^2.0.0"
      }
    },
    "nth-check": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/nth-check/-/nth-check-1.0.2.tgz",
      "integrity": "sha512-WeBOdju8SnzPN5vTUJYxYUxLeXpCaVP5i5e0LF8fg7WORF2Wd7wFX/pk0tYZk7s8T+J7VLy0Da6J1+wCT0AtHg==",
      "dev": true,
      "requires": {
        "boolbase": "~1.0.0"
      }
    },
    "num2fraction": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/num2fraction/-/num2fraction-1.2.2.tgz",
      "integrity": "sha1-b2gragJ6Tp3fpFZM0lidHU5mnt4=",
      "dev": true
    },
    "number-is-nan": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/number-is-nan/-/number-is-nan-1.0.1.tgz",
      "integrity": "sha1-CXtgK1NCKlIsGvuHkDGDNpQaAR0=",
      "dev": true
    },
    "nwsapi": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/nwsapi/-/nwsapi-2.2.0.tgz",
      "integrity": "sha512-h2AatdwYH+JHiZpv7pt/gSX1XoRGb7L/qSIeuqA6GwYoF9w1vP1cw42TO0aI2pNyshRK5893hNSl+1//vHK7hQ==",
      "dev": true
    },
    "oauth-sign": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/oauth-sign/-/oauth-sign-0.9.0.tgz",
      "integrity": "sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ==",
      "dev": true
    },
    "object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM="
    },
    "object-copy": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/object-copy/-/object-copy-0.1.0.tgz",
      "integrity": "sha1-fn2Fi3gb18mRpBupde04EnVOmYw=",
      "requires": {
        "copy-descriptor": "^0.1.0",
        "define-property": "^0.2.5",
        "kind-of": "^3.0.3"
      },
      "dependencies": {
        "define-property": {
          "version": "0.2.5",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
          "requires": {
            "is-descriptor": "^0.1.0"
          }
        },
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "object-hash": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/object-hash/-/object-hash-2.0.3.tgz",
      "integrity": "sha512-JPKn0GMu+Fa3zt3Bmr66JhokJU5BaNBIh4ZeTlaCBzrBsOeXzwcKKAK1tbLiPKgvwmPXsDvvLHoWh5Bm7ofIYg=="
    },
    "object-inspect": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.7.0.tgz",
      "integrity": "sha512-a7pEHdh1xKIAgTySUGgLMx/xwDZskN1Ud6egYYN3EdRW4ZMPNEDUTF+hwy2LUC+Bl+SyLXANnwz/jyh/qutKUw==",
      "dev": true
    },
    "object-is": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/object-is/-/object-is-1.1.2.tgz",
      "integrity": "sha512-5lHCz+0uufF6wZ7CRFWJN3hp8Jqblpgve06U5CMQ3f//6iDjPr2PEo9MWCjEssDsa+UZEL4PkFpr+BMop6aKzQ==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "object-keys": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz",
      "integrity": "sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA=="
    },
    "object-path": {
      "version": "0.11.4",
      "resolved": "https://registry.npmjs.org/object-path/-/object-path-0.11.4.tgz",
      "integrity": "sha1-NwrnUvvzfePqcKhhwju6iRVpGUk=",
      "dev": true
    },
    "object-visit": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/object-visit/-/object-visit-1.0.1.tgz",
      "integrity": "sha1-95xEk68MU3e1n+OdOV5BBC3QRbs=",
      "requires": {
        "isobject": "^3.0.0"
      }
    },
    "object.assign": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/object.assign/-/object.assign-4.1.0.tgz",
      "integrity": "sha512-exHJeq6kBKj58mqGyTQ9DFvrZC/eR6OwxzoM9YRoGBqrXYonaFyGiFMuc9VZrXf7DarreEwMpurG3dd+CNyW5w==",
      "requires": {
        "define-properties": "^1.1.2",
        "function-bind": "^1.1.1",
        "has-symbols": "^1.0.0",
        "object-keys": "^1.0.11"
      }
    },
    "object.getownpropertydescriptors": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/object.getownpropertydescriptors/-/object.getownpropertydescriptors-2.1.0.tgz",
      "integrity": "sha512-Z53Oah9A3TdLoblT7VKJaTDdXdT+lQO+cNpKVnya5JDe9uLvzu1YyY1yFDFrcxrlRgWrEFH0jJtD/IbuwjcEVg==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1"
      }
    },
    "object.pick": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/object.pick/-/object.pick-1.3.0.tgz",
      "integrity": "sha1-h6EKxMFpS9Lhy/U1kaZhQftd10c=",
      "requires": {
        "isobject": "^3.0.1"
      }
    },
    "object.values": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/object.values/-/object.values-1.1.1.tgz",
      "integrity": "sha512-WTa54g2K8iu0kmS/us18jEmdv1a4Wi//BZ/DTVYEcH0XhLM5NYdpDHja3gt57VrZLcNAO2WGA+KpWsDBaHt6eA==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1",
        "function-bind": "^1.1.1",
        "has": "^1.0.3"
      }
    },
    "obuf": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/obuf/-/obuf-1.1.2.tgz",
      "integrity": "sha512-PX1wu0AmAdPqOL1mWhqmlOd8kOIZQwGZw6rh7uby9fTc5lhaOWFLX3I6R1hrF9k3zUY40e6igsLGkDXK92LJNg==",
      "dev": true
    },
    "on-finished": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
      "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
      "requires": {
        "ee-first": "1.1.1"
      }
    },
    "on-headers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/on-headers/-/on-headers-1.0.2.tgz",
      "integrity": "sha512-pZAE+FJLoyITytdqK0U5s+FIpjN0JP3OzFi/u8Rx+EV5/W+JTWGXG8xFzevE7AjBfDqHv/8vL8qQsIhHnqRkrA==",
      "dev": true
    },
    "once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
      "dev": true,
      "requires": {
        "wrappy": "1"
      }
    },
    "onetime": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-5.1.0.tgz",
      "integrity": "sha512-5NcSkPHhwTVFIQN+TUqXoS5+dlElHXdpAWu9I0HP20YOtIi+aZ0Ct82jdlILDxjLEAWwvm+qj1m6aEtsDVmm6Q==",
      "requires": {
        "mimic-fn": "^2.1.0"
      }
    },
    "open": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/open/-/open-7.0.4.tgz",
      "integrity": "sha512-brSA+/yq+b08Hsr4c8fsEW2CRzk1BmfN3SAK/5VCHQ9bdoZJ4qa/+AfR0xHjlbbZUyPkUHs1b8x1RqdyZdkVqQ==",
      "dev": true,
      "requires": {
        "is-docker": "^2.0.0",
        "is-wsl": "^2.1.1"
      }
    },
    "opn": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/opn/-/opn-5.5.0.tgz",
      "integrity": "sha512-PqHpggC9bLV0VeWcdKhkpxY+3JTzetLSqTCWL/z/tFIbI6G8JCjondXklT1JinczLz2Xib62sSp0T/gKT4KksA==",
      "dev": true,
      "requires": {
        "is-wsl": "^1.1.0"
      },
      "dependencies": {
        "is-wsl": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-1.1.0.tgz",
          "integrity": "sha1-HxbkqiKwTRM2tmGIpmrzxgDDpm0=",
          "dev": true
        }
      }
    },
    "optional": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/optional/-/optional-0.1.4.tgz",
      "integrity": "sha512-gtvrrCfkE08wKcgXaVwQVgwEQ8vel2dc5DDBn9RLQZ3YtmtkBss6A2HY6BnJH4N/4Ku97Ri/SF8sNWE2225WJw==",
      "dev": true
    },
    "optionator": {
      "version": "0.8.3",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.8.3.tgz",
      "integrity": "sha512-+IW9pACdk3XWmmTXG8m3upGUJst5XRGzxMRjXzAuJ1XnIFNvfhjjIuYkDvysnPQ7qzqVzLt78BCruntqRhWQbA==",
      "dev": true,
      "requires": {
        "deep-is": "~0.1.3",
        "fast-levenshtein": "~2.0.6",
        "levn": "~0.3.0",
        "prelude-ls": "~1.1.2",
        "type-check": "~0.3.2",
        "word-wrap": "~1.2.3"
      }
    },
    "ora": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/ora/-/ora-4.0.4.tgz",
      "integrity": "sha512-77iGeVU1cIdRhgFzCK8aw1fbtT1B/iZAvWjS+l/o1x0RShMgxHUZaD2yDpWsNCPwXg9z1ZA78Kbdvr8kBmG/Ww==",
      "requires": {
        "chalk": "^3.0.0",
        "cli-cursor": "^3.1.0",
        "cli-spinners": "^2.2.0",
        "is-interactive": "^1.0.0",
        "log-symbols": "^3.0.0",
        "mute-stream": "0.0.8",
        "strip-ansi": "^6.0.0",
        "wcwidth": "^1.0.1"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg=="
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "original": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/original/-/original-1.0.2.tgz",
      "integrity": "sha512-hyBVl6iqqUOJ8FqRe+l/gS8H+kKYjrEndd5Pm1MfBtsEKA038HkkdbAl/72EAXGyonD/PFsvmVG+EvcIpliMBg==",
      "dev": true,
      "requires": {
        "url-parse": "^1.4.3"
      }
    },
    "os-browserify": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/os-browserify/-/os-browserify-0.3.0.tgz",
      "integrity": "sha1-hUNzx/XCMVkU/Jv8a9gjj92h7Cc=",
      "dev": true
    },
    "os-homedir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-homedir/-/os-homedir-1.0.2.tgz",
      "integrity": "sha1-/7xJiDNuDoM94MFox+8VISGqf7M=",
      "dev": true
    },
    "os-locale": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/os-locale/-/os-locale-3.1.0.tgz",
      "integrity": "sha512-Z8l3R4wYWM40/52Z+S265okfFj8Kt2cC2MKY+xNi3kFs+XGI7WXu/I309QQQYbRW4ijiZ+yxs9pqEhJh0DqW3Q==",
      "dev": true,
      "requires": {
        "execa": "^1.0.0",
        "lcid": "^2.0.0",
        "mem": "^4.0.0"
      }
    },
    "os-tmpdir": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz",
      "integrity": "sha1-u+Z0BseaqFxc/sdm/lc0VV36EnQ=",
      "dev": true
    },
    "osenv": {
      "version": "0.1.5",
      "resolved": "https://registry.npmjs.org/osenv/-/osenv-0.1.5.tgz",
      "integrity": "sha512-0CWcCECdMVc2Rw3U5w9ZjqX6ga6ubk1xDVKxtBQPK7wis/0F2r9T6k4ydGYhecl7YUBxBVxhL5oisPsNxAPe2g==",
      "dev": true,
      "requires": {
        "os-homedir": "^1.0.0",
        "os-tmpdir": "^1.0.0"
      }
    },
    "ospath": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/ospath/-/ospath-1.2.2.tgz",
      "integrity": "sha1-EnZjl3Sj+O8lcvf+QoDg6kVQwHs=",
      "dev": true
    },
    "p-defer": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/p-defer/-/p-defer-1.0.0.tgz",
      "integrity": "sha1-n26xgvbJqozXQwBKfU+WsZaw+ww=",
      "dev": true
    },
    "p-each-series": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/p-each-series/-/p-each-series-2.1.0.tgz",
      "integrity": "sha512-ZuRs1miPT4HrjFa+9fRfOFXxGJfORgelKV9f9nNOWw2gl6gVsRaVDOQP0+MI0G0wGKns1Yacsu0GjOFbTK0JFQ==",
      "dev": true
    },
    "p-finally": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/p-finally/-/p-finally-1.0.0.tgz",
      "integrity": "sha1-P7z7FbiZpEEjs0ttzBi3JDNqLK4=",
      "dev": true
    },
    "p-is-promise": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/p-is-promise/-/p-is-promise-2.1.0.tgz",
      "integrity": "sha512-Y3W0wlRPK8ZMRbNq97l4M5otioeA5lm1z7bkNkxCka8HSPjR0xRWmpCmc9utiaLP9Jb1eD8BgeIxTW4AIF45Pg==",
      "dev": true
    },
    "p-limit": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-2.3.0.tgz",
      "integrity": "sha512-//88mFWSJx8lxCzwdAABTJL2MyWB12+eIY7MDL2SqLmAkeKU9qxRvWuSyTjm3FUmpBEMuFfckAIqEaVGUDxb6w==",
      "requires": {
        "p-try": "^2.0.0"
      }
    },
    "p-locate": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-4.1.0.tgz",
      "integrity": "sha512-R79ZZ/0wAxKGu3oYMlz8jy/kbhsNrS7SKZ7PxEHBgJ5+F2mtFW2fK2cOtBh1cHYkQsbzFV7I+EoRKe6Yt0oK7A==",
      "dev": true,
      "requires": {
        "p-limit": "^2.2.0"
      }
    },
    "p-map": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/p-map/-/p-map-2.1.0.tgz",
      "integrity": "sha512-y3b8Kpd8OAN444hxfBbFfj1FY/RjtTd8tzYwhUqNYXx0fXx2iX4maP4Qr6qhIKbQXI02wTLAda4fYUbDagTUFw==",
      "dev": true
    },
    "p-retry": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/p-retry/-/p-retry-3.0.1.tgz",
      "integrity": "sha512-XE6G4+YTTkT2a0UWb2kjZe8xNwf8bIbnqpc/IS/idOBVhyves0mK5OJgeocjx7q5pvX/6m23xuzVPYT1uGM73w==",
      "dev": true,
      "requires": {
        "retry": "^0.12.0"
      }
    },
    "p-try": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/p-try/-/p-try-2.2.0.tgz",
      "integrity": "sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ=="
    },
    "pacote": {
      "version": "9.5.12",
      "resolved": "https://registry.npmjs.org/pacote/-/pacote-9.5.12.tgz",
      "integrity": "sha512-BUIj/4kKbwWg4RtnBncXPJd15piFSVNpTzY0rysSr3VnMowTYgkGKcaHrbReepAkjTr8lH2CVWRi58Spg2CicQ==",
      "dev": true,
      "requires": {
        "bluebird": "^3.5.3",
        "cacache": "^12.0.2",
        "chownr": "^1.1.2",
        "figgy-pudding": "^3.5.1",
        "get-stream": "^4.1.0",
        "glob": "^7.1.3",
        "infer-owner": "^1.0.4",
        "lru-cache": "^5.1.1",
        "make-fetch-happen": "^5.0.0",
        "minimatch": "^3.0.4",
        "minipass": "^2.3.5",
        "mississippi": "^3.0.0",
        "mkdirp": "^0.5.1",
        "normalize-package-data": "^2.4.0",
        "npm-normalize-package-bin": "^1.0.0",
        "npm-package-arg": "^6.1.0",
        "npm-packlist": "^1.1.12",
        "npm-pick-manifest": "^3.0.0",
        "npm-registry-fetch": "^4.0.0",
        "osenv": "^0.1.5",
        "promise-inflight": "^1.0.1",
        "promise-retry": "^1.1.1",
        "protoduck": "^5.0.1",
        "rimraf": "^2.6.2",
        "safe-buffer": "^5.1.2",
        "semver": "^5.6.0",
        "ssri": "^6.0.1",
        "tar": "^4.4.10",
        "unique-filename": "^1.1.1",
        "which": "^1.3.1"
      },
      "dependencies": {
        "fs-minipass": {
          "version": "1.2.7",
          "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-1.2.7.tgz",
          "integrity": "sha512-GWSSJGFy4e9GUeCcbIkED+bgAoFyj7XF1mV8rma3QW4NIqX9Kyx79N/PF61H5udOV3aY1IaMLs6pGbH71nlCTA==",
          "dev": true,
          "requires": {
            "minipass": "^2.6.0"
          }
        },
        "hosted-git-info": {
          "version": "2.8.8",
          "resolved": "https://registry.npmjs.org/hosted-git-info/-/hosted-git-info-2.8.8.tgz",
          "integrity": "sha512-f/wzC2QaWBs7t9IYqB4T3sR1xviIViXJRJTWBlx2Gf3g0Xi5vI7Yy4koXQ1c9OYDGHN9sBy1DQ2AB8fqZBWhUg==",
          "dev": true
        },
        "minipass": {
          "version": "2.9.0",
          "resolved": "https://registry.npmjs.org/minipass/-/minipass-2.9.0.tgz",
          "integrity": "sha512-wxfUjg9WebH+CUDX/CdbRlh5SmfZiy/hpkxaRI16Y9W56Pa75sWgd/rvFilSgrauD9NyFymP/+JFV3KwzIsJeg==",
          "dev": true,
          "requires": {
            "safe-buffer": "^5.1.2",
            "yallist": "^3.0.0"
          }
        },
        "minizlib": {
          "version": "1.3.3",
          "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-1.3.3.tgz",
          "integrity": "sha512-6ZYMOEnmVsdCeTJVE0W9ZD+pVnE8h9Hma/iOwwRDsdQoePpoX56/8B6z3P9VNwppJuBKNRuFDRNRqRWexT9G9Q==",
          "dev": true,
          "requires": {
            "minipass": "^2.9.0"
          }
        },
        "npm-package-arg": {
          "version": "6.1.1",
          "resolved": "https://registry.npmjs.org/npm-package-arg/-/npm-package-arg-6.1.1.tgz",
          "integrity": "sha512-qBpssaL3IOZWi5vEKUKW0cO7kzLeT+EQO9W8RsLOZf76KF9E/K9+wH0C7t06HXPpaH8WH5xF1MExLuCwbTqRUg==",
          "dev": true,
          "requires": {
            "hosted-git-info": "^2.7.1",
            "osenv": "^0.1.5",
            "semver": "^5.6.0",
            "validate-npm-package-name": "^3.0.0"
          }
        },
        "npm-pick-manifest": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/npm-pick-manifest/-/npm-pick-manifest-3.0.2.tgz",
          "integrity": "sha512-wNprTNg+X5nf+tDi+hbjdHhM4bX+mKqv6XmPh7B5eG+QY9VARfQPfCEH013H5GqfNj6ee8Ij2fg8yk0mzps1Vw==",
          "dev": true,
          "requires": {
            "figgy-pudding": "^3.5.1",
            "npm-package-arg": "^6.0.0",
            "semver": "^5.4.1"
          }
        },
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        },
        "ssri": {
          "version": "6.0.1",
          "resolved": "https://registry.npmjs.org/ssri/-/ssri-6.0.1.tgz",
          "integrity": "sha512-3Wge10hNcT1Kur4PDFwEieXSCMCJs/7WvSACcrMYrNp+b8kDL1/0wJch5Ni2WrtwEa2IO8OsVfeKIciKCDx/QA==",
          "dev": true,
          "requires": {
            "figgy-pudding": "^3.5.1"
          }
        },
        "tar": {
          "version": "4.4.13",
          "resolved": "https://registry.npmjs.org/tar/-/tar-4.4.13.tgz",
          "integrity": "sha512-w2VwSrBoHa5BsSyH+KxEqeQBAllHhccyMFVHtGtdMpF4W7IRWfZjFiQceJPChOeTsSDVUpER2T8FA93pr0L+QA==",
          "dev": true,
          "requires": {
            "chownr": "^1.1.1",
            "fs-minipass": "^1.2.5",
            "minipass": "^2.8.6",
            "minizlib": "^1.2.1",
            "mkdirp": "^0.5.0",
            "safe-buffer": "^5.1.2",
            "yallist": "^3.0.3"
          }
        },
        "yallist": {
          "version": "3.1.1",
          "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
          "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
          "dev": true
        }
      }
    },
    "pako": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/pako/-/pako-1.0.11.tgz",
      "integrity": "sha512-4hLB8Py4zZce5s4yd9XzopqwVv/yGNhV1Bl8NTmCq1763HeK2+EwVTv+leGeL13Dnh2wfbqowVPXCIO0z4taYw==",
      "dev": true
    },
    "parallel-transform": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/parallel-transform/-/parallel-transform-1.2.0.tgz",
      "integrity": "sha512-P2vSmIu38uIlvdcU7fDkyrxj33gTUy/ABO5ZUbGowxNCopBq/OoD42bP4UmMrJoPyk4Uqf0mu3mtWBhHCZD8yg==",
      "dev": true,
      "requires": {
        "cyclist": "^1.0.1",
        "inherits": "^2.0.3",
        "readable-stream": "^2.1.5"
      }
    },
    "parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "requires": {
        "callsites": "^3.0.0"
      },
      "dependencies": {
        "callsites": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
          "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
          "dev": true
        }
      }
    },
    "parse-asn1": {
      "version": "5.1.5",
      "resolved": "https://registry.npmjs.org/parse-asn1/-/parse-asn1-5.1.5.tgz",
      "integrity": "sha512-jkMYn1dcJqF6d5CpU689bq7w/b5ALS9ROVSpQDPrZsqqesUJii9qutvoT5ltGedNXMO2e16YUWIghG9KxaViTQ==",
      "dev": true,
      "requires": {
        "asn1.js": "^4.0.0",
        "browserify-aes": "^1.0.0",
        "create-hash": "^1.1.0",
        "evp_bytestokey": "^1.0.0",
        "pbkdf2": "^3.0.3",
        "safe-buffer": "^5.1.1"
      }
    },
    "parse-json": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-4.0.0.tgz",
      "integrity": "sha1-vjX1Qlvh9/bHRxhPmKeIy5lHfuA=",
      "dev": true,
      "requires": {
        "error-ex": "^1.3.1",
        "json-parse-better-errors": "^1.0.1"
      }
    },
    "parse5": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-4.0.0.tgz",
      "integrity": "sha512-VrZ7eOd3T1Fk4XWNXMgiGBK/z0MG48BWG2uQNU4I72fkQuKUTZpl+u9k+CxEG0twMVzSmXEEz12z5Fnw1jIQFA==",
      "dev": true
    },
    "parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ=="
    },
    "pascalcase": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/pascalcase/-/pascalcase-0.1.1.tgz",
      "integrity": "sha1-s2PlXoAGym/iF4TS2yK9FdeRfxQ="
    },
    "path-browserify": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/path-browserify/-/path-browserify-0.0.1.tgz",
      "integrity": "sha512-BapA40NHICOS+USX9SN4tyhq+A2RrN/Ws5F0Z5aMHDp98Fl86lX8Oti8B7uN93L4Ifv4fHOEA+pQw87gmMO/lQ==",
      "dev": true
    },
    "path-dirname": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/path-dirname/-/path-dirname-1.0.2.tgz",
      "integrity": "sha1-zDPSTVJeCZpTiMAzbG4yuRYGCeA=",
      "dev": true
    },
    "path-exists": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-3.0.0.tgz",
      "integrity": "sha1-zg6+ql94yxiSXqfYENe1mwEP1RU="
    },
    "path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
      "dev": true
    },
    "path-is-inside": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/path-is-inside/-/path-is-inside-1.0.2.tgz",
      "integrity": "sha1-NlQX3t5EQw0cEa9hAn+s8HS9/FM=",
      "dev": true
    },
    "path-key": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-2.0.1.tgz",
      "integrity": "sha1-QRyttXTFoUDTpLGRDUDYDMn0C0A=",
      "dev": true
    },
    "path-parse": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.6.tgz",
      "integrity": "sha512-GSmOT2EbHrINBf9SR7CDELwlJ8AENk3Qn7OikK4nFYAu3Ote2+JYNVvkpAEQm3/TLNEJFD/xZJjzyxg3KBWOzw=="
    },
    "path-to-regexp": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
      "integrity": "sha1-32BBeABfUi8V60SQ5yR6G/qmf4w="
    },
    "path-type": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-3.0.0.tgz",
      "integrity": "sha512-T2ZUsdZFHgA3u4e5PfPbjd7HDDpxPnQb5jN0SrDsjNSuVXHJqtwTnWqG0B1jZrgmJ/7lj1EmVIByWt1gxGkWvg==",
      "dev": true,
      "requires": {
        "pify": "^3.0.0"
      },
      "dependencies": {
        "pify": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-3.0.0.tgz",
          "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=",
          "dev": true
        }
      }
    },
    "pathval": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.0.tgz",
      "integrity": "sha1-uULm1L3mUwBe9rcTYd74cn0GReA=",
      "dev": true
    },
    "pbkdf2": {
      "version": "3.0.17",
      "resolved": "https://registry.npmjs.org/pbkdf2/-/pbkdf2-3.0.17.tgz",
      "integrity": "sha512-U/il5MsrZp7mGg3mSQfn742na2T+1/vHDCG5/iTI3X9MKUuYUZVLQhyRsg06mCgDBTd57TxzgZt7P+fYfjRLtA==",
      "dev": true,
      "requires": {
        "create-hash": "^1.1.2",
        "create-hmac": "^1.1.4",
        "ripemd160": "^2.0.1",
        "safe-buffer": "^5.0.1",
        "sha.js": "^2.4.8"
      }
    },
    "pend": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/pend/-/pend-1.2.0.tgz",
      "integrity": "sha1-elfrVQpng/kRUzH89GY9XI4AelA=",
      "dev": true
    },
    "performance-now": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/performance-now/-/performance-now-2.1.0.tgz",
      "integrity": "sha1-Ywn04OX6kT7BxpMHrjZLSzd8nns=",
      "dev": true
    },
    "picomatch": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.2.2.tgz",
      "integrity": "sha512-q0M/9eZHzmr0AulXyPwNfZjtwZ/RBZlbN3K3CErVrk50T2ASYI7Bye0EvekFY3IP1Nt2DHu0re+V2ZHIpMkuWg=="
    },
    "pidtree": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/pidtree/-/pidtree-0.3.1.tgz",
      "integrity": "sha512-qQbW94hLHEqCg7nhby4yRC7G2+jYHY4Rguc2bjw7Uug4GIJuu1tvf2uHaZv5Q8zdt+WKJ6qK1FOI6amaWUo5FA==",
      "dev": true
    },
    "pify": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/pify/-/pify-4.0.1.tgz",
      "integrity": "sha512-uB80kBFb/tfd68bVleG9T5GGsGPjJrLAUpR5PZIrhBnIaRTQRjqdJSsIKkOP6OAIFbj7GOrcudc5pNjZ+geV2g=="
    },
    "pinkie": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/pinkie/-/pinkie-2.0.4.tgz",
      "integrity": "sha1-clVrgM+g1IqXToDnckjoDtT3+HA=",
      "dev": true
    },
    "pinkie-promise": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/pinkie-promise/-/pinkie-promise-2.0.1.tgz",
      "integrity": "sha1-ITXW36ejWMBprJsXh3YogihFD/o=",
      "dev": true,
      "requires": {
        "pinkie": "^2.0.0"
      }
    },
    "pirates": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.1.tgz",
      "integrity": "sha512-WuNqLTbMI3tmfef2TKxlQmAiLHKtFhlsCZnPIpuv2Ow0RDVO8lfy1Opf4NUzlMXLjPl+Men7AuVdX6TA+s+uGA==",
      "dev": true,
      "requires": {
        "node-modules-regexp": "^1.0.0"
      }
    },
    "pkg-dir": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-3.0.0.tgz",
      "integrity": "sha512-/E57AYkoeQ25qkxMj5PBOVgF8Kiu/h7cYS30Z5+R7WaiCCBfLq58ZI/dSeaEKb9WVJV5n/03QwrN3IeWIFllvw==",
      "requires": {
        "find-up": "^3.0.0"
      },
      "dependencies": {
        "find-up": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
          "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
          "requires": {
            "locate-path": "^3.0.0"
          }
        },
        "locate-path": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
          "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
          "requires": {
            "p-locate": "^3.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-locate": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
          "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
          "requires": {
            "p-limit": "^2.0.0"
          }
        }
      }
    },
    "pkg-up": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/pkg-up/-/pkg-up-2.0.0.tgz",
      "integrity": "sha1-yBmscoBZpGHKscOImivjxJoATX8=",
      "requires": {
        "find-up": "^2.1.0"
      },
      "dependencies": {
        "find-up": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-2.1.0.tgz",
          "integrity": "sha1-RdG35QbHF93UgndaK3eSCjwMV6c=",
          "requires": {
            "locate-path": "^2.0.0"
          }
        },
        "locate-path": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-2.0.0.tgz",
          "integrity": "sha1-K1aLJl7slExtnA3pw9u7ygNUzY4=",
          "requires": {
            "p-locate": "^2.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-limit": {
          "version": "1.3.0",
          "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-1.3.0.tgz",
          "integrity": "sha512-vvcXsLAJ9Dr5rQOPk7toZQZJApBl2K4J6dANSsEuh6QI41JYcsS/qhTGa9ErIUUgK3WNQoJYvylxvjqmiqEA9Q==",
          "requires": {
            "p-try": "^1.0.0"
          }
        },
        "p-locate": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-2.0.0.tgz",
          "integrity": "sha1-IKAQOyIqcMj9OcwuWAaA893l7EM=",
          "requires": {
            "p-limit": "^1.1.0"
          }
        },
        "p-try": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/p-try/-/p-try-1.0.0.tgz",
          "integrity": "sha1-y8ec26+P1CKOE/Yh8rGiN8GyB7M="
        }
      }
    },
    "pn": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/pn/-/pn-1.1.0.tgz",
      "integrity": "sha512-2qHaIQr2VLRFoxe2nASzsV6ef4yOOH+Fi9FBOVH6cqeSgUnoyySPZkxzLuzd+RYOQTRpROA0ztTMqxROKSb/nA==",
      "dev": true
    },
    "pnp-webpack-plugin": {
      "version": "1.6.4",
      "resolved": "https://registry.npmjs.org/pnp-webpack-plugin/-/pnp-webpack-plugin-1.6.4.tgz",
      "integrity": "sha512-7Wjy+9E3WwLOEL30D+m8TSTF7qJJUJLONBnwQp0518siuMxUQUbgZwssaFX+QKlZkjHZcw/IpZCt/H0srrntSg==",
      "dev": true,
      "requires": {
        "ts-pnp": "^1.1.6"
      }
    },
    "portfinder": {
      "version": "1.0.26",
      "resolved": "https://registry.npmjs.org/portfinder/-/portfinder-1.0.26.tgz",
      "integrity": "sha512-Xi7mKxJHHMI3rIUrnm/jjUgwhbYMkp/XKEcZX3aG4BrumLpq3nmoQMX+ClYnDZnZ/New7IatC1no5RX0zo1vXQ==",
      "dev": true,
      "requires": {
        "async": "^2.6.2",
        "debug": "^3.1.1",
        "mkdirp": "^0.5.1"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        }
      }
    },
    "posix-character-classes": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/posix-character-classes/-/posix-character-classes-0.1.1.tgz",
      "integrity": "sha1-AerA/jta9xoqbAL+q7jB/vfgDqs="
    },
    "postcss": {
      "version": "7.0.31",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-7.0.31.tgz",
      "integrity": "sha512-a937VDHE1ftkjk+8/7nj/mrjtmkn69xxzJgRETXdAUU+IgOYPQNJF17haGWbeDxSyk++HA14UA98FurvPyBJOA==",
      "dev": true,
      "requires": {
        "chalk": "^2.4.2",
        "source-map": "^0.6.1",
        "supports-color": "^6.1.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          },
          "dependencies": {
            "supports-color": {
              "version": "5.5.0",
              "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
              "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
              "dev": true,
              "requires": {
                "has-flag": "^3.0.0"
              }
            }
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "supports-color": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.1.0.tgz",
          "integrity": "sha512-qe1jfm1Mg7Nq/NSh6XE24gPXROEVsWHxC1LIx//XNlD9iw7YZQGjZNjYN7xGaEG6iKdA8EtNFW6R0gjnVXp+wQ==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "postcss-calc": {
      "version": "7.0.3",
      "resolved": "https://registry.npmjs.org/postcss-calc/-/postcss-calc-7.0.3.tgz",
      "integrity": "sha512-IB/EAEmZhIMEIhG7Ov4x+l47UaXOS1n2f4FBUk/aKllQhtSCxWhTzn0nJgkqN7fo/jcWySvWTSB6Syk9L+31bA==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.27",
        "postcss-selector-parser": "^6.0.2",
        "postcss-value-parser": "^4.0.2"
      }
    },
    "postcss-colormin": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/postcss-colormin/-/postcss-colormin-4.0.3.tgz",
      "integrity": "sha512-WyQFAdDZpExQh32j0U0feWisZ0dmOtPl44qYmJKkq9xFWY3p+4qnRzCHeNrkeRhwPHz9bQ3mo0/yVkaply0MNw==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "color": "^3.0.0",
        "has": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-convert-values": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-convert-values/-/postcss-convert-values-4.0.1.tgz",
      "integrity": "sha512-Kisdo1y77KUC0Jmn0OXU/COOJbzM8cImvw1ZFsBgBgMgb1iL23Zs/LXRe3r+EZqM3vGYKdQ2YJVQ5VkJI+zEJQ==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-discard-comments": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-discard-comments/-/postcss-discard-comments-4.0.2.tgz",
      "integrity": "sha512-RJutN259iuRf3IW7GZyLM5Sw4GLTOH8FmsXBnv8Ab/Tc2k4SR4qbV4DNbyyY4+Sjo362SyDmW2DQ7lBSChrpkg==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "postcss-discard-duplicates": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-discard-duplicates/-/postcss-discard-duplicates-4.0.2.tgz",
      "integrity": "sha512-ZNQfR1gPNAiXZhgENFfEglF93pciw0WxMkJeVmw8eF+JZBbMD7jp6C67GqJAXVZP2BWbOztKfbsdmMp/k8c6oQ==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "postcss-discard-empty": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-discard-empty/-/postcss-discard-empty-4.0.1.tgz",
      "integrity": "sha512-B9miTzbznhDjTfjvipfHoqbWKwd0Mj+/fL5s1QOz06wufguil+Xheo4XpOnc4NqKYBCNqqEzgPv2aPBIJLox0w==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "postcss-discard-overridden": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-discard-overridden/-/postcss-discard-overridden-4.0.1.tgz",
      "integrity": "sha512-IYY2bEDD7g1XM1IDEsUT4//iEYCxAmP5oDSFMVU/JVvT7gh+l4fmjciLqGgwjdWpQIdb0Che2VX00QObS5+cTg==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "postcss-import": {
      "version": "12.0.1",
      "resolved": "https://registry.npmjs.org/postcss-import/-/postcss-import-12.0.1.tgz",
      "integrity": "sha512-3Gti33dmCjyKBgimqGxL3vcV8w9+bsHwO5UrBawp796+jdardbcFl4RP5w/76BwNL7aGzpKstIfF9I+kdE8pTw==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.1",
        "postcss-value-parser": "^3.2.3",
        "read-cache": "^1.0.0",
        "resolve": "^1.1.7"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-load-config": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-2.1.0.tgz",
      "integrity": "sha512-4pV3JJVPLd5+RueiVVB+gFOAa7GWc25XQcMp86Zexzke69mKf6Nx9LRcQywdz7yZI9n1udOxmLuAwTBypypF8Q==",
      "dev": true,
      "requires": {
        "cosmiconfig": "^5.0.0",
        "import-cwd": "^2.0.0"
      }
    },
    "postcss-loader": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/postcss-loader/-/postcss-loader-3.0.0.tgz",
      "integrity": "sha512-cLWoDEY5OwHcAjDnkyRQzAXfs2jrKjXpO/HQFcc5b5u/r7aa471wdmChmwfnv7x2u840iat/wi0lQ5nbRgSkUA==",
      "dev": true,
      "requires": {
        "loader-utils": "^1.1.0",
        "postcss": "^7.0.0",
        "postcss-load-config": "^2.0.0",
        "schema-utils": "^1.0.0"
      },
      "dependencies": {
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        }
      }
    },
    "postcss-merge-longhand": {
      "version": "4.0.11",
      "resolved": "https://registry.npmjs.org/postcss-merge-longhand/-/postcss-merge-longhand-4.0.11.tgz",
      "integrity": "sha512-alx/zmoeXvJjp7L4mxEMjh8lxVlDFX1gqWHzaaQewwMZiVhLo42TEClKaeHbRf6J7j82ZOdTJ808RtN0ZOZwvw==",
      "dev": true,
      "requires": {
        "css-color-names": "0.0.4",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0",
        "stylehacks": "^4.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-merge-rules": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/postcss-merge-rules/-/postcss-merge-rules-4.0.3.tgz",
      "integrity": "sha512-U7e3r1SbvYzO0Jr3UT/zKBVgYYyhAz0aitvGIYOYK5CPmkNih+WDSsS5tvPrJ8YMQYlEMvsZIiqmn7HdFUaeEQ==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "caniuse-api": "^3.0.0",
        "cssnano-util-same-parent": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-selector-parser": "^3.0.0",
        "vendors": "^1.0.0"
      },
      "dependencies": {
        "postcss-selector-parser": {
          "version": "3.1.2",
          "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-3.1.2.tgz",
          "integrity": "sha512-h7fJ/5uWuRVyOtkO45pnt1Ih40CEleeyCHzipqAZO2e5H20g25Y48uYnFUiShvY4rZWNJ/Bib/KVPmanaCtOhA==",
          "dev": true,
          "requires": {
            "dot-prop": "^5.2.0",
            "indexes-of": "^1.0.1",
            "uniq": "^1.0.1"
          }
        }
      }
    },
    "postcss-minify-font-values": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-minify-font-values/-/postcss-minify-font-values-4.0.2.tgz",
      "integrity": "sha512-j85oO6OnRU9zPf04+PZv1LYIYOprWm6IA6zkXkrJXyRveDEuQggG6tvoy8ir8ZwjLxLuGfNkCZEQG7zan+Hbtg==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-minify-gradients": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-minify-gradients/-/postcss-minify-gradients-4.0.2.tgz",
      "integrity": "sha512-qKPfwlONdcf/AndP1U8SJ/uzIJtowHlMaSioKzebAXSG4iJthlWC9iSWznQcX4f66gIWX44RSA841HTHj3wK+Q==",
      "dev": true,
      "requires": {
        "cssnano-util-get-arguments": "^4.0.0",
        "is-color-stop": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-minify-params": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-minify-params/-/postcss-minify-params-4.0.2.tgz",
      "integrity": "sha512-G7eWyzEx0xL4/wiBBJxJOz48zAKV2WG3iZOqVhPet/9geefm/Px5uo1fzlHu+DOjT+m0Mmiz3jkQzVHe6wxAWg==",
      "dev": true,
      "requires": {
        "alphanum-sort": "^1.0.0",
        "browserslist": "^4.0.0",
        "cssnano-util-get-arguments": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0",
        "uniqs": "^2.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-minify-selectors": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-minify-selectors/-/postcss-minify-selectors-4.0.2.tgz",
      "integrity": "sha512-D5S1iViljXBj9kflQo4YutWnJmwm8VvIsU1GeXJGiG9j8CIg9zs4voPMdQDUmIxetUOh60VilsNzCiAFTOqu3g==",
      "dev": true,
      "requires": {
        "alphanum-sort": "^1.0.0",
        "has": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-selector-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-selector-parser": {
          "version": "3.1.2",
          "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-3.1.2.tgz",
          "integrity": "sha512-h7fJ/5uWuRVyOtkO45pnt1Ih40CEleeyCHzipqAZO2e5H20g25Y48uYnFUiShvY4rZWNJ/Bib/KVPmanaCtOhA==",
          "dev": true,
          "requires": {
            "dot-prop": "^5.2.0",
            "indexes-of": "^1.0.1",
            "uniq": "^1.0.1"
          }
        }
      }
    },
    "postcss-modules-extract-imports": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/postcss-modules-extract-imports/-/postcss-modules-extract-imports-2.0.0.tgz",
      "integrity": "sha512-LaYLDNS4SG8Q5WAWqIJgdHPJrDDr/Lv775rMBFUbgjTz6j34lUznACHcdRWroPvXANP2Vj7yNK57vp9eFqzLWQ==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.5"
      }
    },
    "postcss-modules-local-by-default": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/postcss-modules-local-by-default/-/postcss-modules-local-by-default-3.0.3.tgz",
      "integrity": "sha512-e3xDq+LotiGesympRlKNgaJ0PCzoUIdpH0dj47iWAui/kyTgh3CiAr1qP54uodmJhl6p9rN6BoNcdEDVJx9RDw==",
      "dev": true,
      "requires": {
        "icss-utils": "^4.1.1",
        "postcss": "^7.0.32",
        "postcss-selector-parser": "^6.0.2",
        "postcss-value-parser": "^4.1.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          },
          "dependencies": {
            "supports-color": {
              "version": "5.5.0",
              "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
              "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
              "dev": true,
              "requires": {
                "has-flag": "^3.0.0"
              }
            }
          }
        },
        "postcss": {
          "version": "7.0.32",
          "resolved": "https://registry.npmjs.org/postcss/-/postcss-7.0.32.tgz",
          "integrity": "sha512-03eXong5NLnNCD05xscnGKGDZ98CyzoqPSMjOe6SuoQY7Z2hIj0Ld1g/O/UQRuOle2aRtiIRDg9tDcTGAkLfKw==",
          "dev": true,
          "requires": {
            "chalk": "^2.4.2",
            "source-map": "^0.6.1",
            "supports-color": "^6.1.0"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "supports-color": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.1.0.tgz",
          "integrity": "sha512-qe1jfm1Mg7Nq/NSh6XE24gPXROEVsWHxC1LIx//XNlD9iw7YZQGjZNjYN7xGaEG6iKdA8EtNFW6R0gjnVXp+wQ==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "postcss-modules-scope": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/postcss-modules-scope/-/postcss-modules-scope-2.2.0.tgz",
      "integrity": "sha512-YyEgsTMRpNd+HmyC7H/mh3y+MeFWevy7V1evVhJWewmMbjDHIbZbOXICC2y+m1xI1UVfIT1HMW/O04Hxyu9oXQ==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.6",
        "postcss-selector-parser": "^6.0.0"
      }
    },
    "postcss-modules-values": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/postcss-modules-values/-/postcss-modules-values-3.0.0.tgz",
      "integrity": "sha512-1//E5jCBrZ9DmRX+zCtmQtRSV6PV42Ix7Bzj9GbwJceduuf7IqP8MgeTXuRDHOWj2m0VzZD5+roFWDuU8RQjcg==",
      "dev": true,
      "requires": {
        "icss-utils": "^4.0.0",
        "postcss": "^7.0.6"
      }
    },
    "postcss-normalize-charset": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-charset/-/postcss-normalize-charset-4.0.1.tgz",
      "integrity": "sha512-gMXCrrlWh6G27U0hF3vNvR3w8I1s2wOBILvA87iNXaPvSNo5uZAMYsZG7XjCUf1eVxuPfyL4TJ7++SGZLc9A3g==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0"
      }
    },
    "postcss-normalize-display-values": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-display-values/-/postcss-normalize-display-values-4.0.2.tgz",
      "integrity": "sha512-3F2jcsaMW7+VtRMAqf/3m4cPFhPD3EFRgNs18u+k3lTJJlVe7d0YPO+bnwqo2xg8YiRpDXJI2u8A0wqJxMsQuQ==",
      "dev": true,
      "requires": {
        "cssnano-util-get-match": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-positions": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-positions/-/postcss-normalize-positions-4.0.2.tgz",
      "integrity": "sha512-Dlf3/9AxpxE+NF1fJxYDeggi5WwV35MXGFnnoccP/9qDtFrTArZ0D0R+iKcg5WsUd8nUYMIl8yXDCtcrT8JrdA==",
      "dev": true,
      "requires": {
        "cssnano-util-get-arguments": "^4.0.0",
        "has": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-repeat-style": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-repeat-style/-/postcss-normalize-repeat-style-4.0.2.tgz",
      "integrity": "sha512-qvigdYYMpSuoFs3Is/f5nHdRLJN/ITA7huIoCyqqENJe9PvPmLhNLMu7QTjPdtnVf6OcYYO5SHonx4+fbJE1+Q==",
      "dev": true,
      "requires": {
        "cssnano-util-get-arguments": "^4.0.0",
        "cssnano-util-get-match": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-string": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-string/-/postcss-normalize-string-4.0.2.tgz",
      "integrity": "sha512-RrERod97Dnwqq49WNz8qo66ps0swYZDSb6rM57kN2J+aoyEAJfZ6bMx0sx/F9TIEX0xthPGCmeyiam/jXif0eA==",
      "dev": true,
      "requires": {
        "has": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-timing-functions": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-timing-functions/-/postcss-normalize-timing-functions-4.0.2.tgz",
      "integrity": "sha512-acwJY95edP762e++00Ehq9L4sZCEcOPyaHwoaFOhIwWCDfik6YvqsYNxckee65JHLKzuNSSmAdxwD2Cud1Z54A==",
      "dev": true,
      "requires": {
        "cssnano-util-get-match": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-unicode": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-unicode/-/postcss-normalize-unicode-4.0.1.tgz",
      "integrity": "sha512-od18Uq2wCYn+vZ/qCOeutvHjB5jm57ToxRaMeNuf0nWVHaP9Hua56QyMF6fs/4FSUnVIw0CBPsU0K4LnBPwYwg==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-url": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-normalize-url/-/postcss-normalize-url-4.0.1.tgz",
      "integrity": "sha512-p5oVaF4+IHwu7VpMan/SSpmpYxcJMtkGppYf0VbdH5B6hN8YNmVyJLuY9FmLQTzY3fag5ESUUHDqM+heid0UVA==",
      "dev": true,
      "requires": {
        "is-absolute-url": "^2.0.0",
        "normalize-url": "^3.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-normalize-whitespace": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-normalize-whitespace/-/postcss-normalize-whitespace-4.0.2.tgz",
      "integrity": "sha512-tO8QIgrsI3p95r8fyqKV+ufKlSHh9hMJqACqbv2XknufqEDhDvbguXGBBqxw9nsQoXWf0qOqppziKJKHMD4GtA==",
      "dev": true,
      "requires": {
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-ordered-values": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/postcss-ordered-values/-/postcss-ordered-values-4.1.2.tgz",
      "integrity": "sha512-2fCObh5UanxvSxeXrtLtlwVThBvHn6MQcu4ksNT2tsaV2Fg76R2CV98W7wNSlX+5/pFwEyaDwKLLoEV7uRybAw==",
      "dev": true,
      "requires": {
        "cssnano-util-get-arguments": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-reduce-initial": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/postcss-reduce-initial/-/postcss-reduce-initial-4.0.3.tgz",
      "integrity": "sha512-gKWmR5aUulSjbzOfD9AlJiHCGH6AEVLaM0AV+aSioxUDd16qXP1PCh8d1/BGVvpdWn8k/HiK7n6TjeoXN1F7DA==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "caniuse-api": "^3.0.0",
        "has": "^1.0.0",
        "postcss": "^7.0.0"
      }
    },
    "postcss-reduce-transforms": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-reduce-transforms/-/postcss-reduce-transforms-4.0.2.tgz",
      "integrity": "sha512-EEVig1Q2QJ4ELpJXMZR8Vt5DQx8/mo+dGWSR7vWXqcob2gQLyQGsionYcGKATXvQzMPn6DSN1vTN7yFximdIAg==",
      "dev": true,
      "requires": {
        "cssnano-util-get-match": "^4.0.0",
        "has": "^1.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-selector-parser": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-6.0.2.tgz",
      "integrity": "sha512-36P2QR59jDTOAiIkqEprfJDsoNrvwFei3eCqKd1Y0tUsBimsq39BLp7RD+JWny3WgB1zGhJX8XVePwm9k4wdBg==",
      "dev": true,
      "requires": {
        "cssesc": "^3.0.0",
        "indexes-of": "^1.0.1",
        "uniq": "^1.0.1"
      }
    },
    "postcss-svgo": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/postcss-svgo/-/postcss-svgo-4.0.2.tgz",
      "integrity": "sha512-C6wyjo3VwFm0QgBy+Fu7gCYOkCmgmClghO+pjcxvrcBKtiKt0uCF+hvbMO1fyv5BMImRK90SMb+dwUnfbGd+jw==",
      "dev": true,
      "requires": {
        "is-svg": "^3.0.0",
        "postcss": "^7.0.0",
        "postcss-value-parser": "^3.0.0",
        "svgo": "^1.0.0"
      },
      "dependencies": {
        "postcss-value-parser": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-3.3.1.tgz",
          "integrity": "sha512-pISE66AbVkp4fDQ7VHBwRNXzAAKJjw4Vw7nWI/+Q3vuly7SNfgYXvm6i5IgFylHGK5sP/xHAbB7N49OS4gWNyQ==",
          "dev": true
        }
      }
    },
    "postcss-unique-selectors": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/postcss-unique-selectors/-/postcss-unique-selectors-4.0.1.tgz",
      "integrity": "sha512-+JanVaryLo9QwZjKrmJgkI4Fn8SBgRO6WXQBJi7KiAVPlmxikB5Jzc4EvXMT2H0/m0RjrVVm9rGNhZddm/8Spg==",
      "dev": true,
      "requires": {
        "alphanum-sort": "^1.0.0",
        "postcss": "^7.0.0",
        "uniqs": "^2.0.0"
      }
    },
    "postcss-value-parser": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.1.0.tgz",
      "integrity": "sha512-97DXOFbQJhk71ne5/Mt6cOu6yxsSfM0QGQyl0L25Gca4yGWEGJaig7l7gbCX623VqTBNGLRLaVUCnNkcedlRSQ==",
      "dev": true
    },
    "prelude-ls": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.1.2.tgz",
      "integrity": "sha1-IZMqVJ9eUv/ZqCf1cOBL5iqX2lQ=",
      "dev": true
    },
    "prepend-http": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/prepend-http/-/prepend-http-1.0.4.tgz",
      "integrity": "sha1-1PRWKwzjaW5BrFLQ4ALlemNdxtw=",
      "dev": true
    },
    "prettier": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.0.5.tgz",
      "integrity": "sha512-7PtVymN48hGcO4fGjybyBSIWDsLU4H4XlvOHfq91pz9kkGlonzwTfYkaIEwiRg/dAJF9YlbsduBAgtYLi+8cFg==",
      "dev": true
    },
    "pretty-bytes": {
      "version": "5.6.0",
      "resolved": "https://registry.npmjs.org/pretty-bytes/-/pretty-bytes-5.6.0.tgz",
      "integrity": "sha512-FFw039TmrBqFK8ma/7OL3sDz/VytdtJr044/QUJtH0wK9lb9jLq9tJyIxUwtQJHwar2BqtiA4iCWSwo9JLkzFg==",
      "dev": true
    },
    "pretty-format": {
      "version": "25.5.0",
      "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-25.5.0.tgz",
      "integrity": "sha512-kbo/kq2LQ/A/is0PQwsEHM7Ca6//bGPPvU6UnsdDRSKTWxT/ru/xb88v4BJf6a69H+uTytOEsTusT9ksd/1iWQ==",
      "dev": true,
      "requires": {
        "@jest/types": "^25.5.0",
        "ansi-regex": "^5.0.0",
        "ansi-styles": "^4.0.0",
        "react-is": "^16.12.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "dev": true,
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        }
      }
    },
    "private": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/private/-/private-0.1.8.tgz",
      "integrity": "sha512-VvivMrbvd2nKkiG38qjULzlc+4Vx4wm/whI9pQD35YrARNnhxeiRktSOhSukRLFNlzg6Br/cJPet5J/u19r/mg=="
    },
    "process": {
      "version": "0.11.10",
      "resolved": "https://registry.npmjs.org/process/-/process-0.11.10.tgz",
      "integrity": "sha1-czIwDoQBYb2j5podHZGn1LwW8YI=",
      "dev": true
    },
    "process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag=="
    },
    "progress": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz",
      "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==",
      "dev": true
    },
    "promise-inflight": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/promise-inflight/-/promise-inflight-1.0.1.tgz",
      "integrity": "sha1-mEcocL8igTL8vdhoEputEsPAKeM=",
      "dev": true
    },
    "promise-retry": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/promise-retry/-/promise-retry-1.1.1.tgz",
      "integrity": "sha1-ZznpaOMFHaIM5kl/srUPaRHfPW0=",
      "dev": true,
      "requires": {
        "err-code": "^1.0.0",
        "retry": "^0.10.0"
      },
      "dependencies": {
        "retry": {
          "version": "0.10.1",
          "resolved": "https://registry.npmjs.org/retry/-/retry-0.10.1.tgz",
          "integrity": "sha1-52OI0heZLCUnUCQdPTlW/tmNj/Q=",
          "dev": true
        }
      }
    },
    "prompts": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/prompts/-/prompts-2.3.2.tgz",
      "integrity": "sha512-Q06uKs2CkNYVID0VqwfAl9mipo99zkBv/n2JtWY89Yxa3ZabWSrs0e2KTudKVa3peLUvYXMefDqIleLPVUBZMA==",
      "dev": true,
      "requires": {
        "kleur": "^3.0.3",
        "sisteransi": "^1.0.4"
      }
    },
    "protoduck": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/protoduck/-/protoduck-5.0.1.tgz",
      "integrity": "sha512-WxoCeDCoCBY55BMvj4cAEjdVUFGRWed9ZxPlqTKYyw1nDDTQ4pqmnIMAGfJlg7Dx35uB/M+PHJPTmGOvaCaPTg==",
      "dev": true,
      "requires": {
        "genfun": "^5.0.0"
      }
    },
    "protractor": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/protractor/-/protractor-7.0.0.tgz",
      "integrity": "sha512-UqkFjivi4GcvUQYzqGYNe0mLzfn5jiLmO8w9nMhQoJRLhy2grJonpga2IWhI6yJO30LibWXJJtA4MOIZD2GgZw==",
      "dev": true,
      "requires": {
        "@types/q": "^0.0.32",
        "@types/selenium-webdriver": "^3.0.0",
        "blocking-proxy": "^1.0.0",
        "browserstack": "^1.5.1",
        "chalk": "^1.1.3",
        "glob": "^7.0.3",
        "jasmine": "2.8.0",
        "jasminewd2": "^2.1.0",
        "q": "1.4.1",
        "saucelabs": "^1.5.0",
        "selenium-webdriver": "3.6.0",
        "source-map-support": "~0.4.0",
        "webdriver-js-extender": "2.1.0",
        "webdriver-manager": "^12.1.7",
        "yargs": "^15.3.1"
      },
      "dependencies": {
        "@types/q": {
          "version": "0.0.32",
          "resolved": "https://registry.npmjs.org/@types/q/-/q-0.0.32.tgz",
          "integrity": "sha1-vShOV8hPEyXacCur/IKlMoGQwMU=",
          "dev": true
        },
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "ansi-styles": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
          "integrity": "sha1-tDLdM1i2NM914eRmQ2gkBTPB3b4=",
          "dev": true
        },
        "chalk": {
          "version": "1.1.3",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
          "integrity": "sha1-qBFcVeSnAv5NFQq9OHKCKn4J/Jg=",
          "dev": true,
          "requires": {
            "ansi-styles": "^2.2.1",
            "escape-string-regexp": "^1.0.2",
            "has-ansi": "^2.0.0",
            "strip-ansi": "^3.0.0",
            "supports-color": "^2.0.0"
          }
        },
        "del": {
          "version": "2.2.2",
          "resolved": "https://registry.npmjs.org/del/-/del-2.2.2.tgz",
          "integrity": "sha1-wSyYHQZ4RshLyvhiz/kw2Qf/0ag=",
          "dev": true,
          "requires": {
            "globby": "^5.0.0",
            "is-path-cwd": "^1.0.0",
            "is-path-in-cwd": "^1.0.0",
            "object-assign": "^4.0.1",
            "pify": "^2.0.0",
            "pinkie-promise": "^2.0.0",
            "rimraf": "^2.2.8"
          }
        },
        "globby": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/globby/-/globby-5.0.0.tgz",
          "integrity": "sha1-69hGZ8oNuzMLmbz8aOrCvFQ3Dg0=",
          "dev": true,
          "requires": {
            "array-union": "^1.0.1",
            "arrify": "^1.0.0",
            "glob": "^7.0.3",
            "object-assign": "^4.0.1",
            "pify": "^2.0.0",
            "pinkie-promise": "^2.0.0"
          }
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "is-path-cwd": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-path-cwd/-/is-path-cwd-1.0.0.tgz",
          "integrity": "sha1-0iXsIxMuie3Tj9p2dHLmLmXxEG0=",
          "dev": true
        },
        "is-path-in-cwd": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-path-in-cwd/-/is-path-in-cwd-1.0.1.tgz",
          "integrity": "sha512-FjV1RTW48E7CWM7eE/J2NJvAEEVektecDBVBE5Hh3nM1Jd0kvhHtX68Pr3xsDf857xt3Y4AkwVULK1Vku62aaQ==",
          "dev": true,
          "requires": {
            "is-path-inside": "^1.0.0"
          }
        },
        "is-path-inside": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-1.0.1.tgz",
          "integrity": "sha1-jvW33lBDej/cprToZe96pVy0gDY=",
          "dev": true,
          "requires": {
            "path-is-inside": "^1.0.1"
          }
        },
        "pify": {
          "version": "2.3.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
          "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
          "dev": true
        },
        "q": {
          "version": "1.4.1",
          "resolved": "https://registry.npmjs.org/q/-/q-1.4.1.tgz",
          "integrity": "sha1-VXBbzZPF82c1MMLCy8DCs63cKG4=",
          "dev": true
        },
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        },
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
          "dev": true
        },
        "source-map-support": {
          "version": "0.4.18",
          "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.4.18.tgz",
          "integrity": "sha512-try0/JqxPLF9nOjvSta7tVondkP5dwgyLDjVoyMDlmjugT2lRZ1OfsrYTkCd2hkDnJTKRbO/Rl3orm8vlsUzbA==",
          "dev": true,
          "requires": {
            "source-map": "^0.5.6"
          }
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          },
          "dependencies": {
            "strip-ansi": {
              "version": "6.0.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
              "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
              "dev": true,
              "requires": {
                "ansi-regex": "^5.0.0"
              }
            }
          }
        },
        "supports-color": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
          "integrity": "sha1-U10EXOa2Nj+kARcIRimZXp3zJMc=",
          "dev": true
        },
        "webdriver-manager": {
          "version": "12.1.7",
          "resolved": "https://registry.npmjs.org/webdriver-manager/-/webdriver-manager-12.1.7.tgz",
          "integrity": "sha512-XINj6b8CYuUYC93SG3xPkxlyUc3IJbD6Vvo75CVGuG9uzsefDzWQrhz0Lq8vbPxtb4d63CZdYophF8k8Or/YiA==",
          "dev": true,
          "requires": {
            "adm-zip": "^0.4.9",
            "chalk": "^1.1.1",
            "del": "^2.2.0",
            "glob": "^7.0.3",
            "ini": "^1.3.4",
            "minimist": "^1.2.0",
            "q": "^1.4.1",
            "request": "^2.87.0",
            "rimraf": "^2.5.2",
            "semver": "^5.3.0",
            "xml2js": "^0.4.17"
          }
        },
        "yargs": {
          "version": "15.4.1",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-15.4.1.tgz",
          "integrity": "sha512-aePbxDmcYW++PaqBsJ+HYUFwCdv4LVvdnhBy78E57PIor8/OVvhMrADFFEDh8DHDFRv/O9i3lPhsENjO7QX0+A==",
          "dev": true,
          "requires": {
            "cliui": "^6.0.0",
            "decamelize": "^1.2.0",
            "find-up": "^4.1.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^4.2.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^18.1.2"
          }
        }
      }
    },
    "proxy-addr": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.6.tgz",
      "integrity": "sha512-dh/frvCBVmSsDYzw6n926jv974gddhkFPfiN8hPOi30Wax25QZyZEGveluCgliBnqmuM+UJmBErbAUFIoDbjOw==",
      "requires": {
        "forwarded": "~0.1.2",
        "ipaddr.js": "1.9.1"
      }
    },
    "prr": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/prr/-/prr-1.0.1.tgz",
      "integrity": "sha1-0/wRS6BplaRexok/SEzrHXj19HY="
    },
    "psl": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/psl/-/psl-1.8.0.tgz",
      "integrity": "sha512-RIdOzyoavK+hA18OGGWDqUTsCLhtA7IcZ/6NCs4fFJaHBDab+pDDmDIByWFRQJq2Cd7r1OoQxBGKOaztq+hjIQ==",
      "dev": true
    },
    "public-encrypt": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/public-encrypt/-/public-encrypt-4.0.3.tgz",
      "integrity": "sha512-zVpa8oKZSz5bTMTFClc1fQOnyyEzpl5ozpi1B5YcvBrdohMjH2rfsBtyXcuNuwjsDIXmBYlF2N5FlJYhR29t8Q==",
      "dev": true,
      "requires": {
        "bn.js": "^4.1.0",
        "browserify-rsa": "^4.0.0",
        "create-hash": "^1.1.0",
        "parse-asn1": "^5.0.0",
        "randombytes": "^2.0.1",
        "safe-buffer": "^5.1.2"
      },
      "dependencies": {
        "bn.js": {
          "version": "4.11.8",
          "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-4.11.8.tgz",
          "integrity": "sha512-ItfYfPLkWHUjckQCk8xC+LwxgK8NYcXywGigJgSwOP8Y2iyWT4f2vsZnoOXTTbo+o5yXmIUJ4gn5538SO5S3gA==",
          "dev": true
        }
      }
    },
    "pump": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/pump/-/pump-3.0.0.tgz",
      "integrity": "sha512-LwZy+p3SFs1Pytd/jYct4wpv49HiYCqd9Rlc5ZVdk0V+8Yzv6jR5Blk3TRmPL1ft69TxP0IMZGJ+WPFU2BFhww==",
      "dev": true,
      "requires": {
        "end-of-stream": "^1.1.0",
        "once": "^1.3.1"
      }
    },
    "pumpify": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/pumpify/-/pumpify-1.5.1.tgz",
      "integrity": "sha512-oClZI37HvuUJJxSKKrC17bZ9Cu0ZYhEAGPsPUy9KlMUmv9dKX2o77RUmq7f3XjIxbwyGwYzbzQ1L2Ks8sIradQ==",
      "dev": true,
      "requires": {
        "duplexify": "^3.6.0",
        "inherits": "^2.0.3",
        "pump": "^2.0.0"
      },
      "dependencies": {
        "pump": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/pump/-/pump-2.0.1.tgz",
          "integrity": "sha512-ruPMNRkN3MHP1cWJc9OWr+T/xDP0jhXYCLfJcBuX54hhfIBnaQmAUMfDcG4DM5UMWByBbJY69QSphm3jtDKIkA==",
          "dev": true,
          "requires": {
            "end-of-stream": "^1.1.0",
            "once": "^1.3.1"
          }
        }
      }
    },
    "punycode": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz",
      "integrity": "sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A=="
    },
    "q": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/q/-/q-1.5.1.tgz",
      "integrity": "sha1-fjL3W0E4EpHQRhHxvxQQmsAGUdc=",
      "dev": true
    },
    "qs": {
      "version": "6.5.2",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.5.2.tgz",
      "integrity": "sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA==",
      "dev": true
    },
    "query-string": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/query-string/-/query-string-4.3.4.tgz",
      "integrity": "sha1-u7aTucqRXCMlFbIosaArYJBD2+s=",
      "dev": true,
      "requires": {
        "object-assign": "^4.1.0",
        "strict-uri-encode": "^1.0.0"
      }
    },
    "querystring": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/querystring/-/querystring-0.2.0.tgz",
      "integrity": "sha1-sgmEkgO7Jd+CDadW50cAWHhSFiA=",
      "dev": true
    },
    "querystring-es3": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/querystring-es3/-/querystring-es3-0.2.1.tgz",
      "integrity": "sha1-nsYfeQSYdXB9aUFFlv2Qek1xHnM=",
      "dev": true
    },
    "querystringify": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/querystringify/-/querystringify-2.1.1.tgz",
      "integrity": "sha512-w7fLxIRCRT7U8Qu53jQnJyPkYZIaR4n5151KMfcJlO/A9397Wxb1amJvROTK6TOnp7PfoAmg/qXiNHI+08jRfA==",
      "dev": true
    },
    "ramda": {
      "version": "0.27.1",
      "resolved": "https://registry.npmjs.org/ramda/-/ramda-0.27.1.tgz",
      "integrity": "sha512-PgIdVpn5y5Yns8vqb8FzBUEYn98V3xcPgawAkkgj0YJ0qDsnHCiNmZYfOGMgOvoB0eWFLpYbhxUR3mxfDIMvpw==",
      "dev": true
    },
    "randombytes": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
      "dev": true,
      "requires": {
        "safe-buffer": "^5.1.0"
      }
    },
    "randomfill": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/randomfill/-/randomfill-1.0.4.tgz",
      "integrity": "sha512-87lcbR8+MhcWcUiQ+9e+Rwx8MyR2P7qnt15ynUlbm3TU/fjbgz4GsvfSUDTemtCCtVCqb4ZcEFlyPNTh9bBTLw==",
      "dev": true,
      "requires": {
        "randombytes": "^2.0.5",
        "safe-buffer": "^5.1.0"
      }
    },
    "range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg=="
    },
    "raw-body": {
      "version": "2.4.0",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.4.0.tgz",
      "integrity": "sha512-4Oz8DUIwdvoa5qMJelxipzi/iJIi40O5cGV1wNYp5hvZP8ZN0T+jiNkL0QepXs+EsQ9XJ8ipEDoiH70ySUJP3Q==",
      "requires": {
        "bytes": "3.1.0",
        "http-errors": "1.7.2",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "dependencies": {
        "bytes": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.0.tgz",
          "integrity": "sha512-zauLjrfCG+xvoyaqLoV8bLVXXNGC4JqlxFCutSDWA6fJrTo2ZuvLYTqZ7aHBLZSMOopbzwv8f+wZcVzfVTI2Dg=="
        }
      }
    },
    "raw-loader": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/raw-loader/-/raw-loader-4.0.1.tgz",
      "integrity": "sha512-baolhQBSi3iNh1cglJjA0mYzga+wePk7vdEX//1dTFd+v4TsQlQE0jitJSNF1OIP82rdYulH7otaVmdlDaJ64A==",
      "dev": true,
      "requires": {
        "loader-utils": "^2.0.0",
        "schema-utils": "^2.6.5"
      },
      "dependencies": {
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        }
      }
    },
    "react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "dev": true
    },
    "read-cache": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/read-cache/-/read-cache-1.0.0.tgz",
      "integrity": "sha1-5mTvMRYRZsl1HNvo28+GtftY93Q=",
      "dev": true,
      "requires": {
        "pify": "^2.3.0"
      },
      "dependencies": {
        "pify": {
          "version": "2.3.0",
          "resolved": "https://registry.npmjs.org/pify/-/pify-2.3.0.tgz",
          "integrity": "sha1-7RQaasBDqEnqWISY59yosVMw6Qw=",
          "dev": true
        }
      }
    },
    "read-package-json": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/read-package-json/-/read-package-json-2.1.1.tgz",
      "integrity": "sha512-dAiqGtVc/q5doFz6096CcnXhpYk0ZN8dEKVkGLU0CsASt8SrgF6SF7OTKAYubfvFhWaqofl+Y8HK19GR8jwW+A==",
      "dev": true,
      "requires": {
        "glob": "^7.1.1",
        "graceful-fs": "^4.1.2",
        "json-parse-better-errors": "^1.0.1",
        "normalize-package-data": "^2.0.0",
        "npm-normalize-package-bin": "^1.0.0"
      }
    },
    "read-package-tree": {
      "version": "5.3.1",
      "resolved": "https://registry.npmjs.org/read-package-tree/-/read-package-tree-5.3.1.tgz",
      "integrity": "sha512-mLUDsD5JVtlZxjSlPPx1RETkNjjvQYuweKwNVt1Sn8kP5Jh44pvYuUHCp6xSVDZWbNxVxG5lyZJ921aJH61sTw==",
      "dev": true,
      "requires": {
        "read-package-json": "^2.0.0",
        "readdir-scoped-modules": "^1.0.0",
        "util-promisify": "^2.1.0"
      }
    },
    "read-pkg": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/read-pkg/-/read-pkg-3.0.0.tgz",
      "integrity": "sha1-nLxoaXj+5l0WwA4rGcI3/Pbjg4k=",
      "dev": true,
      "requires": {
        "load-json-file": "^4.0.0",
        "normalize-package-data": "^2.3.2",
        "path-type": "^3.0.0"
      }
    },
    "read-pkg-up": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/read-pkg-up/-/read-pkg-up-7.0.1.tgz",
      "integrity": "sha512-zK0TB7Xd6JpCLmlLmufqykGE+/TlOePD6qKClNW7hHDKFh/J7/7gCWGR7joEQEW1bKq3a3yUZSObOoWLFQ4ohg==",
      "dev": true,
      "requires": {
        "find-up": "^4.1.0",
        "read-pkg": "^5.2.0",
        "type-fest": "^0.8.1"
      },
      "dependencies": {
        "parse-json": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.0.0.tgz",
          "integrity": "sha512-OOY5b7PAEFV0E2Fir1KOkxchnZNCdowAJgQ5NuxjpBKTRP3pQhwkrkxqQjeoKJ+fO7bCpmIZaogI4eZGDMEGOw==",
          "dev": true,
          "requires": {
            "@babel/code-frame": "^7.0.0",
            "error-ex": "^1.3.1",
            "json-parse-better-errors": "^1.0.1",
            "lines-and-columns": "^1.1.6"
          }
        },
        "read-pkg": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/read-pkg/-/read-pkg-5.2.0.tgz",
          "integrity": "sha512-Ug69mNOpfvKDAc2Q8DRpMjjzdtrnv9HcSMX+4VsZxD1aZ6ZzrIE7rlzXBtWTyhULSMKg076AW6WR5iZpD0JiOg==",
          "dev": true,
          "requires": {
            "@types/normalize-package-data": "^2.4.0",
            "normalize-package-data": "^2.5.0",
            "parse-json": "^5.0.0",
            "type-fest": "^0.6.0"
          },
          "dependencies": {
            "type-fest": {
              "version": "0.6.0",
              "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.6.0.tgz",
              "integrity": "sha512-q+MB8nYR1KDLrgr4G5yemftpMC7/QLqVndBmEEdqzmNj5dcFOO4Oo8qlwZE3ULT3+Zim1F8Kq4cBnikNhlCMlg==",
              "dev": true
            }
          }
        },
        "type-fest": {
          "version": "0.8.1",
          "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.8.1.tgz",
          "integrity": "sha512-4dbzIzqvjtgiM5rw1k5rEHtBANKmdudhGyBEajN01fEyhaAIhsoKNy6y7+IN93IfpFtwY9iqi7kD+xwKhQsNJA==",
          "dev": true
        }
      }
    },
    "readable-stream": {
      "version": "2.3.7",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.7.tgz",
      "integrity": "sha512-Ebho8K4jIbHAxnuxi7o42OrZgF/ZTNcsZj6nRKyUmkhLFq8CHItp/fy6hQZuZmP/n3yZ9VBUbp4zz/mX8hmYPw==",
      "requires": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      },
      "dependencies": {
        "safe-buffer": {
          "version": "5.1.2",
          "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
          "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g=="
        },
        "string_decoder": {
          "version": "1.1.1",
          "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
          "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
          "requires": {
            "safe-buffer": "~5.1.0"
          }
        }
      }
    },
    "readdir-scoped-modules": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/readdir-scoped-modules/-/readdir-scoped-modules-1.1.0.tgz",
      "integrity": "sha512-asaikDeqAQg7JifRsZn1NJZXo9E+VwlyCfbkZhwyISinqk5zNS6266HS5kah6P0SaQKGF6SkNnZVHUzHFYxYDw==",
      "dev": true,
      "requires": {
        "debuglog": "^1.0.1",
        "dezalgo": "^1.0.0",
        "graceful-fs": "^4.1.2",
        "once": "^1.3.0"
      }
    },
    "readdirp": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.4.0.tgz",
      "integrity": "sha512-0xe001vZBnJEK+uKcj8qOhyAKPzIT+gStxWr3LCB0DwcXR5NZJ3IaC+yGnHCYzB/S7ov3m3EEbZI2zeNvX+hGQ==",
      "requires": {
        "picomatch": "^2.2.1"
      }
    },
    "realpath-native": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/realpath-native/-/realpath-native-2.0.0.tgz",
      "integrity": "sha512-v1SEYUOXXdbBZK8ZuNgO4TBjamPsiSgcFr0aP+tEKpQZK8vooEUqV6nm6Cv502mX4NF2EfsnVqtNAHG+/6Ur1Q==",
      "dev": true
    },
    "reflect-metadata": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/reflect-metadata/-/reflect-metadata-0.1.13.tgz",
      "integrity": "sha512-Ts1Y/anZELhSsjMcU605fU9RE4Oi3p5ORujwbIKXfWa+0Zxs510Qrmrce5/Jowq3cHSZSJqBjypxmHarc+vEWg=="
    },
    "regenerate": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/regenerate/-/regenerate-1.4.0.tgz",
      "integrity": "sha512-1G6jJVDWrt0rK99kBjvEtziZNCICAuvIPkSiUFIQxVP06RCVpq3dmDo2oi6ABpYaDYaTRr67BEhL8r1wgEZZKg=="
    },
    "regenerate-unicode-properties": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/regenerate-unicode-properties/-/regenerate-unicode-properties-8.2.0.tgz",
      "integrity": "sha512-F9DjY1vKLo/tPePDycuH3dn9H1OTPIkVD9Kz4LODu+F2C75mgjAJ7x/gwy6ZcSNRAAkhNlJSOHRe8k3p+K9WhA==",
      "requires": {
        "regenerate": "^1.4.0"
      }
    },
    "regenerator-runtime": {
      "version": "0.13.5",
      "resolved": "https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.5.tgz",
      "integrity": "sha512-ZS5w8CpKFinUzOwW3c83oPeVXoNsrLsaCoLtJvAClH135j/R77RuymhiSErhm2lKcwSCIpmvIWSbDkIfAqKQlA=="
    },
    "regenerator-transform": {
      "version": "0.14.4",
      "resolved": "https://registry.npmjs.org/regenerator-transform/-/regenerator-transform-0.14.4.tgz",
      "integrity": "sha512-EaJaKPBI9GvKpvUz2mz4fhx7WPgvwRLY9v3hlNHWmAuJHI13T4nwKnNvm5RWJzEdnI5g5UwtOww+S8IdoUC2bw==",
      "requires": {
        "@babel/runtime": "^7.8.4",
        "private": "^0.1.8"
      }
    },
    "regex-not": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/regex-not/-/regex-not-1.0.2.tgz",
      "integrity": "sha512-J6SDjUgDxQj5NusnOtdFxDwN/+HWykR8GELwctJ7mdqhcyy1xEc4SRFHUXvxTp661YaVKAjfRLZ9cCqS6tn32A==",
      "requires": {
        "extend-shallow": "^3.0.2",
        "safe-regex": "^1.1.0"
      },
      "dependencies": {
        "extend-shallow": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
          "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
          "requires": {
            "assign-symbols": "^1.0.0",
            "is-extendable": "^1.0.1"
          }
        },
        "is-extendable": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
          "requires": {
            "is-plain-object": "^2.0.4"
          }
        }
      }
    },
    "regex-parser": {
      "version": "2.2.10",
      "resolved": "https://registry.npmjs.org/regex-parser/-/regex-parser-2.2.10.tgz",
      "integrity": "sha512-8t6074A68gHfU8Neftl0Le6KTDwfGAj7IyjPIMSfikI2wJUTHDMaIq42bUsfVnj8mhx0R+45rdUXHGpN164avA==",
      "dev": true
    },
    "regexp.prototype.flags": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.3.0.tgz",
      "integrity": "sha512-2+Q0C5g951OlYlJz6yu5/M33IcsESLlLfsyIaLJaG4FA2r4yP8MvVMJUUP/fVBkSpbbbZlS5gynbEWLipiiXiQ==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1"
      }
    },
    "regexpp": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-2.0.1.tgz",
      "integrity": "sha512-lv0M6+TkDVniA3aD1Eg0DVpfU/booSu7Eev3TDO/mZKHBfVjgCGTV4t4buppESEYDtkArYFOxTJWv6S5C+iaNw==",
      "dev": true
    },
    "regexpu-core": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/regexpu-core/-/regexpu-core-4.7.0.tgz",
      "integrity": "sha512-TQ4KXRnIn6tz6tjnrXEkD/sshygKH/j5KzK86X8MkeHyZ8qst/LZ89j3X4/8HEIfHANTFIP/AbXakeRhWIl5YQ==",
      "requires": {
        "regenerate": "^1.4.0",
        "regenerate-unicode-properties": "^8.2.0",
        "regjsgen": "^0.5.1",
        "regjsparser": "^0.6.4",
        "unicode-match-property-ecmascript": "^1.0.4",
        "unicode-match-property-value-ecmascript": "^1.2.0"
      }
    },
    "regjsgen": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/regjsgen/-/regjsgen-0.5.1.tgz",
      "integrity": "sha512-5qxzGZjDs9w4tzT3TPhCJqWdCc3RLYwy9J2NB0nm5Lz+S273lvWcpjaTGHsT1dc6Hhfq41uSEOw8wBmxrKOuyg=="
    },
    "regjsparser": {
      "version": "0.6.4",
      "resolved": "https://registry.npmjs.org/regjsparser/-/regjsparser-0.6.4.tgz",
      "integrity": "sha512-64O87/dPDgfk8/RQqC4gkZoGyyWFIEUTTh80CU6CWuK5vkCGyekIx+oKcEIYtP/RAxSQltCZHCNu/mdd7fqlJw==",
      "requires": {
        "jsesc": "~0.5.0"
      },
      "dependencies": {
        "jsesc": {
          "version": "0.5.0",
          "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-0.5.0.tgz",
          "integrity": "sha1-597mbjXW/Bb3EP6R1c9p9w8IkR0="
        }
      }
    },
    "remove-trailing-separator": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/remove-trailing-separator/-/remove-trailing-separator-1.1.0.tgz",
      "integrity": "sha1-wkvOKig62tW8P1jg1IJJuSN52O8=",
      "dev": true
    },
    "repeat-element": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/repeat-element/-/repeat-element-1.1.3.tgz",
      "integrity": "sha512-ahGq0ZnV5m5XtZLMb+vP76kcAM5nkLqk0lpqAuojSKGgQtn4eRi4ZZGm2olo2zKFH+sMsWaqOCW1dqAnOru72g=="
    },
    "repeat-string": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/repeat-string/-/repeat-string-1.6.1.tgz",
      "integrity": "sha1-jcrkcOHIirwtYA//Sndihtp15jc="
    },
    "request": {
      "version": "2.88.2",
      "resolved": "https://registry.npmjs.org/request/-/request-2.88.2.tgz",
      "integrity": "sha512-MsvtOrfG9ZcrOwAW+Qi+F6HbD0CWXEh9ou77uOb7FM2WPhwT7smM833PzanhJLsgXjN89Ir6V2PczXNnMpwKhw==",
      "dev": true,
      "requires": {
        "aws-sign2": "~0.7.0",
        "aws4": "^1.8.0",
        "caseless": "~0.12.0",
        "combined-stream": "~1.0.6",
        "extend": "~3.0.2",
        "forever-agent": "~0.6.1",
        "form-data": "~2.3.2",
        "har-validator": "~5.1.3",
        "http-signature": "~1.2.0",
        "is-typedarray": "~1.0.0",
        "isstream": "~0.1.2",
        "json-stringify-safe": "~5.0.1",
        "mime-types": "~2.1.19",
        "oauth-sign": "~0.9.0",
        "performance-now": "^2.1.0",
        "qs": "~6.5.2",
        "safe-buffer": "^5.1.2",
        "tough-cookie": "~2.5.0",
        "tunnel-agent": "^0.6.0",
        "uuid": "^3.3.2"
      }
    },
    "request-progress": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/request-progress/-/request-progress-3.0.0.tgz",
      "integrity": "sha1-TKdUCBx/7GP1BeT6qCWqBs1mnb4=",
      "dev": true,
      "requires": {
        "throttleit": "^1.0.0"
      }
    },
    "request-promise-core": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/request-promise-core/-/request-promise-core-1.1.3.tgz",
      "integrity": "sha512-QIs2+ArIGQVp5ZYbWD5ZLCY29D5CfWizP8eWnm8FoGD1TX61veauETVQbrV60662V0oFBkrDOuaBI8XgtuyYAQ==",
      "dev": true,
      "requires": {
        "lodash": "^4.17.15"
      }
    },
    "request-promise-native": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/request-promise-native/-/request-promise-native-1.0.8.tgz",
      "integrity": "sha512-dapwLGqkHtwL5AEbfenuzjTYg35Jd6KPytsC2/TLkVMz8rm+tNt72MGUWT1RP/aYawMpN6HqbNGBQaRcBtjQMQ==",
      "dev": true,
      "requires": {
        "request-promise-core": "1.1.3",
        "stealthy-require": "^1.1.1",
        "tough-cookie": "^2.3.3"
      }
    },
    "require-directory": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
      "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
      "dev": true
    },
    "require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true
    },
    "require-main-filename": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
      "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
      "dev": true
    },
    "requires-port": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/requires-port/-/requires-port-1.0.0.tgz",
      "integrity": "sha1-kl0mAdOaxIXgkc8NpcbmlNw9yv8=",
      "dev": true
    },
    "resolve": {
      "version": "1.17.0",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.17.0.tgz",
      "integrity": "sha512-ic+7JYiV8Vi2yzQGFWOkiZD5Z9z7O2Zhm9XMaTxdJExKasieFCr+yXZ/WmXsckHiKl12ar0y6XiXDx3m4RHn1w==",
      "requires": {
        "path-parse": "^1.0.6"
      }
    },
    "resolve-cwd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/resolve-cwd/-/resolve-cwd-2.0.0.tgz",
      "integrity": "sha1-AKn3OHVW4nA46uIyyqNypqWbZlo=",
      "dev": true,
      "requires": {
        "resolve-from": "^3.0.0"
      }
    },
    "resolve-from": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-3.0.0.tgz",
      "integrity": "sha1-six699nWiBvItuZTM17rywoYh0g=",
      "dev": true
    },
    "resolve-url": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/resolve-url/-/resolve-url-0.2.1.tgz",
      "integrity": "sha1-LGN/53yJOv0qZj/iGqkIAGjiBSo="
    },
    "resolve-url-loader": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/resolve-url-loader/-/resolve-url-loader-3.1.1.tgz",
      "integrity": "sha512-K1N5xUjj7v0l2j/3Sgs5b8CjrrgtC70SmdCuZiJ8tSyb5J+uk3FoeZ4b7yTnH6j7ngI+Bc5bldHJIa8hYdu2gQ==",
      "dev": true,
      "requires": {
        "adjust-sourcemap-loader": "2.0.0",
        "camelcase": "5.3.1",
        "compose-function": "3.0.3",
        "convert-source-map": "1.7.0",
        "es6-iterator": "2.0.3",
        "loader-utils": "1.2.3",
        "postcss": "7.0.21",
        "rework": "1.0.1",
        "rework-visit": "1.0.0",
        "source-map": "0.6.1"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          },
          "dependencies": {
            "supports-color": {
              "version": "5.5.0",
              "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
              "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
              "dev": true,
              "requires": {
                "has-flag": "^3.0.0"
              }
            }
          }
        },
        "emojis-list": {
          "version": "2.1.0",
          "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-2.1.0.tgz",
          "integrity": "sha1-TapNnbAPmBmIDHn6RXrlsJof04k=",
          "dev": true
        },
        "json5": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
          "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
          "dev": true,
          "requires": {
            "minimist": "^1.2.0"
          }
        },
        "loader-utils": {
          "version": "1.2.3",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-1.2.3.tgz",
          "integrity": "sha512-fkpz8ejdnEMG3s37wGL07iSBDg99O9D5yflE9RGNH3hRdx9SOwYfnGYdZOUIZitN8E+E2vkq3MUMYMvPYl5ZZA==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^2.0.0",
            "json5": "^1.0.1"
          }
        },
        "postcss": {
          "version": "7.0.21",
          "resolved": "https://registry.npmjs.org/postcss/-/postcss-7.0.21.tgz",
          "integrity": "sha512-uIFtJElxJo29QC753JzhidoAhvp/e/Exezkdhfmt8AymWT6/5B7W1WmponYWkHk2eg6sONyTch0A3nkMPun3SQ==",
          "dev": true,
          "requires": {
            "chalk": "^2.4.2",
            "source-map": "^0.6.1",
            "supports-color": "^6.1.0"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "supports-color": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.1.0.tgz",
          "integrity": "sha512-qe1jfm1Mg7Nq/NSh6XE24gPXROEVsWHxC1LIx//XNlD9iw7YZQGjZNjYN7xGaEG6iKdA8EtNFW6R0gjnVXp+wQ==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "restore-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
      "requires": {
        "onetime": "^5.1.0",
        "signal-exit": "^3.0.2"
      }
    },
    "ret": {
      "version": "0.1.15",
      "resolved": "https://registry.npmjs.org/ret/-/ret-0.1.15.tgz",
      "integrity": "sha512-TTlYpa+OL+vMMNG24xSlQGEJ3B/RzEfUlLct7b5G/ytav+wPrplCpVMFuwzXbkecJrb6IYo1iFb0S9v37754mg=="
    },
    "retry": {
      "version": "0.12.0",
      "resolved": "https://registry.npmjs.org/retry/-/retry-0.12.0.tgz",
      "integrity": "sha1-G0KmJmoh8HQh0bC1S33BZ7AcATs=",
      "dev": true
    },
    "reusify": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
      "dev": true
    },
    "rework": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/rework/-/rework-1.0.1.tgz",
      "integrity": "sha1-MIBqhBNCtUUQqkEQhQzUhTQUSqc=",
      "dev": true,
      "requires": {
        "convert-source-map": "^0.3.3",
        "css": "^2.0.0"
      },
      "dependencies": {
        "convert-source-map": {
          "version": "0.3.5",
          "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-0.3.5.tgz",
          "integrity": "sha1-8dgClQr33SYxof6+BZZVDIarMZA=",
          "dev": true
        }
      }
    },
    "rework-visit": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/rework-visit/-/rework-visit-1.0.0.tgz",
      "integrity": "sha1-mUWygD8hni96ygCtuLyfZA+ELJo=",
      "dev": true
    },
    "rgb-regex": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/rgb-regex/-/rgb-regex-1.0.1.tgz",
      "integrity": "sha1-wODWiC3w4jviVKR16O3UGRX+rrE=",
      "dev": true
    },
    "rgba-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/rgba-regex/-/rgba-regex-1.0.0.tgz",
      "integrity": "sha1-QzdOLiyglosO8VI0YLfXMP8i7rM=",
      "dev": true
    },
    "rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "dev": true,
      "requires": {
        "glob": "^7.1.3"
      }
    },
    "ripemd160": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/ripemd160/-/ripemd160-2.0.2.tgz",
      "integrity": "sha512-ii4iagi25WusVoiC4B4lq7pbXfAp3D9v5CwfkY33vffw2+pkDjY1D8GaN7spsxvCSx8dkPqOZCEZyfxcmJG2IA==",
      "dev": true,
      "requires": {
        "hash-base": "^3.0.0",
        "inherits": "^2.0.1"
      }
    },
    "rollup": {
      "version": "2.10.9",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.10.9.tgz",
      "integrity": "sha512-dY/EbjiWC17ZCUSyk14hkxATAMAShkMsD43XmZGWjLrgFj15M3Dw2kEkA9ns64BiLFm9PKN6vTQw8neHwK74eg==",
      "dev": true,
      "requires": {
        "fsevents": "~2.1.2"
      }
    },
    "rsvp": {
      "version": "4.8.5",
      "resolved": "https://registry.npmjs.org/rsvp/-/rsvp-4.8.5.tgz",
      "integrity": "sha512-nfMOlASu9OnRJo1mbEk2cz0D56a1MBNrJ7orjRZQG10XDyuvwksKbuXNp6qa+kbn839HwjwhBzhFmdsaEAfauA==",
      "dev": true
    },
    "run-async": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz",
      "integrity": "sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==",
      "dev": true
    },
    "run-parallel": {
      "version": "1.1.9",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.1.9.tgz",
      "integrity": "sha512-DEqnSRTDw/Tc3FXf49zedI638Z9onwUotBMiUFKmrO2sdFKIbXamXGQ3Axd4qgphxKB4kw/qP1w5kTxnfU1B9Q==",
      "dev": true
    },
    "run-queue": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/run-queue/-/run-queue-1.0.3.tgz",
      "integrity": "sha1-6Eg5bwV9Ij8kOGkkYY4laUFh7Ec=",
      "dev": true,
      "requires": {
        "aproba": "^1.1.1"
      }
    },
    "rxjs": {
      "version": "6.5.5",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-6.5.5.tgz",
      "integrity": "sha512-WfQI+1gohdf0Dai/Bbmk5L5ItH5tYqm3ki2c5GdWhKjalzjg93N3avFjVStyZZz+A2Em+ZxKH5bNghw9UeylGQ==",
      "requires": {
        "tslib": "^1.9.0"
      }
    },
    "safe-buffer": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.0.tgz",
      "integrity": "sha512-fZEwUGbVl7kouZs1jCdMLdt95hdIv0ZeHg6L7qPeciMZhZ+/gdesW4wgTARkrFWEpspjEATAzUGPG8N2jJiwbg==",
      "dev": true
    },
    "safe-regex": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/safe-regex/-/safe-regex-1.1.0.tgz",
      "integrity": "sha1-QKNmnzsHfR6UPURinhV91IAjvy4=",
      "requires": {
        "ret": "~0.1.10"
      }
    },
    "safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "sane": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/sane/-/sane-4.1.0.tgz",
      "integrity": "sha512-hhbzAgTIX8O7SHfp2c8/kREfEn4qO/9q8C9beyY6+tvZ87EpoZ3i1RIEvp27YBswnNbY9mWd6paKVmKbAgLfZA==",
      "dev": true,
      "requires": {
        "@cnakazawa/watch": "^1.0.3",
        "anymatch": "^2.0.0",
        "capture-exit": "^2.0.0",
        "exec-sh": "^0.3.2",
        "execa": "^1.0.0",
        "fb-watchman": "^2.0.0",
        "micromatch": "^3.1.4",
        "minimist": "^1.1.1",
        "walker": "~1.0.5"
      },
      "dependencies": {
        "anymatch": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-2.0.0.tgz",
          "integrity": "sha512-5teOsQWABXHHBFP9y3skS5P3d/WfWXpv3FUpy+LorMrNYaT9pI4oLMQX7jzQ2KklNpGpWHzdCXTDT2Y3XGlZBw==",
          "dev": true,
          "requires": {
            "micromatch": "^3.1.4",
            "normalize-path": "^2.1.1"
          }
        },
        "normalize-path": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
          "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
          "dev": true,
          "requires": {
            "remove-trailing-separator": "^1.0.1"
          }
        }
      }
    },
    "sass": {
      "version": "1.26.5",
      "resolved": "https://registry.npmjs.org/sass/-/sass-1.26.5.tgz",
      "integrity": "sha512-FG2swzaZUiX53YzZSjSakzvGtlds0lcbF+URuU9mxOv7WBh7NhXEVDa4kPKN4hN6fC2TkOTOKqiqp6d53N9X5Q==",
      "dev": true,
      "requires": {
        "chokidar": ">=2.0.0 <4.0.0"
      }
    },
    "sass-loader": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/sass-loader/-/sass-loader-8.0.2.tgz",
      "integrity": "sha512-7o4dbSK8/Ol2KflEmSco4jTjQoV988bM82P9CZdmo9hR3RLnvNc0ufMNdMrB0caq38JQ/FgF4/7RcbcfKzxoFQ==",
      "dev": true,
      "requires": {
        "clone-deep": "^4.0.1",
        "loader-utils": "^1.2.3",
        "neo-async": "^2.6.1",
        "schema-utils": "^2.6.1",
        "semver": "^6.3.0"
      },
      "dependencies": {
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "saucelabs": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/saucelabs/-/saucelabs-1.5.0.tgz",
      "integrity": "sha512-jlX3FGdWvYf4Q3LFfFWS1QvPg3IGCGWxIc8QBFdPTbpTJnt/v17FHXYVAn7C8sHf1yUXo2c7yIM0isDryfYtHQ==",
      "dev": true,
      "requires": {
        "https-proxy-agent": "^2.2.1"
      }
    },
    "sax": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/sax/-/sax-1.2.4.tgz",
      "integrity": "sha512-NqVDv9TpANUjFm0N8uM5GxL36UgKi9/atZw+x7YFnQ8ckwFGKrl4xX4yWtrey3UJm5nP1kUbnYgLopqWNSRhWw==",
      "dev": true
    },
    "saxes": {
      "version": "3.1.11",
      "resolved": "https://registry.npmjs.org/saxes/-/saxes-3.1.11.tgz",
      "integrity": "sha512-Ydydq3zC+WYDJK1+gRxRapLIED9PWeSuuS41wqyoRmzvhhh9nc+QQrVMKJYzJFULazeGhzSV0QleN2wD3boh2g==",
      "dev": true,
      "requires": {
        "xmlchars": "^2.1.1"
      }
    },
    "schema-utils": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-2.7.0.tgz",
      "integrity": "sha512-0ilKFI6QQF5nxDZLFn2dMjvc4hjg/Wkg7rHd3jK6/A4a1Hl9VFdQWvgB1UMGoU94pad1P/8N7fMcEnLnSiju8A==",
      "requires": {
        "@types/json-schema": "^7.0.4",
        "ajv": "^6.12.2",
        "ajv-keywords": "^3.4.1"
      },
      "dependencies": {
        "ajv": {
          "version": "6.12.4",
          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.4.tgz",
          "integrity": "sha512-eienB2c9qVQs2KWexhkrdMLVDoIQCz5KSeLxwg9Lzk4DOfBtIK9PQwwufcsn1jjGuf9WZmqPMbGxOzfcuphJCQ==",
          "requires": {
            "fast-deep-equal": "^3.1.1",
            "fast-json-stable-stringify": "^2.0.0",
            "json-schema-traverse": "^0.4.1",
            "uri-js": "^4.2.2"
          }
        }
      }
    },
    "select-hose": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/select-hose/-/select-hose-2.0.0.tgz",
      "integrity": "sha1-Yl2GWPhlr0Psliv8N2o3NZpJlMo=",
      "dev": true
    },
    "selenium-webdriver": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/selenium-webdriver/-/selenium-webdriver-3.6.0.tgz",
      "integrity": "sha512-WH7Aldse+2P5bbFBO4Gle/nuQOdVwpHMTL6raL3uuBj/vPG07k6uzt3aiahu352ONBr5xXh0hDlM3LhtXPOC4Q==",
      "dev": true,
      "requires": {
        "jszip": "^3.1.3",
        "rimraf": "^2.5.4",
        "tmp": "0.0.30",
        "xml2js": "^0.4.17"
      },
      "dependencies": {
        "rimraf": {
          "version": "2.7.1",
          "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
          "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
          "dev": true,
          "requires": {
            "glob": "^7.1.3"
          }
        },
        "tmp": {
          "version": "0.0.30",
          "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.0.30.tgz",
          "integrity": "sha1-ckGdSovn1s51FI/YsyTlk6cRwu0=",
          "dev": true,
          "requires": {
            "os-tmpdir": "~1.0.1"
          }
        }
      }
    },
    "selfsigned": {
      "version": "1.10.7",
      "resolved": "https://registry.npmjs.org/selfsigned/-/selfsigned-1.10.7.tgz",
      "integrity": "sha512-8M3wBCzeWIJnQfl43IKwOmC4H/RAp50S8DF60znzjW5GVqTcSe2vWclt7hmYVPkKPlHWOu5EaWOMZ2Y6W8ZXTA==",
      "dev": true,
      "requires": {
        "node-forge": "0.9.0"
      }
    },
    "semver": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
      "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ=="
    },
    "semver-dsl": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/semver-dsl/-/semver-dsl-1.0.1.tgz",
      "integrity": "sha1-02eN5VVeimH2Ke7QJTZq5fJzQKA=",
      "dev": true,
      "requires": {
        "semver": "^5.3.0"
      }
    },
    "semver-intersect": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/semver-intersect/-/semver-intersect-1.4.0.tgz",
      "integrity": "sha512-d8fvGg5ycKAq0+I6nfWeCx6ffaWJCsBYU0H2Rq56+/zFePYfT8mXkB3tWBSjR5BerkHNZ5eTPIk1/LBYas35xQ==",
      "dev": true,
      "requires": {
        "semver": "^5.0.0"
      }
    },
    "send": {
      "version": "0.17.1",
      "resolved": "https://registry.npmjs.org/send/-/send-0.17.1.tgz",
      "integrity": "sha512-BsVKsiGcQMFwT8UxypobUKyv7irCNRHk1T0G680vk88yf6LBByGcZJOTJCrTP2xVN6yI+XjPJcNuE3V4fT9sAg==",
      "requires": {
        "debug": "2.6.9",
        "depd": "~1.1.2",
        "destroy": "~1.0.4",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "~1.7.2",
        "mime": "1.6.0",
        "ms": "2.1.1",
        "on-finished": "~2.3.0",
        "range-parser": "~1.2.1",
        "statuses": "~1.5.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          },
          "dependencies": {
            "ms": {
              "version": "2.0.0",
              "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
              "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
            }
          }
        },
        "ms": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.1.tgz",
          "integrity": "sha512-tgp+dl5cGk28utYktBsrFqA7HKgrhgPsg6Z/EfhWI4gl1Hwq8B/GmY/0oXZ6nF8hDVesS/FpnYaD/kOWhYQvyg=="
        }
      }
    },
    "serialize-javascript": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-2.1.2.tgz",
      "integrity": "sha512-rs9OggEUF0V4jUSecXazOYsLfu7OGK2qIn3c7IPBiffz32XniEp/TX9Xmc9LQfK2nQ2QKHvZ2oygKUGU0lG4jQ==",
      "dev": true
    },
    "serve-index": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/serve-index/-/serve-index-1.9.1.tgz",
      "integrity": "sha1-03aNabHn2C5c4FD/9bRTvqEqkjk=",
      "dev": true,
      "requires": {
        "accepts": "~1.3.4",
        "batch": "0.6.1",
        "debug": "2.6.9",
        "escape-html": "~1.0.3",
        "http-errors": "~1.6.2",
        "mime-types": "~2.1.17",
        "parseurl": "~1.3.2"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "http-errors": {
          "version": "1.6.3",
          "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.6.3.tgz",
          "integrity": "sha1-i1VoC7S+KDoLW/TqLjhYC+HZMg0=",
          "dev": true,
          "requires": {
            "depd": "~1.1.2",
            "inherits": "2.0.3",
            "setprototypeof": "1.1.0",
            "statuses": ">= 1.4.0 < 2"
          }
        },
        "inherits": {
          "version": "2.0.3",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
          "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=",
          "dev": true
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        },
        "setprototypeof": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.0.tgz",
          "integrity": "sha512-BvE/TwpZX4FXExxOxZyRGQQv651MSwmWKZGqvmPcRIjDqWub67kTKuIMx43cZZrS/cBBzwBcNDWoFxt2XEFIpQ==",
          "dev": true
        }
      }
    },
    "serve-static": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.14.1.tgz",
      "integrity": "sha512-JMrvUwE54emCYWlTI+hGrGv5I8dEwmco/00EvkzIIsR7MqrHonbD9pO2MOfFnpFntl7ecpZs+3mW+XbQZu9QCg==",
      "requires": {
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.17.1"
      }
    },
    "set-blocking": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
      "integrity": "sha1-BF+XgtARrppoA93TgrJDkrPYkPc=",
      "dev": true
    },
    "set-immediate-shim": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/set-immediate-shim/-/set-immediate-shim-1.0.1.tgz",
      "integrity": "sha1-SysbJ+uAip+NzEgaWOXlb1mfP2E=",
      "dev": true
    },
    "set-value": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/set-value/-/set-value-2.0.1.tgz",
      "integrity": "sha512-JxHc1weCN68wRY0fhCoXpyK55m/XPHafOmK4UWD7m2CI14GMcFypt4w/0+NV5f/ZMby2F6S2wwA7fgynh9gWSw==",
      "requires": {
        "extend-shallow": "^2.0.1",
        "is-extendable": "^0.1.1",
        "is-plain-object": "^2.0.3",
        "split-string": "^3.0.1"
      }
    },
    "setimmediate": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/setimmediate/-/setimmediate-1.0.5.tgz",
      "integrity": "sha1-KQy7Iy4waULX1+qbg3Mqt4VvgoU=",
      "dev": true
    },
    "setprototypeof": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.1.1.tgz",
      "integrity": "sha512-JvdAWfbXeIGaZ9cILp38HntZSFSo3mWg6xGcJJsd+d4aRMOqauag1C63dJfDw7OaMYwEbHMOxEZ1lqVRYP2OAw=="
    },
    "sha.js": {
      "version": "2.4.11",
      "resolved": "https://registry.npmjs.org/sha.js/-/sha.js-2.4.11.tgz",
      "integrity": "sha512-QMEp5B7cftE7APOjk5Y6xgrbWu+WkLVQwk8JNjZ8nKRciZaByEW6MubieAiToS7+dwvrjGhH8jRXz3MVd0AYqQ==",
      "dev": true,
      "requires": {
        "inherits": "^2.0.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "shallow-clone": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/shallow-clone/-/shallow-clone-3.0.1.tgz",
      "integrity": "sha512-/6KqX+GVUdqPuPPd2LxDDxzX6CAbjJehAAOKlNpqqUpAqPM6HeL8f+o3a+JsyGjn2lv0WY8UsTgUJjU9Ok55NA==",
      "dev": true,
      "requires": {
        "kind-of": "^6.0.2"
      }
    },
    "shebang-command": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-1.2.0.tgz",
      "integrity": "sha1-RKrGW2lbAzmJaMOfNj/uXer98eo=",
      "dev": true,
      "requires": {
        "shebang-regex": "^1.0.0"
      }
    },
    "shebang-regex": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-1.0.0.tgz",
      "integrity": "sha1-2kL0l0DAtC2yypcoVxyxkMmO/qM=",
      "dev": true
    },
    "shell-quote": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/shell-quote/-/shell-quote-1.7.2.tgz",
      "integrity": "sha512-mRz/m/JVscCrkMyPqHc/bczi3OQHkLTqXHEFu0zDhK/qfv3UcOA4SVmRCLmos4bhjr9ekVQubj/R7waKapmiQg==",
      "dev": true
    },
    "shellwords": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/shellwords/-/shellwords-0.1.1.tgz",
      "integrity": "sha512-vFwSUfQvqybiICwZY5+DAWIPLKsWO31Q91JSKl3UYv+K5c2QRPzn0qzec6QPu1Qc9eHYItiP3NdJqNVqetYAww==",
      "dev": true,
      "optional": true
    },
    "signal-exit": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.3.tgz",
      "integrity": "sha512-VUJ49FC8U1OxwZLxIbTTrDvLnf/6TDgxZcK8wxR8zs13xpx7xbG60ndBlhNrFi2EMuFRoeDoJO7wthSLq42EjA=="
    },
    "simple-swizzle": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/simple-swizzle/-/simple-swizzle-0.2.2.tgz",
      "integrity": "sha1-pNprY1/8zMoz9w0Xy5JZLeleVXo=",
      "dev": true,
      "requires": {
        "is-arrayish": "^0.3.1"
      },
      "dependencies": {
        "is-arrayish": {
          "version": "0.3.2",
          "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.3.2.tgz",
          "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==",
          "dev": true
        }
      }
    },
    "sinon": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/sinon/-/sinon-9.0.2.tgz",
      "integrity": "sha512-0uF8Q/QHkizNUmbK3LRFqx5cpTttEVXudywY9Uwzy8bTfZUhljZ7ARzSxnRHWYWtVTeh4Cw+tTb3iU21FQVO9A==",
      "dev": true,
      "requires": {
        "@sinonjs/commons": "^1.7.2",
        "@sinonjs/fake-timers": "^6.0.1",
        "@sinonjs/formatio": "^5.0.1",
        "@sinonjs/samsam": "^5.0.3",
        "diff": "^4.0.2",
        "nise": "^4.0.1",
        "supports-color": "^7.1.0"
      },
      "dependencies": {
        "diff": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
          "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
          "dev": true
        }
      }
    },
    "sinon-chai": {
      "version": "3.5.0",
      "resolved": "https://registry.npmjs.org/sinon-chai/-/sinon-chai-3.5.0.tgz",
      "integrity": "sha512-IifbusYiQBpUxxFJkR3wTU68xzBN0+bxCScEaKMjBvAQERg6FnTTc1F17rseLb1tjmkJ23730AXpFI0c47FgAg==",
      "dev": true
    },
    "sisteransi": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/sisteransi/-/sisteransi-1.0.5.tgz",
      "integrity": "sha512-bLGGlR1QxBcynn2d5YmDX4MGjlZvy2MRBDRNHLJ8VI6l6+9FUiyTFNJ0IveOSP0bcXgVDPRcfGqA0pjaqUpfVg==",
      "dev": true
    },
    "slash": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-1.0.0.tgz",
      "integrity": "sha1-xB8vbDn8FtHNF61LXYlhFK5HDVU=",
      "dev": true
    },
    "slice-ansi": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-2.1.0.tgz",
      "integrity": "sha512-Qu+VC3EwYLldKa1fCxuuvULvSJOKEgk9pi8dZeCVK7TqBfUNTH4sFkk4joj8afVSfAYgJoSOetjx9QWOJ5mYoQ==",
      "dev": true,
      "requires": {
        "ansi-styles": "^3.2.0",
        "astral-regex": "^1.0.0",
        "is-fullwidth-code-point": "^2.0.0"
      }
    },
    "slide": {
      "version": "1.1.6",
      "resolved": "https://registry.npmjs.org/slide/-/slide-1.1.6.tgz",
      "integrity": "sha1-VusCfWW00tzmyy4tMsTUr8nh1wc="
    },
    "smart-buffer": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.1.0.tgz",
      "integrity": "sha512-iVICrxOzCynf/SNaBQCw34eM9jROU/s5rzIhpOvzhzuYHfJR/DhZfDkXiZSgKXfgv26HT3Yni3AV/DGw0cGnnw==",
      "dev": true
    },
    "snapdragon": {
      "version": "0.8.2",
      "resolved": "https://registry.npmjs.org/snapdragon/-/snapdragon-0.8.2.tgz",
      "integrity": "sha512-FtyOnWN/wCHTVXOMwvSv26d+ko5vWlIDD6zoUJ7LW8vh+ZBC8QdljveRP+crNrtBwioEUWy/4dMtbBjA4ioNlg==",
      "requires": {
        "base": "^0.11.1",
        "debug": "^2.2.0",
        "define-property": "^0.2.5",
        "extend-shallow": "^2.0.1",
        "map-cache": "^0.2.2",
        "source-map": "^0.5.6",
        "source-map-resolve": "^0.5.0",
        "use": "^3.1.0"
      },
      "dependencies": {
        "debug": {
          "version": "2.6.9",
          "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
          "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
          "requires": {
            "ms": "2.0.0"
          }
        },
        "define-property": {
          "version": "0.2.5",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
          "requires": {
            "is-descriptor": "^0.1.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g="
        },
        "source-map": {
          "version": "0.5.7",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
          "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w="
        }
      }
    },
    "snapdragon-node": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/snapdragon-node/-/snapdragon-node-2.1.1.tgz",
      "integrity": "sha512-O27l4xaMYt/RSQ5TR3vpWCAB5Kb/czIcqUFOM/C4fYcLnbZUc1PkjTAMjof2pBWaSTwOUd6qUHcFGVGj7aIwnw==",
      "requires": {
        "define-property": "^1.0.0",
        "isobject": "^3.0.0",
        "snapdragon-util": "^3.0.1"
      },
      "dependencies": {
        "define-property": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-1.0.0.tgz",
          "integrity": "sha1-dp66rz9KY6rTr56NMEybvnm/sOY=",
          "requires": {
            "is-descriptor": "^1.0.0"
          }
        },
        "is-accessor-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-accessor-descriptor/-/is-accessor-descriptor-1.0.0.tgz",
          "integrity": "sha512-m5hnHTkcVsPfqx3AKlyttIPb7J+XykHvJP2B9bZDjlhLIoEq4XoK64Vg7boZlVWYK6LUY94dYPEE7Lh0ZkZKcQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-data-descriptor": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/is-data-descriptor/-/is-data-descriptor-1.0.0.tgz",
          "integrity": "sha512-jbRXy1FmtAoCjQkVmIVYwuuqDFUbaOeDjmed1tOGPrsMhtJA4rD9tkgA0F1qJ3gRFRXcHYVkdeaP50Q5rE/jLQ==",
          "requires": {
            "kind-of": "^6.0.0"
          }
        },
        "is-descriptor": {
          "version": "1.0.2",
          "resolved": "https://registry.npmjs.org/is-descriptor/-/is-descriptor-1.0.2.tgz",
          "integrity": "sha512-2eis5WqQGV7peooDyLmNEPUrps9+SXX5c9pL3xEB+4e9HnGuDa7mB7kHxHw4CbqS9k1T2hOH3miL8n8WtiYVtg==",
          "requires": {
            "is-accessor-descriptor": "^1.0.0",
            "is-data-descriptor": "^1.0.0",
            "kind-of": "^6.0.2"
          }
        }
      }
    },
    "snapdragon-util": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/snapdragon-util/-/snapdragon-util-3.0.1.tgz",
      "integrity": "sha512-mbKkMdQKsjX4BAL4bRYTj21edOf8cN7XHdYUJEe+Zn99hVEYcMvKPct1IqNe7+AZPirn8BCDOQBHQZknqmKlZQ==",
      "requires": {
        "kind-of": "^3.2.0"
      },
      "dependencies": {
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "sockjs": {
      "version": "0.3.19",
      "resolved": "https://registry.npmjs.org/sockjs/-/sockjs-0.3.19.tgz",
      "integrity": "sha512-V48klKZl8T6MzatbLlzzRNhMepEys9Y4oGFpypBFFn1gLI/QQ9HtLLyWJNbPlwGLelOVOEijUbTTJeLLI59jLw==",
      "dev": true,
      "requires": {
        "faye-websocket": "^0.10.0",
        "uuid": "^3.0.1"
      }
    },
    "sockjs-client": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/sockjs-client/-/sockjs-client-1.4.0.tgz",
      "integrity": "sha512-5zaLyO8/nri5cua0VtOrFXBPK1jbL4+1cebT/mmKA1E1ZXOvJrII75bPu0l0k843G/+iAbhEqzyKr0w/eCCj7g==",
      "dev": true,
      "requires": {
        "debug": "^3.2.5",
        "eventsource": "^1.0.7",
        "faye-websocket": "~0.11.1",
        "inherits": "^2.0.3",
        "json3": "^3.3.2",
        "url-parse": "^1.4.3"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        },
        "faye-websocket": {
          "version": "0.11.3",
          "resolved": "https://registry.npmjs.org/faye-websocket/-/faye-websocket-0.11.3.tgz",
          "integrity": "sha512-D2y4bovYpzziGgbHYtGCMjlJM36vAl/y+xUyn1C+FVx8szd1E+86KwVw6XvYSzOP8iMpm1X0I4xJD+QtUb36OA==",
          "dev": true,
          "requires": {
            "websocket-driver": ">=0.5.1"
          }
        }
      }
    },
    "socks": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/socks/-/socks-2.3.3.tgz",
      "integrity": "sha512-o5t52PCNtVdiOvzMry7wU4aOqYWL0PeCXRWBEiJow4/i/wr+wpsJQ9awEu1EonLIqsfGd5qSgDdxEOvCdmBEpA==",
      "dev": true,
      "requires": {
        "ip": "1.1.5",
        "smart-buffer": "^4.1.0"
      }
    },
    "socks-proxy-agent": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-4.0.2.tgz",
      "integrity": "sha512-NT6syHhI9LmuEMSK6Kd2V7gNv5KFZoLE7V5udWmn0de+3Mkj3UMA/AJPLyeNUVmElCurSHtUdM3ETpR3z770Wg==",
      "dev": true,
      "requires": {
        "agent-base": "~4.2.1",
        "socks": "~2.3.2"
      },
      "dependencies": {
        "agent-base": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-4.2.1.tgz",
          "integrity": "sha512-JVwXMr9nHYTUXsBFKUqhJwvlcYU/blreOEUkhNR2eXZIvwd+c+o5V4MgDPKWnMS/56awN3TRzIP+KoPn+roQtg==",
          "dev": true,
          "requires": {
            "es6-promisify": "^5.0.0"
          }
        }
      }
    },
    "sort-keys": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/sort-keys/-/sort-keys-1.1.2.tgz",
      "integrity": "sha1-RBttTTRnmPG05J6JIK37oOVD+a0=",
      "dev": true,
      "requires": {
        "is-plain-obj": "^1.0.0"
      }
    },
    "source-list-map": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/source-list-map/-/source-list-map-2.0.1.tgz",
      "integrity": "sha512-qnQ7gVMxGNxsiL4lEuJwe/To8UnK7fAnmbGEEH8RpLouuKbeEm0lhbQVFIrNSuB+G7tVrAlVsZgETT5nljf+Iw==",
      "dev": true
    },
    "source-map": {
      "version": "0.7.3",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.7.3.tgz",
      "integrity": "sha512-CkCj6giN3S+n9qrYiBTX5gystlENnRW5jZeNLHpe6aue+SrHcG5VYwujhW9s4dY31mEGsxBDrHR6oI69fTXsaQ=="
    },
    "source-map-loader": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/source-map-loader/-/source-map-loader-1.0.0.tgz",
      "integrity": "sha512-ZayyQCSCrQazN50aCvuS84lJT4xc1ZAcykH5blHaBdVveSwjiFK8UGMPvao0ho54DTb0Jf7m57uRRG/YYUZ2Fg==",
      "dev": true,
      "requires": {
        "data-urls": "^2.0.0",
        "iconv-lite": "^0.5.1",
        "loader-utils": "^2.0.0",
        "schema-utils": "^2.6.6",
        "source-map": "^0.6.0"
      },
      "dependencies": {
        "data-urls": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-2.0.0.tgz",
          "integrity": "sha512-X5eWTSXO/BJmpdIKCRuKUgSCgAN0OwliVK3yPKbwIWU1Tdw5BRajxlzMidvh+gwko9AfQ9zIj52pzF91Q3YAvQ==",
          "dev": true,
          "requires": {
            "abab": "^2.0.3",
            "whatwg-mimetype": "^2.3.0",
            "whatwg-url": "^8.0.0"
          }
        },
        "iconv-lite": {
          "version": "0.5.2",
          "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.5.2.tgz",
          "integrity": "sha512-kERHXvpSaB4aU3eANwidg79K8FlrN77m8G9V+0vOR3HYaRifrlwMEpT7ZBJqLSEIHnEgJTHcWK82wwLwwKwtag==",
          "dev": true,
          "requires": {
            "safer-buffer": ">= 2.1.2 < 3"
          }
        },
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "tr46": {
          "version": "2.0.2",
          "resolved": "https://registry.npmjs.org/tr46/-/tr46-2.0.2.tgz",
          "integrity": "sha512-3n1qG+/5kg+jrbTzwAykB5yRYtQCTqOGKq5U5PE3b0a1/mzo6snDhjGS0zJVJunO0NrT3Dg1MLy5TjWP/UJppg==",
          "dev": true,
          "requires": {
            "punycode": "^2.1.1"
          }
        },
        "webidl-conversions": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-5.0.0.tgz",
          "integrity": "sha512-VlZwKPCkYKxQgeSbH5EyngOmRp7Ww7I9rQLERETtf5ofd9pGeswWiOtogpEO850jziPRarreGxn5QIiTqpb2wA==",
          "dev": true
        },
        "whatwg-url": {
          "version": "8.1.0",
          "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-8.1.0.tgz",
          "integrity": "sha512-vEIkwNi9Hqt4TV9RdnaBPNt+E2Sgmo3gePebCRgZ1R7g6d23+53zCTnuB0amKI4AXq6VM8jj2DUAa0S1vjJxkw==",
          "dev": true,
          "requires": {
            "lodash.sortby": "^4.7.0",
            "tr46": "^2.0.2",
            "webidl-conversions": "^5.0.0"
          }
        }
      }
    },
    "source-map-resolve": {
      "version": "0.5.3",
      "resolved": "https://registry.npmjs.org/source-map-resolve/-/source-map-resolve-0.5.3.tgz",
      "integrity": "sha512-Htz+RnsXWk5+P2slx5Jh3Q66vhQj1Cllm0zvnaY98+NFx+Dv2CF/f5O/t8x+KaNdrdIAsruNzoh/KpialbqAnw==",
      "requires": {
        "atob": "^2.1.2",
        "decode-uri-component": "^0.2.0",
        "resolve-url": "^0.2.1",
        "source-map-url": "^0.4.0",
        "urix": "^0.1.0"
      }
    },
    "source-map-support": {
      "version": "0.5.16",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.16.tgz",
      "integrity": "sha512-efyLRJDr68D9hBBNIPWFjhpFzURh+KJykQwvMyW5UiZzYwoF6l4YMMDIJJEyFWxWCqfyxLzz6tSfUFR+kXXsVQ==",
      "dev": true,
      "requires": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "source-map-url": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/source-map-url/-/source-map-url-0.4.0.tgz",
      "integrity": "sha1-PpNdfd1zYxuXZZlW1VEo6HtQhKM="
    },
    "sourcemap-codec": {
      "version": "1.4.8",
      "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
      "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA=="
    },
    "spdx-correct": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/spdx-correct/-/spdx-correct-3.1.0.tgz",
      "integrity": "sha512-lr2EZCctC2BNR7j7WzJ2FpDznxky1sjfxvvYEyzxNyb6lZXHODmEoJeFu4JupYlkfha1KZpJyoqiJ7pgA1qq8Q==",
      "dev": true,
      "requires": {
        "spdx-expression-parse": "^3.0.0",
        "spdx-license-ids": "^3.0.0"
      }
    },
    "spdx-exceptions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/spdx-exceptions/-/spdx-exceptions-2.3.0.tgz",
      "integrity": "sha512-/tTrYOC7PPI1nUAgx34hUpqXuyJG+DTHJTnIULG4rDygi4xu/tfgmq1e1cIRwRzwZgo4NLySi+ricLkZkw4i5A==",
      "dev": true
    },
    "spdx-expression-parse": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/spdx-expression-parse/-/spdx-expression-parse-3.0.0.tgz",
      "integrity": "sha512-Yg6D3XpRD4kkOmTpdgbUiEJFKghJH03fiC1OPll5h/0sO6neh2jqRDVHOQ4o/LMea0tgCkbMgea5ip/e+MkWyg==",
      "dev": true,
      "requires": {
        "spdx-exceptions": "^2.1.0",
        "spdx-license-ids": "^3.0.0"
      }
    },
    "spdx-license-ids": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/spdx-license-ids/-/spdx-license-ids-3.0.5.tgz",
      "integrity": "sha512-J+FWzZoynJEXGphVIS+XEh3kFSjZX/1i9gFBaWQcB+/tmpe2qUsSBABpcxqxnAxFdiUFEgAX1bjYGQvIZmoz9Q==",
      "dev": true
    },
    "spdy": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/spdy/-/spdy-4.0.2.tgz",
      "integrity": "sha512-r46gZQZQV+Kl9oItvl1JZZqJKGr+oEkB08A6BzkiR7593/7IbtuncXHd2YoYeTsG4157ZssMu9KYvUHLcjcDoA==",
      "dev": true,
      "requires": {
        "debug": "^4.1.0",
        "handle-thing": "^2.0.0",
        "http-deceiver": "^1.2.7",
        "select-hose": "^2.0.0",
        "spdy-transport": "^3.0.0"
      }
    },
    "spdy-transport": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/spdy-transport/-/spdy-transport-3.0.0.tgz",
      "integrity": "sha512-hsLVFE5SjA6TCisWeJXFKniGGOpBgMLmerfO2aCyCU5s7nJ/rpAepqmFifv/GCbSbueEeAJJnmSQ2rKC/g8Fcw==",
      "dev": true,
      "requires": {
        "debug": "^4.1.0",
        "detect-node": "^2.0.4",
        "hpack.js": "^2.1.6",
        "obuf": "^1.1.2",
        "readable-stream": "^3.0.6",
        "wbuf": "^1.7.3"
      },
      "dependencies": {
        "readable-stream": {
          "version": "3.6.0",
          "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
          "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
          "dev": true,
          "requires": {
            "inherits": "^2.0.3",
            "string_decoder": "^1.1.1",
            "util-deprecate": "^1.0.1"
          }
        }
      }
    },
    "speed-measure-webpack-plugin": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/speed-measure-webpack-plugin/-/speed-measure-webpack-plugin-1.3.3.tgz",
      "integrity": "sha512-2ljD4Ch/rz2zG3HsLsnPfp23osuPBS0qPuz9sGpkNXTN1Ic4M+W9xB8l8rS8ob2cO4b1L+WTJw/0AJwWYVgcxQ==",
      "dev": true,
      "requires": {
        "chalk": "^2.0.1"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "split-string": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/split-string/-/split-string-3.1.0.tgz",
      "integrity": "sha512-NzNVhJDYpwceVVii8/Hu6DKfD2G+NrQHlS/V/qgv763EYudVwEcMQNxd2lh+0VrUByXN/oJkl5grOhYWvQUYiw==",
      "requires": {
        "extend-shallow": "^3.0.0"
      },
      "dependencies": {
        "extend-shallow": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
          "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
          "requires": {
            "assign-symbols": "^1.0.0",
            "is-extendable": "^1.0.1"
          }
        },
        "is-extendable": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
          "requires": {
            "is-plain-object": "^2.0.4"
          }
        }
      }
    },
    "sprintf-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz",
      "integrity": "sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=",
      "dev": true
    },
    "sshpk": {
      "version": "1.16.1",
      "resolved": "https://registry.npmjs.org/sshpk/-/sshpk-1.16.1.tgz",
      "integrity": "sha512-HXXqVUq7+pcKeLqqZj6mHFUMvXtOJt1uoUx09pFW6011inTMxqI8BA8PM95myrIyyKwdnzjdFjLiE6KBPVtJIg==",
      "dev": true,
      "requires": {
        "asn1": "~0.2.3",
        "assert-plus": "^1.0.0",
        "bcrypt-pbkdf": "^1.0.0",
        "dashdash": "^1.12.0",
        "ecc-jsbn": "~0.1.1",
        "getpass": "^0.1.1",
        "jsbn": "~0.1.0",
        "safer-buffer": "^2.0.2",
        "tweetnacl": "~0.14.0"
      }
    },
    "ssri": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/ssri/-/ssri-8.0.0.tgz",
      "integrity": "sha512-aq/pz989nxVYwn16Tsbj1TqFpD5LLrQxHf5zaHuieFV+R0Bbr4y8qUsOA45hXT/N4/9UNXTarBjnjVmjSOVaAA==",
      "dev": true,
      "requires": {
        "minipass": "^3.1.1"
      }
    },
    "stable": {
      "version": "0.1.8",
      "resolved": "https://registry.npmjs.org/stable/-/stable-0.1.8.tgz",
      "integrity": "sha512-ji9qxRnOVfcuLDySj9qzhGSEFVobyt1kIOSkj1qZzYLzq7Tos/oUUWvotUPQLlrsidqsK6tBH89Bc9kL5zHA6w==",
      "dev": true
    },
    "stack-utils": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/stack-utils/-/stack-utils-1.0.2.tgz",
      "integrity": "sha512-MTX+MeG5U994cazkjd/9KNAapsHnibjMLnfXodlkXw76JEea0UiNzrqidzo1emMwk7w5Qhc9jd4Bn9TBb1MFwA==",
      "dev": true
    },
    "static-extend": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/static-extend/-/static-extend-0.1.2.tgz",
      "integrity": "sha1-YICcOcv/VTNyJv1eC1IPNB8ftcY=",
      "requires": {
        "define-property": "^0.2.5",
        "object-copy": "^0.1.0"
      },
      "dependencies": {
        "define-property": {
          "version": "0.2.5",
          "resolved": "https://registry.npmjs.org/define-property/-/define-property-0.2.5.tgz",
          "integrity": "sha1-w1se+RjsPJkPmlvFe+BKrOxcgRY=",
          "requires": {
            "is-descriptor": "^0.1.0"
          }
        }
      }
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow="
    },
    "stealthy-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/stealthy-require/-/stealthy-require-1.1.1.tgz",
      "integrity": "sha1-NbCYdbT/SfJqd35QmzCQoyJr8ks=",
      "dev": true
    },
    "stream-browserify": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/stream-browserify/-/stream-browserify-2.0.2.tgz",
      "integrity": "sha512-nX6hmklHs/gr2FuxYDltq8fJA1GDlxKQCz8O/IM4atRqBH8OORmBNgfvW5gG10GT/qQ9u0CzIvr2X5Pkt6ntqg==",
      "dev": true,
      "requires": {
        "inherits": "~2.0.1",
        "readable-stream": "^2.0.2"
      }
    },
    "stream-each": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/stream-each/-/stream-each-1.2.3.tgz",
      "integrity": "sha512-vlMC2f8I2u/bZGqkdfLQW/13Zihpej/7PmSiMQsbYddxuTsJp8vRe2x2FvVExZg7FaOds43ROAuFJwPR4MTZLw==",
      "dev": true,
      "requires": {
        "end-of-stream": "^1.1.0",
        "stream-shift": "^1.0.0"
      }
    },
    "stream-http": {
      "version": "2.8.3",
      "resolved": "https://registry.npmjs.org/stream-http/-/stream-http-2.8.3.tgz",
      "integrity": "sha512-+TSkfINHDo4J+ZobQLWiMouQYB+UVYFttRA94FpEzzJ7ZdqcL4uUUQ7WkdkI4DSozGmgBUE/a47L+38PenXhUw==",
      "dev": true,
      "requires": {
        "builtin-status-codes": "^3.0.0",
        "inherits": "^2.0.1",
        "readable-stream": "^2.3.6",
        "to-arraybuffer": "^1.0.0",
        "xtend": "^4.0.0"
      }
    },
    "stream-shift": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/stream-shift/-/stream-shift-1.0.1.tgz",
      "integrity": "sha512-AiisoFqQ0vbGcZgQPY1cdP2I76glaVA/RauYR4G4thNFgkTqr90yXTo4LYX60Jl+sIlPNHHdGSwo01AvbKUSVQ==",
      "dev": true
    },
    "streamsearch": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-0.1.2.tgz",
      "integrity": "sha1-gIudDlb8Jz2Am6VzOOkpkZoanxo="
    },
    "strict-uri-encode": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/strict-uri-encode/-/strict-uri-encode-1.1.0.tgz",
      "integrity": "sha1-J5siXfHVgrH1TmWt3UNS4Y+qBxM=",
      "dev": true
    },
    "string-length": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/string-length/-/string-length-3.1.0.tgz",
      "integrity": "sha512-Ttp5YvkGm5v9Ijagtaz1BnN+k9ObpvS0eIBblPMp2YWL8FBmi9qblQ9fexc2k/CXFgrTIteU3jAw3payCnwSTA==",
      "dev": true,
      "requires": {
        "astral-regex": "^1.0.0",
        "strip-ansi": "^5.2.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        }
      }
    },
    "string-width": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-2.1.1.tgz",
      "integrity": "sha512-nOqH59deCq9SRHlxq1Aw85Jnt4w6KvLKqWVik6oA9ZklXLNIOlqg4F2yrT1MVaTjAqvVwdfeZ7w7aCvJD7ugkw==",
      "dev": true,
      "requires": {
        "is-fullwidth-code-point": "^2.0.0",
        "strip-ansi": "^4.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-3.0.0.tgz",
          "integrity": "sha1-7QMXwyIGT3lGbAKWa922Bas32Zg=",
          "dev": true
        },
        "strip-ansi": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-4.0.0.tgz",
          "integrity": "sha1-qEeQIusaw2iocTibY1JixQXuNo8=",
          "dev": true,
          "requires": {
            "ansi-regex": "^3.0.0"
          }
        }
      }
    },
    "string.prototype.padend": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/string.prototype.padend/-/string.prototype.padend-3.1.0.tgz",
      "integrity": "sha512-3aIv8Ffdp8EZj8iLwREGpQaUZiPyrWrpzMBHvkiSW/bK/EGve9np07Vwy7IJ5waydpGXzQZu/F8Oze2/IWkBaA==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.0-next.1"
      }
    },
    "string.prototype.trimend": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.1.tgz",
      "integrity": "sha512-LRPxFUaTtpqYsTeNKaFOw3R4bxIzWOnbQ837QfBylo8jIxtcbK/A/sMV7Q+OAV/vWo+7s25pOE10KYSjaSO06g==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "string.prototype.trimleft": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/string.prototype.trimleft/-/string.prototype.trimleft-2.1.2.tgz",
      "integrity": "sha512-gCA0tza1JBvqr3bfAIFJGqfdRTyPae82+KTnm3coDXkZN9wnuW3HjGgN386D7hfv5CHQYCI022/rJPVlqXyHSw==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5",
        "string.prototype.trimstart": "^1.0.0"
      }
    },
    "string.prototype.trimright": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/string.prototype.trimright/-/string.prototype.trimright-2.1.2.tgz",
      "integrity": "sha512-ZNRQ7sY3KroTaYjRS6EbNiiHrOkjihL9aQE/8gfQ4DtAC/aEBRHFJa44OmoWxGGqXuJlfKkZW4WcXErGr+9ZFg==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5",
        "string.prototype.trimend": "^1.0.0"
      }
    },
    "string.prototype.trimstart": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.1.tgz",
      "integrity": "sha512-XxZn+QpvrBI1FOcg6dIpxUPgWCPuNXvMD72aaRaUQv1eD4e/Qy8i/hFTe0BUmD60p/QA6bh1avmuPTfNjqVWRw==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.5"
      }
    },
    "string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dev": true,
      "requires": {
        "safe-buffer": "~5.2.0"
      }
    },
    "strip-ansi": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
      "integrity": "sha1-ajhfuIU9lS1f8F0Oiq+UJ43GPc8=",
      "requires": {
        "ansi-regex": "^2.0.0"
      }
    },
    "strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha1-IzTBjpx1n3vdVv3vfprj1YjmjtM="
    },
    "strip-eof": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/strip-eof/-/strip-eof-1.0.0.tgz",
      "integrity": "sha1-u0P/VZim6wXYm1n80SnJgzE2Br8=",
      "dev": true
    },
    "strip-final-newline": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-2.0.0.tgz",
      "integrity": "sha512-BrpvfNAE3dcvq7ll3xVumzjKjZQ5tI1sEUIKr3Uoks0XUl45St3FlatVqef9prk4jRDzhW6WZg+3bk93y6pLjA==",
      "dev": true
    },
    "strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha1-PFMZQukIwml8DsNEhYwobHygpgo=",
      "dev": true
    },
    "style-loader": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/style-loader/-/style-loader-1.2.1.tgz",
      "integrity": "sha512-ByHSTQvHLkWE9Ir5+lGbVOXhxX10fbprhLvdg96wedFZb4NDekDPxVKv5Fwmio+QcMlkkNfuK+5W1peQ5CUhZg==",
      "dev": true,
      "requires": {
        "loader-utils": "^2.0.0",
        "schema-utils": "^2.6.6"
      },
      "dependencies": {
        "loader-utils": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/loader-utils/-/loader-utils-2.0.0.tgz",
          "integrity": "sha512-rP4F0h2RaWSvPEkD7BLDFQnvSf+nK+wr3ESUjNTyAGobqrijmW92zc+SO6d4p4B1wh7+B/Jg1mkQe5NYUEHtHQ==",
          "dev": true,
          "requires": {
            "big.js": "^5.2.2",
            "emojis-list": "^3.0.0",
            "json5": "^2.1.2"
          }
        }
      }
    },
    "stylehacks": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/stylehacks/-/stylehacks-4.0.3.tgz",
      "integrity": "sha512-7GlLk9JwlElY4Y6a/rmbH2MhVlTyVmiJd1PfTCqFaIBEGMYNsrO/v3SeGTdhBThLg4Z+NbOk/qFMwCa+J+3p/g==",
      "dev": true,
      "requires": {
        "browserslist": "^4.0.0",
        "postcss": "^7.0.0",
        "postcss-selector-parser": "^3.0.0"
      },
      "dependencies": {
        "postcss-selector-parser": {
          "version": "3.1.2",
          "resolved": "https://registry.npmjs.org/postcss-selector-parser/-/postcss-selector-parser-3.1.2.tgz",
          "integrity": "sha512-h7fJ/5uWuRVyOtkO45pnt1Ih40CEleeyCHzipqAZO2e5H20g25Y48uYnFUiShvY4rZWNJ/Bib/KVPmanaCtOhA==",
          "dev": true,
          "requires": {
            "dot-prop": "^5.2.0",
            "indexes-of": "^1.0.1",
            "uniq": "^1.0.1"
          }
        }
      }
    },
    "stylus": {
      "version": "0.54.7",
      "resolved": "https://registry.npmjs.org/stylus/-/stylus-0.54.7.tgz",
      "integrity": "sha512-Yw3WMTzVwevT6ZTrLCYNHAFmanMxdylelL3hkWNgPMeTCpMwpV3nXjpOHuBXtFv7aiO2xRuQS6OoAdgkNcSNug==",
      "dev": true,
      "requires": {
        "css-parse": "~2.0.0",
        "debug": "~3.1.0",
        "glob": "^7.1.3",
        "mkdirp": "~0.5.x",
        "safer-buffer": "^2.1.2",
        "sax": "~1.2.4",
        "semver": "^6.0.0",
        "source-map": "^0.7.3"
      },
      "dependencies": {
        "debug": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.1.0.tgz",
          "integrity": "sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==",
          "dev": true,
          "requires": {
            "ms": "2.0.0"
          }
        },
        "ms": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
          "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
          "dev": true
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        }
      }
    },
    "stylus-loader": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/stylus-loader/-/stylus-loader-3.0.2.tgz",
      "integrity": "sha512-+VomPdZ6a0razP+zinir61yZgpw2NfljeSsdUF5kJuEzlo3khXhY19Fn6l8QQz1GRJGtMCo8nG5C04ePyV7SUA==",
      "dev": true,
      "requires": {
        "loader-utils": "^1.0.2",
        "lodash.clonedeep": "^4.5.0",
        "when": "~3.6.x"
      }
    },
    "supports-color": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.1.0.tgz",
      "integrity": "sha512-oRSIpR8pxT1Wr2FquTNnGet79b3BWljqOuoW/h4oBhxJ/HUbX5nX6JSruTkvXDCFMwDPvsaTTbvMLKZWSy0R5g==",
      "requires": {
        "has-flag": "^4.0.0"
      },
      "dependencies": {
        "has-flag": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ=="
        }
      }
    },
    "supports-hyperlinks": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/supports-hyperlinks/-/supports-hyperlinks-2.1.0.tgz",
      "integrity": "sha512-zoE5/e+dnEijk6ASB6/qrK+oYdm2do1hjoLWrqUC/8WEIW1gbxFcKuBof7sW8ArN6e+AYvsE8HBGiVRWL/F5CA==",
      "dev": true,
      "requires": {
        "has-flag": "^4.0.0",
        "supports-color": "^7.0.0"
      },
      "dependencies": {
        "has-flag": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
          "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
          "dev": true
        }
      }
    },
    "svgo": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/svgo/-/svgo-1.3.2.tgz",
      "integrity": "sha512-yhy/sQYxR5BkC98CY7o31VGsg014AKLEPxdfhora76l36hD9Rdy5NZA/Ocn6yayNPgSamYdtX2rFJdcv07AYVw==",
      "dev": true,
      "requires": {
        "chalk": "^2.4.1",
        "coa": "^2.0.2",
        "css-select": "^2.0.0",
        "css-select-base-adapter": "^0.1.1",
        "css-tree": "1.0.0-alpha.37",
        "csso": "^4.0.2",
        "js-yaml": "^3.13.1",
        "mkdirp": "~0.5.1",
        "object.values": "^1.1.0",
        "sax": "~1.2.4",
        "stable": "^0.1.8",
        "unquote": "~1.1.1",
        "util.promisify": "~1.0.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "symbol-observable": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/symbol-observable/-/symbol-observable-1.2.0.tgz",
      "integrity": "sha512-e900nM8RRtGhlV36KGEU9k65K3mPb1WV70OdjfxlG2EAuM1noi/E/BaW/uMhL7bPEssK8QV57vN3esixjUvcXQ==",
      "dev": true
    },
    "symbol-tree": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.4.tgz",
      "integrity": "sha512-9QNk5KwDF+Bvz+PyObkmSYjI5ksVUYtjW7AU22r2NKcfLJcXp96hkDWU3+XndOsUb+AQ9QhfzfCT2O+CNWT5Tw==",
      "dev": true
    },
    "table": {
      "version": "5.4.6",
      "resolved": "https://registry.npmjs.org/table/-/table-5.4.6.tgz",
      "integrity": "sha512-wmEc8m4fjnob4gt5riFRtTu/6+4rSe12TpAELNSqHMfF3IqnA+CH37USM6/YR3qRZv7e56kAEAtd6nKZaxe0Ug==",
      "dev": true,
      "requires": {
        "ajv": "^6.10.2",
        "lodash": "^4.17.14",
        "slice-ansi": "^2.1.0",
        "string-width": "^3.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "emoji-regex": {
          "version": "7.0.3",
          "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
          "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
          "dev": true
        },
        "string-width": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
          "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
          "dev": true,
          "requires": {
            "emoji-regex": "^7.0.1",
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^5.1.0"
          }
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        }
      }
    },
    "tapable": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/tapable/-/tapable-1.1.3.tgz",
      "integrity": "sha512-4WK/bYZmj8xLr+HUCODHGF1ZFzsYffasLUgEiMBY4fgtltdO6B4WJtlSbPaDTLpYTcGVwM2qLnFTICEcNxs3kA=="
    },
    "tar": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/tar/-/tar-6.0.2.tgz",
      "integrity": "sha512-Glo3jkRtPcvpDlAs/0+hozav78yoXKFr+c4wgw62NNMO3oo4AaJdCo21Uu7lcwr55h39W2XD1LMERc64wtbItg==",
      "dev": true,
      "requires": {
        "chownr": "^2.0.0",
        "fs-minipass": "^2.0.0",
        "minipass": "^3.0.0",
        "minizlib": "^2.1.0",
        "mkdirp": "^1.0.3",
        "yallist": "^4.0.0"
      },
      "dependencies": {
        "chownr": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
          "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
          "dev": true
        },
        "mkdirp": {
          "version": "1.0.4",
          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
          "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
          "dev": true
        }
      }
    },
    "terminal-link": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/terminal-link/-/terminal-link-2.1.1.tgz",
      "integrity": "sha512-un0FmiRUQNr5PJqy9kP7c40F5BOfpGlYTrxonDChEZB7pzZxRNp/bt+ymiy9/npwXya9KH99nJ/GXFIiUkYGFQ==",
      "dev": true,
      "requires": {
        "ansi-escapes": "^4.2.1",
        "supports-hyperlinks": "^2.0.0"
      }
    },
    "terser": {
      "version": "4.8.0",
      "resolved": "https://registry.npmjs.org/terser/-/terser-4.8.0.tgz",
      "integrity": "sha512-EAPipTNeWsb/3wLPeup1tVPaXfIaU68xMnVdPafIL1TV05OhASArYyIfFvnvJCNrR2NIOvDVNNTFRa+Re2MWyw==",
      "dev": true,
      "requires": {
        "commander": "^2.20.0",
        "source-map": "~0.6.1",
        "source-map-support": "~0.5.12"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "terser-webpack-plugin": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-3.0.1.tgz",
      "integrity": "sha512-eFDtq8qPUEa9hXcUzTwKXTnugIVtlqc1Z/ZVhG8LmRT3lgRY13+pQTnFLY2N7ATB6TKCHuW/IGjoAnZz9wOIqw==",
      "dev": true,
      "requires": {
        "cacache": "^15.0.3",
        "find-cache-dir": "^3.3.1",
        "jest-worker": "^26.0.0",
        "p-limit": "^2.3.0",
        "schema-utils": "^2.6.6",
        "serialize-javascript": "^3.0.0",
        "source-map": "^0.6.1",
        "terser": "^4.6.13",
        "webpack-sources": "^1.4.3"
      },
      "dependencies": {
        "cacache": {
          "version": "15.0.5",
          "resolved": "https://registry.npmjs.org/cacache/-/cacache-15.0.5.tgz",
          "integrity": "sha512-lloiL22n7sOjEEXdL8NAjTgv9a1u43xICE9/203qonkZUCj5X1UEWIdf2/Y0d6QcCtMzbKQyhrcDbdvlZTs/+A==",
          "dev": true,
          "requires": {
            "@npmcli/move-file": "^1.0.1",
            "chownr": "^2.0.0",
            "fs-minipass": "^2.0.0",
            "glob": "^7.1.4",
            "infer-owner": "^1.0.4",
            "lru-cache": "^6.0.0",
            "minipass": "^3.1.1",
            "minipass-collect": "^1.0.2",
            "minipass-flush": "^1.0.5",
            "minipass-pipeline": "^1.2.2",
            "mkdirp": "^1.0.3",
            "p-map": "^4.0.0",
            "promise-inflight": "^1.0.1",
            "rimraf": "^3.0.2",
            "ssri": "^8.0.0",
            "tar": "^6.0.2",
            "unique-filename": "^1.1.1"
          }
        },
        "chownr": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
          "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
          "dev": true
        },
        "find-cache-dir": {
          "version": "3.3.1",
          "resolved": "https://registry.npmjs.org/find-cache-dir/-/find-cache-dir-3.3.1.tgz",
          "integrity": "sha512-t2GDMt3oGC/v+BMwzmllWDuJF/xcDtE5j/fCGbqDD7OLuJkj0cfh1YSA5VKPvwMeLFLNDBkwOKZ2X85jGLVftQ==",
          "dev": true,
          "requires": {
            "commondir": "^1.0.1",
            "make-dir": "^3.0.2",
            "pkg-dir": "^4.1.0"
          }
        },
        "lru-cache": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
          "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
          "dev": true,
          "requires": {
            "yallist": "^4.0.0"
          }
        },
        "mkdirp": {
          "version": "1.0.4",
          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
          "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
          "dev": true
        },
        "p-map": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
          "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
          "dev": true,
          "requires": {
            "aggregate-error": "^3.0.0"
          }
        },
        "pkg-dir": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/pkg-dir/-/pkg-dir-4.2.0.tgz",
          "integrity": "sha512-HRDzbaKjC+AOWVXxAU/x54COGeIv9eb+6CkDSQoNTt4XyWoIJvuPsXizxu/Fr23EiekbtZwmh1IcIG/l/a10GQ==",
          "dev": true,
          "requires": {
            "find-up": "^4.0.0"
          }
        },
        "serialize-javascript": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-3.1.0.tgz",
          "integrity": "sha512-JIJT1DGiWmIKhzRsG91aS6Ze4sFUrYbltlkg2onR5OrnNM02Kl/hnY/T4FN2omvyeBbQmMJv+K4cPOpGzOTFBg==",
          "dev": true,
          "requires": {
            "randombytes": "^2.1.0"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "terser": {
          "version": "4.8.0",
          "resolved": "https://registry.npmjs.org/terser/-/terser-4.8.0.tgz",
          "integrity": "sha512-EAPipTNeWsb/3wLPeup1tVPaXfIaU68xMnVdPafIL1TV05OhASArYyIfFvnvJCNrR2NIOvDVNNTFRa+Re2MWyw==",
          "dev": true,
          "requires": {
            "commander": "^2.20.0",
            "source-map": "~0.6.1",
            "source-map-support": "~0.5.12"
          }
        }
      }
    },
    "test-exclude": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-6.0.0.tgz",
      "integrity": "sha512-cAGWPIyOHU6zlmg88jwm7VRyXnMN7iV68OGAbYDk/Mh/xC/pzVPlQtY6ngoIH/5/tciuhGfvESU8GrHrcxD56w==",
      "dev": true,
      "requires": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^7.1.4",
        "minimatch": "^3.0.4"
      }
    },
    "text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha1-f17oI66AUgfACvLfSoTsP8+lcLQ=",
      "dev": true
    },
    "throat": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/throat/-/throat-5.0.0.tgz",
      "integrity": "sha512-fcwX4mndzpLQKBS1DVYhGAcYaYt7vsHNIvQV+WXMvnow5cgjPphq5CaayLaGsjRdSCKZFNGt7/GYAuXaNOiYCA==",
      "dev": true
    },
    "throttleit": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/throttleit/-/throttleit-1.0.0.tgz",
      "integrity": "sha1-nnhYNtr0Z0MUWlmEtiaNgoUorGw=",
      "dev": true
    },
    "through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha1-DdTJ/6q8NXlgsbckEV1+Doai4fU=",
      "dev": true
    },
    "through2": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/through2/-/through2-2.0.5.tgz",
      "integrity": "sha512-/mrRod8xqpA+IHSLyGCQ2s8SPHiCDEeQJSep1jqLYeEUClOFG2Qsh+4FU6G9VeqpZnGW/Su8LQGc4YKni5rYSQ==",
      "dev": true,
      "requires": {
        "readable-stream": "~2.3.6",
        "xtend": "~4.0.1"
      }
    },
    "thunky": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/thunky/-/thunky-1.1.0.tgz",
      "integrity": "sha512-eHY7nBftgThBqOyHGVN+l8gF0BucP09fMo0oO/Lb0w1OF80dJv+lDVpXG60WMQvkcxAkNybKsrEIE3ZtKGmPrA==",
      "dev": true
    },
    "timers-browserify": {
      "version": "2.0.11",
      "resolved": "https://registry.npmjs.org/timers-browserify/-/timers-browserify-2.0.11.tgz",
      "integrity": "sha512-60aV6sgJ5YEbzUdn9c8kYGIqOubPoUdqQCul3SBAsRCZ40s6Y5cMcrW4dt3/k/EsbLVJNl9n6Vz3fTc+k2GeKQ==",
      "dev": true,
      "requires": {
        "setimmediate": "^1.0.4"
      }
    },
    "timers-ext": {
      "version": "0.1.7",
      "resolved": "https://registry.npmjs.org/timers-ext/-/timers-ext-0.1.7.tgz",
      "integrity": "sha512-b85NUNzTSdodShTIbky6ZF02e8STtVVfD+fu4aXXShEELpozH+bCpJLYMPZbsABN2wDH7fJpqIoXxJpzbf0NqQ==",
      "requires": {
        "es5-ext": "~0.10.46",
        "next-tick": "1"
      }
    },
    "timsort": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/timsort/-/timsort-0.3.0.tgz",
      "integrity": "sha1-QFQRqOfmM5/mTbmiNN4R3DHgK9Q=",
      "dev": true
    },
    "tmp": {
      "version": "0.0.33",
      "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz",
      "integrity": "sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==",
      "dev": true,
      "requires": {
        "os-tmpdir": "~1.0.2"
      }
    },
    "tmpl": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/tmpl/-/tmpl-1.0.4.tgz",
      "integrity": "sha1-I2QN17QtAEM5ERQIIOXPRA5SHdE=",
      "dev": true
    },
    "to-arraybuffer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/to-arraybuffer/-/to-arraybuffer-1.0.1.tgz",
      "integrity": "sha1-fSKbH8xjfkZsoIEYCDanqr/4P0M=",
      "dev": true
    },
    "to-fast-properties": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
      "integrity": "sha1-3F5pjL0HkmW8c+A3doGk5Og/YW4="
    },
    "to-object-path": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/to-object-path/-/to-object-path-0.3.0.tgz",
      "integrity": "sha1-KXWIt7Dn4KwI4E5nL4XB9JmeF68=",
      "requires": {
        "kind-of": "^3.0.2"
      },
      "dependencies": {
        "kind-of": {
          "version": "3.2.2",
          "resolved": "https://registry.npmjs.org/kind-of/-/kind-of-3.2.2.tgz",
          "integrity": "sha1-MeohpzS6ubuw8yRm2JOupR5KPGQ=",
          "requires": {
            "is-buffer": "^1.1.5"
          }
        }
      }
    },
    "to-regex": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/to-regex/-/to-regex-3.0.2.tgz",
      "integrity": "sha512-FWtleNAtZ/Ki2qtqej2CXTOayOH9bHDQF+Q48VpWyDXjbYxA4Yz8iDB31zXOBUlOHHKidDbqGVrTUvQMPmBGBw==",
      "requires": {
        "define-property": "^2.0.2",
        "extend-shallow": "^3.0.2",
        "regex-not": "^1.0.2",
        "safe-regex": "^1.1.0"
      },
      "dependencies": {
        "extend-shallow": {
          "version": "3.0.2",
          "resolved": "https://registry.npmjs.org/extend-shallow/-/extend-shallow-3.0.2.tgz",
          "integrity": "sha1-Jqcarwc7OfshJxcnRhMcJwQCjbg=",
          "requires": {
            "assign-symbols": "^1.0.0",
            "is-extendable": "^1.0.1"
          }
        },
        "is-extendable": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-extendable/-/is-extendable-1.0.1.tgz",
          "integrity": "sha512-arnXMxT1hhoKo9k1LZdmlNyJdDDfy2v0fXjFlmok4+i8ul/6WlbVge9bhM74OpNPQPMGUToDtz+KXa1PneJxOA==",
          "requires": {
            "is-plain-object": "^2.0.4"
          }
        }
      }
    },
    "to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "requires": {
        "is-number": "^7.0.0"
      },
      "dependencies": {
        "is-number": {
          "version": "7.0.0",
          "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
          "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng=="
        }
      }
    },
    "toidentifier": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.0.tgz",
      "integrity": "sha512-yaOH/Pk/VEhBWWTlhI+qXxDFXlejDGcQipMlyxda9nthulaxLZUNcUqFxokp0vcYnvteJln5FNQDRrxj3YcbVw=="
    },
    "tough-cookie": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-2.5.0.tgz",
      "integrity": "sha512-nlLsUzgm1kfLXSXfRZMc1KLAugd4hqJHDTvc2hDIwS3mZAfMEuMbc03SujMF+GEcpaX/qboeycw6iO8JwVv2+g==",
      "dev": true,
      "requires": {
        "psl": "^1.1.28",
        "punycode": "^2.1.1"
      }
    },
    "tr46": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz",
      "integrity": "sha1-qLE/1r/SSJUZZ0zN5VujaTtwbQk=",
      "dev": true,
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "tree-kill": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A=="
    },
    "ts-jest": {
      "version": "25.4.0",
      "resolved": "https://registry.npmjs.org/ts-jest/-/ts-jest-25.4.0.tgz",
      "integrity": "sha512-+0ZrksdaquxGUBwSdTIcdX7VXdwLIlSRsyjivVA9gcO+Cvr6ByqDhu/mi5+HCcb6cMkiQp5xZ8qRO7/eCqLeyw==",
      "dev": true,
      "requires": {
        "bs-logger": "0.x",
        "buffer-from": "1.x",
        "fast-json-stable-stringify": "2.x",
        "json5": "2.x",
        "lodash.memoize": "4.x",
        "make-error": "1.x",
        "micromatch": "4.x",
        "mkdirp": "1.x",
        "resolve": "1.x",
        "semver": "6.x",
        "yargs-parser": "18.x"
      },
      "dependencies": {
        "micromatch": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.2.tgz",
          "integrity": "sha512-y7FpHSbMUMoyPbYUSzO6PaZ6FyRnQOpHuKwbo1G+Knck95XVU4QAiKdGEnj5wwoS7PlOgthX/09u5iFJ+aYf5Q==",
          "dev": true,
          "requires": {
            "braces": "^3.0.1",
            "picomatch": "^2.0.5"
          }
        },
        "mkdirp": {
          "version": "1.0.4",
          "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
          "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
          "dev": true
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "yargs-parser": {
          "version": "18.1.3",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-18.1.3.tgz",
          "integrity": "sha512-o50j0JeToy/4K6OZcaQmW6lyXXKhq7csREXcDwk2omFPJEwUNOVtJKvmDr9EI1fAJZUyZcRF7kxGBWmRXudrCQ==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "ts-loader": {
      "version": "5.4.5",
      "resolved": "https://registry.npmjs.org/ts-loader/-/ts-loader-5.4.5.tgz",
      "integrity": "sha512-XYsjfnRQCBum9AMRZpk2rTYSVpdZBpZK+kDh0TeT3kxmQNBDVIeUjdPjY5RZry4eIAb8XHc4gYSUiUWPYvzSRw==",
      "requires": {
        "chalk": "^2.3.0",
        "enhanced-resolve": "^4.0.0",
        "loader-utils": "^1.0.2",
        "micromatch": "^3.1.4",
        "semver": "^5.0.1"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "ts-node": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-7.0.1.tgz",
      "integrity": "sha512-BVwVbPJRspzNh2yfslyT1PSbl5uIk03EZlb493RKHN4qej/D06n1cEhjlOJG69oFsE7OT8XjpTUcYf6pKTLMhw==",
      "dev": true,
      "requires": {
        "arrify": "^1.0.0",
        "buffer-from": "^1.1.0",
        "diff": "^3.1.0",
        "make-error": "^1.1.1",
        "minimist": "^1.2.0",
        "mkdirp": "^0.5.1",
        "source-map-support": "^0.5.6",
        "yn": "^2.0.0"
      }
    },
    "ts-pnp": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/ts-pnp/-/ts-pnp-1.2.0.tgz",
      "integrity": "sha512-csd+vJOb/gkzvcCHgTGSChYpy5f1/XKNsmvBGO4JXS+z1v2HobugDz4s1IeFXM3wZB44uczs+eazB5Q/ccdhQw==",
      "dev": true
    },
    "tsconfig-paths": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.9.0.tgz",
      "integrity": "sha512-dRcuzokWhajtZWkQsDVKbWyY+jgcLC5sqJhg2PSgf4ZkH2aHPvaOY8YWGhmjb68b5qqTfasSsDO9k7RUiEmZAw==",
      "requires": {
        "@types/json5": "^0.0.29",
        "json5": "^1.0.1",
        "minimist": "^1.2.0",
        "strip-bom": "^3.0.0"
      },
      "dependencies": {
        "json5": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/json5/-/json5-1.0.1.tgz",
          "integrity": "sha512-aKS4WQjPenRxiQsC93MNfjx+nbF4PAdYzmd/1JIj8HYzqfbu86beTuNgXDzPknWk0n0uARlyewZo4s++ES36Ow==",
          "requires": {
            "minimist": "^1.2.0"
          }
        }
      }
    },
    "tsconfig-paths-webpack-plugin": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/tsconfig-paths-webpack-plugin/-/tsconfig-paths-webpack-plugin-3.2.0.tgz",
      "integrity": "sha512-S/gOOPOkV8rIL4LurZ1vUdYCVgo15iX9ZMJ6wx6w2OgcpT/G4wMyHB6WM+xheSqGMrWKuxFul+aXpCju3wmj/g==",
      "requires": {
        "chalk": "^2.3.0",
        "enhanced-resolve": "^4.0.0",
        "tsconfig-paths": "^3.4.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "requires": {
            "has-flag": "^3.0.0"
          }
        }
      }
    },
    "tslib": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.11.1.tgz",
      "integrity": "sha512-aZW88SY8kQbU7gpV19lN24LtXh/yD4ZZg6qieAJDDg+YBsJcSmLGK9QpnUjAKVG/xefmvJGd1WUmfpT/g6AJGA=="
    },
    "tslint": {
      "version": "6.1.3",
      "resolved": "https://registry.npmjs.org/tslint/-/tslint-6.1.3.tgz",
      "integrity": "sha512-IbR4nkT96EQOvKE2PW/djGz8iGNeJ4rF2mBfiYaR/nvUWYKJhLwimoJKgjIFEIDibBtOevj7BqCRL4oHeWWUCg==",
      "dev": true,
      "requires": {
        "@babel/code-frame": "^7.0.0",
        "builtin-modules": "^1.1.1",
        "chalk": "^2.3.0",
        "commander": "^2.12.1",
        "diff": "^4.0.1",
        "glob": "^7.1.1",
        "js-yaml": "^3.13.1",
        "minimatch": "^3.0.4",
        "mkdirp": "^0.5.3",
        "resolve": "^1.3.2",
        "semver": "^5.3.0",
        "tslib": "^1.13.0",
        "tsutils": "^2.29.0"
      },
      "dependencies": {
        "chalk": {
          "version": "2.4.2",
          "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
          "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.1",
            "escape-string-regexp": "^1.0.5",
            "supports-color": "^5.3.0"
          }
        },
        "diff": {
          "version": "4.0.2",
          "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
          "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
          "dev": true
        },
        "supports-color": {
          "version": "5.5.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
          "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "tslib": {
          "version": "1.13.0",
          "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.13.0.tgz",
          "integrity": "sha512-i/6DQjL8Xf3be4K/E6Wgpekn5Qasl1usyw++dAA35Ue5orEn65VIxOA+YvNNl9HV3qv70T7CNwjODHZrLwvd1Q==",
          "dev": true
        }
      }
    },
    "tsutils": {
      "version": "2.29.0",
      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-2.29.0.tgz",
      "integrity": "sha512-g5JVHCIJwzfISaXpXE1qvNalca5Jwob6FjI4AoPlqMusJ6ftFE7IkkFoMhVLRgK+4Kx3gkzb8UZK5t5yTTvEmA==",
      "dev": true,
      "requires": {
        "tslib": "^1.8.1"
      }
    },
    "tty-browserify": {
      "version": "0.0.0",
      "resolved": "https://registry.npmjs.org/tty-browserify/-/tty-browserify-0.0.0.tgz",
      "integrity": "sha1-oVe6QC2iTpv5V/mqadUk7tQpAaY=",
      "dev": true
    },
    "tunnel-agent": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/tunnel-agent/-/tunnel-agent-0.6.0.tgz",
      "integrity": "sha1-J6XeoGs2sEoKmWZ3SykIaPD8QP0=",
      "dev": true,
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "tweetnacl": {
      "version": "0.14.5",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-0.14.5.tgz",
      "integrity": "sha1-WuaBd/GS1EViadEIr6k/+HQ/T2Q=",
      "dev": true
    },
    "type": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/type/-/type-1.2.0.tgz",
      "integrity": "sha512-+5nt5AAniqsCnu2cEQQdpzCAh33kVx8n0VoFidKpB1dVVLAN/F+bgVOqOJqOnEnrhp222clB5p3vUlD+1QAnfg=="
    },
    "type-check": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.3.2.tgz",
      "integrity": "sha1-WITKtRLPHTVeP7eE8wgEsrUg23I=",
      "dev": true,
      "requires": {
        "prelude-ls": "~1.1.2"
      }
    },
    "type-detect": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
      "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
      "dev": true
    },
    "type-fest": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.11.0.tgz",
      "integrity": "sha512-OdjXJxnCN1AvyLSzeKIgXTXxV+99ZuXl3Hpo9XpJAv9MBcHrrJOQ5kV7ypXOuQie+AmWG25hLbiKdwYTifzcfQ==",
      "dev": true
    },
    "type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "requires": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      }
    },
    "typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha1-hnrHTjhkGHsdPUfZlqeOxciDB3c="
    },
    "typedarray-to-buffer": {
      "version": "3.1.5",
      "resolved": "https://registry.npmjs.org/typedarray-to-buffer/-/typedarray-to-buffer-3.1.5.tgz",
      "integrity": "sha512-zdu8XMNEDepKKR+XYOXAVPtWui0ly0NtohUscw+UmaHiAWT8hrV1rr//H6V+0DvJ3OQ19S979M0laLfX8rm82Q==",
      "dev": true,
      "requires": {
        "is-typedarray": "^1.0.0"
      }
    },
    "typescript": {
      "version": "3.9.7",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-3.9.7.tgz",
      "integrity": "sha512-BLbiRkiBzAwsjut4x/dsibSTB6yWpwT5qWmC2OfuCg3GgVQCSgMs4vEctYPhsaGtd0AeuuHMkjZ2h2WG8MSzRw==",
      "dev": true
    },
    "unicode-canonical-property-names-ecmascript": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/unicode-canonical-property-names-ecmascript/-/unicode-canonical-property-names-ecmascript-1.0.4.tgz",
      "integrity": "sha512-jDrNnXWHd4oHiTZnx/ZG7gtUTVp+gCcTTKr8L0HjlwphROEW3+Him+IpvC+xcJEFegapiMZyZe02CyuOnRmbnQ=="
    },
    "unicode-match-property-ecmascript": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/unicode-match-property-ecmascript/-/unicode-match-property-ecmascript-1.0.4.tgz",
      "integrity": "sha512-L4Qoh15vTfntsn4P1zqnHulG0LdXgjSO035fEpdtp6YxXhMT51Q6vgM5lYdG/5X3MjS+k/Y9Xw4SFCY9IkR0rg==",
      "requires": {
        "unicode-canonical-property-names-ecmascript": "^1.0.4",
        "unicode-property-aliases-ecmascript": "^1.0.4"
      }
    },
    "unicode-match-property-value-ecmascript": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/unicode-match-property-value-ecmascript/-/unicode-match-property-value-ecmascript-1.2.0.tgz",
      "integrity": "sha512-wjuQHGQVofmSJv1uVISKLE5zO2rNGzM/KCYZch/QQvez7C1hUhBIuZ701fYXExuufJFMPhv2SyL8CyoIfMLbIQ=="
    },
    "unicode-property-aliases-ecmascript": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/unicode-property-aliases-ecmascript/-/unicode-property-aliases-ecmascript-1.1.0.tgz",
      "integrity": "sha512-PqSoPh/pWetQ2phoj5RLiaqIk4kCNwoV3CI+LfGmWLKI3rE3kl1h59XpX2BjgDrmbxD9ARtQobPGU1SguCYuQg=="
    },
    "union-value": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/union-value/-/union-value-1.0.1.tgz",
      "integrity": "sha512-tJfXmxMeWYnczCVs7XAEvIV7ieppALdyepWMkHkwciRpZraG/xwT+s2JN8+pr1+8jCRf80FFzvr+MpQeeoF4Xg==",
      "requires": {
        "arr-union": "^3.1.0",
        "get-value": "^2.0.6",
        "is-extendable": "^0.1.1",
        "set-value": "^2.0.1"
      }
    },
    "uniq": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/uniq/-/uniq-1.0.1.tgz",
      "integrity": "sha1-sxxa6CVIRKOoKBVBzisEuGWnNP8=",
      "dev": true
    },
    "uniqs": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/uniqs/-/uniqs-2.0.0.tgz",
      "integrity": "sha1-/+3ks2slKQaW5uFl1KWe25mOawI=",
      "dev": true
    },
    "unique-filename": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/unique-filename/-/unique-filename-1.1.1.tgz",
      "integrity": "sha512-Vmp0jIp2ln35UTXuryvjzkjGdRyf9b2lTXuSYUiPmzRcl3FDtYqAwOnTJkAngD9SWhnoJzDbTKwaOrZ+STtxNQ==",
      "dev": true,
      "requires": {
        "unique-slug": "^2.0.0"
      }
    },
    "unique-slug": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/unique-slug/-/unique-slug-2.0.2.tgz",
      "integrity": "sha512-zoWr9ObaxALD3DOPfjPSqxt4fnZiWblxHIgeWqW8x7UqDzEtHEQLzji2cuJYQFCU6KmoJikOYAZlrTHHebjx2w==",
      "dev": true,
      "requires": {
        "imurmurhash": "^0.1.4"
      }
    },
    "universal-analytics": {
      "version": "0.4.20",
      "resolved": "https://registry.npmjs.org/universal-analytics/-/universal-analytics-0.4.20.tgz",
      "integrity": "sha512-gE91dtMvNkjO+kWsPstHRtSwHXz0l2axqptGYp5ceg4MsuurloM0PU3pdOfpb5zBXUvyjT4PwhWK2m39uczZuw==",
      "dev": true,
      "requires": {
        "debug": "^3.0.0",
        "request": "^2.88.0",
        "uuid": "^3.0.0"
      },
      "dependencies": {
        "debug": {
          "version": "3.2.6",
          "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.6.tgz",
          "integrity": "sha512-mel+jf7nrtEl5Pn1Qx46zARXKDpBbvzezse7p7LqINmdoIk8PYP5SySaxEmYv6TZ0JyEKA1hsCId6DIhgITtWQ==",
          "dev": true,
          "requires": {
            "ms": "^2.1.1"
          }
        }
      }
    },
    "universalify": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/universalify/-/universalify-0.1.2.tgz",
      "integrity": "sha512-rBJeI5CXAlmy1pV+617WB9J63U6XcazHHF2f2dbJix4XzpUF0RS3Zbj0FGIOCAva5P/d/GBOYaACQ1w+0azUkg==",
      "dev": true
    },
    "unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw="
    },
    "unquote": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/unquote/-/unquote-1.1.1.tgz",
      "integrity": "sha1-j97XMk7G6IoP+LkF58CYzcCG1UQ=",
      "dev": true
    },
    "unset-value": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unset-value/-/unset-value-1.0.0.tgz",
      "integrity": "sha1-g3aHP30jNRef+x5vw6jtDfyKtVk=",
      "requires": {
        "has-value": "^0.3.1",
        "isobject": "^3.0.0"
      },
      "dependencies": {
        "has-value": {
          "version": "0.3.1",
          "resolved": "https://registry.npmjs.org/has-value/-/has-value-0.3.1.tgz",
          "integrity": "sha1-ex9YutpiyoJ+wKIHgCVlSEWZXh8=",
          "requires": {
            "get-value": "^2.0.3",
            "has-values": "^0.1.4",
            "isobject": "^2.0.0"
          },
          "dependencies": {
            "isobject": {
              "version": "2.1.0",
              "resolved": "https://registry.npmjs.org/isobject/-/isobject-2.1.0.tgz",
              "integrity": "sha1-8GVWEJaj8dou9GJy+BXIQNh+DIk=",
              "requires": {
                "isarray": "1.0.0"
              }
            }
          }
        },
        "has-values": {
          "version": "0.1.4",
          "resolved": "https://registry.npmjs.org/has-values/-/has-values-0.1.4.tgz",
          "integrity": "sha1-bWHeldkd/Km5oCCJrThL/49it3E="
        }
      }
    },
    "untildify": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/untildify/-/untildify-4.0.0.tgz",
      "integrity": "sha512-KK8xQ1mkzZeg9inewmFVDNkg3l5LUhoq9kN6iWYB/CC9YMG8HA+c1Q8HwDe6dEX7kErrEVNVBO3fWsVq5iDgtw==",
      "dev": true
    },
    "upath": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/upath/-/upath-1.2.0.tgz",
      "integrity": "sha512-aZwGpamFO61g3OlfT7OQCHqhGnW43ieH9WZeP7QxN/G/jS4jfqUkZxoryvJgVPEcrl5NL/ggHsSmLMHuH64Lhg==",
      "dev": true
    },
    "uri-js": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.2.2.tgz",
      "integrity": "sha512-KY9Frmirql91X2Qgjry0Wd4Y+YTdrdZheS8TFwvkbLWf/G5KNJDCh6pKL5OZctEW4+0Baa5idK2ZQuELRwPznQ==",
      "requires": {
        "punycode": "^2.1.0"
      }
    },
    "urix": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/urix/-/urix-0.1.0.tgz",
      "integrity": "sha1-2pN/emLiH+wf0Y1Js1wpNQZ6bHI="
    },
    "url": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/url/-/url-0.11.0.tgz",
      "integrity": "sha1-ODjpfPxgUh63PFJajlW/3Z4uKPE=",
      "dev": true,
      "requires": {
        "punycode": "1.3.2",
        "querystring": "0.2.0"
      },
      "dependencies": {
        "punycode": {
          "version": "1.3.2",
          "resolved": "https://registry.npmjs.org/punycode/-/punycode-1.3.2.tgz",
          "integrity": "sha1-llOgNvt8HuQjQvIyXM7v6jkmxI0=",
          "dev": true
        }
      }
    },
    "url-parse": {
      "version": "1.4.7",
      "resolved": "https://registry.npmjs.org/url-parse/-/url-parse-1.4.7.tgz",
      "integrity": "sha512-d3uaVyzDB9tQoSXFvuSUNFibTd9zxd2bkVrDRvF5TmvWWQwqE4lgYJ5m+x1DbecWkw+LK4RNl2CU1hHuOKPVlg==",
      "dev": true,
      "requires": {
        "querystringify": "^2.1.1",
        "requires-port": "^1.0.0"
      }
    },
    "use": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/use/-/use-3.1.1.tgz",
      "integrity": "sha512-cwESVXlO3url9YWlFW/TA9cshCEhtu7IKJ/p5soJ/gGpj7vbvFrAY/eIioQ6Dw23KjZhYgiIo8HOs1nQ2vr/oQ=="
    },
    "util": {
      "version": "0.11.1",
      "resolved": "https://registry.npmjs.org/util/-/util-0.11.1.tgz",
      "integrity": "sha512-HShAsny+zS2TZfaXxD9tYj4HQGlBezXZMZuM/S5PKLLoZkShZiGk9o5CzukI1LVHZvjdvZ2Sj1aW/Ndn2NB/HQ==",
      "dev": true,
      "requires": {
        "inherits": "2.0.3"
      },
      "dependencies": {
        "inherits": {
          "version": "2.0.3",
          "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz",
          "integrity": "sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=",
          "dev": true
        }
      }
    },
    "util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8="
    },
    "util-promisify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/util-promisify/-/util-promisify-2.1.0.tgz",
      "integrity": "sha1-PCI2R2xNMsX/PEcAKt18E7moKlM=",
      "dev": true,
      "requires": {
        "object.getownpropertydescriptors": "^2.0.3"
      }
    },
    "util.promisify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/util.promisify/-/util.promisify-1.0.1.tgz",
      "integrity": "sha512-g9JpC/3He3bm38zsLupWryXHoEcS22YHthuPQSJdMy6KNrzIRzWqcsHzD/WUnqe45whVou4VIsPew37DoXWNrA==",
      "dev": true,
      "requires": {
        "define-properties": "^1.1.3",
        "es-abstract": "^1.17.2",
        "has-symbols": "^1.0.1",
        "object.getownpropertydescriptors": "^2.1.0"
      }
    },
    "utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM="
    },
    "uuid": {
      "version": "3.4.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-3.4.0.tgz",
      "integrity": "sha512-HjSDRw6gZE5JMggctHBcjVak08+KEVhSIiDzFnT9S9aegmp85S/bReBVTb4QTFaRNptJ9kuYaNhnbNEOkbKb/A==",
      "dev": true
    },
    "v8-compile-cache": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.1.0.tgz",
      "integrity": "sha512-usZBT3PW+LOjM25wbqIlZwPeJV+3OSz3M1k1Ws8snlW39dZyYL9lOGC5FgPVHfk0jKmjiDV8Z0mIbVQPiwFs7g==",
      "dev": true
    },
    "v8-to-istanbul": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/v8-to-istanbul/-/v8-to-istanbul-4.1.3.tgz",
      "integrity": "sha512-sAjOC+Kki6aJVbUOXJbcR0MnbfjvBzwKZazEJymA2IX49uoOdEdk+4fBq5cXgYgiyKtAyrrJNtBZdOeDIF+Fng==",
      "dev": true,
      "requires": {
        "@types/istanbul-lib-coverage": "^2.0.1",
        "convert-source-map": "^1.6.0",
        "source-map": "^0.7.3"
      }
    },
    "validate-npm-package-license": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/validate-npm-package-license/-/validate-npm-package-license-3.0.4.tgz",
      "integrity": "sha512-DpKm2Ui/xN7/HQKCtpZxoRWBhZ9Z0kqtygG8XCgNQ8ZlDnxuQmWhj566j8fN4Cu3/JmbhsDo7fcAJq4s9h27Ew==",
      "dev": true,
      "requires": {
        "spdx-correct": "^3.0.0",
        "spdx-expression-parse": "^3.0.0"
      }
    },
    "validate-npm-package-name": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/validate-npm-package-name/-/validate-npm-package-name-3.0.0.tgz",
      "integrity": "sha1-X6kS2B630MdK/BQN5zF/DKffQ34=",
      "dev": true,
      "requires": {
        "builtins": "^1.0.3"
      }
    },
    "vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw="
    },
    "vendors": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/vendors/-/vendors-1.0.4.tgz",
      "integrity": "sha512-/juG65kTL4Cy2su4P8HjtkTxk6VmJDiOPBufWniqQ6wknac6jNiXS9vU+hO3wgusiyqWlzTbVHi0dyJqRONg3w==",
      "dev": true
    },
    "verror": {
      "version": "1.10.0",
      "resolved": "https://registry.npmjs.org/verror/-/verror-1.10.0.tgz",
      "integrity": "sha1-OhBcoXBTr1XW4nDB+CiGguGNpAA=",
      "dev": true,
      "requires": {
        "assert-plus": "^1.0.0",
        "core-util-is": "1.0.2",
        "extsprintf": "^1.2.0"
      }
    },
    "vm-browserify": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vm-browserify/-/vm-browserify-1.1.2.tgz",
      "integrity": "sha512-2ham8XPWTONajOR0ohOKOHXkm3+gaBmGut3SRuu75xLd/RRaY6vqgh8NBYYk7+RW3u5AtzPQZG8F10LHkl0lAQ==",
      "dev": true
    },
    "w3c-hr-time": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/w3c-hr-time/-/w3c-hr-time-1.0.2.tgz",
      "integrity": "sha512-z8P5DvDNjKDoFIHK7q8r8lackT6l+jo/Ye3HOle7l9nICP9lf1Ci25fy9vHd0JOWewkIFzXIEig3TdKT7JQ5fQ==",
      "dev": true,
      "requires": {
        "browser-process-hrtime": "^1.0.0"
      }
    },
    "w3c-xmlserializer": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-1.1.2.tgz",
      "integrity": "sha512-p10l/ayESzrBMYWRID6xbuCKh2Fp77+sA0doRuGn4tTIMrrZVeqfpKjXHY+oDh3K4nLdPgNwMTVP6Vp4pvqbNg==",
      "dev": true,
      "requires": {
        "domexception": "^1.0.1",
        "webidl-conversions": "^4.0.2",
        "xml-name-validator": "^3.0.0"
      }
    },
    "walker": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/walker/-/walker-1.0.7.tgz",
      "integrity": "sha1-L3+bj9ENZ3JisYqITijRlhjgKPs=",
      "dev": true,
      "requires": {
        "makeerror": "1.0.x"
      }
    },
    "watchpack": {
      "version": "1.6.1",
      "resolved": "https://registry.npmjs.org/watchpack/-/watchpack-1.6.1.tgz",
      "integrity": "sha512-+IF9hfUFOrYOOaKyfaI7h7dquUIOgyEMoQMLA7OP5FxegKA2+XdXThAZ9TU2kucfhDH7rfMHs1oPYziVGWRnZA==",
      "dev": true,
      "requires": {
        "chokidar": "^2.1.8",
        "graceful-fs": "^4.1.2",
        "neo-async": "^2.5.0"
      },
      "dependencies": {
        "anymatch": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-2.0.0.tgz",
          "integrity": "sha512-5teOsQWABXHHBFP9y3skS5P3d/WfWXpv3FUpy+LorMrNYaT9pI4oLMQX7jzQ2KklNpGpWHzdCXTDT2Y3XGlZBw==",
          "dev": true,
          "requires": {
            "micromatch": "^3.1.4",
            "normalize-path": "^2.1.1"
          },
          "dependencies": {
            "normalize-path": {
              "version": "2.1.1",
              "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
              "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
              "dev": true,
              "requires": {
                "remove-trailing-separator": "^1.0.1"
              }
            }
          }
        },
        "binary-extensions": {
          "version": "1.13.1",
          "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.1.tgz",
          "integrity": "sha512-Un7MIEDdUC5gNpcGDV97op1Ywk748MpHcFTHoYs6qnj1Z3j7I53VG3nwZhKzoBZmbdRNnb6WRdFlwl7tSDuZGw==",
          "dev": true
        },
        "braces": {
          "version": "2.3.2",
          "resolved": "https://registry.npmjs.org/braces/-/braces-2.3.2.tgz",
          "integrity": "sha512-aNdbnj9P8PjdXU4ybaWLK2IF3jc/EoDYbC7AazW6to3TRsfXxscC9UXOB5iDiEQrkyIbWp2SLQda4+QAa7nc3w==",
          "dev": true,
          "requires": {
            "arr-flatten": "^1.1.0",
            "array-unique": "^0.3.2",
            "extend-shallow": "^2.0.1",
            "fill-range": "^4.0.0",
            "isobject": "^3.0.1",
            "repeat-element": "^1.1.2",
            "snapdragon": "^0.8.1",
            "snapdragon-node": "^2.0.1",
            "split-string": "^3.0.2",
            "to-regex": "^3.0.1"
          }
        },
        "chokidar": {
          "version": "2.1.8",
          "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-2.1.8.tgz",
          "integrity": "sha512-ZmZUazfOzf0Nve7duiCKD23PFSCs4JPoYyccjUFF3aQkQadqBhfzhjkwBH2mNOG9cTBwhamM37EIsIkZw3nRgg==",
          "dev": true,
          "requires": {
            "anymatch": "^2.0.0",
            "async-each": "^1.0.1",
            "braces": "^2.3.2",
            "fsevents": "^1.2.7",
            "glob-parent": "^3.1.0",
            "inherits": "^2.0.3",
            "is-binary-path": "^1.0.0",
            "is-glob": "^4.0.0",
            "normalize-path": "^3.0.0",
            "path-is-absolute": "^1.0.0",
            "readdirp": "^2.2.1",
            "upath": "^1.1.1"
          }
        },
        "fill-range": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-4.0.0.tgz",
          "integrity": "sha1-1USBHUKPmOsGpj3EAtJAPDKMOPc=",
          "dev": true,
          "requires": {
            "extend-shallow": "^2.0.1",
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1",
            "to-regex-range": "^2.1.0"
          }
        },
        "fsevents": {
          "version": "1.2.12",
          "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-1.2.12.tgz",
          "integrity": "sha512-Ggd/Ktt7E7I8pxZRbGIs7vwqAPscSESMrCSkx2FtWeqmheJgCo2R74fTsZFCifr0VTPwqRpPv17+6b8Zp7th0Q==",
          "dev": true,
          "optional": true,
          "requires": {
            "bindings": "^1.5.0",
            "nan": "^2.12.1",
            "node-pre-gyp": "*"
          },
          "dependencies": {
            "abbrev": {
              "version": "1.1.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "ansi-regex": {
              "version": "2.1.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "aproba": {
              "version": "1.2.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "are-we-there-yet": {
              "version": "1.1.5",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "delegates": "^1.0.0",
                "readable-stream": "^2.0.6"
              }
            },
            "balanced-match": {
              "version": "1.0.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "brace-expansion": {
              "version": "1.1.11",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "balanced-match": "^1.0.0",
                "concat-map": "0.0.1"
              }
            },
            "chownr": {
              "version": "1.1.4",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "code-point-at": {
              "version": "1.1.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "concat-map": {
              "version": "0.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "console-control-strings": {
              "version": "1.1.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "core-util-is": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "debug": {
              "version": "3.2.6",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "ms": "^2.1.1"
              }
            },
            "deep-extend": {
              "version": "0.6.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "delegates": {
              "version": "1.0.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "detect-libc": {
              "version": "1.0.3",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "fs-minipass": {
              "version": "1.2.7",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "minipass": "^2.6.0"
              }
            },
            "fs.realpath": {
              "version": "1.0.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "gauge": {
              "version": "2.7.4",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "aproba": "^1.0.3",
                "console-control-strings": "^1.0.0",
                "has-unicode": "^2.0.0",
                "object-assign": "^4.1.0",
                "signal-exit": "^3.0.0",
                "string-width": "^1.0.1",
                "strip-ansi": "^3.0.1",
                "wide-align": "^1.1.0"
              }
            },
            "glob": {
              "version": "7.1.6",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "fs.realpath": "^1.0.0",
                "inflight": "^1.0.4",
                "inherits": "2",
                "minimatch": "^3.0.4",
                "once": "^1.3.0",
                "path-is-absolute": "^1.0.0"
              }
            },
            "has-unicode": {
              "version": "2.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "iconv-lite": {
              "version": "0.4.24",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "safer-buffer": ">= 2.1.2 < 3"
              }
            },
            "ignore-walk": {
              "version": "3.0.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "minimatch": "^3.0.4"
              }
            },
            "inflight": {
              "version": "1.0.6",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "once": "^1.3.0",
                "wrappy": "1"
              }
            },
            "inherits": {
              "version": "2.0.4",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "ini": {
              "version": "1.3.5",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "is-fullwidth-code-point": {
              "version": "1.0.0",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "number-is-nan": "^1.0.0"
              }
            },
            "isarray": {
              "version": "1.0.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "minimatch": {
              "version": "3.0.4",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "brace-expansion": "^1.1.7"
              }
            },
            "minimist": {
              "version": "1.2.5",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "minipass": {
              "version": "2.9.0",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "safe-buffer": "^5.1.2",
                "yallist": "^3.0.0"
              }
            },
            "minizlib": {
              "version": "1.3.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "minipass": "^2.9.0"
              }
            },
            "mkdirp": {
              "version": "0.5.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "minimist": "^1.2.5"
              }
            },
            "ms": {
              "version": "2.1.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "needle": {
              "version": "2.3.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "debug": "^3.2.6",
                "iconv-lite": "^0.4.4",
                "sax": "^1.2.4"
              }
            },
            "node-pre-gyp": {
              "version": "0.14.0",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "detect-libc": "^1.0.2",
                "mkdirp": "^0.5.1",
                "needle": "^2.2.1",
                "nopt": "^4.0.1",
                "npm-packlist": "^1.1.6",
                "npmlog": "^4.0.2",
                "rc": "^1.2.7",
                "rimraf": "^2.6.1",
                "semver": "^5.3.0",
                "tar": "^4.4.2"
              }
            },
            "nopt": {
              "version": "4.0.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "abbrev": "1",
                "osenv": "^0.1.4"
              }
            },
            "npm-bundled": {
              "version": "1.1.1",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "npm-normalize-package-bin": "^1.0.1"
              }
            },
            "npm-normalize-package-bin": {
              "version": "1.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "npm-packlist": {
              "version": "1.4.8",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "ignore-walk": "^3.0.1",
                "npm-bundled": "^1.0.1",
                "npm-normalize-package-bin": "^1.0.1"
              }
            },
            "npmlog": {
              "version": "4.1.2",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "are-we-there-yet": "~1.1.2",
                "console-control-strings": "~1.1.0",
                "gauge": "~2.7.3",
                "set-blocking": "~2.0.0"
              }
            },
            "number-is-nan": {
              "version": "1.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "object-assign": {
              "version": "4.1.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "once": {
              "version": "1.4.0",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "wrappy": "1"
              }
            },
            "os-homedir": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "os-tmpdir": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "osenv": {
              "version": "0.1.5",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "os-homedir": "^1.0.0",
                "os-tmpdir": "^1.0.0"
              }
            },
            "path-is-absolute": {
              "version": "1.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "process-nextick-args": {
              "version": "2.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "rc": {
              "version": "1.2.8",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "deep-extend": "^0.6.0",
                "ini": "~1.3.0",
                "minimist": "^1.2.0",
                "strip-json-comments": "~2.0.1"
              }
            },
            "readable-stream": {
              "version": "2.3.7",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "core-util-is": "~1.0.0",
                "inherits": "~2.0.3",
                "isarray": "~1.0.0",
                "process-nextick-args": "~2.0.0",
                "safe-buffer": "~5.1.1",
                "string_decoder": "~1.1.1",
                "util-deprecate": "~1.0.1"
              }
            },
            "rimraf": {
              "version": "2.7.1",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "glob": "^7.1.3"
              }
            },
            "safe-buffer": {
              "version": "5.1.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "safer-buffer": {
              "version": "2.1.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "sax": {
              "version": "1.2.4",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "semver": {
              "version": "5.7.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "set-blocking": {
              "version": "2.0.0",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "signal-exit": {
              "version": "3.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "string-width": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "code-point-at": "^1.0.0",
                "is-fullwidth-code-point": "^1.0.0",
                "strip-ansi": "^3.0.0"
              }
            },
            "string_decoder": {
              "version": "1.1.1",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "safe-buffer": "~5.1.0"
              }
            },
            "strip-ansi": {
              "version": "3.0.1",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "ansi-regex": "^2.0.0"
              }
            },
            "strip-json-comments": {
              "version": "2.0.1",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "tar": {
              "version": "4.4.13",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "chownr": "^1.1.1",
                "fs-minipass": "^1.2.5",
                "minipass": "^2.8.6",
                "minizlib": "^1.2.1",
                "mkdirp": "^0.5.0",
                "safe-buffer": "^5.1.2",
                "yallist": "^3.0.3"
              }
            },
            "util-deprecate": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "wide-align": {
              "version": "1.1.3",
              "bundled": true,
              "dev": true,
              "optional": true,
              "requires": {
                "string-width": "^1.0.2 || 2"
              }
            },
            "wrappy": {
              "version": "1.0.2",
              "bundled": true,
              "dev": true,
              "optional": true
            },
            "yallist": {
              "version": "3.1.1",
              "bundled": true,
              "dev": true,
              "optional": true
            }
          }
        },
        "glob-parent": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-3.1.0.tgz",
          "integrity": "sha1-nmr2KZ2NO9K9QEMIMr0RPfkGxa4=",
          "dev": true,
          "requires": {
            "is-glob": "^3.1.0",
            "path-dirname": "^1.0.0"
          },
          "dependencies": {
            "is-glob": {
              "version": "3.1.0",
              "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-3.1.0.tgz",
              "integrity": "sha1-e6WuJCF4BKxwcHuWkiVnSGzD6Eo=",
              "dev": true,
              "requires": {
                "is-extglob": "^2.1.0"
              }
            }
          }
        },
        "is-binary-path": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-1.0.1.tgz",
          "integrity": "sha1-dfFmQrSA8YenEcgUFh/TpKdlWJg=",
          "dev": true,
          "requires": {
            "binary-extensions": "^1.0.0"
          }
        },
        "readdirp": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-2.2.1.tgz",
          "integrity": "sha512-1JU/8q+VgFZyxwrJ+SVIOsh+KywWGpds3NTqikiKpDMZWScmAYyKIgqkO+ARvNWJfXeXR1zxz7aHF4u4CyH6vQ==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.11",
            "micromatch": "^3.1.10",
            "readable-stream": "^2.0.2"
          }
        },
        "to-regex-range": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-2.1.1.tgz",
          "integrity": "sha1-fIDBe53+vlmeJzZ+DU3VWQFB2zg=",
          "dev": true,
          "requires": {
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1"
          }
        }
      }
    },
    "wbuf": {
      "version": "1.7.3",
      "resolved": "https://registry.npmjs.org/wbuf/-/wbuf-1.7.3.tgz",
      "integrity": "sha512-O84QOnr0icsbFGLS0O3bI5FswxzRr8/gHwWkDlQFskhSPryQXvrTMxjxGP4+iWYoauLoBvfDpkrOauZ+0iZpDA==",
      "dev": true,
      "requires": {
        "minimalistic-assert": "^1.0.0"
      }
    },
    "wcwidth": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/wcwidth/-/wcwidth-1.0.1.tgz",
      "integrity": "sha1-8LDc+RW8X/FSivrbLA4XtTLaL+g=",
      "requires": {
        "defaults": "^1.0.3"
      }
    },
    "webdriver-js-extender": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/webdriver-js-extender/-/webdriver-js-extender-2.1.0.tgz",
      "integrity": "sha512-lcUKrjbBfCK6MNsh7xaY2UAUmZwe+/ib03AjVOpFobX4O7+83BUveSrLfU0Qsyb1DaKJdQRbuU+kM9aZ6QUhiQ==",
      "dev": true,
      "requires": {
        "@types/selenium-webdriver": "^3.0.0",
        "selenium-webdriver": "^3.0.1"
      }
    },
    "webidl-conversions": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz",
      "integrity": "sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==",
      "dev": true
    },
    "webpack": {
      "version": "4.42.0",
      "resolved": "https://registry.npmjs.org/webpack/-/webpack-4.42.0.tgz",
      "integrity": "sha512-EzJRHvwQyBiYrYqhyjW9AqM90dE4+s1/XtCfn7uWg6cS72zH+2VPFAlsnW0+W0cDi0XRjNKUMoJtpSi50+Ph6w==",
      "dev": true,
      "requires": {
        "@webassemblyjs/ast": "1.8.5",
        "@webassemblyjs/helper-module-context": "1.8.5",
        "@webassemblyjs/wasm-edit": "1.8.5",
        "@webassemblyjs/wasm-parser": "1.8.5",
        "acorn": "^6.2.1",
        "ajv": "^6.10.2",
        "ajv-keywords": "^3.4.1",
        "chrome-trace-event": "^1.0.2",
        "enhanced-resolve": "^4.1.0",
        "eslint-scope": "^4.0.3",
        "json-parse-better-errors": "^1.0.2",
        "loader-runner": "^2.4.0",
        "loader-utils": "^1.2.3",
        "memory-fs": "^0.4.1",
        "micromatch": "^3.1.10",
        "mkdirp": "^0.5.1",
        "neo-async": "^2.6.1",
        "node-libs-browser": "^2.2.1",
        "schema-utils": "^1.0.0",
        "tapable": "^1.1.3",
        "terser-webpack-plugin": "^1.4.3",
        "watchpack": "^1.6.0",
        "webpack-sources": "^1.4.1"
      },
      "dependencies": {
        "is-wsl": {
          "version": "1.1.0",
          "resolved": "https://registry.npmjs.org/is-wsl/-/is-wsl-1.1.0.tgz",
          "integrity": "sha1-HxbkqiKwTRM2tmGIpmrzxgDDpm0=",
          "dev": true
        },
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        },
        "serialize-javascript": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-4.0.0.tgz",
          "integrity": "sha512-GaNA54380uFefWghODBWEGisLZFj00nS5ACs6yHa9nLqlLpVLO8ChDGeKRjZnV4Nh4n0Qi7nhYZD/9fCPzEqkw==",
          "dev": true,
          "requires": {
            "randombytes": "^2.1.0"
          }
        },
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        },
        "terser-webpack-plugin": {
          "version": "1.4.5",
          "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-1.4.5.tgz",
          "integrity": "sha512-04Rfe496lN8EYruwi6oPQkG0vo8C+HT49X687FZnpPF0qMAIHONI6HEXYPKDOE8e5HjXTyKfqRd/agHtH0kOtw==",
          "dev": true,
          "requires": {
            "cacache": "^12.0.2",
            "find-cache-dir": "^2.1.0",
            "is-wsl": "^1.1.0",
            "schema-utils": "^1.0.0",
            "serialize-javascript": "^4.0.0",
            "source-map": "^0.6.1",
            "terser": "^4.1.2",
            "webpack-sources": "^1.4.0",
            "worker-farm": "^1.7.0"
          }
        }
      }
    },
    "webpack-dev-middleware": {
      "version": "3.7.2",
      "resolved": "https://registry.npmjs.org/webpack-dev-middleware/-/webpack-dev-middleware-3.7.2.tgz",
      "integrity": "sha512-1xC42LxbYoqLNAhV6YzTYacicgMZQTqRd27Sim9wn5hJrX3I5nxYy1SxSd4+gjUFsz1dQFj+yEe6zEVmSkeJjw==",
      "dev": true,
      "requires": {
        "memory-fs": "^0.4.1",
        "mime": "^2.4.4",
        "mkdirp": "^0.5.1",
        "range-parser": "^1.2.1",
        "webpack-log": "^2.0.0"
      },
      "dependencies": {
        "mime": {
          "version": "2.4.5",
          "resolved": "https://registry.npmjs.org/mime/-/mime-2.4.5.tgz",
          "integrity": "sha512-3hQhEUF027BuxZjQA3s7rIv/7VCQPa27hN9u9g87sEkWaKwQPuXOkVKtOeiyUrnWqTDiOs8Ed2rwg733mB0R5w==",
          "dev": true
        }
      }
    },
    "webpack-dev-server": {
      "version": "3.11.0",
      "resolved": "https://registry.npmjs.org/webpack-dev-server/-/webpack-dev-server-3.11.0.tgz",
      "integrity": "sha512-PUxZ+oSTxogFQgkTtFndEtJIPNmml7ExwufBZ9L2/Xyyd5PnOL5UreWe5ZT7IU25DSdykL9p1MLQzmLh2ljSeg==",
      "dev": true,
      "requires": {
        "ansi-html": "0.0.7",
        "bonjour": "^3.5.0",
        "chokidar": "^2.1.8",
        "compression": "^1.7.4",
        "connect-history-api-fallback": "^1.6.0",
        "debug": "^4.1.1",
        "del": "^4.1.1",
        "express": "^4.17.1",
        "html-entities": "^1.3.1",
        "http-proxy-middleware": "0.19.1",
        "import-local": "^2.0.0",
        "internal-ip": "^4.3.0",
        "ip": "^1.1.5",
        "is-absolute-url": "^3.0.3",
        "killable": "^1.0.1",
        "loglevel": "^1.6.8",
        "opn": "^5.5.0",
        "p-retry": "^3.0.1",
        "portfinder": "^1.0.26",
        "schema-utils": "^1.0.0",
        "selfsigned": "^1.10.7",
        "semver": "^6.3.0",
        "serve-index": "^1.9.1",
        "sockjs": "0.3.20",
        "sockjs-client": "1.4.0",
        "spdy": "^4.0.2",
        "strip-ansi": "^3.0.1",
        "supports-color": "^6.1.0",
        "url": "^0.11.0",
        "webpack-dev-middleware": "^3.7.2",
        "webpack-log": "^2.0.0",
        "ws": "^6.2.1",
        "yargs": "^13.3.2"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "anymatch": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-2.0.0.tgz",
          "integrity": "sha512-5teOsQWABXHHBFP9y3skS5P3d/WfWXpv3FUpy+LorMrNYaT9pI4oLMQX7jzQ2KklNpGpWHzdCXTDT2Y3XGlZBw==",
          "dev": true,
          "requires": {
            "micromatch": "^3.1.4",
            "normalize-path": "^2.1.1"
          },
          "dependencies": {
            "normalize-path": {
              "version": "2.1.1",
              "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-2.1.1.tgz",
              "integrity": "sha1-GrKLVW4Zg2Oowab35vogE3/mrtk=",
              "dev": true,
              "requires": {
                "remove-trailing-separator": "^1.0.1"
              }
            }
          }
        },
        "binary-extensions": {
          "version": "1.13.1",
          "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-1.13.1.tgz",
          "integrity": "sha512-Un7MIEDdUC5gNpcGDV97op1Ywk748MpHcFTHoYs6qnj1Z3j7I53VG3nwZhKzoBZmbdRNnb6WRdFlwl7tSDuZGw==",
          "dev": true
        },
        "braces": {
          "version": "2.3.2",
          "resolved": "https://registry.npmjs.org/braces/-/braces-2.3.2.tgz",
          "integrity": "sha512-aNdbnj9P8PjdXU4ybaWLK2IF3jc/EoDYbC7AazW6to3TRsfXxscC9UXOB5iDiEQrkyIbWp2SLQda4+QAa7nc3w==",
          "dev": true,
          "requires": {
            "arr-flatten": "^1.1.0",
            "array-unique": "^0.3.2",
            "extend-shallow": "^2.0.1",
            "fill-range": "^4.0.0",
            "isobject": "^3.0.1",
            "repeat-element": "^1.1.2",
            "snapdragon": "^0.8.1",
            "snapdragon-node": "^2.0.1",
            "split-string": "^3.0.2",
            "to-regex": "^3.0.1"
          }
        },
        "chokidar": {
          "version": "2.1.8",
          "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-2.1.8.tgz",
          "integrity": "sha512-ZmZUazfOzf0Nve7duiCKD23PFSCs4JPoYyccjUFF3aQkQadqBhfzhjkwBH2mNOG9cTBwhamM37EIsIkZw3nRgg==",
          "dev": true,
          "requires": {
            "anymatch": "^2.0.0",
            "async-each": "^1.0.1",
            "braces": "^2.3.2",
            "fsevents": "^1.2.7",
            "glob-parent": "^3.1.0",
            "inherits": "^2.0.3",
            "is-binary-path": "^1.0.0",
            "is-glob": "^4.0.0",
            "normalize-path": "^3.0.0",
            "path-is-absolute": "^1.0.0",
            "readdirp": "^2.2.1",
            "upath": "^1.1.1"
          }
        },
        "cliui": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-5.0.0.tgz",
          "integrity": "sha512-PYeGSEmmHM6zvoef2w8TPzlrnNpXIjTipYK780YswmIP9vjxmd6Y2a3CB2Ks6/AU8NHjZugXvo8w3oWM2qnwXA==",
          "dev": true,
          "requires": {
            "string-width": "^3.1.0",
            "strip-ansi": "^5.2.0",
            "wrap-ansi": "^5.1.0"
          },
          "dependencies": {
            "strip-ansi": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
              "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
              "dev": true,
              "requires": {
                "ansi-regex": "^4.1.0"
              }
            }
          }
        },
        "emoji-regex": {
          "version": "7.0.3",
          "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
          "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
          "dev": true
        },
        "fill-range": {
          "version": "4.0.0",
          "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-4.0.0.tgz",
          "integrity": "sha1-1USBHUKPmOsGpj3EAtJAPDKMOPc=",
          "dev": true,
          "requires": {
            "extend-shallow": "^2.0.1",
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1",
            "to-regex-range": "^2.1.0"
          }
        },
        "find-up": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
          "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
          "dev": true,
          "requires": {
            "locate-path": "^3.0.0"
          }
        },
        "fsevents": {
          "version": "1.2.13",
          "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-1.2.13.tgz",
          "integrity": "sha512-oWb1Z6mkHIskLzEJ/XWX0srkpkTQ7vaopMQkyaEIoq0fmtFVxOthb8cCxeT+p3ynTdkk/RZwbgG4brR5BeWECw==",
          "dev": true,
          "optional": true,
          "requires": {
            "bindings": "^1.5.0",
            "nan": "^2.12.1"
          }
        },
        "get-caller-file": {
          "version": "2.0.5",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
          "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
          "dev": true
        },
        "glob-parent": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-3.1.0.tgz",
          "integrity": "sha1-nmr2KZ2NO9K9QEMIMr0RPfkGxa4=",
          "dev": true,
          "requires": {
            "is-glob": "^3.1.0",
            "path-dirname": "^1.0.0"
          },
          "dependencies": {
            "is-glob": {
              "version": "3.1.0",
              "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-3.1.0.tgz",
              "integrity": "sha1-e6WuJCF4BKxwcHuWkiVnSGzD6Eo=",
              "dev": true,
              "requires": {
                "is-extglob": "^2.1.0"
              }
            }
          }
        },
        "is-absolute-url": {
          "version": "3.0.3",
          "resolved": "https://registry.npmjs.org/is-absolute-url/-/is-absolute-url-3.0.3.tgz",
          "integrity": "sha512-opmNIX7uFnS96NtPmhWQgQx6/NYFgsUXYMllcfzwWKUMwfo8kku1TvE6hkNcH+Q1ts5cMVrsY7j0bxXQDciu9Q==",
          "dev": true
        },
        "is-binary-path": {
          "version": "1.0.1",
          "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-1.0.1.tgz",
          "integrity": "sha1-dfFmQrSA8YenEcgUFh/TpKdlWJg=",
          "dev": true,
          "requires": {
            "binary-extensions": "^1.0.0"
          }
        },
        "locate-path": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
          "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
          "dev": true,
          "requires": {
            "p-locate": "^3.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-locate": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
          "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
          "dev": true,
          "requires": {
            "p-limit": "^2.0.0"
          }
        },
        "readdirp": {
          "version": "2.2.1",
          "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-2.2.1.tgz",
          "integrity": "sha512-1JU/8q+VgFZyxwrJ+SVIOsh+KywWGpds3NTqikiKpDMZWScmAYyKIgqkO+ARvNWJfXeXR1zxz7aHF4u4CyH6vQ==",
          "dev": true,
          "requires": {
            "graceful-fs": "^4.1.11",
            "micromatch": "^3.1.10",
            "readable-stream": "^2.0.2"
          }
        },
        "require-main-filename": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
          "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
          "dev": true
        },
        "schema-utils": {
          "version": "1.0.0",
          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-1.0.0.tgz",
          "integrity": "sha512-i27Mic4KovM/lnGsy8whRCHhc7VicJajAjTrYg11K9zfZXnYIt4k5F+kZkwjnrhKzLic/HLU4j11mjsz2G/75g==",
          "dev": true,
          "requires": {
            "ajv": "^6.1.0",
            "ajv-errors": "^1.0.0",
            "ajv-keywords": "^3.1.0"
          }
        },
        "semver": {
          "version": "6.3.0",
          "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
          "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
          "dev": true
        },
        "sockjs": {
          "version": "0.3.20",
          "resolved": "https://registry.npmjs.org/sockjs/-/sockjs-0.3.20.tgz",
          "integrity": "sha512-SpmVOVpdq0DJc0qArhF3E5xsxvaiqGNb73XfgBpK1y3UD5gs8DSo8aCTsuT5pX8rssdc2NDIzANwP9eCAiSdTA==",
          "dev": true,
          "requires": {
            "faye-websocket": "^0.10.0",
            "uuid": "^3.4.0",
            "websocket-driver": "0.6.5"
          }
        },
        "string-width": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
          "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
          "dev": true,
          "requires": {
            "emoji-regex": "^7.0.1",
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^5.1.0"
          },
          "dependencies": {
            "strip-ansi": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
              "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
              "dev": true,
              "requires": {
                "ansi-regex": "^4.1.0"
              }
            }
          }
        },
        "supports-color": {
          "version": "6.1.0",
          "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-6.1.0.tgz",
          "integrity": "sha512-qe1jfm1Mg7Nq/NSh6XE24gPXROEVsWHxC1LIx//XNlD9iw7YZQGjZNjYN7xGaEG6iKdA8EtNFW6R0gjnVXp+wQ==",
          "dev": true,
          "requires": {
            "has-flag": "^3.0.0"
          }
        },
        "to-regex-range": {
          "version": "2.1.1",
          "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-2.1.1.tgz",
          "integrity": "sha1-fIDBe53+vlmeJzZ+DU3VWQFB2zg=",
          "dev": true,
          "requires": {
            "is-number": "^3.0.0",
            "repeat-string": "^1.6.1"
          }
        },
        "websocket-driver": {
          "version": "0.6.5",
          "resolved": "https://registry.npmjs.org/websocket-driver/-/websocket-driver-0.6.5.tgz",
          "integrity": "sha1-XLJVbOuF9Dc8bYI4qmkchFThOjY=",
          "dev": true,
          "requires": {
            "websocket-extensions": ">=0.1.1"
          }
        },
        "wrap-ansi": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-5.1.0.tgz",
          "integrity": "sha512-QC1/iN/2/RPVJ5jYK8BGttj5z83LmSKmvbvrXPNCLZSEb32KKVDJDl/MOt2N01qU2H/FkzEa9PKto1BqDjtd7Q==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.0",
            "string-width": "^3.0.0",
            "strip-ansi": "^5.0.0"
          },
          "dependencies": {
            "strip-ansi": {
              "version": "5.2.0",
              "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
              "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
              "dev": true,
              "requires": {
                "ansi-regex": "^4.1.0"
              }
            }
          }
        },
        "yargs": {
          "version": "13.3.2",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-13.3.2.tgz",
          "integrity": "sha512-AX3Zw5iPruN5ie6xGRIDgqkT+ZhnRlZMLMHAs8tg7nRruy2Nb+i5o9bwghAogtM08q1dpr2LVoS8KSTMYpWXUw==",
          "dev": true,
          "requires": {
            "cliui": "^5.0.0",
            "find-up": "^3.0.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^3.0.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^13.1.2"
          }
        },
        "yargs-parser": {
          "version": "13.1.2",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-13.1.2.tgz",
          "integrity": "sha512-3lbsNRf/j+A4QuSZfDRA7HRSfWrzO0YjqTJd5kjAq37Zep1CEgaYmrH9Q3GwPiB9cHyd1Y1UwggGhJGoxipbzg==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "webpack-log": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/webpack-log/-/webpack-log-2.0.0.tgz",
      "integrity": "sha512-cX8G2vR/85UYG59FgkoMamwHUIkSSlV3bBMRsbxVXVUk2j6NleCKjQ/WE9eYg9WY4w25O9w8wKP4rzNZFmUcUg==",
      "dev": true,
      "requires": {
        "ansi-colors": "^3.0.0",
        "uuid": "^3.3.2"
      }
    },
    "webpack-merge": {
      "version": "4.2.2",
      "resolved": "https://registry.npmjs.org/webpack-merge/-/webpack-merge-4.2.2.tgz",
      "integrity": "sha512-TUE1UGoTX2Cd42j3krGYqObZbOD+xF7u28WB7tfUordytSjbWTIjK/8V0amkBfTYN4/pB/GIDlJZZ657BGG19g==",
      "dev": true,
      "requires": {
        "lodash": "^4.17.15"
      }
    },
    "webpack-node-externals": {
      "version": "1.7.2",
      "resolved": "https://registry.npmjs.org/webpack-node-externals/-/webpack-node-externals-1.7.2.tgz",
      "integrity": "sha512-ajerHZ+BJKeCLviLUUmnyd5B4RavLF76uv3cs6KNuO8W+HuQaEs0y0L7o40NQxdPy5w0pcv8Ew7yPUAQG0UdCg=="
    },
    "webpack-sources": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/webpack-sources/-/webpack-sources-1.4.3.tgz",
      "integrity": "sha512-lgTS3Xhv1lCOKo7SA5TjKXMjpSM4sBjNV5+q2bqesbSPs5FjGmU6jjtBSkX9b4qW87vDIsCIlUPOEhbZrMdjeQ==",
      "dev": true,
      "requires": {
        "source-list-map": "^2.0.0",
        "source-map": "~0.6.1"
      },
      "dependencies": {
        "source-map": {
          "version": "0.6.1",
          "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
          "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
          "dev": true
        }
      }
    },
    "webpack-subresource-integrity": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/webpack-subresource-integrity/-/webpack-subresource-integrity-1.4.1.tgz",
      "integrity": "sha512-XMLFInbGbB1HV7K4vHWANzc1CN0t/c4bBvnlvGxGwV45yE/S/feAXIm8dJsCkzqWtSKnmaEgTp/meyeThxG4Iw==",
      "dev": true,
      "requires": {
        "webpack-sources": "^1.3.0"
      }
    },
    "websocket-driver": {
      "version": "0.7.3",
      "resolved": "https://registry.npmjs.org/websocket-driver/-/websocket-driver-0.7.3.tgz",
      "integrity": "sha512-bpxWlvbbB459Mlipc5GBzzZwhoZgGEZLuqPaR0INBGnPAY1vdBX6hPnoFXiw+3yWxDuHyQjO2oXTMyS8A5haFg==",
      "dev": true,
      "requires": {
        "http-parser-js": ">=0.4.0 <0.4.11",
        "safe-buffer": ">=5.1.0",
        "websocket-extensions": ">=0.1.1"
      }
    },
    "websocket-extensions": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/websocket-extensions/-/websocket-extensions-0.1.3.tgz",
      "integrity": "sha512-nqHUnMXmBzT0w570r2JpJxfiSD1IzoI+HGVdd3aZ0yNi3ngvQ4jv1dtHt5VGxfI2yj5yqImPhOK4vmIh2xMbGg==",
      "dev": true
    },
    "whatwg-encoding": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-1.0.5.tgz",
      "integrity": "sha512-b5lim54JOPN9HtzvK9HFXvBma/rnfFeqsic0hSpjtDbVxR3dJKLc+KB4V6GgiGOvl7CY/KNh8rxSo9DKQrnUEw==",
      "dev": true,
      "requires": {
        "iconv-lite": "0.4.24"
      }
    },
    "whatwg-mimetype": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-2.3.0.tgz",
      "integrity": "sha512-M4yMwr6mAnQz76TbJm914+gPpB/nCwvZbJU28cUD6dR004SAxDLOOSUaB1JDRqLtaOV/vi0IC5lEAGFgrjGv/g==",
      "dev": true
    },
    "whatwg-url": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz",
      "integrity": "sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==",
      "dev": true,
      "requires": {
        "lodash.sortby": "^4.7.0",
        "tr46": "^1.0.1",
        "webidl-conversions": "^4.0.2"
      }
    },
    "when": {
      "version": "3.6.4",
      "resolved": "https://registry.npmjs.org/when/-/when-3.6.4.tgz",
      "integrity": "sha1-RztRfsFZ4rhQBUl6E5g/CVQS404=",
      "dev": true
    },
    "which": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/which/-/which-1.3.1.tgz",
      "integrity": "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==",
      "dev": true,
      "requires": {
        "isexe": "^2.0.0"
      }
    },
    "which-module": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/which-module/-/which-module-2.0.0.tgz",
      "integrity": "sha1-2e8H3Od7mQK4o6j6SzHD4/fm6Ho=",
      "dev": true
    },
    "wide-align": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/wide-align/-/wide-align-1.1.3.tgz",
      "integrity": "sha512-QGkOQc8XL6Bt5PwnsExKBPuMKBxnGxWWW3fU55Xt4feHozMUhdUMaBCk290qpm/wG5u/RSKzwdAC4i51YigihA==",
      "dev": true,
      "requires": {
        "string-width": "^1.0.2 || 2"
      }
    },
    "word-wrap": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
      "dev": true
    },
    "worker-farm": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/worker-farm/-/worker-farm-1.7.0.tgz",
      "integrity": "sha512-rvw3QTZc8lAxyVrqcSGVm5yP/IJ2UcB3U0graE3LCFoZ0Yn2x4EoVSqJKdB/T5M+FLcRPjz4TDacRf3OCfNUzw==",
      "dev": true,
      "requires": {
        "errno": "~0.1.7"
      }
    },
    "worker-plugin": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/worker-plugin/-/worker-plugin-4.0.3.tgz",
      "integrity": "sha512-7hFDYWiKcE3yHZvemsoM9lZis/PzurHAEX1ej8PLCu818Rt6QqUAiDdxHPCKZctzmhqzPpcFSgvMCiPbtooqAg==",
      "dev": true,
      "requires": {
        "loader-utils": "^1.1.0"
      }
    },
    "worker-rpc": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/worker-rpc/-/worker-rpc-0.1.1.tgz",
      "integrity": "sha512-P1WjMrUB3qgJNI9jfmpZ/htmBEjFh//6l/5y8SD9hg1Ef5zTTVVoRjTrTEzPrNBQvmhMxkoTsjOXN10GWU7aCg==",
      "requires": {
        "microevent.ts": "~0.1.1"
      }
    },
    "wrap-ansi": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
      "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
      "dev": true,
      "requires": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "ansi-styles": {
          "version": "4.2.1",
          "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.2.1.tgz",
          "integrity": "sha512-9VGjrMsG1vePxcSweQsN20KY/c4zN0h9fLjqAbwbPfahM3t+NL+M9HC8xeXG2I8pX5NoamTGNuomEUFI7fcUjA==",
          "dev": true,
          "requires": {
            "@types/color-name": "^1.1.1",
            "color-convert": "^2.0.1"
          }
        },
        "color-convert": {
          "version": "2.0.1",
          "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
          "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
          "dev": true,
          "requires": {
            "color-name": "~1.1.4"
          }
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
      "dev": true
    },
    "write": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/write/-/write-1.0.3.tgz",
      "integrity": "sha512-/lg70HAjtkUgWPVZhZcm+T4hkL8Zbtp1nFNOn3lRrxnlv50SRBv7cR7RqR+GMsd3hUXy9hWBo4CHTbFTcOYwig==",
      "dev": true,
      "requires": {
        "mkdirp": "^0.5.1"
      }
    },
    "write-file-atomic": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/write-file-atomic/-/write-file-atomic-3.0.3.tgz",
      "integrity": "sha512-AvHcyZ5JnSfq3ioSyjrBkH9yW4m7Ayk8/9My/DD9onKeu/94fwrMocemO2QAJFAlnnDN+ZDS+ZjAR5ua1/PV/Q==",
      "dev": true,
      "requires": {
        "imurmurhash": "^0.1.4",
        "is-typedarray": "^1.0.0",
        "signal-exit": "^3.0.2",
        "typedarray-to-buffer": "^3.1.5"
      }
    },
    "ws": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/ws/-/ws-6.2.1.tgz",
      "integrity": "sha512-GIyAXC2cB7LjvpgMt9EKS2ldqr0MTrORaleiOno6TweZ6r3TKtoFQWay/2PceJ3RuBasOHzXNn5Lrw1X0bEjqA==",
      "dev": true,
      "requires": {
        "async-limiter": "~1.0.0"
      }
    },
    "xml-name-validator": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-3.0.0.tgz",
      "integrity": "sha512-A5CUptxDsvxKJEU3yO6DuWBSJz/qizqzJKOMIfUJHETbBw/sFaDxgd6fxm1ewUaM0jZ444Fc5vC5ROYurg/4Pw==",
      "dev": true
    },
    "xml2js": {
      "version": "0.4.23",
      "resolved": "https://registry.npmjs.org/xml2js/-/xml2js-0.4.23.tgz",
      "integrity": "sha512-ySPiMjM0+pLDftHgXY4By0uswI3SPKLDw/i3UXbnO8M/p28zqexCUoPmQFrYD+/1BzhGJSs2i1ERWKJAtiLrug==",
      "dev": true,
      "requires": {
        "sax": ">=0.6.0",
        "xmlbuilder": "~11.0.0"
      }
    },
    "xmlbuilder": {
      "version": "11.0.1",
      "resolved": "https://registry.npmjs.org/xmlbuilder/-/xmlbuilder-11.0.1.tgz",
      "integrity": "sha512-fDlsI/kFEx7gLvbecc0/ohLG50fugQp8ryHzMTuW9vSa1GJ0XYWKnhsUx7oie3G98+r56aTQIUB4kht42R3JvA==",
      "dev": true
    },
    "xmlchars": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/xmlchars/-/xmlchars-2.2.0.tgz",
      "integrity": "sha512-JZnDKK8B0RCDw84FNdDAIpZK+JuJw+s7Lz8nksI7SIuU3UXJJslUthsi+uWBUYOwPFwW7W7PRLRfUKpxjtjFCw==",
      "dev": true
    },
    "xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ=="
    },
    "y18n": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/y18n/-/y18n-4.0.0.tgz",
      "integrity": "sha512-r9S/ZyXu/Xu9q1tYlpsLIsa3EeLXXk0VwlxqTcFRfg9EhMW+17kbt9G0NrgCmhGb5vT2hyhJZLfDGx+7+5Uj/w==",
      "dev": true
    },
    "yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "yargs": {
      "version": "15.3.0",
      "resolved": "https://registry.npmjs.org/yargs/-/yargs-15.3.0.tgz",
      "integrity": "sha512-g/QCnmjgOl1YJjGsnUg2SatC7NUYEiLXJqxNOQU9qSpjzGtGXda9b+OKccr1kLTy8BN9yqEyqfq5lxlwdc13TA==",
      "dev": true,
      "requires": {
        "cliui": "^6.0.0",
        "decamelize": "^1.2.0",
        "find-up": "^4.1.0",
        "get-caller-file": "^2.0.1",
        "require-directory": "^2.1.1",
        "require-main-filename": "^2.0.0",
        "set-blocking": "^2.0.0",
        "string-width": "^4.2.0",
        "which-module": "^2.0.0",
        "y18n": "^4.0.0",
        "yargs-parser": "^18.1.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.0.tgz",
          "integrity": "sha512-bY6fj56OUQ0hU1KjFNDQuJFezqKdrAyFdIevADiqrWHwSlbmBNMHp5ak2f40Pm8JTFyM2mqxkG6ngkHO11f/lg==",
          "dev": true
        },
        "is-fullwidth-code-point": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
          "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
          "dev": true
        },
        "string-width": {
          "version": "4.2.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.0.tgz",
          "integrity": "sha512-zUz5JD+tgqtuDjMhwIg5uFVV3dtqZ9yQJlZVfq4I01/K5Paj5UHj7VyrQOJvzawSVlKpObApbfD0Ed6yJc+1eg==",
          "dev": true,
          "requires": {
            "emoji-regex": "^8.0.0",
            "is-fullwidth-code-point": "^3.0.0",
            "strip-ansi": "^6.0.0"
          }
        },
        "strip-ansi": {
          "version": "6.0.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz",
          "integrity": "sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==",
          "dev": true,
          "requires": {
            "ansi-regex": "^5.0.0"
          }
        }
      }
    },
    "yargs-parser": {
      "version": "18.1.3",
      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-18.1.3.tgz",
      "integrity": "sha512-o50j0JeToy/4K6OZcaQmW6lyXXKhq7csREXcDwk2omFPJEwUNOVtJKvmDr9EI1fAJZUyZcRF7kxGBWmRXudrCQ==",
      "dev": true,
      "requires": {
        "camelcase": "^5.0.0",
        "decamelize": "^1.2.0"
      }
    },
    "yargs-unparser": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-1.6.0.tgz",
      "integrity": "sha512-W9tKgmSn0DpSatfri0nx52Joq5hVXgeLiqR/5G0sZNDoLZFOr/xjBUDcShCOGNsBnEMNo1KAMBkTej1Hm62HTw==",
      "dev": true,
      "requires": {
        "flat": "^4.1.0",
        "lodash": "^4.17.15",
        "yargs": "^13.3.0"
      },
      "dependencies": {
        "ansi-regex": {
          "version": "4.1.0",
          "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-4.1.0.tgz",
          "integrity": "sha512-1apePfXM1UOSqw0o9IiFAovVz9M5S1Dg+4TrDwfMewQ6p/rmMueb7tWZjQ1rx4Loy1ArBggoqGpfqqdI4rondg==",
          "dev": true
        },
        "cliui": {
          "version": "5.0.0",
          "resolved": "https://registry.npmjs.org/cliui/-/cliui-5.0.0.tgz",
          "integrity": "sha512-PYeGSEmmHM6zvoef2w8TPzlrnNpXIjTipYK780YswmIP9vjxmd6Y2a3CB2Ks6/AU8NHjZugXvo8w3oWM2qnwXA==",
          "dev": true,
          "requires": {
            "string-width": "^3.1.0",
            "strip-ansi": "^5.2.0",
            "wrap-ansi": "^5.1.0"
          }
        },
        "emoji-regex": {
          "version": "7.0.3",
          "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-7.0.3.tgz",
          "integrity": "sha512-CwBLREIQ7LvYFB0WyRvwhq5N5qPhc6PMjD6bYggFlI5YyDgl+0vxq5VHbMOFqLg7hfWzmu8T5Z1QofhmTIhItA==",
          "dev": true
        },
        "find-up": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/find-up/-/find-up-3.0.0.tgz",
          "integrity": "sha512-1yD6RmLI1XBfxugvORwlck6f75tYL+iR0jqwsOrOxMZyGYqUuDhJ0l4AXdO1iX/FTs9cBAMEk1gWSEx1kSbylg==",
          "dev": true,
          "requires": {
            "locate-path": "^3.0.0"
          }
        },
        "get-caller-file": {
          "version": "2.0.5",
          "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
          "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
          "dev": true
        },
        "locate-path": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-3.0.0.tgz",
          "integrity": "sha512-7AO748wWnIhNqAuaty2ZWHkQHRSNfPVIsPIfwEOWO22AmaoVrWavlOcMR5nzTLNYvp36X220/maaRsrec1G65A==",
          "dev": true,
          "requires": {
            "p-locate": "^3.0.0",
            "path-exists": "^3.0.0"
          }
        },
        "p-locate": {
          "version": "3.0.0",
          "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-3.0.0.tgz",
          "integrity": "sha512-x+12w/To+4GFfgJhBEpiDcLozRJGegY+Ei7/z0tSLkMmxGZNybVMSfWj9aJn8Z5Fc7dBUNJOOVgPv2H7IwulSQ==",
          "dev": true,
          "requires": {
            "p-limit": "^2.0.0"
          }
        },
        "require-main-filename": {
          "version": "2.0.0",
          "resolved": "https://registry.npmjs.org/require-main-filename/-/require-main-filename-2.0.0.tgz",
          "integrity": "sha512-NKN5kMDylKuldxYLSUfrbo5Tuzh4hd+2E8NPPX02mZtn1VuREQToYe/ZdlJy+J3uCpfaiGF05e7B8W0iXbQHmg==",
          "dev": true
        },
        "string-width": {
          "version": "3.1.0",
          "resolved": "https://registry.npmjs.org/string-width/-/string-width-3.1.0.tgz",
          "integrity": "sha512-vafcv6KjVZKSgz06oM/H6GDBrAtz8vdhQakGjFIvNrHA6y3HCF1CInLy+QLq8dTJPQ1b+KDUqDFctkdRW44e1w==",
          "dev": true,
          "requires": {
            "emoji-regex": "^7.0.1",
            "is-fullwidth-code-point": "^2.0.0",
            "strip-ansi": "^5.1.0"
          }
        },
        "strip-ansi": {
          "version": "5.2.0",
          "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-5.2.0.tgz",
          "integrity": "sha512-DuRs1gKbBqsMKIZlrffwlug8MHkcnpjs5VPmL1PAh+mA30U0DTotfDZ0d2UUsXpPmPmMMJ6W773MaA3J+lbiWA==",
          "dev": true,
          "requires": {
            "ansi-regex": "^4.1.0"
          }
        },
        "wrap-ansi": {
          "version": "5.1.0",
          "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-5.1.0.tgz",
          "integrity": "sha512-QC1/iN/2/RPVJ5jYK8BGttj5z83LmSKmvbvrXPNCLZSEb32KKVDJDl/MOt2N01qU2H/FkzEa9PKto1BqDjtd7Q==",
          "dev": true,
          "requires": {
            "ansi-styles": "^3.2.0",
            "string-width": "^3.0.0",
            "strip-ansi": "^5.0.0"
          }
        },
        "yargs": {
          "version": "13.3.2",
          "resolved": "https://registry.npmjs.org/yargs/-/yargs-13.3.2.tgz",
          "integrity": "sha512-AX3Zw5iPruN5ie6xGRIDgqkT+ZhnRlZMLMHAs8tg7nRruy2Nb+i5o9bwghAogtM08q1dpr2LVoS8KSTMYpWXUw==",
          "dev": true,
          "requires": {
            "cliui": "^5.0.0",
            "find-up": "^3.0.0",
            "get-caller-file": "^2.0.1",
            "require-directory": "^2.1.1",
            "require-main-filename": "^2.0.0",
            "set-blocking": "^2.0.0",
            "string-width": "^3.0.0",
            "which-module": "^2.0.0",
            "y18n": "^4.0.0",
            "yargs-parser": "^13.1.2"
          }
        },
        "yargs-parser": {
          "version": "13.1.2",
          "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-13.1.2.tgz",
          "integrity": "sha512-3lbsNRf/j+A4QuSZfDRA7HRSfWrzO0YjqTJd5kjAq37Zep1CEgaYmrH9Q3GwPiB9cHyd1Y1UwggGhJGoxipbzg==",
          "dev": true,
          "requires": {
            "camelcase": "^5.0.0",
            "decamelize": "^1.2.0"
          }
        }
      }
    },
    "yauzl": {
      "version": "2.10.0",
      "resolved": "https://registry.npmjs.org/yauzl/-/yauzl-2.10.0.tgz",
      "integrity": "sha1-x+sXyT4RLLEIb6bY5R+wZnt5pfk=",
      "dev": true,
      "requires": {
        "buffer-crc32": "~0.2.3",
        "fd-slicer": "~1.1.0"
      }
    },
    "yn": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/yn/-/yn-2.0.0.tgz",
      "integrity": "sha1-5a2ryKz0CPY4X8dklWhMiOavaJo=",
      "dev": true
    },
    "zone.js": {
      "version": "0.10.3",
      "resolved": "https://registry.npmjs.org/zone.js/-/zone.js-0.10.3.tgz",
      "integrity": "sha512-LXVLVEq0NNOqK/fLJo3d0kfzd4sxwn2/h67/02pjCjfKDxgx1i9QqpvtHD8CrBnSSwMw5+dy11O7FRX5mkO7Cg=="
    }
  }
}
package hsbc.emf.data.crm

sealed trait Approach{val name: String}

case object STD extends Approach {
   val name = "STD"
}
case object FOU extends Approach {
   val name = "FOU"
}
case object ADV extends Approach {
   val name = "ADV"
}


package hsbc.emf.infrastructure.serde


import hsbc.emf.data.crm.{ADV, Approach, FOU, STD}
import org.json4s.CustomSerializer
import org.json4s.JsonAST.{JNull, JString}

case object ApproachSerializer extends CustomSerializer[Approach](format => ( {
  case JString(approachSerializer) => approachSerializer match {
    case "STD" => STD
    case "FOU" => FOU
    case "ADV" => ADV
  }
  case JNull => null
}, {
  case approach: Approach => JString(approach.getClass.getSimpleName.replace("$", ""))
}))
package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo

case class AssertInfo(message: MessageInfo, assertQuery: String,assertionResult: Boolean, assertionMessage: String, severity: String, created: Timestamp = new Timestamp(System.currentTimeMillis())) extends ContextInfo
package hsbc.emf.infrastructure.logging.audit

import java.sql.Date

import scala.util.{Failure, Success, Try}

import hsbc.emf.data.ingestion.CatalogueEntity
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution.{ResolutionCriteria, ResolutionTarget}
import hsbc.emf.infrastructure.config.{EmfConfig, ParquetFileFormatConfig}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, LoggingSchemas}
import org.apache.commons.lang.StringUtils

import org.apache.spark.sql.{Row, SaveMode, SparkSession}

private[logging] class AuditLogger {

  // private var dfWriter: DataFrameWriterService[ParquetFileFormatConfig] = null
  private var logsCfsPath: String = StringUtils.EMPTY

  def audit[A <: ContextInfo](a: A)(implicit spark: SparkSession): Unit = {
    // if (dfWriter == null) dfWriter = new DataFrameWriterService(ParquetFileFormatConfig())(spark)

    Try {
      a match {
        case x: ExceptionInfo => {
          val data = Seq(Row(messageToRow(x.message), x.exceptionMessage, x.stacktrace, x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.exceptionsSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/emf_exceptions")
          // dfWriter.saveDFIntoTable(df, "emf_exceptions", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.errorLogTable)
        }
        case x: AssertInfo => {
          val data = Seq(Row(messageToRow(x.message), x.assertQuery, x.assertionResult, x.assertionMessage, x.severity, x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.assertInfoSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/assert_info")
          // dfWriter.saveDFIntoTable(df, "assert_info", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.assertLogTable)
        }
        case x: ResolutionInfo => {
          val data = Seq(Row(messageToRow(x.message), criteriaToRow(x.criteria), catalogueEntityToRow(x.resolutions), x.resolutionCount, resolutionTargetToRow(x.resolutionTarget), x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.resolutionInfoSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/resolutions_info")
          // dfWriter.saveDFIntoTable(df, "resolutions_info", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.resolutionLogTable)
        }
        case x: MessageStateInfo => {
          val data = Seq(Row(messageToRow(x.message), x.state.toString, x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.messageStateInfoSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/message_state_info")
          // dfWriter.saveDFIntoTable(df, "message_state_info", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.messageStateLogTable)
        }
        case x: WorkflowSpawnInfo => {
          val data = Seq(Row(messageToRow(x.message), messageToRow(x.spawnMessage), x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.workflowSpawnInfoSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/workflow_spawn_info")
          // dfWriter.saveDFIntoTable(df, "workflow_spawn_info", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.workflowSpawnInfoTable)
        }
        case x: MetadataInfo => {
          val data = Seq(Row(messageToRow(x.message), x.entityUUID, x.fileType, x.attribute, x.value, x.dataType, x.domain, x.reportingDate, x.created, new Date(x.created.getTime)))
          val df = spark.createDataFrame(spark.sparkContext.parallelize(data), LoggingSchemas.metadataInfoSchema)
//          // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//          dfWriter.getWriter(df).mode(SaveMode.Append).partitionBy("log_date").save(s"$logsCfsPath/metadata_info")
          // dfWriter.saveDFIntoTable(df, "metadata_info", "logging",SaveMode.Append, List("log_date"))
//          new HiveRepair().run(EmfConfig.loggingDb, EmfConfig.metadataLogTable)
        }
      }
    } match {
      case Success(_) =>
      case Failure(ex) =>
        EmfLogger.error(s"Error while saving audit information to audit table for type ${a.getClass.getSimpleName}. Reason: " + ex.getMessage)(a.message)
    }
  }

  private def messageToRow(message: MessageInfo): Row = {
    Row(message.runUUID, message.workflow, message.orderId, message.command, message.parameterJson, message.parent, message.messageId, message.runDate)
  }

  private def criteriaToRow(criteria: ResolutionCriteria): Row = {
    val constraintRow = criteria.constraints.map(c => Row(c.attribute, c.value, c.operator.toString))
    Row(criteria.file_type, constraintRow, criteria.created_from.orNull, criteria.created_to.orNull, criteria.retry_count, criteria.inter_retry_interval, criteria.as_view, criteria.latest_only, criteria.min_matches)
  }

  private def resolutionTargetToRow(resolutionTarget: ResolutionTarget): Row = {
    val constraintRow = resolutionTarget.where_clause.map(w => Row(w.attribute, w.value, w.operator.toString))
    Row(resolutionTarget.table_name, resolutionTarget.source_entity_type.toString, constraintRow, resolutionTarget.dataset_name.orNull)
  }

  private def catalogueEntityToRow(resolutions: Seq[CatalogueEntity]): Seq[Row] = {
    val catalogueEntityToRows = resolutions.map {
      ce => {
        val metadataRow = ce.metadata.map(m => Row(m.attribute, m.value, m.data_type, m.domain))
        Row(ce.entity_uuid, ce.file_type, ce.created, metadataRow)
      }
    }
    catalogueEntityToRows
  }
}

object AuditLogger {
  private val auditLogger = new AuditLogger()

  def apply()(implicit spark: SparkSession): AuditLogger = {
    val defaultLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging/emf_logs"
    val curateLogLocation = System.getProperty("curateLogLocation", defaultLocation)
    auditLogger.logsCfsPath = StringUtils.substringBefore(curateLogLocation, "emf_logs")
    auditLogger
  }

  def apply(logCfsPath: String): AuditLogger = {
    auditLogger.logsCfsPath = logCfsPath
    auditLogger
  }
}
package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import scala.util.{Failure, Success, Try}

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.helper.HelperUtility
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.commons.lang.StringUtils
import org.apache.commons.lang.exception.ExceptionUtils

import org.apache.spark.sql.Row

class AuditLoggerTest extends IntegrationTestSuiteBase {

  private def fixture = new {
    val runUUID: String = HelperUtility.generateRunUUID()
    val messageId: String = HelperUtility.generateRunUUID()
    val workflow = "audit-test-workflow"
    val orderId = "audit-test-order-id"
    val parameters = "audit-test-parameters"
  }

  "AssertInfo" should "stored in assert_info table" in {
    val messageId = fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "SPARK-ASSERT", fixture.parameters, parent = List.empty, messageId)
    val assertInfo: AssertInfo = AssertInfo(message, "test-assertion-query", assertionResult = true, assertionMessage = "some assertion message", severity = "info")
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(logCfsPath = s"$tablesLocation/assert").audit[AssertInfo](assertInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/assert/assert_info").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row](0)
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("command") == "SPARK-ASSERT")
//    assert(data.getAs[String]("assertion") == "test-assertion-query")
//    assert(data.getAs[Boolean]("assertion_result"))
//    assert(data.getAs[String]("assertion_message") == "some assertion message")
//    assert(data.getAs[String]("severity") == "info")
  }

  "ResolutionInfo" should "stored in resolution_info table" in {
    val messageId = fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "SPARK-RESOLVE", fixture.parameters, parent = List.empty, messageId)
    val resConstraint = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "10", GreaterThan))
    val resolutionCriteria = ResolutionCriteria("some-file-type", resConstraint)
    val resolutions = Seq(CatalogueEntity("entity_1", "file_type_1", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr1", "val1", "string", null), MetadataEntry("attr2", "val2", "string", null))),
      CatalogueEntity("entity_2", "file_type_2", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr3", "val3", "string", null))))
    val resolutionTarget = ResolutionTarget("test_target_table")
    val resolutionInfo: ResolutionInfo = ResolutionInfo(message, resolutionCriteria, resolutions, resolutions.size, resolutionTarget)
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(s"$tablesLocation/resolutions").audit[ResolutionInfo](resolutionInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/resolutions/resolutions_info").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row]("message")
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("command") == "SPARK-RESOLVE")
//    val criteriaRow = data.getAs[Row]("criteria")
//    assert(criteriaRow.getAs[String]("file_type") == "some-file-type")
//    val constraintRow = criteriaRow.getAs[Seq[Row]]("constraints")
//    assert(constraintRow(0).getAs[String]("attribute") == "location")
//    assert(constraintRow(0).getAs[String]("value") == "UK")
//    assert(constraintRow(0).getAs[String]("operator") == "=")
//    assert(constraintRow(1).getAs[String]("attribute") == "md5")
//    assert(constraintRow(1).getAs[String]("value") == "10")
//    assert(constraintRow(1).getAs[String]("operator") == ">")
//    val resolvedEntities = data.getAs[Seq[Row]]("resolutions")
//    assert(resolvedEntities(0).getAs[String]("entity_uuid") == "entity_1")
//    assert(resolvedEntities(0).getAs[String]("file_type") == "file_type_1")
//    assert(resolvedEntities(0).getAs[Timestamp]("created") == Timestamp.valueOf("2021-01-01 00:00:00"))
//    val metadataRow1 = resolvedEntities(0).getAs[Seq[Row]]("metadata")
//    assert(metadataRow1(0).getAs[String]("attribute") == "attr1")
//    assert(metadataRow1(0).getAs[String]("value") == "val1")
//    assert(metadataRow1(0).getAs[String]("data_type") == "string")
//    assert(metadataRow1(0).getAs[String]("domain") == null)
//    assert(metadataRow1(1).getAs[String]("attribute") == "attr2")
//    assert(metadataRow1(1).getAs[String]("value") == "val2")
//    assert(metadataRow1(1).getAs[String]("data_type") == "string")
//    assert(metadataRow1(1).getAs[String]("domain") == null)
//    assert(data.getAs[Int]("resolution_count") == 2)
//    val resolutionTargetRow = data.getAs[Row]("resolution_target")
//    assert(resolutionTargetRow.getAs[String]("table_name") == "test_target_table")
//    assert(resolutionTargetRow.getAs[String]("source_entity_type") == "DATA")
//    assert(resolutionTargetRow.getAs[String]("dataset_name") == null)
//    assert(resolutionTargetRow.getAs[Seq[Row]]("where_clause").isEmpty)
  }

  "ExceptionInfo" should "stored in emf_exceptions table" in {
    val messageId = fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "ALL-COMMAND", fixture.parameters, parent = List.empty, messageId)
    var stackTrace = StringUtils.EMPTY
    Try(1 / 0) match {
      case Success(x) => assert(false)
      case Failure(exception) => {
        stackTrace = ExceptionUtils.getStackTrace(exception)
      }
    }
    val exceptionInfo: ExceptionInfo = ExceptionInfo(message, "divide operation failed", stackTrace, new Timestamp(System.currentTimeMillis()))
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(s"$tablesLocation/exceptions").audit[ExceptionInfo](exceptionInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/exceptions/emf_exceptions").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row]("message")
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("command") == "ALL-COMMAND")
//    assert(data.getString(1) contains "divide operation failed")
//    assert(data.getString(2) == stackTrace)
  }

  "WorkflowSpawnInfo" should "stored in workflow_spawn_info table" in {
    val messageId = fixture.messageId
    val spawnMessageId =  fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "ANY-COMMAND", fixture.parameters, parent = List.empty, messageId)
    val spawnMessage : MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "ANY-SPAWN-COMMAND", fixture.parameters, parent = List.empty, spawnMessageId)
    val workFlowSpawnInfo = WorkflowSpawnInfo(message, spawnMessage,  new Timestamp(System.currentTimeMillis()))
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(s"$tablesLocation/workflow_spawn").audit[WorkflowSpawnInfo](workFlowSpawnInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/workflow_spawn/workflow_spawn_info").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row]("message")
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("order_id") == "audit-test-order-id")
//    assert(messageInfoRow.getAs[String]("command") == "ANY-COMMAND")
//
//    val spawnMessageInfoRow = data.getAs[Row]("spawn_message")
//    assert(spawnMessageInfoRow.getAs[String]("message_id") == spawnMessageId)
//    assert(spawnMessageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(spawnMessageInfoRow.getAs[String]("order_id") == "audit-test-order-id")
//    assert(spawnMessageInfoRow.getAs[String]("command") == "ANY-SPAWN-COMMAND")
  }

  "MessageStateInfo" should "stored in message_state_info table" in {
    val messageId = fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "SOME-COMMAND", fixture.parameters, parent = List.empty, messageId)

    val messageStateInfo: MessageStateInfo = MessageStateInfo(message, Active, new Timestamp(System.currentTimeMillis()))
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(s"$tablesLocation/message_state").audit[MessageStateInfo](messageStateInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/message_state/message_state_info").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row]("message")
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("command") == "SOME-COMMAND")
//    assert(data.getString(1) contains Active.toString)
  }

  "MetaDataInfo" should "stored in metadata_info table" in {
    val messageId = fixture.messageId
    val message: MessageInfo = MessageInfo(fixture.runUUID, fixture.workflow, fixture.orderId, "SOME-COMMAND", fixture.parameters, parent = List.empty, messageId)
    val metadataInfo = MetadataInfo(message, "some_entity_uuid", "some_file_type", "some_attribute", "some_value", "some_datatype", "some_domain",  new Timestamp(System.currentTimeMillis()))
    val tablesLocation = spark.conf.get("spark.sql.warehouse.dir") + "/logging"
    AuditLogger(s"$tablesLocation/metadata").audit[MetadataInfo](metadataInfo)
//    // FCCC-11332 Temporarily disable write and hiverepair from AuditLogger
//    val df = spark.read.parquet(s"$tablesLocation/metadata/metadata_info").where(s"message.message_id = '${messageId}'")
//    assert(df.count() == 1)
//    val data = df.head()
//    val messageInfoRow = data.getAs[Row]("message")
//    assert(messageInfoRow.getAs[String]("message_id") == messageId)
//    assert(messageInfoRow.getAs[String]("workflow") == "audit-test-workflow")
//    assert(messageInfoRow.getAs[String]("order_id") == "audit-test-order-id")
//    assert(messageInfoRow.getAs[String]("command") == "SOME-COMMAND")
//
//    assert(data.getAs[String]("entity_uuid") == metadataInfo.entityUUID)
//    assert(data.getAs[String]("file_type") == metadataInfo.fileType)
//    assert(data.getAs[String]("value") == metadataInfo.value)
//    assert(data.getAs[String]("attribute") == metadataInfo.attribute)
//    assert(data.getAs[String]("domain") == metadataInfo.domain)
//    assert(data.getAs[Timestamp]("reporting_date") == metadataInfo.reportingDate)
  }
}package hsbc.emf.infrastructure.io.readers

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.{AvroFileFormatConfig, EmfConfig}
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.infrastructure.helper.{CustomSchemaConverters, FileUtility}
import hsbc.emf.infrastructure.logging.EmfLogger.{debug, error}
import hsbc.emf.infrastructure.logging.MessageContext
import org.apache.avro.Schema
import org.apache.hadoop.fs.Path
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.{DataFrame, SparkSession}

class AvroFileReadertoDF(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends IFileReader[AvroFileFormatConfig, DataFrame] with MessageContext {

  @throws(classOf[EmfIoException])
  def read(fileFormatConfig: AvroFileFormatConfig, fileLocation: String, schema: Option[StructType], modeFailfast: Boolean = false): DataFrame = {
    try {
      debug(s"Starting reading ${fileFormatConfig.format} files from $fileLocation")

      val fs = FileUtility.getFileSystem(fileLocation)
      val filePaths = fs.listStatus(new Path(s"$fileLocation"))
      filePaths
        .filter(_.getPath.toString.endsWith(fileFormatConfig.format))
        .map(avroFilePath => {
          var optionsMap = if (modeFailfast) Map("mode" -> "FAILFAST") else Map("columnNameOfCorruptRecord" -> EmfConfig.columnNameOfCorruptRecord, "mode" -> "PERMISSIVE")

          val dataFrameAvro = fileFormatConfig.useAvroLogicalType match {
            case true => spark.read.format(fileFormatConfig.format).options(optionsMap).load(avroFilePath.getPath.toString)
            case false =>
              val df = spark.read.format(fileFormatConfig.format).load(avroFilePath.getPath.toString)
              val avroSchema: Schema = CustomSchemaConverters.toAvroType(df.schema)
              debug(s"Avro Schema generated with out using AvroLogicalType $avroSchema")
              optionsMap = optionsMap ++ Map("avroSchema" -> avroSchema.toString)
              spark.read.format(fileFormatConfig.format).options(optionsMap).load(avroFilePath.getPath.toString)
          }
          dataFrameAvro
        }).reduce(_ union _)
    } catch {
      case e: Throwable =>
        error(s"Encountered issue while reading ${fileFormatConfig.format} files from $fileLocation.Error Message - ${e.getMessage}")
        throw new EmfIoException(e.getMessage, e.getCause)
    }
  }
}package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{NotImplementedComparableValue, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper._
import hsbc.emf.infrastructure.helper.StringUtils.removeQuotes

object BooleanComparator extends IComparator {

  override def compare[T <: ComparableValue](entity: T)(inputString: String)(operator: ComparisonOperator): Boolean = {

    val entityBooleanValue = entity match {
      case ComparableBoolean(value) => value
      case _ => throw new NotImplementedComparableValue(s"Not implemented BooleanComparator value: $entity")

    }
    val cleanedInputString = removeQuotes(inputString)

    def equal(): Boolean = parse[Boolean](cleanedInputString) == entityBooleanValue

    if (nullCheck(inputString)) callUnsupportedComparisonException(operator.toString)
    else {
      operator match {
        case Equal => equal()
        case NotEqual => !equal()
        case _ => throw new UnsupportedComparisonOperator(s"Not supported BooleanComparator operator: $operator")
      }
    }
  }
}
package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, UnsupportedComparisonOperator}
import org.scalatest.FlatSpec

class BooleanComparatorTest extends FlatSpec {

  "given same values with Equal operator" should "return true" in {
    assert(BooleanComparator.compare(ComparableBoolean(true))("true")(Equal))
    assert(BooleanComparator.compare(ComparableBoolean(false))("false")(Equal))
  }

  "given dissimilar values with NotEqual operator" should "return true" in {
    assert(
      BooleanComparator.compare(ComparableBoolean(true))("false")(NotEqual))
    assert(
      BooleanComparator.compare(ComparableBoolean(false))("true")(NotEqual))
  }

  "case insensitive comparison" should "be supported" in {
    assert(BooleanComparator.compare(ComparableBoolean(true))("TRUE")(Equal))
    assert(BooleanComparator.compare(ComparableBoolean(false))("FALSE")(Equal))
  }


  "given an invalid value" should "return InvalidCastError error" in {

    val caught1 = intercept[InvalidCastError] {
      BooleanComparator.compare(ComparableBoolean(true))("Right")(Equal)
    }

    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[InvalidCastError] {
      BooleanComparator.compare(ComparableBoolean(false))("Wrong")(Equal)
    }

    assert(!caught2.getMessage.isEmpty)
  }
  "given an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(LessThan)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(LessThanOrEqual)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(GreaterThan)
    }
    assert(!caught3.getMessage.isEmpty)

    val caught4 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(GreaterThanOrEqual)
    }
    assert(!caught4.getMessage.isEmpty)

    val caught5 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(In)
    }
    assert(!caught5.getMessage.isEmpty)

    val caught6 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(NotIn)
    }
    assert(!caught6.getMessage.isEmpty)

    val caught7 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(Like)
    }
    assert(!caught7.getMessage.isEmpty)

    val caught8 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))("true")(NotLike)
    }
    assert(!caught8.getMessage.isEmpty)

    val caught9 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))(null)(Is)
    }
    assert(!caught9.getMessage.isEmpty)

    val caught10 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(true))(null)(IsNot)
    }
    assert(!caught10.getMessage.isEmpty)

    val caught11 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(false))(null)(Is)
    }
    assert(!caught11.getMessage.isEmpty)

    val caught12 = intercept[UnsupportedComparisonOperator] {
      BooleanComparator.compare(ComparableBoolean(false))(null)(IsNot)
    }
    assert(!caught12.getMessage.isEmpty)
  }

}package hsbc.emf.udf.calcencumberance

import hsbc.emf.udf.SeqRowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject
import org.apache.spark.sql.Row

case class CalcEncumberanceInput(
                                  partition_key: String,
                                  order_key: Long,
                                  repo: Option[Double],
                                  reverse: Option[Double],
                                  own_stock: Option[Double]
                                ) extends ScalaProxyObject

object CalcEncumberanceInput extends SeqRowToJSCollection[CalcEncumberanceInput] {
  override def apply(v1: Seq[Row]): Seq[CalcEncumberanceInput] = {
    v1.map { elem =>
      new CalcEncumberanceInput(
        partition_key = elem.getAs(0),
        order_key = elem.getAs(1),
        repo = Option(elem.getAs(2)),
        reverse = Option(elem.getAs(3)),
        own_stock = Option(elem.getAs(4))
      )
    }.sortBy(_.order_key)
  }
}package hsbc.emf.udf.calcencumberance

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

// Note: field names must match output of JavaScript
case class CalcEncumberanceOutput(partition_key: String, order_key: Int, target: Option[Double])

object CalcEncumberanceOutput extends GraalVmValueConverter[CalcEncumberanceOutput] {
  override def apply(v1: Value): CalcEncumberanceOutput = {
    new CalcEncumberanceOutput(
      v1.getMember("partition_key").asString(),
      v1.getMember("order_key").asInt(),
      Option(v1.getMember("target").asDouble())
    )
  }
}
package hsbc.emf.udf.calcencumberance

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}
import org.apache.spark.sql.Row
import org.graalvm.polyglot.Value

class CalcEncumbrance() extends SparkUdfRegisterableFunction1[Seq[Row], Seq[CalcEncumberanceOutput]] {

  import CalcEncumbrance.context

  def apply(input: Seq[Row]): Seq[CalcEncumberanceOutput] = {
    CalcEncumbrance.safeExecute {
      context.eval("js", CalcEncumbranceJavaScript.js)
      val encumbrances: Seq[CalcEncumberanceInput] = CalcEncumberanceInput.apply(input)
      // Underlying Js calls Array.reduce which is not supported https://github.com/oracle/graaljs/issues/45
      val jsArray: Value = context.eval("js", "new Array();")
      encumbrances.foreach {
        enc => jsArray.setArrayElement(jsArray.getArraySize(), enc)
      }

      context.getBindings("js").putMember("myO", jsArray)
      val value = context.eval("js", s"$functionName(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => CalcEncumberanceOutput.apply(value.getArrayElement(i)) }
    }

  }

  override protected val functionName: String = "FOTC_UDF_calc_encumberance"
}

object CalcEncumbrance extends UdfBuilder[CalcEncumbrance] {

  override def apply: CalcEncumbrance = new CalcEncumbrance()
}
package hsbc.emf.udf.calcencumberance

object CalcEncumbranceJavaScript {
/*
  {
    "partition_key": "3607|2021-02-28|AU000000REH4|AUD",
    "order_key": "1",
    "repo": "2667251.88",
    "reverse": "0.0",
    "own_stock": "0.0"
  },
 */


  val js =
    """
      |function FOTC_UDF_calc_encumberance(part) {
      | // Initialisation
      |  var remaining = part.reduce((cum, next) => cum + next.own_stock, 0.0);
      |  print(remaining)
      |  var bank_prev = 0.0;
      |  var bank_curr = 0.0;
      |  var target = 0.0;
      | var result = new Array();
      |  var n = part.length;
      |
      |  // Encumberance calculation
      |  for (var i = 0; i < n; i++) {
      |      var item = part[i];
      |      bank_prev = bank_curr;
      |      bank_curr = Math.max(bank_prev + item.reverse - item.repo, 0);
      |      remaining -= target;
      |      target = Math.min(Math.max(item.repo - bank_prev, 0), remaining);
      |      result.push({partition_key: item.partition_key, order_key: item.order_key, target: target});
      |  }
      |  return result;
      | }
      |""".stripMargin

}
package hsbc.emf.udf.calcencumberance

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.Row
import org.apache.spark.sql.functions._

class CalcEncumbranceTest extends IntegrationTestSuiteBase {

  it should "execute the JavaScript inside a UDF" in {
    import spark.implicits._
    val testObj = new CalcEncumbrance()
    spark.udf.register("FOTC_UDF_calc_encumberance", testObj.apply(_: Seq[Row]))
    val input = CalcEncumbranceTestData.input.toDS.createOrReplaceTempView("CalcEncumbranceTest")

    val sqlStatment =
      """select
        |FOTC_UDF_calc_encumberance(
        | collect_list(
        |   struct(
        |     partition_key,
        |     order_key,
        |     repo,
        |     reverse,
        |     own_stock
        |   )
        |  )
        | ) as result
        |FROM    CalcEncumbranceTest
        |
        |""".stripMargin
    val result = spark.sql(sqlStatment).select(explode(col("result"))).select("col.*")
    val target = CalcEncumbranceTestData.output.toDF
    result.show(
      false)
    target.show(false)
    assert(result.except(target).count() == 0)
    assert(result.intersect(target).count() == 8)
  }
}
package hsbc.emf.udf.calcencumberance

object CalcEncumbranceTestData {

  val input = Seq(
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|AU000XINAAD8|GBP",
      order_key = 1,
      repo = None,
      reverse = Some(0.0),
      own_stock = Some(940.5)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|BE0000346552|EUR",
      order_key = 1,
      repo = None,
      reverse = Some(0.0),
      own_stock = Some(-4524971.829941201)
    ),
    CalcEncumberanceInput(
      partition_key = "3181|2021-02-28|IL0011254005|ILS",
      order_key = 1,
      repo = Some(0.0),
      reverse = None,
      own_stock = Some(0.0)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|US02079K1079|USD",
      order_key = 158,
      repo = Some(10490.96),
      reverse = Some(0.0),
      own_stock = Some(0.0)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|GB00BDX8CX86|GBP",
      order_key = 158,
      repo = Some(2105967.99),
      reverse = Some(0.0),
      own_stock = Some(0.0)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|BE0000346552|EUR",
      order_key = 5,
      repo = Some(0.0),
      reverse = Some(0.0),
      own_stock = Some(9548650.37281315)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|GB00B421JZ66|GBP",
      order_key = 158,
      repo = Some(203488.2),
      reverse = Some(0.0),
      own_stock = Some(0.0)
    ),
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|TW0002330008|TWD",
      order_key = 158,
      repo = Some(1092.76),
      reverse = Some(0.0),
      own_stock = Some(0.0)
    ) /*,
    CalcEncumberanceInput(
      partition_key = "3607|2021-02-28|GB00B3LZBF68|GBP",
      order_key = 158,
      repo =Some( 2751023.12),
      reverse =Some( 0.0),
      own_stock =Some( 0.0)
    )*/
  )
  val output = Seq(

    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|AU000XINAAD8|GBP",
      order_key = 1,
      target = Some(0.0)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|BE0000346552|EUR",
      order_key = 1,
      target = Some(0.0)
    ),
    CalcEncumberanceOutput(
      partition_key = "3181|2021-02-28|IL0011254005|ILS",
      order_key = 1,
      target = Some(0.0)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|US02079K1079|USD",
      order_key = 158,
      target = Some(10490.96)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|GB00BDX8CX86|GBP",
      order_key = 158,
      target = Some(2105967.99)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|BE0000346552|EUR",
      order_key = 5,
      target = Some(0.0)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|GB00B421JZ66|GBP",
      order_key = 158,
      target = Some(203488.2)
    ),
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|TW0002330008|TWD",
      order_key = 158,
      target = Some(1092.76)
    ) /*,
    CalcEncumberanceOutput(
      partition_key = "3607|2021-02-28|GB00B3LZBF68|GBP",
      order_key = 158,
      target =Some( 2751023.12)
    )*/
  )
}


package hsbc.emf.udf.ilmcalcmonetisation.data

import hsbc.emf.udf.ilmcalcmonetisation._

object CalcIlmMonetisationTestData {

  val input = Seq(

    IlmCalcMonetisationInput(
      partition_key = "GB|RFB|SOV_L1_USD|COMBINED",
      instrument_partition_key = "GB|RFB|SOV_L1_USD|US9128284A52",
      order_key = 32,
      balance_sheet = Some(104910156.0),
      off_balance_sheet = None,
      cumulative_contractual_balance_sheet = Some(104910156.0),
      working_day_number = 1,
      sale_start_days = Some(2.0),
      sale_cap = Some(4500000000.0),
      repo_start_days = Some(1.0),
      overnight_repo_total_cap = Some(6000000000.0),
      overnight_repo_daily_cap = Some(6000000000.0),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 135,
      my_check = 1
    ),
    IlmCalcMonetisationInput(
      partition_key = "GB|RFB|SOV_L1_USD|COMBINED",
      instrument_partition_key = "GB|RFB|SOV_L1_USD|US9128284A52",
      order_key = 60,
      balance_sheet = Some(-104910156.0),
      off_balance_sheet = Some(0.0),
      cumulative_contractual_balance_sheet = Some(0.0),
      working_day_number = 135,
      sale_start_days = Some(2.0),
      sale_cap = Some(4500000000.0),
      repo_start_days = Some(1.0),
      overnight_repo_total_cap = Some(6000000000.0),
      overnight_repo_daily_cap = Some(6000000000.0),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 135,
      my_check = 1
    ),
    IlmCalcMonetisationInput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|GRS518003009",
      order_key = 878,
      balance_sheet = Some(17353.849279096063),
      off_balance_sheet = Some(0.0),
      cumulative_contractual_balance_sheet = Some(17353.849279096063),
      working_day_number = 1,
      sale_start_days = Some(3.0),
      sale_cap = Some(700000000.0),
      repo_start_days = Some(1.0),
      overnight_repo_total_cap = Some(700000000.0),
      overnight_repo_daily_cap = Some(700000000.0),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 137,
      my_check = 1
    ),
    IlmCalcMonetisationInput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|GRS518003009",
      order_key = 6445,
      balance_sheet = Some(-17353.849279096063),
      off_balance_sheet = Some(0.0),
      cumulative_contractual_balance_sheet = Some(0.0),
      working_day_number = 137,
      sale_start_days = Some(3.0),
      sale_cap = Some(700000000.0),
      repo_start_days = Some(1.0),
      overnight_repo_total_cap = Some(700000000.0),
      overnight_repo_daily_cap = Some(700000000.0),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 137,
      my_check = 1
    ),
    IlmCalcMonetisationInput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|XS1269854870",
      order_key = 1206,
      balance_sheet = Some(2186979.7492057406),
      off_balance_sheet = None,
      cumulative_contractual_balance_sheet = Some(2286955.9657582771),
      working_day_number = 2,
      sale_start_days = Some(3.0),
      sale_cap = Some(700000000.0),
      repo_start_days = Some(1.0),
      overnight_repo_total_cap = Some(700000000.0),
      overnight_repo_daily_cap = Some(700000000.0),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 135,
      my_check = 1
    )
  )
  val output = Seq(
    IlmCalcMonetisationOutput(
      partition_key = "GB|RFB|SOV_L1_USD|COMBINED",
      instrument_partition_key = "GB|RFB|SOV_L1_USD|US9128284A52",
      order_key = 32,
      repo_post_cap = -1.04910156E8,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(1.04910156E8),
      current_off_balance_sheet = -1.04910156E8,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = -1.04910156E8,
      overnight_repo_current_cap = 6.0E9,
      repo_cap_used = -1.04910156E8,
      current_balance_sheet = 1.04910156E8,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is 104910156, current_position after sales is: 104910156 ,repo subject to cap left 6000000000 ,alter the repo cap by the repo move"
    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|RFB|SOV_L1_USD|COMBINED",
      instrument_partition_key = "GB|RFB|SOV_L1_USD|US9128284A52",
      order_key = 32,
      repo_post_cap = 1.04910156E8,
      sale_post_cap = -1.04910156E8,
      working_day_number_original = 1,
      working_day_number = 2,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = -1.04910156E8,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 6.0E9,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = -1.04910156E8,
      test = "Day: 2 result leftover:0, current_position prior to sales is 104910156, available_for_sale is 104910156 ,sell off subject to cap 4500000000, current_position after sales is: 0 ,alter the repo cap by the repo move"

    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|RFB|SOV_L1_USD|COMBINED",
      instrument_partition_key = "GB|RFB|SOV_L1_USD|US9128284A52",
      order_key = 60,
      repo_post_cap = 0.0,
      sale_post_cap = 1.04910156E8,
      working_day_number_original = 135,
      working_day_number = 135,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Option(0.0),
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 6.0E9,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = 0.0,
      test = "Day: 135 new input , current_position prior to sales is -104910156, available_for_sale is 0 ,buy back at maturity, current_position after sales is: 0 ,alter the repo cap by the repo move"

    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|GRS518003009",
      order_key = 878,
      repo_post_cap = -17353.849279096063,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Option(17353.849279096063),
      current_off_balance_sheet = -17353.849279096063,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = -17353.849279096063,
      overnight_repo_current_cap = 7.0E8,
      repo_cap_used = -17353.849279096063,
      current_balance_sheet = 17353.849279096063,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is 17353.849279096063, current_position after sales is: 17353.849279096063 ,repo subject to cap left 700000000 ,alter the repo cap by the repo move"
    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|GRS518003009",
      order_key = 878,
      repo_post_cap = 17353.849279096063,
      sale_post_cap = -17353.849279096063,
      working_day_number_original = 1,
      working_day_number = 3,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = -17353.849279096063,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 7.0E8,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = -17353.849279096063,
      test = "Day: 3 result leftover:0, current_position prior to sales is 17353.849279096063, available_for_sale is 17353.849279096063 ,sell off subject to cap 700000000, current_position after sales is: 0 ,alter the repo cap by the repo move"

    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|GRS518003009",
      order_key = 6445,
      repo_post_cap = 0.0,
      sale_post_cap = 17353.849279096063,
      working_day_number_original = 137,
      working_day_number = 137,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Option(0.0),
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 7.0E8,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = 0.0,
      test = "Day: 137 new input , current_position prior to sales is -17353.849279096063, available_for_sale is 0 ,buy back at maturity, current_position after sales is: 0 ,alter the repo cap by the repo move"

    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|XS1269854870",
      order_key = 1206,
      repo_post_cap = -2186979.7492057406,
      sale_post_cap = 0.0,
      working_day_number_original = 2,
      working_day_number = 2,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Option(2286955.965758277),
      current_off_balance_sheet = -2186979.7492057406,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = -2186979.7492057406,
      overnight_repo_current_cap = 7.0E8,
      repo_cap_used = -2186979.7492057406,
      current_balance_sheet = 2186979.7492057406,
      sale_cap_used = 0.0,
      test = "Day: 2 new input , current_position prior to sales is 2186979.7492057406, current_position after sales is: 2186979.7492057406 ,repo subject to cap left 700000000 ,alter the repo cap by the repo move"
    ),
    IlmCalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_CORP_L2B_EUR|COMBINED",
      instrument_partition_key = "GB|nRFB|GM_CORP_L2B_EUR|XS1269854870",
      order_key = 1206,
      repo_post_cap = 2186979.7492057406,
      sale_post_cap = -2186979.7492057406,
      working_day_number_original = 2,
      working_day_number = 3,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = -2186979.7492057406,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 7.0E8,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = -2186979.7492057406,
      test = "Day: 3 result leftover:0, current_position prior to sales is 2186979.7492057406, available_for_sale is 2186979.7492057406 ,sell off subject to cap 700000000, current_position after sales is: 0 ,alter the repo cap by the repo move"

    )
  )
}
package hsbc.emf.udf.calcmonetisation

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}
import org.apache.spark.sql.Row
import org.graalvm.polyglot.proxy.ProxyArray

class CalcMonetisation extends SparkUdfRegisterableFunction1[Seq[Row], Seq[CalcMonetisationOutput]] {

  import CalcMonetisation.context

  def apply(input: Seq[Row]): Seq[CalcMonetisationOutput] = {
    CalcMonetisation.safeExecute {
      context.eval("js", CalcMonetisationJavaScript.js)
      val ilmMonetisation: Seq[CalcMonetisationInput] = CalcMonetisationInput.apply(input)
      val proxyArray: ProxyArray = ProxyArray.fromArray(ilmMonetisation: _*)
      context.getBindings("js").putMember("myO", proxyArray)
      val value = context.eval("js", "calcMonetisation(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => CalcMonetisationOutput.apply(value.getArrayElement(i)) }
    }
  }

  override protected val functionName: String = "FOTC_UDF_calc_monetisation"
}

object CalcMonetisation extends UdfBuilder[CalcMonetisation] {

  override def apply: CalcMonetisation = new CalcMonetisation()
}package hsbc.emf.udf.calcmonetisation

import hsbc.emf.udf.SeqRowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject
import org.apache.spark.sql.Row

case class CalcMonetisationInput(
                                     partition_key: String,
                                     instrument_partition_key: String,
                                     order_key: Long,
                                     balance_sheet_move: Option[Double],
                                     off_balance_sheet_move: Option[Double],
                                     cumulative_contractual_balance_sheet: Option[Double],
                                     working_day_number: Long,
                                     sale_start_days: Long,
                                     sale_cap: Option[Double],
                                     repo_start_days: Long,
                                     overnight_repo_total_cap: Option[Double],
                                     overnight_repo_daily_cap: Option[Double],
                                     maximum_daily_bucket: Long,
                                     maximum_balance_sheet_day: Long,
                                     my_check: Long
                                   ) extends ScalaProxyObject

object CalcMonetisationInput extends SeqRowToJSCollection[CalcMonetisationInput] {

  override def apply(v1: Seq[Row]): Seq[CalcMonetisationInput] = {
    v1.map { e =>
      CalcMonetisationInput(
        e.getAs(0),
        e.getAs(1),
        e.getAs(2),
        Option(e.getAs(3)),
        Option(e.getAs(4)),
        Option(e.getAs(5)),
        e.getLong(6),
        e.getLong(7),
        Option(e.getAs(8)),
        e.getLong(9),
        Option(e.getAs(10)),
        Option(e.getAs(11)),
        e.getLong(12),
        e.getLong(13),
        e.getLong(14)
      )
      // This is needed because the bigquery SQL calling this function orders the input set by order_id
    }.sortBy(a => (a.order_key, a.off_balance_sheet_move))

  }
}
package hsbc.emf.udf.calcmonetisation



object CalcMonetisationJavaScript {
  val js =
    """	function calcMonetisation(part){
      | //FD takes the counterbalancing capacity bucket amount and monetises it with adjustment for the cap
      |	//the data can be daily up to the point of the max_daily_day. After that is allowed to split into 7 further buckets which have been set up
      |	//the working_day_number needs to then adjust from being daily up to the max_daily_day and then represent some discrete buckets.
      |	//This was to overcome some processing time outs
      |	//had previously used filter() function but due to time out changed to for or while loops taking advantage of the data being sorted to limit the check
      |	"use strict";
      |
      |	var repo_move = 0.0;
      |	var sale_cap_used = 0.0;
      |	var repo_cap_left = 0.0;
      |	var sale_cap_left = 0.0;
      |	var result = [];
      |	var result_left = [];
      |	var absolute_move;
      |	var absolute_left;
      |	var result_length = 0;
      |	var list_days = [];
      |	var current_balance_sheet = 0.0;
      |	var current_off_balance_sheet = 0.0;
      |	var opening_monetised_by_repo = 0.0;
      |	var contractual_balance_sheet_move = 0.0;
      |	var contractual_off_balance_sheet_move = 0.0;
      |	var contractual_balance_sheet = 0.0;
      |	var overnight_repo_current_cap = 0.0;
      |	var iDay;
      |	var recheck = 1;
      |
      |	//create a list of days. Have allowed for (21-14)= 7 non daily buckets after the daily list which fits to PRA110
      |	var no_of_non_daily_buckets = 7;
      |	var max_daily_day = part[0].maximum_daily_bucket * 1;
      |	for (var i = 1; i<= max_daily_day +no_of_non_daily_buckets; i++){
      |		list_days.push(i);
      |	}
      |
      |	var daily_sale_cap = part[0].sale_cap; //these variables are identical for all items in the group so can just set it once
      |	var sale_start_days = part[0].sale_start_days * 1;
      |	var repo_start_days = part[0].repo_start_days * 1;
      |	var overnight_repo_total_cap = part[0].overnight_repo_total_cap;
      |	var overnight_repo_daily_cap = part[0].overnight_repo_daily_cap;
      |	var iLastInputParameter = 0;
      |	var result_left = [];
      |	var result_left_current_day = [];
      |	var repo_cap_used = 0;  //doesn't reset for a new day
      |
      |	for(var x = 0; x < list_days.length; x++){
      |
      |		iDay = list_days[x];
      |		sale_cap_used = 0;  //reset for a new day
      |		result_left = result_left_current_day; // this sets it to what was filled at the end of the prev day, on the first run it's empty
      |		result_left_current_day =[]; //clear the current results
      |
      |		if (iDay  > max_daily_day) {
      |			overnight_repo_current_cap = overnight_repo_total_cap;
      |		}
      |		else {
      |			overnight_repo_current_cap = Math.min(overnight_repo_total_cap , overnight_repo_daily_cap * (iDay - repo_start_days + 1)); //cap increases by the daily, surplus unused from prior carried over
      |		}
      |
      |		var this_working_day_number = -1;
      |		if (iLastInputParameter < part.length) {
      |			this_working_day_number = part[iLastInputParameter].working_day_number;
      |		}
      |
      |		//get list of the input parameters for the iDay
      |		var z = iLastInputParameter;
      |		var parameters_current_day = []
      |		while (z < part.length && part[z].working_day_number == iDay){
      |			parameters_current_day.push(part[z]);
      |			z++;
      |			iLastInputParameter = z;
      |		}
      |
      |		var iResultLeft = 0;
      |		while (iResultLeft < result_left.length){
      |
      |			var item = result_left[iResultLeft];
      |
      |			opening_monetised_by_repo = item.current_monetised_by_repo;
      |			current_off_balance_sheet = item.current_off_balance_sheet - opening_monetised_by_repo; //this matures the monetised repo
      |			current_balance_sheet = item.current_balance_sheet  ;
      |			repo_cap_left = overnight_repo_current_cap + repo_cap_used - Math.min(0,opening_monetised_by_repo); //add back the monetised repo (CACL-7881 not rr)now matured
      |		    	sale_cap_left = daily_sale_cap + sale_cap_used;
      |
      |			//check through parameters_current_day to see if the isin exists on it
      |
      |			var z= 0;
      |			var test = "Day: " + iDay + " result leftover:" + iResultLeft ;
      |			contractual_balance_sheet_move = 0.0;
      |			contractual_off_balance_sheet_move = 0.0;
      |			contractual_balance_sheet  = item.cumulative_contractual_balance_sheet;
      |			while (z < parameters_current_day.length){
      |				var itemInput = parameters_current_day[z];
      |				if (itemInput.instrument_partition_key == item.instrument_partition_key){
      |					contractual_balance_sheet_move = itemInput.balance_sheet_move;
      |					contractual_off_balance_sheet_move = itemInput.off_balance_sheet_move;
      |					contractual_balance_sheet = itemInput.cumulative_contractual_balance_sheet
      |					current_off_balance_sheet = current_off_balance_sheet + contractual_off_balance_sheet_move;
      |					current_balance_sheet = current_balance_sheet + contractual_balance_sheet_move;
      |					parameters_current_day[z].my_check = 0; //this will stop checking this in the new deal only part
      |					var test = test + " found_it_in_new:" + z;
      |					z = parameters_current_day.length; //this will break the check through input parameters
      |
      |				}
      |				z++;
      |
      |			}
      |
      |			var result_sold = monetise_position(
      |				  item.working_day_number_original
      |				, iDay
      |				, item.instrument_partition_key
      |				, contractual_balance_sheet
      |				, current_balance_sheet
      |				, current_off_balance_sheet
      |				, sale_cap_left
      |				, sale_cap_used
      |				, repo_cap_left
      |				, repo_cap_used
      |				, sale_start_days
      |				, repo_start_days
      |				, max_daily_day
      |				, item.maximum_balance_sheet_day
      |				, opening_monetised_by_repo
      |				, result_left_current_day
      |				, result
      |				, test);
      |
      |			repo_cap_used = result_sold.repo_cap_used;
      |			sale_cap_used = result_sold.sale_cap_used;
      |			iResultLeft++;
      |		} //end while (iResultLeft < result_left.length)
      |
      |
      |		//go through the new inputs for the day and check for anything not already dealt with
      |		var z = 0;
      |		while (z < parameters_current_day.length ){
      |			var item = parameters_current_day[z];
      |			if (item.my_check == 1) { //this ensures we don't look at records that were dealt with in the leftover section
      |
      |				contractual_balance_sheet = item.cumulative_contractual_balance_sheet
      |				current_off_balance_sheet = item.off_balance_sheet_move;
      |				current_balance_sheet = item.balance_sheet_move ;
      |				opening_monetised_by_repo = 0.0;
      |				repo_cap_left = overnight_repo_current_cap + repo_cap_used;
      |				sale_cap_left = daily_sale_cap + sale_cap_used;
      |
      |				var test = "Day: " + iDay + " new input " ;
      |				//everything here on replicates the previous while loop. Not sure if passing the array in would use memory
      |				var result_sold = monetise_position(
      |				  item.working_day_number
      |				, iDay
      |				, item.instrument_partition_key
      |				, contractual_balance_sheet
      |				, current_balance_sheet
      |				, current_off_balance_sheet
      |				, sale_cap_left
      |				, sale_cap_used
      |				, repo_cap_left
      |				, repo_cap_used
      |				, sale_start_days
      |				, repo_start_days
      |				, max_daily_day
      |				, item.maximum_balance_sheet_day
      |				, opening_monetised_by_repo
      |				, result_left_current_day
      |				, result
      |				, test);
      |
      |				repo_cap_used = result_sold.repo_cap_used;
      |				sale_cap_used = result_sold.sale_cap_used;
      |
      |			}
      |			z++; //increment the while loop
      |		}//end of while (z < parameters_current_day.length )
      |
      |	}//end of look for the list of days
      |
      |	function monetise_position (
      |		working_day_number_original
      |		,working_day_number
      |		,instrument_partition_key
      |		,contractual_balance_sheet
      |		,current_balance_sheet //the position passed in should include all contractual moves
      |		,current_off_balance_sheet   //the position passed in should be after maturing any monetisation overnight repo and all contractual moves
      |		,sale_cap_left
      |		,sale_cap_used
      |		,repo_cap_left
      |		,repo_cap_used
      |		,sale_start_days
      |		,repo_start_days
      |		,max_daily_day
      |		,maximum_balance_sheet_day
      |		,opening_monetised_by_repo //this is the amount of any monetisation overnight repo at the start of day (before they mature..)
      |		,result_left_current_day
      |		,result
      |		,test)
      |		{
      |
      | if (working_day_number >= maximum_balance_sheet_day) {
      |			// if security matured the positions must be zero. previously the maturing entry would be in the input data so the positions would zero naturally
      |			current_balance_sheet = 0.0;
      |			contractual_balance_sheet =0.0;
      |			current_off_balance_sheet =0.0;
      |		}
      |		var current_position = current_balance_sheet + current_off_balance_sheet;
      |		var repo_move_incl_rolls = 0.0;
      |		var repo_cap_used_by_action = 0.0;
      |		var sale_cap_used_by_action = 0.0;
      |		var sale_move = 0.0;
      |		var repo_move =0.0;
      |		var current_monetised_by_repo = 0.0;
      |		var available_for_sale = 0.0;
      |
      |		test = test + ', current_position prior to sales is ' + current_position;
      |
      |		if (sale_start_days <= working_day_number ){ //check security has not matured
      |			available_for_sale = Math.max(0, current_balance_sheet +  Math.min(0,current_off_balance_sheet));
      |			test = test + ', available_for_sale is ' + available_for_sale;
      |
      |			if (available_for_sale > 0) {
      |				if (working_day_number  > max_daily_day) {
      |					sale_move = - available_for_sale;
      |					test = test + ' ,sell off without checking cap';
      |				}
      |				else {
      |					sale_move =-Math.min(available_for_sale,sale_cap_left);
      |					test = test + ' ,sell off subject to cap ' + sale_cap_left;
      |				}
      |			}
      |
      |
      |			//deal with short balance sheet
      |			if (Math.round(current_balance_sheet) < 0 ) {
      |				if (maximum_balance_sheet_day == working_day_number && Math.round(contractual_balance_sheet) >= 0 ) { //indicates maturity of the bond
      |					sale_move = - current_balance_sheet ; //flatten the whole balance sheet
      |					test = test + ' ,buy back at maturity';
      |				}
      |				else if (contractual_balance_sheet >= 0 && current_position < 0) { //if the monetisation created the short then flatten the balance sheet
      |						sale_move = - current_balance_sheet //flatten the whole balance sheet this is a short balance sheet created by the actions
      |						test = test + ' ,buy back to reverse short created by monetisation';
      |				}
      |				else if (current_position < 0) {
      |						sale_move = - (current_balance_sheet + Math.max( 0, current_off_balance_sheet)) ; //buy back just enough to flatten the position
      |						test = test + ' ,buy back to flatten position';
      |				}
      |			}
      |
      |		}
      |		current_balance_sheet = current_balance_sheet + sale_move;
      |		current_position = current_balance_sheet + current_off_balance_sheet;
      |		sale_cap_used_by_action = Math.min(0,sale_move); //a positive here means a buy back so no cap consumed. cacl-7782
      |		test = test + ', current_position after sales is: ' + current_position;
      |
      |		if (current_position < 0 ) {
      |			repo_move_incl_rolls = - current_position;  //need to cover short add in extra field to indicate it's cover of short rather than maturing of repo
      |			test = test + ' ,add in repo roll if short';
      |		}
      |		else if (current_position > 0) {
      |			if (repo_start_days <= working_day_number) {
      |				repo_move_incl_rolls =-Math.min(current_position,repo_cap_left);
      |				test = test + ' ,repo subject to cap left ' + repo_cap_left;
      |			}
      |		}
      |
      |		repo_move = repo_move_incl_rolls - opening_monetised_by_repo; //just pick up the additional above rolls
      |		current_off_balance_sheet = current_off_balance_sheet + repo_move_incl_rolls;
      |		current_monetised_by_repo = repo_move_incl_rolls;
      |
      |		if (current_monetised_by_repo <= 0){ //i.e. the position is a net repo
      |			if (opening_monetised_by_repo <= 0 ){
      |				repo_cap_used_by_action = repo_move;
      |				test = test + ' ,alter the repo cap by the repo move';
      |			}
      |			else { //open monetised was postive so a net rev repo, the unwind of the rev repo doesn't consume cap, only the additional repo
      |				repo_cap_used_by_action = current_monetised_by_repo;
      |				test = test + ' ,reduce the repo cap by the additional repo'
      |			}
      |		}
      |		else if (opening_monetised_by_repo <= 0 ){ //is open is net repo and close is net rr then we must have unwound all the repos so it frees up the cap
      |			repo_cap_used_by_action =  - opening_monetised_by_repo;
      |			test = test + ' ,increase the repo cap by the unwound monetisation repo'
      |		}
      |
      |		current_position = current_balance_sheet + current_off_balance_sheet;
      |		repo_cap_used = repo_cap_used + repo_cap_used_by_action;
      |		sale_cap_used = sale_cap_used + sale_cap_used_by_action;
      |		absolute_move = Math.abs(repo_move)+ Math.abs(sale_move);
      |		absolute_left = Math.abs(current_off_balance_sheet)+ Math.abs(current_balance_sheet) + Math.abs(current_monetised_by_repo);
      |
      |		if (absolute_move > 0) { //create results if a move
      |			result.push({partition_key: item.partition_key
      |				,instrument_partition_key : instrument_partition_key
      |				,order_key : item.order_key //I didn't pass in item but it seems to read it..
      |				,repo_post_cap : repo_move
      |				,sale_post_cap : sale_move
      |				,working_day_number_original : working_day_number_original
      |				,working_day_number : working_day_number
      |				,cumulative_contractual_balance_sheet : contractual_balance_sheet
      |				,current_balance_sheet: current_balance_sheet
      |				,current_off_balance_sheet : current_off_balance_sheet
      |				,opening_monetised_by_repo : opening_monetised_by_repo
      |				,current_monetised_by_repo : current_monetised_by_repo
      |				,overnight_repo_current_cap : overnight_repo_current_cap
      |				,repo_cap_used : repo_cap_used
      |				,sale_cap_used : sale_cap_used
      |				,test : test
      |				});
      |		}
      |
      |		if (absolute_left > 0) { //create to look at the next day
      |
      |			result_left_current_day.push({partition_key: item.partition_key
      |				,instrument_partition_key : instrument_partition_key
      |				,order_key : item.order_key
      |				,working_day_number_original : working_day_number_original
      |				,working_day_number : working_day_number
      |				,current_balance_sheet : current_balance_sheet
      |				,current_off_balance_sheet : current_off_balance_sheet
      |				,current_monetised_by_repo : current_monetised_by_repo
      |				,repo_start_days : repo_start_days
      |				,overnight_repo_current_cap : overnight_repo_current_cap
      |				,current_balance_sheet : current_balance_sheet
      |				,sale_start_days : sale_start_days
      |				,maximum_balance_sheet_day : maximum_balance_sheet_day
      |				,test:'HERE4'
      |				});
      |		}
      |
      |		var caps_used = {repo_cap_used: repo_cap_used, sale_cap_used:sale_cap_used}; // need to check the scope
      |		return caps_used;
      |	}
      |
      |	return result;
      | }
      |""".stripMargin
}package hsbc.emf.udf.calcmonetisation

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

case class CalcMonetisationOutput(partition_key: String,
                                     instrument_partition_key: String,
                                     order_key: Long,
                                     repo_post_cap: Double,
                                     sale_post_cap: Double,
                                     working_day_number_original: Long,
                                     working_day_number: Long,
                                     contractual_balance_sheet_move: Option[Double],
                                     contractual_off_balance_sheet_move: Option[Double],
                                     cumulative_contractual_balance_sheet: Option[Double],
                                     current_off_balance_sheet: Double,
                                     opening_monetised_by_repo: Double,
                                     current_monetised_by_repo: Double,
                                     overnight_repo_current_cap: Double,
                                     repo_cap_used: Double,
                                     current_balance_sheet: Double,
                                     sale_cap_used: Double,
                                     test: String
                                    )

object CalcMonetisationOutput extends GraalVmValueConverter[CalcMonetisationOutput] {

  override def apply(v1: Value): CalcMonetisationOutput = {

    val helper = (name: String) => v1.getMember(name)

    def helperNull(name: String): Option[Double] = {

      Option(helper(name)) match {
        case Some(value) => if (value.isNull) {
          None
        } else {
          Option(value.asDouble())
        }
        case _ => None
      }

    }

    new CalcMonetisationOutput(
      helper("partition_key").asString(),
      helper("instrument_partition_key").asString(),
      helper("order_key").asLong(),
      helper("repo_post_cap").asDouble(),
      helper("sale_post_cap").asDouble(),
      helper("working_day_number_original").asLong(),
      helper("working_day_number").asLong(),
      helperNull("contractual_balance_sheet_move"),
      helperNull("contractual_off_balance_sheet_move"),
      helperNull("cumulative_contractual_balance_sheet"),
      helper("current_off_balance_sheet").asDouble(),
      helper("opening_monetised_by_repo").asDouble(),
      helper("current_monetised_by_repo").asDouble(),
      helper("overnight_repo_current_cap").asDouble(),
      helper("repo_cap_used").asDouble(),
      helper("current_balance_sheet").asDouble(),
      helper("sale_cap_used").asDouble(),
      helper("test").asString()
    )
  }
}package hsbc.emf.udf.calcmonetisation

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.utils.TolerantCaseCaseEquality.ProductEquality
import org.apache.spark.sql.Row
import org.apache.spark.sql.functions._
import org.scalatest.FlatSpec

class CalcMonetisationTest extends FlatSpec with IntegrationTestSuiteBase {
  implicit val outputEquality: ProductEquality[CalcMonetisationOutput] = new ProductEquality[CalcMonetisationOutput](1e-9)

  behavior of "CalcMonetisation"

  it should "execute the FOTC_UDF_calc_monetisation UDF in spark" in {
    val testObj = new CalcMonetisation()
    spark.udf.register("FOTC_UDF_calc_monetisation", testObj.apply(_ :Seq[Row]))
    val sqlStatement =
      """
        |select FOTC_UDF_calc_monetisation(
        | collect_list(
        |   struct(
        |      partition_key,
        |      instrument_partition_key,
        |      order_key,
        |      balance_sheet_move,
        |      off_balance_sheet_move,
        |      cumulative_contractual_balance_sheet,
        |      working_day_number,
        |      sale_start_days,
        |      sale_cap,
        |      repo_start_days,
        |      overnight_repo_total_cap,
        |      overnight_repo_daily_cap,
        |      maximum_daily_bucket,
        |      maximum_balance_sheet_day,
        |      my_check
        |    )
        |  )
        | ) as result
        |  from CalcIlmMonetisationTest
        |  group by partition_key
        |
        |""".stripMargin
    import spark.implicits._

    data.CalcMonetisationTestData.input.toDF.createOrReplaceTempView("CalcIlmMonetisationTest")

    val results = spark.sql(sqlStatement)
      .select(explode(col("result")))
      .select("col.*")
      .withColumn("test", lit("dummy")) // cannot compare strings with tolerant doubles in them
      .as[CalcMonetisationOutput]
      .collect().sortBy { a => (a.order_key, a.contractual_balance_sheet_move) }
    val paired = results zip data.CalcMonetisationTestData.output.sortBy { a => (a.order_key, a.contractual_balance_sheet_move) }.map {
      _.copy(test = "dummy") // cannot compare strings with tolerant doubles in them
    }

    paired.foreach { case (res, target) => assert(res === target) }

  }
}
package hsbc.emf.udf.calcmonetisation.data

import hsbc.emf.udf.calcmonetisation.{CalcMonetisationInput, CalcMonetisationOutput}

object CalcMonetisationTestData {

  val input: Seq[CalcMonetisationInput] = Seq(
    CalcMonetisationInput(partition_key = "GB|nRFB|GM_SOV_L2B_OTH",
      instrument_partition_key = "GB|nRFB|GM_SOV_L2B_OTH|TW0006462005",
      order_key = 2,
      balance_sheet_move = Some(-221863.49852416097),
      off_balance_sheet_move = Some(221863.495739226),
      cumulative_contractual_balance_sheet = Some(-221863.49852416097),
      working_day_number = 1,
      sale_start_days = 3,
      sale_cap = Some(5000000.0),
      repo_start_days = 1,
      overnight_repo_total_cap = Some(1.0E7),
      overnight_repo_daily_cap = Some(1.0E7),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 100000,
      my_check = 1
    ),
    CalcMonetisationInput(
      partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH",
      instrument_partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH|AU0000KFWHU6",
      order_key = 1,
      balance_sheet_move = Some(1.1377375915776579E8),
      off_balance_sheet_move = Some(0.0),
      cumulative_contractual_balance_sheet = Some(1.1377375915776579E8),
      working_day_number = 1,
      sale_start_days = 3,
      sale_cap = Some(1.0E8),
      repo_start_days = 1,
      overnight_repo_total_cap = Some(1.0E8),
      overnight_repo_daily_cap = Some(1.0E8),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 248,
      my_check = 1
    ),
    CalcMonetisationInput(
      partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP",
      instrument_partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP|XS2281370903",
      order_key = 1,
      balance_sheet_move = Some(5.559316273013323E7),
      off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(5.559316273013323E7),
      working_day_number = 1,
      sale_start_days = 3,
      sale_cap = Some(6.0E8),
      repo_start_days = 1,
      overnight_repo_total_cap = Some(1.0E9),
      overnight_repo_daily_cap = Some(1.0E9),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 1511,
      my_check = 1
    ),
    CalcMonetisationInput(
      partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L2B_USD",
      instrument_partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L2B_USD|US29272W1099",
      order_key = 2,
      balance_sheet_move = Some(134387.16),
      off_balance_sheet_move = Some(-400330.2125866164),
      cumulative_contractual_balance_sheet = Some(134387.16),
      working_day_number = 1,
      sale_start_days = 3,
      sale_cap = Some(5000000.0),
      repo_start_days = 1,
      overnight_repo_total_cap = Some(1.0E7),
      overnight_repo_daily_cap = Some(1.0E7),
      maximum_daily_bucket = 130,
      maximum_balance_sheet_day = 100000,
      my_check = 1
    )

  )
  val output: Seq[CalcMonetisationOutput] = Seq(

    CalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_SOV_L2B_OTH",
      instrument_partition_key = "GB|nRFB|GM_SOV_L2B_OTH|TW0006462005",
      order_key = 2,
      repo_post_cap = 0.0027849349717143923,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(-221863.49852416097),
      current_off_balance_sheet = 221863.49852416097,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = 0.0027849349717143923,
      overnight_repo_current_cap = 1.0E7,
      repo_cap_used = 0.0,
      current_balance_sheet = -221863.49852416097,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is -0.0027849349717143923, current_position after sales is: -0.0027849349717143923 ,add in repo roll if short ,increase the repo cap by the unwound monetisation repo"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_SOV_L2B_OTH",
      instrument_partition_key = "GB|nRFB|GM_SOV_L2B_OTH|TW0006462005",
      order_key = 2,
      repo_post_cap = -0.0027849349717143923,
      sale_post_cap = 0.0027849349717143923,
      working_day_number_original = 1,
      working_day_number = 3,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 221863.495739226,
      opening_monetised_by_repo = 0.0027849349717143923,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 1.0E7,
      repo_cap_used = 0.0,
      current_balance_sheet = -221863.495739226,
      sale_cap_used = 0.0,
      test = "Day: 3 result leftover:0, current_position prior to sales is -0.0027849349717143923, available_for_sale is 0 ,buy back to flatten position, current_position after sales is: 0 ,reduce the repo cap by the additional repo"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH",
      instrument_partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH|AU0000KFWHU6",
      order_key = 1,
      repo_post_cap = -1.0E8,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(1.1377375915776579E8),
      current_off_balance_sheet = -1.0E8,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = -1.0E8,
      overnight_repo_current_cap = 1.0E8,
      repo_cap_used = -1.0E8,
      current_balance_sheet = 1.1377375915776579E8,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is 113773759.15776579, current_position after sales is: 113773759.15776579 ,repo subject to cap left 100000000 ,alter the repo cap by the repo move"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH",
      instrument_partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH|AU0000KFWHU6",
      order_key = 1,
      repo_post_cap = 8.622624084223421E7,
      sale_post_cap = -1.0E8,
      working_day_number_original = 1,
      working_day_number = 3,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = -1.377375915776579E7,
      opening_monetised_by_repo = -1.0E8,
      current_monetised_by_repo = -1.377375915776579E7,
      overnight_repo_current_cap = 1.0E8,
      repo_cap_used = -1.377375915776579E7,
      current_balance_sheet = 1.377375915776579E7,
      sale_cap_used = -1.0E8,
      test = "Day: 3 result leftover:0, current_position prior to sales is 113773759.15776579, available_for_sale is 113773759.15776579 ,sell off subject to cap 100000000, current_position after sales is: 13773759.15776579 ,repo subject to cap left 100000000 ,alter the repo cap by the repo move"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH",
      instrument_partition_key = "GB|nRFB|SUPRA_GG_OTHER_L1_OTH|AU0000KFWHU6",
      order_key = 1,
      repo_post_cap = 1.377375915776579E7,
      sale_post_cap = -1.377375915776579E7,
      working_day_number_original = 1,
      working_day_number = 4,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = -1.377375915776579E7,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 1.0E8,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = -1.377375915776579E7,
      test = "Day: 4 result leftover:0, current_position prior to sales is 13773759.15776579, available_for_sale is 13773759.15776579 ,sell off subject to cap 100000000, current_position after sales is: 0 ,alter the repo cap by the repo move"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP",
      instrument_partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP|XS2281370903",
      order_key = 1,
      repo_post_cap = -5.559316273013323E7,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(5.559316273013323E7),
      current_off_balance_sheet = -5.559316273013323E7,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = -5.559316273013323E7,
      overnight_repo_current_cap = 1.0E9,
      repo_cap_used = -5.559316273013323E7,
      current_balance_sheet = 5.559316273013323E7,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is 55593162.73013323, current_position after sales is: 55593162.73013323 ,repo subject to cap left 1000000000 ,alter the repo cap by the repo move"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP",
      instrument_partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L1_GBP|XS2281370903",
      order_key = 1,
      repo_post_cap = 5.559316273013323E7,
      sale_post_cap = -5.559316273013323E7,
      working_day_number_original = 1,
      working_day_number = 3,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = None,
      current_off_balance_sheet = 0.0,
      opening_monetised_by_repo = -5.559316273013323E7,
      current_monetised_by_repo = 0.0,
      overnight_repo_current_cap = 1.0E9,
      repo_cap_used = 0.0,
      current_balance_sheet = 0.0,
      sale_cap_used = -5.559316273013323E7,
      test = "Day: 3 result leftover:0, current_position prior to sales is 55593162.73013323, available_for_sale is 55593162.73013323 ,sell off subject to cap 600000000, current_position after sales is: 0 ,alter the repo cap by the repo move"
    ),
    CalcMonetisationOutput(
      partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L2B_USD",
      instrument_partition_key = "GB|nRFB|GM_SUPRA_GG_OTHER_L2B_USD|US29272W1099",
      order_key = 2,
      repo_post_cap = 265943.05258661625,
      sale_post_cap = 0.0,
      working_day_number_original = 1,
      working_day_number = 1,
      contractual_balance_sheet_move = None,
      contractual_off_balance_sheet_move = None,
      cumulative_contractual_balance_sheet = Some(134387.16),
      current_off_balance_sheet = -134387.16000000003,
      opening_monetised_by_repo = 0.0,
      current_monetised_by_repo = 265943.05258661625,
      overnight_repo_current_cap = 1.0E7,
      repo_cap_used = 0.0,
      current_balance_sheet = 134387.16,
      sale_cap_used = 0.0,
      test = "Day: 1 new input , current_position prior to sales is -265943.05258661625, current_position after sales is: -265943.05258661625 ,add in repo roll if short ,increase the repo cap by the unwound monetisation repo"
    )

  )
}
package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}
import org.graalvm.polyglot.proxy.ProxyArray
import org.apache.spark.sql.Row

private[udf] class CalcUncoveredRollOff extends SparkUdfRegisterableFunction1[Seq[Row], Seq[CalcUncoveredRollOffOutput]] {

  import CalcUncoveredRollOff._

  override val functionName: String = "FOTC_UDF_calc_uncovered_roll_off"

  def apply(input: Seq[Row]): Seq[CalcUncoveredRollOffOutput] = {
    CalcUncoveredRollOff.safeExecute {
      context.eval("js", CalcUncoveredRollOffJavaScript.js)
      val calcUncoveredRollOffInput: Seq[CalcUncoveredRollOffInput] = CalcUncoveredRollOffInput.apply(input)
      val proxyArray: ProxyArray = ProxyArray.fromArray(calcUncoveredRollOffInput: _*)
      context.getBindings("js").putMember("myO", proxyArray)
      val value = context.eval("js", s"$functionName(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => CalcUncoveredRollOffOutput.apply(value.getArrayElement(i)) }
    }
  }

}

object CalcUncoveredRollOff extends UdfBuilder[CalcUncoveredRollOff] {

  override def apply: CalcUncoveredRollOff = new CalcUncoveredRollOff
}package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.udf.SeqRowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject

import org.apache.spark.sql.Row

private[udf] case class CalcUncoveredRollOffInput(
                                                   partition_key: String,
                                                   order_key: Int,
                                                   Movement_In_Short: Option[Double],
                                                   Short_Increase_Uncovered: Option[Double],
                                                   Short_Increase_Covered_CS: Option[Double],
                                                   Short_Increase_Covered_RR: Option[Double]
                                                 ) extends ScalaProxyObject

private[udf] object CalcUncoveredRollOffInput extends SeqRowToJSCollection[CalcUncoveredRollOffInput] {
  override def apply(v1: Seq[Row]): Seq[CalcUncoveredRollOffInput] = {
    v1.map { e =>
      CalcUncoveredRollOffInput(
        e.getAs("partition_key"),
        e.getAs("order_key"),
        Option(e.getAs[Double]("Movement_In_Short")),
        Option(e.getAs[Double]("Short_Increase_Uncovered")),
        Option(e.getAs[Double]("Short_Increase_Covered_CS")),
        Option(e.getAs[Double]("Short_Increase_Covered_RR"))
      )
      // This is needed because the bigquery SQL calling this function orders the input set by order_id
    }.sortBy(_.order_key)
  }
}

package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.udf.calcuncoveredrolloff.data.CalcUncoveredRollOffTestData1
import org.scalatest.FlatSpec

class CalcUncoveredRollOffInputTest extends FlatSpec with IntegrationTestSuiteBase {

  behavior of "CalcUncoveredRollOffInputTest"

  import spark.implicits._

  val testCases = Seq(CalcUncoveredRollOffTestData1)

  private def df = Seq(CalcUncoveredRollOffTestData1.input).toDF

  it should "convert a Seq Rows back to a sequence of 'CalcUncoveredRollOffInput'" in {
    val result: Seq[CalcUncoveredRollOffInput] = CalcUncoveredRollOffInput.apply(Seq(df.head))

    assert(result === List(CalcUncoveredRollOffTestData1.input))
  }

}
package hsbc.emf.udf.calcuncoveredrolloff

private[calcuncoveredrolloff] object CalcUncoveredRollOffJavaScript {
 val js: String =
   """
     |
     |function FOTC_UDF_calc_uncovered_roll_off(part) {
     |	//FD takes the movement in the short balances over time and applies it to the uncovered to work out the changes, particularly for reductions
     |	var uncovered_prev = 0.0;
     |	var uncovered_curr = 0.0;
     |	var uncovered_move = 0.0;
     |	var covered_rr_prev = 0.0;
     |	var covered_rr_curr = 0.0;
     |	var covered_rr_move = 0.0;
     |	var covered_cs_prev = 0.0;
     |	var covered_cs_curr = 0.0;
     |	var covered_cs_move = 0.0;
     |	var result = new Array();
     |	var n = part.length;
     |
     |	for (var i = 0; i < n; i++) {
     |		var item = part[i];
     |		uncovered_prev = uncovered_curr;
     |		if (item.Movement_In_Short <= 0) {  //this is a short increases
     |			uncovered_curr = uncovered_prev + item.Short_Increase_Uncovered;
     |		} else { //reduction in short
     |			if (item.Movement_In_Short > uncovered_prev) { //reduction would wipe out the uncovered_prev so it's zero after
     |				uncovered_curr = 0;
     |			} else {
     |				uncovered_curr = uncovered_prev - item.Movement_In_Short;
     |			}
     |		}
     |		uncovered_move = uncovered_curr - uncovered_prev;
     |
     |		//FD 20190123 CACL-4737 added in all the covered sections to the function
     |		covered_rr_prev = covered_rr_curr;
     |		if (item.Movement_In_Short <= 0) {  //this is a short increases
     |			covered_rr_curr = covered_rr_prev + item.Short_Increase_Covered_RR;
     |		} else { //reduction in short is first applied to uncovered so only what is left gets applied to RR
     |			if (item.Movement_In_Short <= uncovered_prev) { //if short less than uncovered then nothing left to apply to RR
     |				covered_rr_curr = covered_rr_prev;
     |			} else if ((item.Movement_In_Short - uncovered_prev) > covered_rr_prev) { //if what is left after applying to uncov is greater than the RR bal then RR will be zero after
     |				covered_rr_curr = 0;
     |			} else {
     |				covered_rr_curr = covered_rr_prev - (item.Movement_In_Short - uncovered_prev);
     |			}
     |		}
     |		covered_rr_move = covered_rr_curr - covered_rr_prev;
     |
     |		covered_cs_prev = covered_cs_curr;
     |		if (item.Movement_In_Short <= 0) {  //this is a short increases
     |			covered_cs_curr = covered_cs_prev + item.Short_Increase_Covered_CS;
     |		} else { //reduction in short. First apply to uncovered, then RR, only left over to CS
     |			if (item.Movement_In_Short <= (covered_rr_prev + uncovered_prev)) { //if short move is less than uncov/rr then nothing left to apply to CS
     |				covered_cs_curr = covered_cs_prev;
     |			} else if ((item.Movement_In_Short - uncovered_prev - covered_rr_prev) > covered_cs_prev) { //if leftover of the short after uncov & rr is greater than the cs bal then the cs must now be zero
     |				covered_cs_curr = 0;
     |			} else {
     |				covered_cs_curr = covered_cs_prev - (item.Movement_In_Short - uncovered_prev - covered_rr_prev);
     |			}
     |		}
     |		covered_cs_move = covered_cs_curr - covered_cs_prev;
     |
     |		result.push({
     |			partition_key: item.partition_key
     |			, order_key: item.order_key
     |			, uncovered_move: uncovered_move
     |			, covered_cs_move: covered_cs_move
     |			, covered_rr_move: covered_rr_move
     |		});
     |	}
     |	return result;
     |}
     |""".stripMargin
}
package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

private[udf] case class CalcUncoveredRollOffOutput(
                                       partition_key: String,
                                       order_key: Int,
                                       uncovered_move: Double,
                                       covered_cs_move: Double,
                                       covered_rr_move: Double
                                     )

private[udf] object CalcUncoveredRollOffOutput extends GraalVmValueConverter[CalcUncoveredRollOffOutput] {
  override def apply(v1: Value): CalcUncoveredRollOffOutput = {
    val helper = (name: String) => v1.getMember(name)

    new CalcUncoveredRollOffOutput(
      helper("partition_key").asString(),
      helper("order_key").asInt(),
      helper("uncovered_move").asDouble(),
      helper("covered_cs_move").asDouble(),
      helper("covered_rr_move").asDouble()
    )
  }
}package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.udf.calcuncoveredrolloff.data.CalcUncoveredRollOffTestData1
import org.graalvm.polyglot.Context
import org.scalatest.FlatSpec

class CalcUncoveredRollOffOutputTest extends FlatSpec {

  val context: Context = Context.newBuilder("js")
    .allowExperimentalOptions(true)
    .allowAllAccess(true)
    .build()

  private val (a, b, c, d, e) = CalcUncoveredRollOffOutput.unapply(
    CalcUncoveredRollOffTestData1.target.head
  ).get

  private val js =
    s"""
       | out =
       |        {  partition_key: "$a",
       |           order_key: $b,
       |           uncovered_move: $c,
       |           covered_cs_move: $d,
       |           covered_rr_move: $e
       |         }
       |
    """.stripMargin.format()

  behavior of "CalcUncoveredRollOffOutput"
  context.eval("js", js)
  it should "convert a javascript object back to case class" in {
    val value = context.getBindings("js").getMember("out")
    assert(CalcUncoveredRollOffOutput.apply(value) == CalcUncoveredRollOffTestData1.target.head)
  }


}
package hsbc.emf.udf.calcuncoveredrolloff

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.utils.TolerantCaseCaseEquality.ProductEquality
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types.{ArrayType, StructType}
import org.apache.spark.sql.{Encoders, Row}
import org.scalatest.FlatSpec


class CalcUncoveredRollOffTest extends FlatSpec with IntegrationTestSuiteBase {

  behavior of "CalcUncoveredRollOffTest"

  implicit val cashFlowsoutputEquality: ProductEquality[CalcUncoveredRollOffOutput] = new ProductEquality[CalcUncoveredRollOffOutput]( 1e-9)

  // Get data from json on disk and format it field names nd types correctly
  private val pathInput = "tests/resources/udf/FOTC_UDF_calc_uncovered_roll_off/INPUT_FOTC_UDF_calc_uncovered_roll_off.json"
  private val c1 = col("Instrument_Partition_Key").as("partition_key")
  private val c2 = col("Order_Number").cast("Int").as("order_key")
  private val c3 = col("Maturing_RR_Covering_Short_Increase").as("Short_Increase_Covered_RR")
  private val c4 = col("Maturing_CS_Covering_Short_Increase").as("Short_Increase_Covered_CS")
  private val c5 = col("Movement_In_Short_Balance_LCY").as("Movement_In_Short")
  private val c6 = col("Short_Increase_Uncovered").cast("Double").as("Short_Increase_Uncovered")

  it should "execute the FOTC_UDF_calc_uncovered_roll_off UDF in spark" in {
    import spark.implicits._
    val df = spark.read.option("multiline", "true").json(pathInput).select(c1, c2, c3, c4, c5, c6).as[CalcUncoveredRollOffInput]

    val rollOff = new CalcUncoveredRollOff()
    spark.udf.register("FOTC_UDF_calc_uncovered_roll_off", rollOff.apply(_: Seq[Row]))
    df.createOrReplaceTempView("uncovered_roll_off")

    val result = spark.sql(
      """select
        |FOTC_UDF_calc_uncovered_roll_off(
        | collect_list(
        |  struct(
        |  partition_key,
        |  order_key,
        |  Movement_In_Short,
        |  Short_Increase_Uncovered,
        |  Short_Increase_Covered_CS,
        |  Short_Increase_Covered_RR
        | )
        |)
        | ) as cf
        |FROM
        |  uncovered_roll_off
        |
     """.stripMargin)

    // targets
    val targetFile = "tests/resources/udf/FOTC_UDF_calc_uncovered_roll_off/OUTPUT_FOTC_UDF_calc_uncovered_roll_off.json"
    val outputSchema = Encoders.product[CalcUncoveredRollOffOutput].schema
    val targetSchema = new StructType().add("result_uncovered_moves", ArrayType(outputSchema))
    val target = spark.read.schema(targetSchema).option("multiline", "true").json(targetFile)
      .select(explode(col("result_uncovered_moves")))
      .select("col.*")


    val explodedTarget = target.as[CalcUncoveredRollOffOutput]
      .sort("partition_key", "order_key")

    val explodedResult = result.select(explode(col("cf"))).select("col.*")
      .as[CalcUncoveredRollOffOutput]
      .sort("partition_key", "order_key")

    val paired = explodedTarget.collect() zip explodedResult.collect()

    paired.foreach { case (target, result) => assert(target === result) }
  }
}
package hsbc.emf.udf.calcuncoveredrolloff.data

import hsbc.emf.udf.calcuncoveredrolloff.{CalcUncoveredRollOffInput, CalcUncoveredRollOffOutput}

object CalcUncoveredRollOffTestData1 extends TestDataSet {

  val input: CalcUncoveredRollOffInput = CalcUncoveredRollOffInput(
    partition_key = "3607|NL0012015705|EUR",
    order_key = 2,
    Movement_In_Short = Some(-29763197.12),
    Short_Increase_Uncovered = None,
    Short_Increase_Covered_CS = Some(29763197.12),
    Short_Increase_Covered_RR = Some(0.0)
  )
  val target: Seq[CalcUncoveredRollOffOutput] = Seq(CalcUncoveredRollOffOutput(
    partition_key = "3607|NL0012015705|EUR",
    order_key = 2,
    uncovered_move = 0,
    covered_cs_move = 29763197.12,
    covered_rr_move = 0))
}
package hsbc.emf.udf.calcuncoveredrolloff.data

import hsbc.emf.udf.calcuncoveredrolloff.{CalcUncoveredRollOffInput, CalcUncoveredRollOffOutput}

object CalcUncoveredRollOffTestData2 extends TestDataSet {

  val input: CalcUncoveredRollOffInput = CalcUncoveredRollOffInput(
    partition_key = "3607|NL0012015705|EUR",
    order_key = 3,
    Movement_In_Short = Some(2015056.4100000001),
    Short_Increase_Uncovered = None,
    Short_Increase_Covered_CS = None,
    Short_Increase_Covered_RR = None
  )
  val target: Seq[CalcUncoveredRollOffOutput] = Seq(CalcUncoveredRollOffOutput(
    partition_key = "3607|NL0012015705|EUR",
    order_key = 3,
    uncovered_move = 0,
    covered_cs_move = 0.0,
    covered_rr_move = -2015056.4100000001))
}
package hsbc.emf.utils

import java.util.Date


object CaseClassHelper {

  import scala.reflect.runtime.universe._

  private def classAccessors[T: TypeTag]: List[String] = typeOf[T].members.sorted.collect {
    case m: MethodSymbol if m.isCaseAccessor => m.name.toString
  }

  // Converts a case class instance to string that is it's instantiation in Scala
  def convertToInstanceDefinition[T <: Product : TypeTag](cc: T): String = {
    def quoted(field: String, value: Any) = s"""$field ="$value""""

    def unquoted(field: String, value: Any) = s"""$field = $value"""

    val className = cc.productPrefix

    val values = (classAccessors[T] zip cc.productIterator.toList).map {
      case (field, value: String) => quoted(field, value)
      case (field, value: Date) => s"""$field = java.sql.Date.valueOf("$value")"""
      case (field, Some(value: Date)) => s"""$field = Some(java.sql.Date.valueOf("$value"))"""
      case (field, Some(value: String)) => s"""$field = Some("$value")"""
      case (field, value) => unquoted(field, value)
    }
    val valueString = values.mkString(",\n")
    s"$className(\n$valueString\n)"
  }

}
package hsbc.emf.udf.cashflows

import hsbc.emf.udf.{CommonJavaScript, SparkUdfRegisterableFunction1, UdfBuilder}
import org.apache.spark.sql.Row

private[udf] class CashFlows() extends SparkUdfRegisterableFunction1[Row, Seq[CashFlowsOutput]] {

  import CashFlows.context

  override val functionName: String = "cashflows"

  override def apply(input: Row): Seq[CashFlowsOutput] = {
    CashFlows.safeExecute {
      context.eval("js", CommonJavaScript.CashFlowsJavaScript.js)
      val cashFlowInput = CashFlowsInput.apply(input)
      context.getBindings("js").putMember("myO", cashFlowInput)
      // note: JavaScript function name differs from UDF name
      val value = context.eval("js", s"RowToCashflows(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => CashFlowsOutput.apply(value.getArrayElement(i)) }
    }
  }

}

private[udf] object CashFlows extends UdfBuilder[CashFlows] {

  override def apply: CashFlows = new CashFlows
}package hsbc.emf.udf.cashflows

import hsbc.emf.udf.RowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject

import org.apache.spark.sql.Row

private[udf] case class CashFlowsInput(
                                        ACCOUNT_DEAL_ID: String
                                        , REPORTING_DATE: java.sql.Date
                                        , SCHEDULE_START_DATE: java.sql.Date
                                        , SCHEDULE_END_DATE: java.sql.Date
                                        , AMORTISATION_TYPE: String
                                        , INS_FREQ_TIME_UNIT: String
                                        , INS_FREQ_NUM_OF_TIME_UNITS: Long
                                        , INT_COMPND_FREQ: String
                                        , CASH_FLOW_DATE_TYPE: String
                                        , CASH_FLOW_DATE_OFFSET: Long
                                        , GROSS_GL_BAL_ACT_CCY: Option[Double]
                                        , INSTALMENT_AMT: Option[Double]
                                        , INSTALMENT_AMT_CCY_CD: String
                                        , INTEREST_TYPE_CD: String
                                        , INTEREST_DAY_COUNT_CONVENTION: String
                                        , INTEREST_RATE: Option[Double]
                                        , ACCRUED_INT: Option[Double]
                                        , ORIGINAL_PRIN_BAL: Option[Double]
                                        , MATURITY_DATE: java.sql.Date
                                        , DEPOSIT_DRAWDOWN_DATE: java.sql.Date
                                        , REP_FREQ_TIME_UNIT: String
                                        , REP_FREQ_NUM_OF_TIME_UNITS: Option[Long]
                                        , COUPON_TYPE: String
                                        , REFERENCE_CURVE: Option[Seq[ReferenceCurve]]
                                        , INTEREST_RATE_SPREAD: Option[Double]
                                        , NEXT_INTEREST_RESET: Option[java.sql.Date]
                                        , LAST_INTEREST_RESET: Option[java.sql.Date]
                                        , NET_LIFE_FLOOR: Option[Double]
                                        , NET_LIFE_CAP: Option[Double]
                                      ) extends ScalaProxyObject {
}

private[udf] object CashFlowsInput extends RowToJSCollection[CashFlowsInput] {
  override def apply(v1: Row): CashFlowsInput = {
    new CashFlowsInput(
      v1.getAs[String]("ACCOUNT_DEAL_ID"),
      v1.getAs[java.sql.Date]("REPORTING_DATE"),
      v1.getAs[java.sql.Date]("SCHEDULE_START_DATE"),
      v1.getAs[java.sql.Date]("SCHEDULE_END_DATE"),
      v1.getAs[String]("AMORTISATION_TYPE"),
      v1.getAs[String]("INS_FREQ_TIME_UNIT"),
      v1.getAs[Long]("INS_FREQ_NUM_OF_TIME_UNITS"),
      v1.getAs[String]("INT_COMPND_FREQ"),
      v1.getAs[String]("CASH_FLOW_DATE_TYPE"),
      v1.getAs[Long]("CASH_FLOW_DATE_OFFSET"),
      Option(v1.getAs[Double]("GROSS_GL_BAL_ACT_CCY")),
      Option(v1.getAs[Double]("INSTALMENT_AMT")),
      v1.getAs[String]("INSTALMENT_AMT_CCY_CD"),
      v1.getAs[String]("INTEREST_TYPE_CD"),
      v1.getAs[String]("INTEREST_DAY_COUNT_CONVENTION"),
      Option(v1.getAs[Double]("INTEREST_RATE")),
      Option(v1.getAs[Double]("ACCRUED_INT")),
      Option(v1.getAs[Double]("ORIGINAL_PRIN_BAL")),
      v1.getAs[java.sql.Date]("MATURITY_DATE"),
      v1.getAs[java.sql.Date]("DEPOSIT_DRAWDOWN_DATE"),
      v1.getAs[String]("REP_FREQ_TIME_UNIT"),
      Option(v1.getAs[Long]("REP_FREQ_NUM_OF_TIME_UNITS")),
      v1.getAs[String]("COUPON_TYPE"),
      Option(v1.getSeq(v1.fieldIndex("REFERENCE_CURVE"))).map{_.toList},
      Option(v1.getAs[Double]("INTEREST_RATE_SPREAD")),
      Option(v1.getAs[java.sql.Date]("NEXT_INTEREST_RESET")),
      Option(v1.getAs[java.sql.Date]("LAST_INTEREST_RESET")),
      Option(v1.getAs[Double]("NET_LIFE_FLOOR")),
      Option(v1.getAs[Double]("NET_LIFE_CAP"))
    )
  }

}package hsbc.emf.udf.cashflows

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.udf.cashflows.data._
import org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema
import org.apache.spark.sql.{Encoders, Row}
import org.scalatest.FlatSpec

class CashFlowsInputTest extends FlatSpec with IntegrationTestSuiteBase {
  behavior of "CashFlowsInputTest"

  import spark.implicits._

  val testCases = Seq(CashFlowTestData1, CashFlowTestData2, CashFlowTestData3, CashFlowTestData4, CashFlowTestData5)
  def results: Array[Row] = testCases.map { cs => cs.input }.toDF.collect()

  // TODO: Make this work

  it should s"convert a row of CashFlowInput back to a case class for CashFlowTestData1}" in {
    println(CashFlowsInput(results(0)) )
    assert(CashFlowsInput(results(0)) == CashFlowTestData1.input)
  }
  it should s"convert a row of CashFlowInput back to a case class for CashFlowTestData2}" in {
    assert(CashFlowsInput(results(1)) == CashFlowTestData2.input)
  }
  it should s"convert a row of CashFlowInput back to a case class for CashFlowTestData3}" in {
    assert(CashFlowsInput(results(2)) == CashFlowTestData3.input)
  }
  it should s"convert a row of CashFlowInput back to a case class for CashFlowTestData4}" in {
    assert(CashFlowsInput(results(3)) == CashFlowTestData4.input)
  }
  it should s"convert a row of CashFlowInput back to a case class for CashFlowTestData5}" in {
    assert(CashFlowsInput(results(4)) == CashFlowTestData5.input)
  }

}package hsbc.emf.udf.cashflows

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

private[udf] case class CashFlowsOutput(
                                         ACCOUNT_DEAL_ID: Option[String],
                                         CASHFLOW_TYPE: Option[String],
                                         FROM_DATE: Option[java.sql.Date],
                                         PAYMENT_DATE: Option[java.sql.Date],
                                         RATE: Option[Double],
                                         STEP: Option[Double],
                                         AMOUNT: Option[Double],
                                         OUTSTANDING: Option[Double],
                                         VARIABLE_AMOUNT: Option[Double],
                                         VARIABLE_RATE: Option[Double],
                                         VARIABLE_OUTSTANDING: Option[Double],
                                         VARIABLE_STEP: Option[Double],
                                         CCY: Option[String]
                                       )

private[udf] object CashFlowsOutput extends GraalVmValueConverter[CashFlowsOutput] {

  override def apply(v1: Value): CashFlowsOutput = {
    val helper = (name: String) => v1.getMember(name)

    new CashFlowsOutput(

      (helper andThen safeConvert[String]) ("ACCOUNT_DEAL_ID"),
      (helper andThen safeConvert[String]) ("CASHFLOW_TYPE"),
      (helper andThen safeConvertToDate) ("FROM_DATE"),
      (helper andThen safeConvertToDate) ("PAYMENT_DATE"),
      (helper andThen safeConvert[Double]) ("RATE"),
      (helper andThen safeConvert[Double]) ("STEP"),
      (helper andThen safeConvert[Double]) ("AMOUNT"),
      (helper andThen safeConvert[Double]) ("OUTSTANDING"),
      (helper andThen safeConvert[Double]) ("VARIABLE_AMOUNT"),
      (helper andThen safeConvert[Double]) ("VARIABLE_RATE"),
      (helper andThen safeConvert[Double]) ("VARIABLE_OUTSTANDING"),
      (helper andThen safeConvert[Double]) ("VARIABLE_STEP"),
      (helper andThen safeConvert[String]) ("CCY")
    )
  }
}
package hsbc.emf.udf.cashflows

import hsbc.emf.udf.cashflows.data.CashFlowTestData1
import org.graalvm.polyglot.Context
import org.scalatest.FlatSpec

class CashFlowsOutputTest extends FlatSpec {
  val context: Context = Context.newBuilder("js").allowExperimentalOptions(true).allowAllAccess(true).build()

  private val (a, b, c, d, e, f, g, h, i, j, k, l, m) = CashFlowsOutput.unapply(CashFlowTestData1.target(0)).get

  private val js =
    s"""
       | out ={
       |                            ACCOUNT_DEAL_ID: "${a.get}",
       |                            CASHFLOW_TYPE: "${b.get}",
       |                            FROM_DATE: new Date("${c.get}"),
       |                            PAYMENT_DATE: new Date("${d.get}"),
       |                            RATE: ${e.get},
       |                            STEP: ${f.get},
       |                            AMOUNT: ${g.get},
       |                            OUTSTANDING: ${h.get},
       |                            VARIABLE_AMOUNT: ${i.orNull},
       |                            VARIABLE_RATE: ${j.orNull},
       |                            VARIABLE_OUTSTANDING: ${k.orNull},
       |                            VARIABLE_STEP: ${l.orNull},
       |                            CCY: "${m.get}"
       |                            }
    """.stripMargin.format()
  behavior of "CashFlowsOutputTest"
  context.eval("js", js)
  it should "convert a javascript object back to case class" in {
    val value = context.getBindings("js").getMember("out")
    assert(CashFlowsOutput.apply(value) == CashFlowTestData1.target(0))
  }

}
package hsbc.emf.udf.cashflows

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.udf.cashflows.data._
import hsbc.emf.utils.TolerantCaseCaseEquality._
import org.apache.spark.sql.{Encoders, Row}
import org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema
import org.scalatest.FlatSpec

class CashFlowsTest extends FlatSpec with IntegrationTestSuiteBase {

  val testCases = Seq(CashFlowTestData1, CashFlowTestData2, CashFlowTestData3, CashFlowTestData4, CashFlowTestData5)
  behavior of "CashFlowsTest"
  implicit val cashFlowsoutputEquality: SeqEquality[CashFlowsOutput] = new SeqEquality[CashFlowsOutput](0.0001)

  behavior of "CashFlowsTest in Spark"

  it should "execute the UDF in spark" in {
    val cashFlow = new CashFlows()
    import spark.implicits._
    val input = testCases.map {
      _.input
    }.toDS
    spark.udf.register("CASHFLOWS", cashFlow.apply(_: Row))
    input.createOrReplaceTempView("CashFlowsTest")

    val result = spark.sql(
      """select
        |CASHFLOWS(
        | struct(
        |  ACCOUNT_DEAL_ID,
        |  REPORTING_DATE,
        |  SCHEDULE_START_DATE,
        |  SCHEDULE_END_DATE,
        |  AMORTISATION_TYPE,
        |  INS_FREQ_TIME_UNIT,
        |  INS_FREQ_NUM_OF_TIME_UNITS,
        |  INT_COMPND_FREQ,
        |  CASH_FLOW_DATE_TYPE,
        |  CASH_FLOW_DATE_OFFSET,
        |  GROSS_GL_BAL_ACT_CCY,
        |  INSTALMENT_AMT,
        |  INSTALMENT_AMT_CCY_CD,
        |  INTEREST_TYPE_CD,
        |  INTEREST_DAY_COUNT_CONVENTION,
        |  INTEREST_RATE,
        |  ACCRUED_INT,
        |  ORIGINAL_PRIN_BAL,
        |  MATURITY_DATE,
        |  DEPOSIT_DRAWDOWN_DATE,
        |  REP_FREQ_TIME_UNIT,
        |  REP_FREQ_NUM_OF_TIME_UNITS,
        |  COUPON_TYPE,
        |  REFERENCE_CURVE,
        |  INTEREST_RATE_SPREAD,
        |  NEXT_INTEREST_RESET,
        |  LAST_INTEREST_RESET,
        |  NET_LIFE_FLOOR,
        |  NET_LIFE_CAP
        | )
        |) as cf
        |FROM
        |  CashFlowsTest
        |
     """.stripMargin).as[Seq[CashFlowsOutput]]

    val targets: List[Seq[CashFlowsOutput]] = testCases.map {
      _.target
    }.toList
    val resultsUDF = result.collect.toList

    assert(resultsUDF(0) === CashFlowTestData1.target)

    assert(resultsUDF(1) === CashFlowTestData2.target)

    assert(resultsUDF(2) === CashFlowTestData3.target)

    assert(resultsUDF(3) === CashFlowTestData4.target)

    assert(resultsUDF(4) === CashFlowTestData5.target)

  }


}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

object CashFlowTestData1 extends TestDataSet {

  val input: CashFlowsInput = CashFlowsInput(
    ACCOUNT_DEAL_ID = "5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W0VaG+jT3Ukh+bwjidtEFQ'",
    REPORTING_DATE = java.sql.Date.valueOf("2020-12-31"),
    SCHEDULE_START_DATE = java.sql.Date.valueOf("2020-03-02"),
    SCHEDULE_END_DATE = java.sql.Date.valueOf("2021-03-02"),
    AMORTISATION_TYPE = "BULLET",
    INS_FREQ_TIME_UNIT = "Y",
    INS_FREQ_NUM_OF_TIME_UNITS = 1,
    INT_COMPND_FREQ = "M",
    CASH_FLOW_DATE_TYPE = "A",
    CASH_FLOW_DATE_OFFSET = 0,
    GROSS_GL_BAL_ACT_CCY = Some(5798009.84),
    INSTALMENT_AMT = Some(0.0),
    INSTALMENT_AMT_CCY_CD = "AED",
    INTEREST_TYPE_CD = "S",
    INTEREST_DAY_COUNT_CONVENTION = "ACT/360",
    INTEREST_RATE = Some(0.01206916),
    ACCRUED_INT = Some(0.0),
    ORIGINAL_PRIN_BAL = Some(0.0),
    MATURITY_DATE = java.sql.Date.valueOf("2021-03-02"),
    DEPOSIT_DRAWDOWN_DATE = java.sql.Date.valueOf("2020-03-02"),
    REP_FREQ_TIME_UNIT = null,
    REP_FREQ_NUM_OF_TIME_UNITS = None,
    COUPON_TYPE = "FIXED",
    REFERENCE_CURVE = Some(Seq()),
    INTEREST_RATE_SPREAD = Some(0.0),
    NEXT_INTEREST_RESET = None,
    LAST_INTEREST_RESET = None,
    NET_LIFE_FLOOR = None,
    NET_LIFE_CAP = None
  )

  val target = List(CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W0VaG+jT3Ukh+bwjidtEFQ'"),
    CASHFLOW_TYPE = Some("Interest"),
    Some(java.sql.Date.valueOf("2020-12-31")),
    Some(java.sql.Date.valueOf("2021-03-02")),
    RATE = Some(0.0020450521111111115),
    STEP = Some(0.16944444444444445),
    AMOUNT = Some(11857.232263534997),
    OUTSTANDING = Some(5798009.84),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ), CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W0VaG+jT3Ukh+bwjidtEFQ'"),
    CASHFLOW_TYPE = Some("Principal"),
    FROM_DATE = None,
    Some(java.sql.Date.valueOf("2021-03-02")),
    RATE = Some(0.0020450521111111115),
    STEP = None,
    AMOUNT = Some(5798009.84),
    OUTSTANDING = Some(0.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ))
}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

object CashFlowTestData2 extends TestDataSet {

  val input = CashFlowsInput(
    ACCOUNT_DEAL_ID = "5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WG/pkpooZ1g8mnl8y0Kt8S'",
    REPORTING_DATE = java.sql.Date.valueOf("2020-12-31"),
    SCHEDULE_START_DATE = java.sql.Date.valueOf("2019-12-15"),
    SCHEDULE_END_DATE = java.sql.Date.valueOf("2022-07-27"),
    AMORTISATION_TYPE = "BULLET",
    INS_FREQ_TIME_UNIT = "AM",
    INS_FREQ_NUM_OF_TIME_UNITS = 1,
    INT_COMPND_FREQ = "M",
    CASH_FLOW_DATE_TYPE = "A",
    CASH_FLOW_DATE_OFFSET = 0,
    GROSS_GL_BAL_ACT_CCY = Some(18000.0),
    INSTALMENT_AMT = Some(0.0),
    INSTALMENT_AMT_CCY_CD = "AED",
    INTEREST_TYPE_CD = "S",
    INTEREST_DAY_COUNT_CONVENTION = "ACT/360",
    INTEREST_RATE = Some(0.01930357),
    ACCRUED_INT = Some(0.0),
    ORIGINAL_PRIN_BAL = Some(0.0),
    MATURITY_DATE = java.sql.Date.valueOf("2022-07-27"),
    DEPOSIT_DRAWDOWN_DATE = java.sql.Date.valueOf("2019-12-15"),
    REP_FREQ_TIME_UNIT = null,
    REP_FREQ_NUM_OF_TIME_UNITS = None,
    COUPON_TYPE = "FIXED",
    REFERENCE_CURVE = None,
    INTEREST_RATE_SPREAD = Some(0.0),
    NEXT_INTEREST_RESET = None,
    LAST_INTEREST_RESET = None,
    NET_LIFE_FLOOR = None,
    NET_LIFE_CAP = None
  )

  val target = List(CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WG/pkpooZ1g8mnl8y0Kt8S'"),
    CASHFLOW_TYPE = Some("Interest"),
    Some(java.sql.Date.valueOf("2020-12-31")),
    Some(java.sql.Date.valueOf("2022-07-27")),
    RATE = Some(0.030724848916666662),
    STEP = Some(1.5916666666666666),
    AMOUNT = Some(553.0472804999999),
    OUTSTANDING = Some(18000.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ), CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WG/pkpooZ1g8mnl8y0Kt8S'"),
    CASHFLOW_TYPE = Some("Principal"),
    FROM_DATE = None,
    Some(java.sql.Date.valueOf("2022-07-27")),
    RATE = Some(0.030724848916666662),
    STEP = None,
    AMOUNT = Some(18000.0),
    OUTSTANDING = Some(0.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ))

  /* USEFUL SNIPPET
  import scala.io.Source

val fileContents = Source.fromFile("C:\\Users\\44053894\\Desktop\\projects\\emf-spark\\application\\tests\\resources\\casgFlowTestOutputs.json").getLines.mkString
  import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.udf.cashflows.CashFlowsOutput

val g  = JsonReader.deserialize[List[Map[String, List[CashFlowsOutput]]]](fileContents)
  import hsbc.emf.utils.CaseClassHelper

println (g.right.get.take(2).map{ a=> a.getOrElse("cf",Seq()).map{CaseClassHelper.convertToInstanceDefinition(_)}}.last)
   */


  /*
  Another

import hsbc.emf.udf.cashflows.CashFlowsInput
import org.apache.spark.sql.SparkSession
import org.graalvm.polyglot.Context
val spark = {SparkSession.builder().config("spark.testing.memory", "2147480000")
  .appName("Spark SQL basic example").master("local")
  .config("spark.some.config.option", "some-value")
  .getOrCreate()}

spark.sparkContext.setLogLevel("warn")

import hsbc.emf.udf.cashflows.CashFlowsOutput
import org.apache.spark.sql.Encoders
import org.apache.spark.sql.types.{StructField, StructType}
val schema = Encoders.product[CashFlowsInput].schema
val newSchema  =   StructType(Seq(StructField("cf",schema)))
val df  = spark.read.option("multiline","true").option("inferSchema", true).schema(newSchema).
  json("C:\\Users\\44053894\\Desktop\\projects\\emf-spark\\application\\tests\\resources\\cashFlowTestInputs.json")
   */
}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

object CashFlowTestData3 extends TestDataSet {

  val input = CashFlowsInput(
    ACCOUNT_DEAL_ID = "5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WA3oH5ihqSXu2I7UHm2dhN'",
    REPORTING_DATE = java.sql.Date.valueOf("2020-12-31"),
    SCHEDULE_START_DATE = java.sql.Date.valueOf("2020-03-03"),
    SCHEDULE_END_DATE = java.sql.Date.valueOf("2021-03-03"),
    AMORTISATION_TYPE = "BULLET",
    INS_FREQ_TIME_UNIT = "Y",
    INS_FREQ_NUM_OF_TIME_UNITS = 1,
    INT_COMPND_FREQ = "M",
    CASH_FLOW_DATE_TYPE = "A",
    CASH_FLOW_DATE_OFFSET = 0,
    GROSS_GL_BAL_ACT_CCY = Some(3862393.08),
    INSTALMENT_AMT = Some(0.0),
    INSTALMENT_AMT_CCY_CD = "AED",
    INTEREST_TYPE_CD = "S",
    INTEREST_DAY_COUNT_CONVENTION = "ACT/360",
    INTEREST_RATE = Some(0.01258745),
    ACCRUED_INT = Some(0.0),
    ORIGINAL_PRIN_BAL = Some(0.0),
    MATURITY_DATE = java.sql.Date.valueOf("2021-03-03"),
    DEPOSIT_DRAWDOWN_DATE = java.sql.Date.valueOf("2020-03-03"),
    REP_FREQ_TIME_UNIT = null,
    REP_FREQ_NUM_OF_TIME_UNITS = None,
    COUPON_TYPE = "FIXED",
    REFERENCE_CURVE = Some(Seq()),
    INTEREST_RATE_SPREAD = Some(0.0),
    NEXT_INTEREST_RESET = None,
    LAST_INTEREST_RESET = None,
    NET_LIFE_FLOOR = None,
    NET_LIFE_CAP = None
  )
  override val target: Seq[CashFlowsOutput] = List(CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WA3oH5ihqSXu2I7UHm2dhN'"),
    CASHFLOW_TYPE = Some("Interest"),
    FROM_DATE = Some(java.sql.Date.valueOf("2020-12-31")),
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-03-03")),
    RATE = Some(0.002167838611111111),
    STEP = Some(0.17222222222222222),
    AMOUNT = Some(8373.044850112366),
    OUTSTANDING = Some(3862393.08),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ), CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+WA3oH5ihqSXu2I7UHm2dhN'"),
    CASHFLOW_TYPE = Some("Principal"),
    FROM_DATE = None,
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-03-03")),
    RATE = Some(0.002167838611111111),
    STEP = None,
    AMOUNT = Some(3862393.08),
    OUTSTANDING = Some(0.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ))
}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

object CashFlowTestData4 extends TestDataSet {

  val input = CashFlowsInput(
    ACCOUNT_DEAL_ID = "5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W1d8S87+k6JsNwzWv9QXK9'",
    REPORTING_DATE = java.sql.Date.valueOf("2020-12-31"),
    SCHEDULE_START_DATE = java.sql.Date.valueOf("2020-02-17"),
    SCHEDULE_END_DATE = java.sql.Date.valueOf("2021-11-15"),
    AMORTISATION_TYPE = "BULLET",
    INS_FREQ_TIME_UNIT = "AM",
    INS_FREQ_NUM_OF_TIME_UNITS = 1,
    INT_COMPND_FREQ = "M",
    CASH_FLOW_DATE_TYPE = "A",
    CASH_FLOW_DATE_OFFSET = 0,
    GROSS_GL_BAL_ACT_CCY = Some(279000.0),
    INSTALMENT_AMT = Some(0.0),
    INSTALMENT_AMT_CCY_CD = "USD",
    INTEREST_TYPE_CD = "S",
    INTEREST_DAY_COUNT_CONVENTION = "ACT/360",
    INTEREST_RATE = Some(0.01493958),
    ACCRUED_INT = Some(0.0),
    ORIGINAL_PRIN_BAL = Some(0.0),
    MATURITY_DATE = java.sql.Date.valueOf("2021-11-15"),
    DEPOSIT_DRAWDOWN_DATE = java.sql.Date.valueOf("2020-02-17"),
    REP_FREQ_TIME_UNIT = null,
    REP_FREQ_NUM_OF_TIME_UNITS = None,
    COUPON_TYPE = "FIXED",
    REFERENCE_CURVE = None,
    INTEREST_RATE_SPREAD = Some(0.0),
    NEXT_INTEREST_RESET = None,
    LAST_INTEREST_RESET = None,
    NET_LIFE_FLOOR = None,
    NET_LIFE_CAP = None
  )
  override val target: Seq[CashFlowsOutput] = List(CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W1d8S87+k6JsNwzWv9QXK9'"),
    CASHFLOW_TYPE = Some("Interest"),
    FROM_DATE = Some(java.sql.Date.valueOf("2020-12-31")),
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-11-15")),
    RATE = Some(0.013238127833333332),
    STEP = Some(0.8861111111111111),
    AMOUNT = Some(3693.4376654999996),
    OUTSTANDING = Some(279000.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("USD")
  ), CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+W1d8S87+k6JsNwzWv9QXK9'"),
    CASHFLOW_TYPE = Some("Principal"),
    FROM_DATE = None,
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-11-15")),
    RATE = Some(0.013238127833333332),
    STEP = None,
    AMOUNT = Some(279000.0),
    OUTSTANDING = Some(0.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("USD")
  ))

}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

object CashFlowTestData5 extends TestDataSet {

  val input = CashFlowsInput(
    ACCOUNT_DEAL_ID = "5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+VapBNOgJjMpDsHHhyooNfs'",
    REPORTING_DATE = java.sql.Date.valueOf("2020-12-31"),
    SCHEDULE_START_DATE = java.sql.Date.valueOf("2020-07-21"),
    SCHEDULE_END_DATE = java.sql.Date.valueOf("2021-03-06"),
    AMORTISATION_TYPE = "BULLET",
    INS_FREQ_TIME_UNIT = "AM",
    INS_FREQ_NUM_OF_TIME_UNITS = 1,
    INT_COMPND_FREQ = "M",
    CASH_FLOW_DATE_TYPE = "A",
    CASH_FLOW_DATE_OFFSET = 0,
    GROSS_GL_BAL_ACT_CCY = Some(73631.25),
    INSTALMENT_AMT = Some(0.0),
    INSTALMENT_AMT_CCY_CD = "AED",
    INTEREST_TYPE_CD = "S",
    INTEREST_DAY_COUNT_CONVENTION = "ACT/360",
    INTEREST_RATE = Some(0.00704115),
    ACCRUED_INT = Some(0.0),
    ORIGINAL_PRIN_BAL = Some(0.0),
    MATURITY_DATE = java.sql.Date.valueOf("2021-03-06"),
    DEPOSIT_DRAWDOWN_DATE = java.sql.Date.valueOf("2020-07-21"),
    REP_FREQ_TIME_UNIT = null,
    REP_FREQ_NUM_OF_TIME_UNITS = Some(0),
    COUPON_TYPE = "FIXED",
    REFERENCE_CURVE = Some(Seq()),
    INTEREST_RATE_SPREAD = Some(0.0),
    NEXT_INTEREST_RESET = None,
    LAST_INTEREST_RESET = None,
    NET_LIFE_FLOOR = None,
    NET_LIFE_CAP = None
  )
  override val target: Seq[CashFlowsOutput] = List(CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+VapBNOgJjMpDsHHhyooNfs'"),
    CASHFLOW_TYPE = Some("Interest"),
    FROM_DATE = Some(java.sql.Date.valueOf("2020-12-31")),
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-03-08")),
    RATE = Some(0.0013104362500000002),
    STEP = Some(0.18611111111111112),
    AMOUNT = Some(96.48905913281251),
    OUTSTANDING = Some(73631.25),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ), CashFlowsOutput(
    ACCOUNT_DEAL_ID = Some("5626|TTSAE_LOA_ZC|b'MTIzNDU2Nzg5MDEyMzQ1NlRZoIpRUxLkUVWImxGcJ+VapBNOgJjMpDsHHhyooNfs'"),
    CASHFLOW_TYPE = Some("Principal"),
    FROM_DATE = None,
    PAYMENT_DATE = Some(java.sql.Date.valueOf("2021-03-08")),
    RATE = Some(0.0013104362500000002),
    STEP = None,
    AMOUNT = Some(73631.25),
    OUTSTANDING = Some(0.0),
    VARIABLE_AMOUNT = None,
    VARIABLE_RATE = None,
    VARIABLE_OUTSTANDING = None,
    VARIABLE_STEP = None,
    CCY = Some("AED")
  ))
}
package hsbc.emf.dao.ingestion

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry, MetadataRaw}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfIoException, MissingLoadInfo}
import hsbc.emf.infrastructure.helper.{FileUtility, HiveUtils}
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import hsbc.emf.infrastructure.sql.{ISqlExecutor, SqlExecutor}
import org.apache.spark.sql.{SaveMode, SparkSession}


class CatalogueDAO(sqlExecutor: ISqlExecutor)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ICatalogueDAO with MessageContext
  with SparkSessionWrapper {



  def readById(entityUuid: String): List[CatalogueEntity] = {
    if (entityUuid == null || entityUuid.trim.isEmpty) List.empty
    else {
      import spark.implicits._
      spark.catalog.refreshTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
      val catalogueEntity = spark.sql(s"SELECT entity_uuid, file_type, created, metadata" +
        s" FROM ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView} where entity_uuid = '$entityUuid'").as[CatalogueEntity]

      catalogueEntity.collect().toList
    }

  }

  def readByFileType(fileType: String): List[CatalogueEntity] = {

    if (fileType == null || fileType.trim.isEmpty) List.empty[CatalogueEntity]
    else {
      import spark.implicits._

      spark.catalog.refreshTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

      //      val catalogueDS = spark.sql(s"SELECT  entity_uuid , MAX(file_type) AS file_type," +
      //        s"MIN(created) AS created, collect_list(STRUCT(attribute, value, data_type,domain)) AS metadata" +
      //        s" FROM ${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName} where file_type = '$fileType'" +
      //        s" GROUP BY entity_uuid").as[CatalogueEntity]
      // fccc-11256, read catalogue from {file_type}.catalogue instead of catalogue.access_view for improve the performance
      if (fileType.equalsIgnoreCase(EmfConfig.process_tasks)) {
        if (!HiveUtils.checkTableInCatalogue(EmfConfig.processTaskCacheView)) {
          spark.sql(s"SELECT entity_uuid, file_type, created, metadata" +
            s" FROM $fileType.${EmfConfig.catalogueDatabaseName} where UPPER(file_type) = UPPER('$fileType')").createOrReplaceTempView(EmfConfig.processTaskCacheView)
          spark.catalog.cacheTable(EmfConfig.processTaskCacheView)
        }
        val catalogueDS = spark.sql(s"SELECT entity_uuid, file_type, created, metadata FROM ${EmfConfig.processTaskCacheView}").as[CatalogueEntity]
        catalogueDS.collect().toList
      } else {
        val catalogueDS = spark.sql(s"SELECT entity_uuid, file_type, created, metadata" +
          s" FROM $fileType.${EmfConfig.catalogueDatabaseName} where UPPER(file_type) = UPPER('$fileType')").as[CatalogueEntity]
        catalogueDS.collect().toList
      }
    }
  }

  def write(metadataRawList: List[MetadataRaw]): Unit = {

    try {
      import spark.implicits._
      // FCCC-11550, change metadata update from saveAsTable into insertInto
      val catalogueLoadInfoEntry = new LoadInfoDAO(sqlExecutor).readByType(EmfConfig.catalogueDatabaseName)
      val catalogueLoadInfo = catalogueLoadInfoEntry match {
        case Some(_) => catalogueLoadInfoEntry.get
        case None => throw new MissingLoadInfo(s" catalgoue file type '${EmfConfig.catalogueDatabaseName}' does not exists!!! ")
      }
      val writerService = new DataFrameWriterService(catalogueLoadInfo.curateFormatConfig)
      writerService.saveDFIntoTable(metadataRawList.toDF(), EmfConfig.defaultTableName, catalogueLoadInfo.fileType, SaveMode.Append, catalogueLoadInfo.ingestHierarchy.hierarchy)
    }
    catch {
      case e: Exception =>
        EmfLogger.error(s"CatalogueDAO.write Exception occured during saving catalogue entities data " +
          s"into table ${EmfConfig.catalogueTableName}: $e")
        throw EmfIoException(s"Exception occured during saving catalogue entities data " +
          s"into table ${EmfConfig.catalogueTableName}", e.getCause)
    }
  }

  override def writeMetadataFile(metadataEntryList: List[MetadataEntry], fileLoc: String, tokenFileName: Option[String]): Unit = {
    try {
      // check file type
      // scalastyle:off caselocale
      if (metadataEntryList != null && metadataEntryList.nonEmpty && fileLoc != null && fileLoc.nonEmpty) {
        if (metadataEntryList.filter(entry => entry.attribute.toLowerCase == "file_type").nonEmpty) {
          import spark.implicits._
          metadataEntryList.toDS().coalesce(1).write.mode(SaveMode.Append).format("json")
            .save(fileLoc)
          val metadataFileName = tokenFileName match {
            case Some(fileName) => fileName
            case _ => EmfConfig.real_meta_chunk_token
          }
          FileUtility.renameFiles(fileLoc, "json", metadataFileName,
            isMetadataFile = true)
          EmfLogger.debug(s"${metadataFileName} written successfully to $fileLoc")
        }
        else {
          EmfLogger.error(s"CatalogueDAO.writeMetadataFile there is no file_type attribute found in  " +
            s"$metadataEntryList")
          throw EmfIoException(s"CatalogueDAO.writeMetadataFile there is no file_type attribute found in  " +
            s"$metadataEntryList", None.orNull)
        }
      }
      else {
        EmfLogger.error(s"CatalogueDAO.writeMetadataFile metadataEntryList: ${metadataEntryList} " +
          s"or fileloc: ${fileLoc} cannot be null or empty")
        throw EmfIoException(s"CatalogueDAO.writeMetadataFile metadataEntryList: ${metadataEntryList} " +
          s"or fileloc: ${fileLoc} cannot be null or empty", None.orNull)
      }

    }
    catch {
      case e: Exception =>
        EmfLogger.error(s"CatalogueDAO.writeMetadataFile error while writing metadata file with entries:" +
          s"${metadataEntryList} into file location: ${fileLoc}")
        throw EmfIoException(s"CatalogueDAO.writeMetadataFile error while writing metadata file with entries:" +
          s"${metadataEntryList} into file location: ${fileLoc}", e.getCause)
    }
  }

}
package hsbc.emf.dao.ingestion

import java.io.File
import java.sql.Timestamp

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry, MetadataRaw}
import hsbc.emf.infrastructure.config.{EmfConfig, MetaDataTextFileFormatConfig}
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.infrastructure.io.readers.MetaDataTextFileReaderToDF
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.commons.io.FileUtils
import org.apache.spark.sql.SaveMode


class CatalogueDAOTest extends IntegrationTestSuiteBase {

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists ${EmfConfig.catalogueDatabaseName}")
    spark.sql(s"create database if not exists person")
    spark.sql(
      s"""create table if not exists ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}
         | (reporting_date timestamp,
         | domain string,
         | attribute string,
         | value string,
         | data_type string)
         | partitioned by
         | (file_type string,
         | created timestamp,
         | entity_uuid string)
       """.stripMargin)
    spark.sql(
      s"""create view if not exists ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView} as select m.entity_uuid as table_uuid,
         |max(m.file_type) as file_type, max(m.reporting_date) as reporting_date,
         |min(m.created) as created, m.entity_uuid as entity_uuid,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata
         |from catalogue.data m group by m.entity_uuid
      """.stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}")
    spark.sql(s"DROP VIEW IF EXISTS person.${EmfConfig.catalogueDatabaseName}")
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS person CASCADE")
    super.afterAll()
  }

  "given a null MetadataRawList" should "throw EmfIoException" in {

    val caught = intercept[EmfIoException] {
      val metadataRawList = null
      new CatalogueDAO(new SqlExecutor()).write(metadataRawList)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a non-null MetadataRawList" should "not throw Exception" in {
    try {
      import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID


      val uuid: String = generateEntityUUID()
      val testFileType = "CatalogueDAOTest_dummy_type"
      val metadataRaw = MetadataRaw(uuid, testFileType, new java.sql.Timestamp(System.currentTimeMillis()), "file_type", "dummy2", "dummy3", "dummy4", None)
      val metadataRawList = List(metadataRaw)
      new CatalogueDAO(new SqlExecutor()).write(metadataRawList)
      import spark.implicits._
      val metadataRawFromTable = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName} where file_type='${testFileType}'").as[MetadataRaw].collect().toList

      // assert table data
      assert(metadataRawFromTable.size == 1 && metadataRaw == metadataRawFromTable(0))

      val catalogueTablePartitionsFromTable = spark.catalog.listColumns(EmfConfig.catalogueDatabaseName, EmfConfig.catalogueTableName)
        .filter($"isPartition" === true)
        .select($"name")
        .as[String]
        .collect
        .toList

      // assert table partition name
      assert(List("file_type", "created", "entity_uuid").equals(catalogueTablePartitionsFromTable))
    }
    catch {
      case e: Exception => fail(s"CatalogueEntity failed with exception ${e.getMessage}")
    }
  }

  "given a file_type to readByFileType method" should "return List[CatalogueEntity]" in {

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    val catalogueEntityList = new CatalogueDAO(new SqlExecutor())
      .readByFileType("person")

    assert(catalogueEntityList(0) == CatalogueEntity("T1", "person",
      Timestamp.valueOf("2021-01-01 00:00:00"),
      List(MetadataEntry("location", "UK", "string", null))))
  }
  "given a null file_type to readByFileType method" should "return emppty List[CatalogueEntity]" in {

    val catalogueEntityList = new CatalogueDAO(new SqlExecutor())
      .readByFileType(null)
    assert(catalogueEntityList.isEmpty)

  }

  "CatalogueDAOTest: Case null readById" should "return None" in {
    val catalogueEntity = new CatalogueDAO(new SqlExecutor())
      .readById(null)
    assert(catalogueEntity.size == 0)
  }

  "CatalogueDAOTest: Case validId readById" should "return CatalogueEntity" in {

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue4.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    val catalogueEntity = new CatalogueDAO(new SqlExecutor())
      .readById("T12")

    assert(catalogueEntity(0) == CatalogueEntity("T12", "test1",
      Timestamp.valueOf("2021-01-01 00:00:00"),
      List(MetadataEntry("location", "UK", "string", null))))

    val catalogueEntityEmpty = new CatalogueDAO(new SqlExecutor())
      .readById("T1222")
    assert(catalogueEntityEmpty.size == 0)
  }
  "given a list of MetatdatEntry and file location to writeMetadataFile method" should "write metadata token file" in {

    val metadata = MetadataEntry("file_type", "fotc_carm_f_fac_snapshot_v08_00", "STRING", "")
    val filLocation = "CatalogueDAO/writeMetadataFile/json"
    new CatalogueDAO(new SqlExecutor()).writeMetadataFile(List(metadata), filLocation, tokenFileName = None)
    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
    //assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), filLocation, None).count() == List(metadata).length)
    FileUtils.deleteDirectory(new File(filLocation.split("/")(0)))
  }

  "given a list of MetatdatEntry without file_type and file location to writeMetadataFile method" should "throw EmfIoException" in {

    val metadata = MetadataEntry("location", "UK", "STRING", "")
    val filLocation = "CatalogueDAO/writeMetadataFile/json"
    val caught = intercept[EmfIoException] {
      new CatalogueDAO(new SqlExecutor()).writeMetadataFile(List(metadata), filLocation, None)
    }
    assert(caught.getMessage.contains(s"CatalogueDAO.writeMetadataFile error while writing metadata file"))
    FileUtils.deleteDirectory(new File(filLocation.split("/")(0)))
  }

  "given a empty MetadatEntry to writeMetadataFile method" should "throw EmfIoException" in {

    val filLocation = "CatalogueDAO/writeMetadataFile/json"
    val caught = intercept[EmfIoException] {
      new CatalogueDAO(new SqlExecutor()).writeMetadataFile(List.empty[MetadataEntry], filLocation, None)
    }
    assert(caught.getMessage.contains(s"CatalogueDAO.writeMetadataFile error while writing metadata file"))
    FileUtils.deleteDirectory(new File(filLocation.split("/")(0)))
  }

  "given a empty fileLocation to writeMetadataFile method" should "throw EmfIoException" in {

    val metadata = MetadataEntry("file_type", "fotc_carm_f_fac_snapshot_v08_00", "STRING", "")
    val filLocation = "CatalogueDAO/writeMetadataFile/json"
    val caught = intercept[EmfIoException] {
      new CatalogueDAO(new SqlExecutor()).writeMetadataFile(List(metadata), "", None)
    }
    assert(caught.getMessage.contains(s"CatalogueDAO.writeMetadataFile error while writing metadata file"))
    FileUtils.deleteDirectory(new File(filLocation.split("/")(0)))
  }
}
package hsbc.emf.data.ingestion

import org.apache.spark.sql.{DataFrame, Dataset}

import java.sql.Timestamp

final case class CatalogueEntity(
                                  entity_uuid: String,
                                  file_type: String,
                                  created: Timestamp,
                                  metadata: List[MetadataEntry]
                                )package hsbc.emf.constants

import java.util.Locale

sealed trait CloudType {
  def toString: String
  def protocolPrefix: String
}

case object GCP extends CloudType {
  override def toString: String = "GCP"
  val protocolPrefix: String = "gs://"
}

case object Azure extends CloudType {
  override def toString: String = "Azure"
  val protocolPrefix: String = "abfs://"
}

case object OnPrem extends CloudType {
  override def toString: String = "OnPrem"
  val protocolPrefix: String = "hdfs://"
}

case object Local extends CloudType {
  override def toString: String = "Local"
  val protocolPrefix: String = ""
}

object CloudType {
  def apply(cloudTypeString: String): CloudType = {
    cloudTypeString.toLowerCase(Locale.ROOT) match {
      case "gcp" => GCP
      case "azure" => Azure
      case "onprem" => OnPrem
      case "local" => Local
      case _ => throw new IllegalArgumentException(s"Invalid CloudType: $cloudTypeString")
    }
  }
}package hsbc.emf.infrastructure.helper

import hsbc.emf.constants.CloudType

object CloudTypeUtils {
  def prependFsProtocol(bucket: String, cloudType: CloudType): String = {
    if (bucket.startsWith(cloudType.protocolPrefix))
      bucket
    else
      cloudType.protocolPrefix + bucket
  }
}package hsbc.emf.infrastructure.helper

import hsbc.emf.constants.{Azure, GCP, Local, OnPrem}
import org.scalatest.FlatSpec

class CloudTypeUtilsTest extends FlatSpec {
  behavior of "CloudTypeUtils.prependFsProtocol"

  it should s"return a bucket string with cloud type specific protocol prepended if the input bucket have no such prefix" in {
    val inputBucket = "testing_bucket"
    assert(CloudTypeUtils.prependFsProtocol(inputBucket, GCP) == GCP.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(inputBucket, Azure) == Azure.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(inputBucket, OnPrem) == OnPrem.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(inputBucket, Local) == Local.protocolPrefix + inputBucket)
  }

  it should s"return the original bucket string if the bucket have cloud type specific prefix already" in {
    val inputBucket = "testing"
    assert(CloudTypeUtils.prependFsProtocol(GCP.protocolPrefix + inputBucket, GCP) == GCP.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(Azure.protocolPrefix + inputBucket, Azure) == Azure.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(OnPrem.protocolPrefix + inputBucket, OnPrem) == OnPrem.protocolPrefix + inputBucket)
    assert(CloudTypeUtils.prependFsProtocol(Local.protocolPrefix + inputBucket, Local) == Local.protocolPrefix + inputBucket)
  }
}package hsbc.emf.udf

private[udf] object CommonJavaScript {


  object CashFlowsJavaScript {
    val js: String =
      """
        |// @flow strict
        |
        |/*::
        |type CashFlowDateType = "L" | "F" |"A";
        |type AmortisationType = "MODIFIED RULE OF 78"| "ACCRUAL" | "BULLET" | "STRAIGHT LINE" | "LEVEL PAY";
        |type InsFreqTimeUnit = "D" | "W" | "M" | "Q" | "Y" | "AM" | "" | "H";
        |type RepFreqTimeUnit = "D" | "W" | "M" | "Q" | "Y";
        |type IntrestTypeCD = "C" | "S";
        |type CouponType = "FIXED" | "VARIABLE" | "FLOATING" | "MANAGED" | "ADMINISTERED";
        |type CashflowType = "Accrued" | "Principal" | "Interest" | "Residual" | "Settlement";
        |type DayCount = "30E/360" | "30E/365" | "30E/360.ISDA" | "30E+/360" | "30E/360.ITL" | "30U/360" | "ACT/365" | "ACT/360" | "ACT/ACT" | "ACT+1/365" | "ACT+1/360" | "ACT/365.25" | "ACT/365(366)";
        |type IntCompndFreq = "C" | "D" | "W" | "F" | "M" | "Q" | "H" | "Y";
        |type ReferenceCurve = {date: Date, rate: number | null}[];
        |
        |type Row = {
        |	ACCOUNT_DEAL_ID: string,
        |	REPORTING_DATE: Date,
        |	SCHEDULE_START_DATE: Date,
        |	SCHEDULE_END_DATE: Date,
        |	AMORTISATION_TYPE: AmortisationType,
        |	INS_FREQ_TIME_UNIT: InsFreqTimeUnit,
        |	INS_FREQ_NUM_OF_TIME_UNITS: number,
        |	INT_COMPND_FREQ?: IntCompndFreq,
        |	CASH_FLOW_DATE_TYPE: CashFlowDateType,
        |	CASH_FLOW_DATE_OFFSET: number,
        |	GROSS_GL_BAL_ACT_CCY: number,
        |	INSTALMENT_AMT: number,
        |	INSTALMENT_AMT_CCY_CD: string,
        |	INTEREST_TYPE_CD: IntrestTypeCD,
        |	INTEREST_DAY_COUNT_CONVENTION: DayCount,
        |	INTEREST_RATE: number,
        |	ACCRUED_INT: number,
        |	ORIGINAL_PRIN_BAL: number,
        |	MATURITY_DATE: Date,
        |	DEPOSIT_DRAWDOWN_DATE: Date,
        |
        |	COUPON_TYPE?: CouponType,
        |	NEXT_INTEREST_RESET?: Date,
        |	LAST_INTEREST_RESET?: Date,
        |	REP_FREQ_TIME_UNIT?: RepFreqTimeUnit,
        |	REP_FREQ_NUM_OF_TIME_UNITS?: number,
        |	REFERENCE_CURVE?: ReferenceCurve,
        |	INTEREST_RATE_SPREAD?: number,
        |	NET_LIFE_CAP?: number,
        |	NET_LIFE_FLOOR?: number,
        |};
        |
        |type ExtendedRow =  { ...Row,
        |	isInstallmentEqualToglbalance: boolean,
        |	SCHEDULE_START_OVERRIDE: Date
        |};
        |
        |type Cashflow = {
        |	ACCOUNT_DEAL_ID: string,
        |	CASHFLOW_TYPE: CashflowType | null,
        |	FROM_DATE: Date | null,
        |	PAYMENT_DATE: Date | null,
        |	STEP: number | null,
        |	RATE: number | null,
        |	AMOUNT: number | null,
        |	OUTSTANDING: number | null,
        |
        |	VARIABLE_RATE: number | null,
        |	VARIABLE_AMOUNT: number | null,
        |	VARIABLE_OUTSTANDING: number | null,
        |	VARIABLE_STEP: number | null,
        |
        |	CCY: string | null,
        |	STATUS: "OK" | "Error",
        |	ERROR?: string
        |};
        |
        |type Schedule = {
        |	schedule: Date[],
        |	reportingIndex: number,
        |};
        |
        |type Product = {
        |	data: ExtendedRow,
        |	AddSettlement: (Schedule) => void,
        |	AddCashflow: (CashflowType, Date | null, Date, number | null, number | null, number | null, number, ?number, ?number, ?number, ?number, ?number) => Cashflow | null,
        |	DayCountFunc: (Date, Date) => number,
        |	RateConverter: (number, number) => number,
        |	isForwardStart: boolean,
        |	schedule: Schedule
        |};
        |
        |type VariableRate = {
        |	annualRate: number,
        |	offset: number
        |};
        |
        |type RateMap = {[string]: number};
        |
        |type StepFunc = (Date, ExtendedRow, number) => Date
        |*/
        |
        |
        |// Global constants
        |var _MAX_CASHFLOWS = 1100;
        |
        |/**
        |*	A list of all fields used across all products
        |*
        |*	Parameters needed:
        |*		W/R.AMORTISATION_TYPE			(Amortisation type)
        |*		W/R.GROSS_GL_BAL_ACT_CCY		(Balance amount)
        |*		W/R.LEGAL_ENTITY				(Legal Entity)
        |*		W/R.SYSTEM_ID					(Source System)
        |*		W/R.ACCOUNT_DEAL_ID				(Account ID)
        |*		W/R.GROSS_GL_BAL_ACT_CCY_CD		(Currency)
        |*
        |*		C.INSTALMENT_AMT				(Installment amount)
        |*		C.SCHEDULE_START_DATE
        |*		C.SCHEDULE_END_DATE
        |*		C.INS_FREQ_NUM_OF_TIME_UNITS
        |*		C.INS_FREQ_TIME_UNIT 			(D - Day / W - Week / M - Month / Q - Quarter / Y - Year)
        |*		C.CASH_FLOW_DATE_TYPE			(A - Absolute / F - First Day / L - Last Day)
        |*		C.CASH_FLOW_DATE_OFFSET			(always in days)
        |*		C.INTEREST_DAY_COUNT_CONVENTION
        |*		C.INTEREST_TYPE_CD				(C - Compount / S - Simple)
        |*		C.INT_COMPND_FREQ
        |*
        |*		D.REPRICING_TYPE				(S - Standard / A - Arrears)
        |*		D.REP_FREQ_TIME_UNIT			(D - Day / W - Week / M - Month / Q - Quarter / Y - Year)
        |*		D.REP_FREQ_NUM_OF_TIME_UNITS
        |*		D.COUPON_TYPE					(FLOATING / FIXED / VARIABLE / ADMINISTERED / MANAGED)
        |*		D.REFERENCE_CURVE				(Only relevant for FLOATING)
        |*		D.REFERENCE_CURVE_POINT			(Only relevant for FLOATING)
        |*		D.INTEREST_RATE
        |*		D.INTEREST_RATE_SPREAD
        |*		D.CASHFLOW_DIRECTION_INDICATOR	(R - Receive / P - Pay)
        |*
        |*/
        |/* Following changes are made
        |	1. Settlement flow is added to all amortization types. Also while generating flows, need to pass GROSS_GL_BAL_ACT_CCY in place of ORIGINAL_PRINCIPAL_BALANCE
        |	2. Updated the code for cashflow_date_type = "L" where offset was added and now that has been corrected.
        |	3. in some cases where schudule_start_date was greater than the schedule_end_date
        |*/
        |
        |/**
        |* 	A factory for day-count convention functions
        |*
        |*	Parameters:
        |*	C.INTEREST_DAY_COUNT_CONVENTION
        |*
        |*	Usage:
        |*		DayCountFactory["30E/360"](new Date(2016, 1, 1), new Date(2016, 2, 1))
        |*/
        |var DayCountFactory /*: {[DayCount]: (Date, Date) => number} */ = {};
        |DayCountFactory["30E/360"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D1 == 31) {
        |        c.D1 = 30;
        |    }
        |	if (c.D2 == 31) {
        |		c.D2 = 30;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1)) / 360;
        |	return result;
        |}
        |
        |DayCountFactory["30E/365"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D1 == 31) {
        |        c.D1 = 30;
        |    }
        |	if (c.D2 == 31) {
        |		c.D2 = 30;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1)) / 365;
        |	return result;
        |}
        |
        |DayCountFactory["30E/360.ISDA"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D1 == eoMonthUTC(startDate, 0).getUTCDate()) {
        |        c.D1 = 30;
        |    }
        |	if (c.D2 == eoMonthUTC(endDate, 0).getUTCDate() && c.M2 != 2) {
        |		c.D2 = 30;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1)) / 360;
        |	return result;
        |};
        |
        |DayCountFactory["30E+/360"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D1 == 31) {
        |        c.D1 = 30;
        |    }
        |	if (c.D2 == 31) {
        |		c.M2 = c.M2 + 1;
        |		c.D2 = 1;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1)) / 360;
        |	return result;
        |};
        |
        |DayCountFactory["30E/360.ITL"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D1 == 31) {
        |        c.D1 = 30;
        |    }
        |	if (c.D2 == 31) {
        |		c.D2 = 30;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1 + 1)) / 360;
        |	return result;
        |};
        |
        |// needs test
        |DayCountFactory["30U/360"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |    if (c.D2 == eoMonthUTC(endDate, 0).getUTCDate() && c.D1 == eoMonthUTC(startDate, 0).getUTCDate()) {
        |        c.D2 = 30;
        |    }
        |	if (c.D1 == eoMonthUTC(startDate, 0).getUTCDate()) {
        |		c.D1 = 30;
        |	}
        |	if (c.D2 == 31 && (c.D1 == 30 || c.D1 == 31)) {
        |		c.D2 = 30;
        |	}
        |	if (c.D1 == 31) {
        |		c.D1 = 30;
        |	}
        |	var result = ((c.Y2 - c.Y1) * 360 + (c.M2 - c.M1) * 30 + (c.D2 - c.D1)) / 360;
        |	return result;
        |};
        |
        |DayCountFactory["ACT/365"] = function(startDate, endDate) {
        |	var result = daysBetween(startDate, endDate) / 365;
        |	return result;
        |};
        |
        |DayCountFactory["ACT/360"] = function(startDate, endDate) {
        |	var result = daysBetween(startDate, endDate) / 360;
        |	return result;
        |};
        |
        |DayCountFactory["ACT/ACT"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |	var result;
        |
        |    if (c.Y1 < c.Y2) {
        |        result = daysBetween(startDate, new Date(Date.UTC(c.Y2, 1, 1))) / daysInYear(c.Y1) + daysBetween(new Date(Date.UTC(c.Y2, 1, 1)), endDate) / daysInYear(c.Y2) + (c.Y2 - c.Y1 - 1);
        |    } else {
        |        result = daysBetween(startDate, endDate) / daysInYear(c.Y1);
        |    }
        |
        |	return result;
        |};
        |
        |DayCountFactory["ACT+1/365"] = function(startDate, endDate) {
        |    return (daysBetween(startDate, endDate)+1) / 365 ;
        |};
        |
        |DayCountFactory["ACT+1/360"] = function(startDate, endDate) {
        |    return (daysBetween(startDate, endDate)+1) / 360 ;
        |};
        |
        |DayCountFactory["ACT/365.25"] = function(startDate, endDate) {
        |    return daysBetween(startDate, endDate) / 365.25;
        |};
        |
        |DayCountFactory["ACT/365(366)"] = function(startDate, endDate) {
        |	var c = toDateComponents(startDate, endDate);
        |	if ((daysInYear(c.Y1) === 366 || daysInYear(c.Y2) === 366) && startDate <= new Date(Date.UTC(c.Y1, 2, 29)) && endDate >= new Date(Date.UTC(c.Y2, 2, 29))){
        |		return daysBetween(startDate, endDate) / 366;
        |	}
        |	return daysBetween(startDate, endDate) / 365;
        |};
        |
        |/**
        |* Converts a nominal rate into an effective rate over the compounding period
        |*
        |*	Parameters				Supported
        |*	C.INTEREST_TYPE_CD		C, S
        |*	C.INT_COMPND_FREQ		C, D, W, F, M, Q, H, Y
        |*
        |* 	Usage:
        |*		CompounderFactory["S"](0.0410914, 0.08888)
        |*     	CompounderFactory["S"](0.0410914, DayCountFactory["ACT/360"](new Date("2016-08-30"), new Date("2016-09-30")))
        |*/
        |
        |var simpleCompounder = (rate, years) => {
        |	return rate * years;
        |};
        |
        |var CompounderFactory /* {[IntCompndFreq]: (number, number) => number} */ = {
        |	"C": (rate, years) => { // Continuous
        |		return Math.exp(rate * years) - 1;
        |	},
        |	"D": (rate, years) => { // Daily
        |		return Math.pow(1+rate/365.25, years) - 1;
        |	},
        |	"W": (rate, years) => { // Weekly
        |		return Math.pow(1+rate/52, years * 52) - 1;
        |	},
        |	"F": (rate, years) => { // Fortnightly
        |		return Math.pow(1+rate/26, years * 26) - 1;
        |	},
        |	"M": (rate, years) => { // Monthly
        |		return Math.pow(1+rate/12, years * 12) - 1;
        |	},
        |	"Q": (rate, years) => { // Quarterly
        |		return Math.pow(1+rate/4, years * 4) - 1;
        |	},
        |	"H": (rate, years) => { // Half-yearly
        |		return Math.pow(1+rate/2, years * 2) - 1;
        |	},
        |	"Y": (rate, years) => { // Yearly
        |		return Math.pow(1+rate, years) - 1;
        |	}
        |};
        |
        |
        |function ModifiedFollowing(dt) {
        |	// Adjust Modified Following to account for weekends
        |	var weekDay = dt.getUTCDay();
        |	var lastDay = eoMonthUTC(dt, 0).getUTCDate();
        |
        |	// Days remaining between pay-date and last day in month
        |	var daysBeforeLast = lastDay - dt.getUTCDate();
        |	var increment = 0;
        |	if (weekDay == 0) { increment = 1; }
        |	if (weekDay == 6) { increment = 2; }
        |
        |	// If there are not enough days left in the month, we can"t walk forward, we should walk back
        |	if (increment > daysBeforeLast) { increment = increment - 3; }
        |
        |	var result = addDays(dt, increment);
        |	return result;
        |}
        |
        |/**
        |* 	The StepFactory deterimines how to step between dates
        |*
        |*	Parameters							Supported
        |*		C.INS_FREQ_TIME_UNIT			D, W, M, Q, Y
        |*		C.INS_FREQ_NUM_OF_TIME_UNITS	any
        |*		C.CASH_FLOW_DATE_TYPE			F, L, A
        |*		C.CASH_FLOW_DATE_OFFSET			any
        |*
        |* 	Usage:
        |*		StepFactory[INS_FREQ_TIME_UNIT]
        |*
        |*/
        |var StepFactory /*: {[InsFreqTimeUnit]: StepFunc}*/ = {};
        |StepFactory["AM"] = function(currentDate, row, scheduleCount) {
        |	return row.SCHEDULE_START_OVERRIDE;
        |};
        |
        |StepFactory["D"] = function(currentDate, row, scheduleCount) {
        |	// Sree: Changes. Updated row.INS_FREQ_NUM_OF_TIME_UNITS with freq_num_of_times
        |	var freq_num_of_times = row.INS_FREQ_NUM_OF_TIME_UNITS;
        |	if (scheduleCount == 0) {
        |		// CHECK IF MATURITY_DAY WITH SCHDULE START DATE
        |		// IF Minimum of SCHEDULE_END_DAY AND MATURITY_DAY < SCHDULE_START_DATE THEN INS_FREQ_NUM_OF_TIME_UNITS ELSE SET TO 0
        |		var schedule_start_day = row.SCHEDULE_START_DATE.getUTCDate();
        |		var maturity_day = row.MATURITY_DATE.getUTCDate();
        |		var schedule_end_day = row.SCHEDULE_END_DATE.getUTCDate();
        |		if ( Math.min(maturity_day,schedule_end_day) > schedule_start_day) {
        |			freq_num_of_times = 0;
        |		}
        |	}
        |	return addDays(currentDate, -freq_num_of_times);
        |};
        |
        |StepFactory["W"] = function(currentDate, row, scheduleCount) {
        |	return StepFactory["D"](currentDate, {...row,
        |		INS_FREQ_NUM_OF_TIME_UNITS: row.INS_FREQ_NUM_OF_TIME_UNITS * 7
        |	}, scheduleCount);
        |};
        |
        |StepFactory["M"] = function(currentDate, row, scheduleCount) {
        |	// Last day in next payment period
        |	// sREE
        |	var lastDay = eoMonthUTC(currentDate, -row.INS_FREQ_NUM_OF_TIME_UNITS).getUTCDate();
        |	var result;
        |	var offset = row.CASH_FLOW_DATE_OFFSET;
        |	// Sree: Changes. Updated row.INS_FREQ_NUM_OF_TIME_UNITS with freq_num_of_times
        |	var freq_num_of_times = row.INS_FREQ_NUM_OF_TIME_UNITS;
        |	if (scheduleCount == 0) {
        |		// CHECK IF MATURITY_DAY WITH SCHDULE START DATE
        |		// IF MATURITY_DAY < SCHDULE_START_DATE THEN INS_FREQ_NUM_OF_TIME_UNITS ELSE SET TO 0
        |		var schedule_start_day = row.SCHEDULE_START_DATE.getUTCDate();
        |		var maturity_day = row.MATURITY_DATE.getUTCDate();
        |		var schedule_end_day = row.SCHEDULE_END_DATE.getUTCDate();
        |		if ( Math.min(maturity_day,schedule_end_day) > schedule_start_day) {
        |			freq_num_of_times = 0;
        |		}
        |	}
        |
        |	if (row.CASH_FLOW_DATE_TYPE === "F") {
        |		// Offset can be more than Last day of month - 1 (offsets start from 0)
        |		offset = Math.min(row.CASH_FLOW_DATE_OFFSET, lastDay - 1);
        |		result = addDays(addDays(eoMonthUTC(currentDate, -freq_num_of_times - 1), 1), offset);
        |	} else if (row.CASH_FLOW_DATE_TYPE === "L") {
        |		// Offset can never be more than Last working day of month - 1 (offsets start from 0)
        |		offset = -Math.min(-row.CASH_FLOW_DATE_OFFSET, lastDay - 1);
        |		// Sree: Change the signage of offset value while getting the schedule.
        |		result = addDays(eoMonthUTC(currentDate, -freq_num_of_times), offset);
        |	} else if (row.CASH_FLOW_DATE_TYPE === "A") {
        |		// Absoulte
        |		result = eoMonthUTC(currentDate, -freq_num_of_times);
        |		var day = Math.min(row.SCHEDULE_START_DATE.getUTCDate(), result.getUTCDate())
        |		result = new Date(Date.UTC(result.getUTCFullYear(), result.getUTCMonth(), day));
        |	}else{
        |		/*:: (row.CASH_FLOW_DATE_TYPE: empty)*/
        |		throw new Error("")
        |	}
        |
        |	// Adjust Modified Following to account for weekends
        |	result = ModifiedFollowing(result);
        |
        |	return result;
        |};
        |
        |StepFactory["Q"] = function(currentDate, row, scheduleCount) {
        |	return StepFactory["M"](currentDate, {...row,
        |		INS_FREQ_NUM_OF_TIME_UNITS: row.INS_FREQ_NUM_OF_TIME_UNITS * 3
        |	}, scheduleCount);
        |};
        |
        |// Sree: Halfyearly is missing
        |StepFactory["H"] = function(currentDate, row, scheduleCount) {
        |	return StepFactory["M"](currentDate, {...row,
        |		INS_FREQ_NUM_OF_TIME_UNITS: row.INS_FREQ_NUM_OF_TIME_UNITS * 6
        |	}, scheduleCount);
        |};
        |
        |StepFactory["Y"] = function(currentDate, row, scheduleCount) {
        |	return StepFactory["M"](currentDate, {...row,
        |		INS_FREQ_NUM_OF_TIME_UNITS: row.INS_FREQ_NUM_OF_TIME_UNITS * 12
        |	}, scheduleCount);
        |};
        |
        |// BULLET schedule
        |StepFactory[""] = function(currentDate, row, scheduleCount) {
        |	return row.SCHEDULE_END_DATE;
        |};
        |
        |
        |var imputeCurve = (curve /*: ReferenceCurve*/) => {
        |	/* Impute missing curve values and convert to decimal proportion */
        |	var lastRate = null;
        |	var imputedCurve = curve.map(({date, rate}) => {
        |		var d = date.toISOString().slice(0, 10);
        |		if (rate === null){
        |			return [d, lastRate]
        |		}
        |		lastRate = rate / 100;
        |		return [d, lastRate];
        |	});
        |	return new Map(imputedCurve);
        |}
        |
        |/**
        |*	A function that returns the correct FIXED / FLOATING rate based on the input
        |*/
        |
        |var RateFactory = {};
        |RateFactory["FIXED"] = function (row, startDate, endDate, currentRate) { return row.INTEREST_RATE; }
        |
        |
        |var getCurveRate = (row, endDate /*: Date */, imputedCurve) => {
        |	var curveKey = eoMonthUTC(endDate, 0).toISOString().slice(0, 10);
        |	var curveRate = imputedCurve.get(curveKey);
        |	var spreadRate = curveRate != undefined ? curveRate + (row.INTEREST_RATE_SPREAD || 0) : row.INTEREST_RATE;
        |	var floorRate = Math.max(spreadRate, row.NET_LIFE_FLOOR || 0);
        |	return row.NET_LIFE_CAP != undefined ? Math.min(floorRate, row.NET_LIFE_CAP) : floorRate;
        |}
        |
        |/**
        |*	A function that returns a payment schedule object
        |*
        |*	Parameters							Supported
        |*		C.SCHEDULE_START_DATE
        |*		C.SCHEDULE_END_DATE
        |*		C.INS_FREQ_NUM_OF_TIME_UNITS
        |*		C.INS_FREQ_TIME_UNIT 			D - Day,  W - Week, M - Month, Q - Quarter, Y - Year
        |*		C.CASH_FLOW_DATE_TYPE			A - Absolute, F - First Day, L - Last Day
        |*		C.CASH_FLOW_DATE_OFFSET			always in days
        |*
        |*/
        |function scheduleFactory(row) /*: Schedule */ {
        |	var schedule = [];
        |	var reportingIndex = 0;
        |	var Step /*: StepFunc*/ = StepFactory[row.INS_FREQ_TIME_UNIT] || StepFactory[""];
        |	// Helper: Add to schedule, note this is a date step not an interest step
        |	var addStep = (dt, i) => {
        |			var result = ModifiedFollowing(dt);
        |			// The Result is the payment date
        |			schedule.push(result);
        |			result = Step(result, row, i); // This calls the step factory
        |			return result;
        |	}
        |	// This will generate the full schedule from start to end date regardless of reporting date
        |
        |	// Step through all dates starting from Maturity backwards
        |	var currentDate = row.MATURITY_DATE;
        |	// Stop if the first date after maturity
        |	if (currentDate.getTime() < row.SCHEDULE_START_OVERRIDE.getTime()) {
        |		return {schedule: [], reportingIndex: 0}; }
        |
        |	// Phase 1: If Maturity Date > Schedule End Date, step back up to the end date.
        |	var startTime = row.SCHEDULE_START_OVERRIDE.getTime();
        |	var endTime = row.SCHEDULE_END_DATE.getTime();
        |	var checkEnd = endTime < row.MATURITY_DATE.getTime();
        |	var i = 0;
        |	do {
        |		currentDate = addStep(currentDate, i);
        |
        |		// Check if an adjustment is required for SCHEDULE_END_DATE < MATURITY_DATE
        |		var curTime = currentDate.getTime();
        |		if (checkEnd && curTime <= endTime) {
        |			checkEnd = false;
        |			currentDate = row.SCHEDULE_END_DATE;
        |		}
        |
        |		// Built-in error check to cap cashflows
        |		i++;
        |		// Sree: Add counter to check the offset values
        |		if (i > _MAX_CASHFLOWS) {
        |			throw "Maximum cashflows exceeded"
        |		}
        |	} while (curTime > startTime);
        |
        |	// Replace first with the stopDate
        |	schedule.push(ModifiedFollowing(row.SCHEDULE_START_OVERRIDE));
        |
        |	// Reverse schedule
        |	schedule = schedule.reverse();
        |
        |	// Set the reporting index
        |	var i = 0;
        |	while (schedule[i] < row.REPORTING_DATE) { i++; }
        |	// TODO: bug with underscore
        |	// reporting_index = i-1;
        |
        |	return {
        |		schedule: schedule,
        |		reportingIndex: reportingIndex
        |	};
        |}
        |
        |var variableInstalment = (rate, nperiod, pv) => {
        |	if (rate == 0){
        |		return pv / nperiod;
        |	}
        |	return pv * (rate *(1 + rate)**nperiod)/((1 + rate)**nperiodÂ - 1);
        |}
        |
        |
        |var getHistoricStart = (timeFreq /*: RepFreqTimeUnit*/, numUnit /*: number*/, reportingDate) => {
        |	/* When the repricing time starts before the interest schedule, find the maximum reprice date
        |	preceding the reporting date. */
        |	var days = {"D": 1, "W": 7, "M": 31, "Q": 92, "H": 183, "Y": 366};
        |	return addDays(reportingDate, - days[timeFreq] * numUnit);
        |}
        |
        |
        |var createRepricingDivisor = (row) => {
        |	/* Create the devisor for the modulo that maps the repricing schedule onto the interest schedule.*/
        |
        |	if (!row.REP_FREQ_TIME_UNIT || !row.REP_FREQ_NUM_OF_TIME_UNITS){
        |		return 1;
        |	}
        |	// These day units are just an assumption
        |	var days/*: {[InsFreqTimeUnit]: number}*/ = {"D": 1, "W": 7, "M": 30, "Q": 90, "H": 180, "Y": 360};
        |
        |	// Normalise the time periods to days
        |	var interestDays = days[row.INS_FREQ_TIME_UNIT] * row.INS_FREQ_NUM_OF_TIME_UNITS;
        |	var repricingDays = days[row.REP_FREQ_TIME_UNIT] * row.REP_FREQ_NUM_OF_TIME_UNITS;
        |
        |	// If the RepFreqTimeUnit is a smaller then InsFreqTimeUnit reprice every time
        |	return Math.max(Math.floor(repricingDays / interestDays), 1);
        |}
        |
        |
        |var indexMap = (devisor, row, schedule, resetDate=null, left=true) => {
        |	var imputedCurve = imputeCurve(row.REFERENCE_CURVE || []);
        |
        |	if (row.INS_FREQ_TIME_UNIT === "AM"){
        |		return {[row.REPORTING_DATE.toISOString()]: getCurveRate(row, schedule[schedule.length - 1], imputedCurve)};
        |	}
        |	var adjSchedule /*: [Date, Date][]*/ = [];
        |	for (var i = 1; i < schedule.length; i++) {
        |		adjSchedule.push([schedule[i-1], schedule[i]]);
        |	}
        |
        |	var startOffset = 0;
        |	var reducer = (accumulator, [startDate, endDate], i) => {
        |		if (resetDate && startDate < resetDate){
        |			startOffset -= 1;
        |			return accumulator;
        |		}
        |		var index = i + startOffset;
        |		// This index handles reducing from the right and left
        |		var reduceIndex = left ? index : (adjSchedule.length - index - 1);
        |
        |		if (reduceIndex % devisor === 0){
        |			// if F use first date of month end and if L use last date
        |			var keyDate = row.CASH_FLOW_DATE_TYPE === "F" ? startDate : endDate;
        |			var curveRate = getCurveRate(row, keyDate, imputedCurve);
        |			return {...accumulator, [startDate.toISOString()]: curveRate};
        |		}
        |		return accumulator;
        |	}
        |	return left ? adjSchedule.reduce(reducer, {}) : adjSchedule.reduceRight(reducer, {});
        |}
        |
        |var addFirstReprice = (row, rateMap /*: RateMap */) => {
        |	/* For historic repricing starts, find the reporting date rate */
        |	var allDates /*: string[] */ = Object.keys(rateMap);
        |	if (allDates.length === 0){
        |		return {};
        |	}
        |	var reportKey = row.REPORTING_DATE.toISOString();
        |	if (row.INS_FREQ_TIME_UNIT === "AM" || rateMap.hasOwnProperty(reportKey)){
        |		return rateMap;
        |	}
        |
        |	var beforeDates /*: Date[] */ = allDates.map(d => new Date(d)).filter(d => d - row.REPORTING_DATE <= 0);
        |	beforeDates.sort((a, b) => b.getTime() - a.getTime());
        |	var lastDate = beforeDates[0].toISOString();
        |
        |	if (rateMap[lastDate] == null){
        |		// if the historic curve rate is to far back in time return the SDI rate
        |		return {...rateMap, [reportKey]: row.INTEREST_RATE};
        |	}
        |	return {...rateMap, [reportKey]: rateMap[lastDate]};
        |}
        |
        |var repricingSchedule = (row, s) => {
        |	var devisor = createRepricingDivisor(row);
        |
        |	if (row.NEXT_INTEREST_RESET && row.REPORTING_DATE <= row.NEXT_INTEREST_RESET || devisor == 1){
        |		// if we have next interest date use that as the start or we reprice everytime
        |		var rateMap = indexMap(devisor, row, s, row.NEXT_INTEREST_RESET)
        |
        |		if (rateMap[row.REPORTING_DATE.toISOString()] == null){
        |			return {...rateMap, [row.REPORTING_DATE.toISOString()]: row.INTEREST_RATE};
        |		}
        |		return rateMap;
        |	}else if (row.LAST_INTEREST_RESET && row.REPORTING_DATE >= row.LAST_INTEREST_RESET) {
        |		// Use LAST_INTEREST_RESET to reprice
        |		var historicSchedule = scheduleFactory({...row, REPORTING_DATE: row.LAST_INTEREST_RESET, SCHEDULE_START_OVERRIDE: row.LAST_INTEREST_RESET}).schedule;
        |		var rateMap = indexMap(devisor, row, historicSchedule);
        |		return addFirstReprice(row, rateMap);
        |	}else if (row.MATURITY_DATE && row.REP_FREQ_TIME_UNIT && row.REP_FREQ_NUM_OF_TIME_UNITS) {
        |		// Unknown repricing start date, work backwards from maturity
        |		var historicStart = getHistoricStart(row.REP_FREQ_TIME_UNIT, row.REP_FREQ_NUM_OF_TIME_UNITS,
        |			row.REPORTING_DATE);
        |		var historicSchedule = scheduleFactory(
        |			{...row, REPORTING_DATE: historicStart, SCHEDULE_START_OVERRIDE: historicStart}).schedule;
        |
        |		var rateMap = indexMap(devisor, row, historicSchedule, null, false);
        |		return addFirstReprice(row, rateMap);
        |	}
        |
        |	// It dosnt look like this ever happens as MATURITY_DATE is never null
        |	return indexMap(devisor, row, s, null, false);
        |}
        |
        |
        |function generateFlows(product, principleFunc, lastCashflow) {
        |	var {data: row} = product;
        |	var residual = row.GROSS_GL_BAL_ACT_CCY;
        |	var variableCoupons = new Set(["VARIABLE", "FLOATING", "MANAGED", "ADMINISTERED"]);
        |	var s = product.schedule.schedule;
        |
        |	var variableResidual = null;
        |	var rs /*: RateMap */ = {};
        |	if (row.GROSS_GL_BAL_ACT_CCY  && variableCoupons.has(row.COUPON_TYPE) &&
        |		row.REFERENCE_CURVE && row.REFERENCE_CURVE.length !== 0 &&
        |		row.REP_FREQ_TIME_UNIT !== null && row.REP_FREQ_NUM_OF_TIME_UNITS !== null
        |		){
        |			rs = repricingSchedule(row, s);
        |			variableResidual = row.GROSS_GL_BAL_ACT_CCY;
        |	}
        |
        |	// Make settlement payment in case of forward start
        |	product.AddSettlement(product.schedule);
        |
        |	// Accrued interest
        |	product.AddCashflow("Accrued", s[0], s[1], null, null, row.ACCRUED_INT, residual,
        |					    null, variableResidual && row.ACCRUED_INT, variableResidual);
        |
        |	var staticCashflow = (i, residual) => {
        |		var step = product.DayCountFunc(s[i - 1], s[i]);
        |		var rate = product.RateConverter(row.INTEREST_RATE, step);
        |		var interest = residual * rate;
        |		var principal = principleFunc(i, row.INSTALMENT_AMT, residual, interest);
        |		return { interest, rate, principal, step };
        |	}
        |
        |	var variableCashflow = (i, residual, currentAnnualRate /*: number */) => {
        |		var startDate = s[i-1].toISOString();
        |		var annualRate = rs.hasOwnProperty(startDate) ? rs[startDate] : currentAnnualRate;
        |
        |		var step = product.DayCountFunc(s[i - 1], s[i]);
        |		var instalmentAmount = row.INSTALMENT_AMT;
        |		var rate = product.RateConverter(annualRate, step);
        |
        |		if (row['AMORTISATION_TYPE'] === "LEVEL PAY" &&
        |			(!row.NEXT_INTEREST_RESET || s[i-1] >= row.NEXT_INTEREST_RESET)){
        |			// For level pay products we need a crude normalisation method to ensure
        |			// the total cashflow payments stay the same for the repricing period
        |			var levelPayNormalisation /*: {[InsFreqTimeUnit]: number}*/ = {
        |				'D': product.DayCountFunc(s[i - 1], s[i]),
        |				'W': 1/52,
        |				'M': 1/12,
        |				'Q': 1/4,
        |				'Y': 1/1,
        |				// AM is not required as only applicable to bullet products
        |			};
        |			step = levelPayNormalisation[row.INS_FREQ_TIME_UNIT];
        |			rate = product.RateConverter(annualRate, step);
        |			instalmentAmount = variableInstalment(rate, s.length - i, residual); // Total payment
        |		}
        |		var interest = residual * rate;
        |
        |		var principal = principleFunc(i, instalmentAmount, residual, interest);
        |
        |		return { interest, rate, principal, annualRate, step };
        |	}
        |
        |    // Check if installment amount is equal to outstanding principal amount
        |	if (row.isInstallmentEqualToglbalance) {
        |		// then generate one principal flow at maturity and insterest at all schedules
        |		product.AddCashflow("Principal", row.REPORTING_DATE, row.MATURITY_DATE, 0.0, 0.0, residual, 0.0,
        |		variableResidual && 0.0, variableResidual, variableResidual && 0.0);
        |	}
        |	var vc = { interest: null, rate: null, principal: null, annualRate: row.INTEREST_RATE, step: null }
        |	var c = { rate: null, step: null };
        |
        |	for (var i = 1; i < s.length; i++) {
        |		c = staticCashflow(i, residual);
        |		residual -= c.principal;
        |
        |		if (variableResidual !== null) {
        |			vc = variableCashflow(i, variableResidual, vc.annualRate);
        |			variableResidual -= vc.principal;
        |		}
        |
        |		if (!row.isInstallmentEqualToglbalance && row['AMORTISATION_TYPE'] !== "BULLET") {
        |			product.AddCashflow("Principal", s[i-1], s[i], c.rate, c.step, c.principal, residual,
        |				vc.rate, vc.principal, variableResidual, vc.step);
        |		}
        |		product.AddCashflow("Interest", s[i-1], s[i], c.rate, c.step, c.interest, residual,
        |				vc.rate, vc.interest, variableResidual, vc.step);
        |	}
        |
        |	lastCashflow(c, vc, i, residual, variableResidual);
        |}
        |
        |/**
        |*	A generator that maps Amortization/Produt Types into cashflow functions
        |*/
        |var CashflowFactory /*: {[AmortisationType]: (Product) => void} */= {};
        |
        |CashflowFactory["LEVEL PAY"] = function(product){
        |	var s = product.schedule.schedule;
        |	var principle = (i, payment, residual, interest) => {
        |		return Math.min(payment - interest - (i == 1 ? product.data.ACCRUED_INT : 0), residual  || 0);
        |	}
        |	var lastCashflow = (c, vc, i, residual, variableResidual) => {
        |		if (residual > 0 || variableResidual) {
        |			product.AddCashflow("Residual", s[i-2], s[i-1], c.rate, c.step, residual, 0,
        |			                    vc.rate, variableResidual, variableResidual && 0, vc.step);
        |		}
        |	}
        |	return generateFlows(product, principle, lastCashflow);
        |}
        |
        |CashflowFactory["STRAIGHT LINE"] = function(product) {
        |	var s = product.schedule.schedule;
        |	var principle = (i, payment, residual, interest) => {
        |		return Math.min(product.data.INSTALMENT_AMT, residual || 0);
        |	}
        |	var lastCashflow = (c, vc, i, residual, variableResidual) => {
        |		if (residual > 0 || variableResidual) {
        |			product.AddCashflow("Residual", s[i-2], product.data.MATURITY_DATE, c.rate, c.step, residual, 0,
        |								vc.rate, variableResidual, variableResidual && 0, vc.step);
        |		}
        |	}
        |	return generateFlows(product, principle, lastCashflow);
        |}
        |
        |CashflowFactory["BULLET"] = function(product) {
        |	var s = product.schedule.schedule;
        |	var principle = (i, payment, residual, interest) => {
        |		return 0;
        |	}
        |	var lastCashflow = (c, vc, i, residual, variableResidual) => {
        |		product.AddCashflow("Principal", null, s[i-1], c.rate, null, product.data.GROSS_GL_BAL_ACT_CCY, 0.0,
        |							vc.rate, variableResidual, variableResidual && 0, vc.step);
        |	}
        |	return generateFlows(product, principle, lastCashflow);
        |}
        |
        |
        |CashflowFactory["ACCRUAL"] = function(product) {
        |	var openBalance = product.data.GROSS_GL_BAL_ACT_CCY;
        |	var residual = openBalance;
        |	var s = product.schedule.schedule;
        |	//Sree: Add Settlement Flow
        |	// Make settlement payment in case of forward start
        |	product.AddSettlement(product.schedule);
        |	var rate = null;
        |
        |	for (var i = 1; i < s.length; i++) {
        |		var step = product.DayCountFunc(s[i-1], s[i]);
        |		var rateFunc = RateFactory["FIXED"](product.data, s[i - 1], s[i]);
        |		rate = product.RateConverter(rateFunc, step);
        |		residual = residual * (1 + rate);
        |	}
        |
        |	// Principal
        |	product.AddCashflow("Principal", s[0], s[i-1], null, s[i-1] - s[0], openBalance, 0);
        |
        |	// Interest
        |	product.AddCashflow("Interest", s[0], s[i-1], rate, s[i-1] - s[0], residual - openBalance, 0);
        |}
        |
        |CashflowFactory["MODIFIED RULE OF 78"] = function(product) {
        |	// Remaining payments
        |	// To derive the no of installments need to use maturity and settlement dates and not schedule start and end dates
        |	var n = product.schedule.schedule.length - 1;
        |	var no_of_installments = monthDiff(product.data.DEPOSIT_DRAWDOWN_DATE, product.data.MATURITY_DATE) + 1;
        |	var step = product.DayCountFunc(product.data.DEPOSIT_DRAWDOWN_DATE, product.data.MATURITY_DATE);
        |	var rateFunc = RateFactory["FIXED"](product.data, product.data.DEPOSIT_DRAWDOWN_DATE, product.data.MATURITY_DATE);
        |	var rate = product.RateConverter(rateFunc, step);
        |	var total_interest = rate * product.data.ORIGINAL_PRIN_BAL;
        |	var denominator = no_of_installments * (no_of_installments + 1) / 2;
        |
        |	var start = product.schedule.reportingIndex+1;
        |
        |	// Change Installment
        |	// var installment = (product.data.ORIGINAL_PRIN_BAL + total_interest) / n;
        |	var installment = (product.data.ORIGINAL_PRIN_BAL + total_interest) / no_of_installments;
        |
        |	var residual = product.data.GROSS_GL_BAL_ACT_CCY;
        |	var s = product.schedule.schedule;
        |
        |	// Make settlement payment in case of forward start
        |	product.AddSettlement(product.schedule);
        |
        |	// Accrued interest
        |	product.AddCashflow("Accrued", s[0], s[1], null, null, product.data.ACCRUED_INT, residual);
        |
        |	for (var i = start; i < s.length; i++) {
        |		step = product.DayCountFunc(s[i-1], s[i]);
        |		rate = (n+1-i)/denominator;
        |		var interest =  total_interest * rate;
        |		var principal = Math.min(installment - interest - (i == 1 ? product.data.ACCRUED_INT : 0), residual);
        |		residual -= principal;
        |
        |		// Principal
        |		product.AddCashflow("Principal", s[i-1], s[i], rate, step, principal, residual);
        |
        |		// Interest
        |		product.AddCashflow("Interest", s[i-1], s[i], rate, step, interest, residual);
        |	}
        |
        |	// Residual
        |	if (residual > 0) { product.AddCashflow("Residual", s[i-2], s[i-1], rate, step, residual, 0); }
        |
        |}
        |
        |
        |var constructor = (product /*: Product */) => {
        |	var row = product.data;
        |	// Parameter defaults
        |	row.CASH_FLOW_DATE_TYPE = row.CASH_FLOW_DATE_TYPE || "L";
        |	row.CASH_FLOW_DATE_OFFSET = row.CASH_FLOW_DATE_OFFSET || 0;
        |
        |	// TODO: check the length
        |	if (row.COUPON_TYPE === "VARIABLE" && !row.REFERENCE_CURVE){
        |		row.COUPON_TYPE = "FIXED";
        |	}
        |
        |	// Initialise components
        |	// Schedule start should be either Settlement date or The Reporting_Date +/- day from the schedule startDate
        |	// The above need to be confirmed
        |	row.SCHEDULE_START_OVERRIDE = product.isForwardStart ? row.DEPOSIT_DRAWDOWN_DATE : row.REPORTING_DATE;
        |
        |	// Product specific constructors
        |	var amort_type = product.data.AMORTISATION_TYPE;
        |
        |	// This is might be a bug, the following overide was never executed
        |	// if (amort_type === "MODIFIED RULE OF 78") {
        |	// 	row.SCHEDULE_START_OVERRIDE = row.SCHEDULE_START_DATE;
        |	// }
        |
        |	// sree: end of changes
        |	//Sree: Check if installment amount is equal to outstanding then generate on principal flow at maturity and then interest flows at calculated schedules. JIRA CACL-
        |	row.isInstallmentEqualToglbalance = false;
        |	if ( (row.GROSS_GL_BAL_ACT_CCY  != 0.0 && row.INSTALMENT_AMT != 0.0 ) && (  Math.abs(row.INSTALMENT_AMT) >= Math.abs(row.GROSS_GL_BAL_ACT_CCY)  )  ) {
        |		row.isInstallmentEqualToglbalance = true;
        |	}
        |
        |	// Calculate the schedule
        |	product.schedule = scheduleFactory(row);
        |	// Calculate the cashflows
        |	CashflowFactory[amort_type](product);
        |
        |	return product;
        |}
        |
        |/**
        |*	A generator creates a Product based on a set of parameters
        |*/
        |var processCashflows = (row /*: ExtendedRow */) => {
        |	var cashflows = [];
        |
        |	var addCashflow = (cashflow_type, from_date, payment_date, rate, step, amount, outstanding,
        |		variableRate=null, variableAmount=null, variableOutsanding=null, variableStep=null ) /*: Cashflow | null*/ => {
        |		if ([amount, variableAmount].every((a) => a == null || a == 0.0)) {
        |			return null;
        |		}
        |		var cashflow /* Cashflow */ = {
        |			ACCOUNT_DEAL_ID: 	row.ACCOUNT_DEAL_ID,
        |			CASHFLOW_TYPE: 		cashflow_type,
        |			FROM_DATE: 			from_date,
        |			PAYMENT_DATE: 		payment_date,
        |			RATE:				rate,
        |			STEP:				step,
        |			AMOUNT:				amount,
        |			OUTSTANDING:		outstanding,
        |			VARIABLE_RATE: 		variableRate,
        |			VARIABLE_AMOUNT: 	variableAmount,
        |			VARIABLE_OUTSTANDING: variableOutsanding,
        |			VARIABLE_STEP: 		variableStep,
        |			CCY:				row.INSTALMENT_AMT_CCY_CD,
        |			STATUS: "OK"
        |		};
        |		cashflows.push(cashflow);
        |		return cashflow;
        |	}
        |
        |	var isForwardStart = row.DEPOSIT_DRAWDOWN_DATE != null && !isNaN(row.DEPOSIT_DRAWDOWN_DATE.getTime()) && row.DEPOSIT_DRAWDOWN_DATE.getTime() > row.REPORTING_DATE.getTime();
        |
        |	var AddSettlement = (schedule) => {
        |		if (!isForwardStart) return;
        |		addCashflow("Settlement", null, schedule.schedule[0], null, null, -row.GROSS_GL_BAL_ACT_CCY, null, null);
        |	}
        |
        |	constructor({
        |		data: row,
        |		AddCashflow: addCashflow,
        |		AddSettlement: AddSettlement,
        |		DayCountFunc: DayCountFactory[row.INTEREST_DAY_COUNT_CONVENTION],
        |		RateConverter: row.INTEREST_TYPE_CD === "S" ? simpleCompounder : CompounderFactory[row.INT_COMPND_FREQ || 'Y'],
        |		isForwardStart: isForwardStart,
        |		schedule: {schedule: [], reportingIndex: 0}
        |	});
        |
        |	return cashflows;
        |}
        |
        |
        |////////////////////////////////////////////////////////////////////////
        |// Helper Functions
        |////////////////////////////////////////////////////////////////////////
        |
        |/**
        |*	Returns the number of days in a specific year
        |*/
        |function daysInYear(yr) {
        |    var result = daysBetween(new Date(Date.UTC(yr, 0, 1)), new Date(Date.UTC(yr + 1, 0, 1)));
        |    return result;
        |}
        |
        |/**
        |*	Calculates the number of days between two dates
        |*/
        |function daysBetween(startDate, endDate) {
        |    var result = (endDate - startDate)/1000/60/60/24;
        |    return result;
        |}
        |
        |function isLeapYear(year) {
        |	return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
        |}
        |
        |var lastDaysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        |
        |/**
        |* 	A function that returns the last day of the month, given a starting date and a month offset
        |*
        |*   e.g eoMonthUTC(new Date("2016-01-01"), -2) = Mon Nov 30 2015 00:00:00 GMT+0000 (GMT Standard Time)
        |*   e.g eoMonthUTC(new Date("2016-01-01"),  1) = Mon Feb 29 2016 00:00:00 GMT+0000 (GMT Standard Time)
        |*/
        |function eoMonthUTC(dt /*: Date */, offset) {
        |	var year = dt.getUTCFullYear();
        |	var month = dt.getUTCMonth() + offset;
        |	var result = new Date(Date.UTC(year, month, 1));
        |	var lastDay = lastDaysOfMonth[result.getUTCMonth()];
        |	/* special case for February */
        |	if (lastDay === 28 && isLeapYear(result.getUTCFullYear())) {
        |		lastDay = 29;
        |	}
        |	result.setUTCDate(lastDay);
        |	return result;
        |}
        |
        |/**
        |*	A function that returns the next workday given an input date
        |*/
        |
        |function addDays(dt, days) {
        |    return new Date(dt.valueOf() + days * 1000*60*60*24);
        |}
        |
        |// Converts to dates into an object that contains the constituents
        |function toDateComponents(startDate, endDate) {
        |	var result = {
        |		D1: startDate.getUTCDate(),
        |		M1: startDate.getUTCMonth() + 1,
        |		Y1: startDate.getUTCFullYear(),
        |		D2: endDate.getUTCDate(),
        |		M2: endDate.getUTCMonth() + 1,
        |		Y2: endDate.getUTCFullYear()
        |	};
        |	return result;
        |};
        |
        |
        |// Sree: Add function to get no of months for the given two dates..
        |function monthDiff(d1, d2) {
        |    var months;
        |    months = (d2.getFullYear() - d1.getFullYear()) * 12;
        |    months -= d1.getMonth() + 1;
        |    months += d2.getMonth();
        |    return months <= 0 ? 0 : months;
        |}
        |
        |
        |/**
        |	Entry point for BigQuery function
        |*/
        |
        |function RowToCashflows(row /*: ExtendedRow */) /*: Cashflow[] */ {
        |	try {
        |		return processCashflows(row);
        |	} catch (err) {
        |		return [{
        |			STATUS: 			"Error"
        |			, ERROR:			err
        |			, ACCOUNT_DEAL_ID: 	row.ACCOUNT_DEAL_ID
        |			, CASHFLOW_TYPE: 	null
        |			, FROM_DATE:		null
        |			, PAYMENT_DATE:		null
        |			, RATE: 			null
        |			, STEP: 			null
        |			, AMOUNT: 			null
        |			, OUTSTANDING:		null
        |			, CCY:				null
        |			, VARIABLE_OUTSTANDING: null
        |			, VARIABLE_AMOUNT: null
        |			, VARIABLE_RATE: null
        |			, VARIABLE_STEP: null
        |		}]
        |	}
        |}
        |
        |if (typeof module !== 'undefined') {
        |	module.exports = {
        |		processCashflows,
        |		eoMonthUTC,
        |		toDateComponents,
        |		eoMonthUTC,
        |		DayCountFactory,
        |		StepFactory,
        |		scheduleFactory,
        |		imputeCurve,
        |		createRepricingDivisor,
        |		getCurveRate,
        |		getHistoricStart,
        |		addFirstReprice,
        |		variableInstalment,
        |		indexMap
        |	}
        |}
    """.stripMargin
  }

}
package hsbc.emf.data.resolution

import java.sql.{Date, Timestamp}

sealed trait ComparableValue
final case class ComparableInt(value: Int) extends ComparableValue
final case class ComparableDouble(value: Double) extends ComparableValue
final case class ComparableDecimal(value: BigDecimal) extends ComparableValue
final case class ComparableBoolean(value: Boolean) extends ComparableValue
final case class ComparableString(value: String) extends ComparableValue
final case class ComparableDate(value: Date) extends ComparableValue
final case class ComparableTimestamp(value: Timestamp) extends ComparableValue
final case class ComparableNull() extends ComparableValuepackage hsbc.emf.data.resolution

sealed trait ComparisonOperator
case object Equal extends ComparisonOperator {
  override def toString: String = "="
}
case object NotEqual extends ComparisonOperator {
  override def toString: String = "!="
}
case object GreaterThan extends ComparisonOperator {
  override def toString: String = ">"
}
case object GreaterThanOrEqual extends ComparisonOperator {
  override def toString: String = ">="
}
case object LessThanOrEqual extends ComparisonOperator {
  override def toString: String = "<="
}
case object LessThan extends ComparisonOperator {
  override def toString: String = "<"
}
case object In extends ComparisonOperator {
  override def toString: String = "IN"
}
case object NotIn extends ComparisonOperator {
  override def toString: String = "NOT IN"
}
case object Like extends ComparisonOperator {
  override def toString: String = "LIKE"
}
case object NotLike extends ComparisonOperator {
  override def toString: String = "NOT LIKE"
}

case object Is extends ComparisonOperator {
  override def toString: String = "IS"
}

case object IsNot extends ComparisonOperator {
  override def toString: String = "IS NOT"
}
package hsbc.emf.infrastructure.serde

import hsbc.emf.data.resolution._
import org.json4s.CustomSerializer
import org.json4s.JsonAST.{JNull, JString}

case object ComparisonOperatorSerializer extends CustomSerializer[ComparisonOperator](format => (
  {
    case JString(comparisonOperator) =>  comparisonOperator match {
      case "=" => Equal
      case "!=" => NotEqual
      case ">" => GreaterThan
      case ">=" => GreaterThanOrEqual
      case "<" => LessThan
      case "<=" => LessThanOrEqual
      case "IN" => In
      case "NOT IN" => NotIn
      case "LIKE" => Like
      case "NOT LIKE" => NotLike
      case "IS" => Is
      case "IS NOT" => IsNot
    }
    case JNull => null
  },
  {
    case comparisonOperator:ComparisonOperator => JString(comparisonOperator.getClass.getSimpleName.replace("$",""))
  }))
package hsbc.emf.infrastructure.logging.audit

import hsbc.emf.data.logging.MessageInfo

trait ContextInfo{
  val message: MessageInfo
}
package hsbc.emf.infrastructure.io.readers

import hsbc.emf.command.PlaceholderParameterisation
import hsbc.emf.data.crm.{CrmInput, CrmInputRaw}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRwaCrmMessage
import hsbc.emf.infrastructure.exception._
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.services.mapper.CrmInputRawToCrmInputMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import org.apache.spark.sql.{Dataset, SparkSession}

import scala.util.{Failure, Success, Try}

class CrmDataReader(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) {

  def getInput(message: SparkRwaCrmMessage): List[CrmInput] = {
    Try(queryCrmData(message)) match {
      case Success(crmInputList) => crmInputList
      case Failure(exception) =>
        val customMessage = s"CrmDataReader.getInput failed to read CrmInput data from query: ${message.crm_read_sql}: ${exception.getMessage}"
        EmfLogger.error(customMessage)
        throw new EmfCrmReadException(customMessage, exception)
    }
  }

  def queryCrmData(message: SparkRwaCrmMessage): List[CrmInput] = {
    val params = PlaceholderParameters(Map("dataset" -> message.source_dataset, "table" -> message.source_table,
      "approach" -> message.approach.name))
    val sqlToExecute: String = PlaceholderParameterisation.insertParams(params, message.crm_read_sql)
    EmfLogger.debug(s"CrmDataReader.getInput replaced placeholder params in query : ${message.crm_read_sql}" +
      s" to : ${sqlToExecute} get the input data")
    import spark.implicits._
    val crmInputListRaw: Dataset[CrmInputRaw] = new SqlExecutor().execute(sqlToExecute).as[CrmInputRaw]
    if (crmInputListRaw.isEmpty || crmInputListRaw.count() == 0) {
      val customMessage = s"CrmDataReader.getInput returns zero records for query: ${sqlToExecute}"
      EmfLogger.error(customMessage)
      throw new EmfCrmZeroRecordsReturnedException(customMessage)
    }
    CrmInputRawToCrmInputMapper.map(crmInputListRaw.collect().toList)
  }
}
package hsbc.emf.infrastructure.io.writers

import hsbc.emf.data.crm.{CrmOutput, CrmOutputRaw}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.HiveFileFormatConfig
import hsbc.emf.infrastructure.exception.EmfCrmWriteException
import hsbc.emf.infrastructure.helper.HiveUtils
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.services.mapper.CrmOutputToCrmOutputRawMapper
import org.apache.spark.sql.{Dataset, Encoders, SaveMode, SparkSession}

import scala.util.{Failure, Success, Try}

class CrmDataWriter(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) {

  def writeOutput(targetDataset: String, targetTable: String, crmOutputList: List[CrmOutput]): Unit = {
    Try {
      HiveUtils.createDatabase(s"${targetDataset}", None)
      val crmOutputListRaw : List[CrmOutputRaw] = CrmOutputToCrmOutputRawMapper.map(crmOutputList)
      val crmOutputRawEncoder = Encoders.product[CrmOutputRaw]
      val crmOutputs: Dataset[CrmOutputRaw] = spark.createDataset(crmOutputListRaw)(crmOutputRawEncoder)

      val dfWriter = new DataFrameWriterService(HiveFileFormatConfig())
      dfWriter.saveDFAsTable(crmOutputs.toDF(),targetTable, Some(targetDataset), SaveMode.Append, List.empty[String], None, Some(true))
    }
    match {
      case Success(_) => EmfLogger.debug(s"CrmDataWriter.writeOutput wrote CrmOutput data into database : ${targetDataset} and table: ${targetTable} successfully")
      case Failure(exception) =>
        val customMessage = s"CrmDataWriter.writeOutput failed to write CrmOutput data into database : ${targetDataset} and table: ${targetTable} : : ${exception.getMessage}"
        EmfLogger.error(customMessage)
        throw new EmfCrmWriteException(customMessage, exception)
    }
  }
}package hsbc.emf.data.crm

final case class CrmInput(
  uniqueAccountId : String,
  uniqueMitigantId : String,
  undrawnFlag : String,
  crmPriorityOrderSequenceNumber : String,
  creditMitigantValue : Double,
  totalOriginalExposurePreCcf : Double,
  effectiveCrmFactor : Double,
  cstar : Double
)
package hsbc.emf.data.crm

final case class CrmInputRaw(
                              Unique_Account_Id: String,
                              Unique_Mitigant_Id: String,
                              Undrawn_Flag: String,
                              CRM_Priority_Order_Sequence_Number: String,
                              Credit_Mitigant_Value: Double,
                              Total_Original_Exposure_pre_CCF: Double,
                              Effective_CRM_Factor: Double,
                              Cstar: Double
                            )
package hsbc.emf.infrastructure.services.mapper

import hsbc.emf.data.crm.{CrmInput, CrmInputRaw}
import hsbc.emf.infrastructure.exception.EmfCrmInputMapperException

object CrmInputRawToCrmInputMapper extends IMapper[List[CrmInputRaw], List[CrmInput]] {
  @throws(classOf[EmfCrmInputMapperException])
  override def map(crmInputRaw: List[CrmInputRaw]): List[CrmInput] = {
    crmInputRaw match {
      case list: List[CrmInputRaw] => list.map(crmInputRaw => transformCrmInput(crmInputRaw))
      case _ => List.empty
    }
  }

  def transformCrmInput(crmInputRaw: CrmInputRaw): CrmInput = {
    try {
      CrmInput(crmInputRaw.Unique_Account_Id,
        crmInputRaw.Unique_Mitigant_Id,
        crmInputRaw.Undrawn_Flag,
        crmInputRaw.CRM_Priority_Order_Sequence_Number,
        crmInputRaw.Credit_Mitigant_Value,
        crmInputRaw.Total_Original_Exposure_pre_CCF,
        crmInputRaw.Effective_CRM_Factor,
        crmInputRaw.Cstar
      )
    } catch {
      case e: Exception =>
        val customMessage = "CrmInputRawToCrmInputMapper.map fails with other reason: " + e.getMessage
        throw new EmfCrmInputMapperException(customMessage, e)
    }
  }
}
package hsbc.emf.data.crm

final case class CrmOutput(
                             uniqAccountId: String,
                             uniqCrmId: Option[String],
                             undrawnFlag: String,
                             crmPriorityOrderSequenceNumber: Option[String],
                             regulator: Option[String],
                             praReportingApproachFromCrmEngine: String,
                             adjustmentFlag: Option[String],
                             originalExposureCoveredUsd: Double,
                             cbyeRatio: Option[Double],
                             crmEligibleForExposureFlag: String,
                             effectiveCrmAmountAfterEfficiency: Double,
                             effectiveCrmAmountAllocatedUsd: Double,
                             effectiveCrmAmountAvailableUsd: Option[Double],
                             originalExposureNotCovered: Option[Double],
                             comment: Option[String],
                             securedIndicator: String,
                             allocationOrder: Double
                           )
package hsbc.emf.data.crm

final case class CrmOutputRaw(
                               Uniq_Account_Id: String,
                               Uniq_CRM_ID: String,
                               Undrawn_Flag: String,
                               CRM_Priority_Order_Sequence_Number: String,
                               Regulator: String,
                               PRA_Reporting_Approach_From_CRM_Engine: String,
                               Adjustment_Flag: String,
                               Original_Exposure_Covered_USD: Double,
                               CbyE_Ratio: Double,
                               CRM_Eligible_For_Exposure_Flag: String,
                               Effective_CRM_Amount_After_Efficiency: Double,
                               Effective_CRM_Amount_Allocated_USD: Double,
                               Effective_CRM_Amount_Available_USD: Double,
                               Original_Exposure_not_covered: Double,
                               Comment: String,
                               Secured_Indicator: String,
                               Allocation_Order: Double
                             )package hsbc.emf.infrastructure.services.mapper


import hsbc.emf.data.crm.{CrmOutput, CrmOutputRaw}
import hsbc.emf.infrastructure.exception.EmfCrmOutputMapperException

object CrmOutputToCrmOutputRawMapper extends IMapper[List[CrmOutput], List[CrmOutputRaw]] {
  @throws(classOf[EmfCrmOutputMapperException])
  override def map(crmOutput: List[CrmOutput]): List[CrmOutputRaw] = {
    crmOutput match {
      case list: List[CrmOutput] => list.map(crmOutput => transformCrmOutput(crmOutput))
      case _ => List.empty
    }
  }

  def bigDecimalFormatter(x: Double) = BigDecimal(x).setScale(6, BigDecimal.RoundingMode.HALF_UP).toDouble

  def bigDecimalFormatter(x: Option[Double]):Option[Double] = Some(BigDecimal(x.getOrElse(0.0)).setScale(6, BigDecimal.RoundingMode.HALF_UP).toDouble)


  def transformCrmOutput(crmOutput: CrmOutput): CrmOutputRaw = {
    try {
      CrmOutputRaw(crmOutput.uniqAccountId,
        crmOutput.uniqCrmId.orNull,
        crmOutput.undrawnFlag,
        crmOutput.crmPriorityOrderSequenceNumber.orNull,
        crmOutput.regulator.orNull,
        crmOutput.praReportingApproachFromCrmEngine,
        crmOutput.adjustmentFlag.orNull,
        bigDecimalFormatter(crmOutput.originalExposureCoveredUsd),
        bigDecimalFormatter(crmOutput.cbyeRatio.getOrElse(0.0)),
        crmOutput.crmEligibleForExposureFlag,
        bigDecimalFormatter(crmOutput.effectiveCrmAmountAfterEfficiency),
        bigDecimalFormatter(crmOutput.effectiveCrmAmountAllocatedUsd),
        bigDecimalFormatter(crmOutput.effectiveCrmAmountAvailableUsd.getOrElse(0.0)),
        bigDecimalFormatter(crmOutput.originalExposureNotCovered.getOrElse(0.0)),
        crmOutput.comment.orNull,
        crmOutput.securedIndicator,
        bigDecimalFormatter(crmOutput.allocationOrder)
      )
    } catch {
      case e: Exception =>
        val customMessage = "CrmOutputRawToCrmOutputMapper.map fails with other reason: " + e.getMessage
        throw new EmfCrmOutputMapperException(customMessage, e)
    }
  }
}
package hsbc.emf.infrastructure.io.writers

import hsbc.emf.infrastructure.config.CsvFileFormatConfig

import org.apache.spark.sql.{DataFrame, DataFrameWriter, Row}

case class CsvDataFrameWriter(fileFormat: CsvFileFormatConfig) extends EmfDataFrameWriter(fileFormat) {
  override def getWriter(input: DataFrame): DataFrameWriter[Row] = {
    super.getWriter(input)
      .option("delimiter", fileFormat.delimiter)
      .option("quote", fileFormat.quoteCharacter)
      .option("header", fileFormat.printHeader)
      .options(
        // fix for FCCC-10692 to populate empty string instead of null for nullValue
        //        Map("nullValue" -> "null",
        Map("nullValue" -> "",
          "emptyValue" -> "",
          "ignoreLeadingWhiteSpace" -> "false",
          "ignoreTrailingWhiteSpace" -> "false")
      )
  }
}
package hsbc.emf.infrastructure.io.writers

import hsbc.emf.data.{SparkAllDataType, SparkCSVAllDataType}
import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode

import scala.io.Source

class CsvDataFrameWriterTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  "given a test dataframe to the ParquetDataFrameWriter.getWriter with CsvFileFormatConfig" should "return a csv DataFrameWriter[Row]" in {
    val testDfCsv = Seq(1, 2, 3, 4).toDF()
    val tempTableName = "testDfCsv"
    val csvDataFrameWriter = new CsvDataFrameWriter(CsvFileFormatConfig())
    val dfWriter = csvDataFrameWriter.getWriter(testDfCsv)
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    val location = spark.conf.get("spark.sql.warehouse.dir") + s"/$tempTableName"
    dfWriter.mode(SaveMode.Overwrite).save(location)
    // read file from the table root path using avro format
    val savedDf = spark.read.csv(location)
    // testDfAvro should match with the savedDf
    assert(savedDf.except(testDfCsv).count() == 0)
  }

  "FCCC-10692: given a dataframe with null field" should "save to disk with empty string for null fields" in {
    // 1. cover all CSV supported spark field types listed in https://spark.apache.org/docs/2.4.5/sql-reference.html#data-types
    val row1 = SparkCSVAllDataType("row1")
    val testDfCsv = Seq(row1).toDF()
    val tempTableName = "testCsvWriter_EmptyFields"

    // 2. write the dataframe to given location
    val csvFileFormatConfig = CsvFileFormatConfig()
    val csvDataFrameWriter = new CsvDataFrameWriter(csvFileFormatConfig)
    val dfWriter = csvDataFrameWriter.getWriter(testDfCsv)
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true") //set it for junit rerun purpose to avoid "the associated location already exists" exception
    val location = spark.conf.get("spark.sql.warehouse.dir") + s"/$tempTableName"
    dfWriter.mode(SaveMode.Overwrite).save(location)
    // read file from the table root path using avro format
    val savedDf = spark.read.format("csv").options(Map("header" -> "false", "delimiter" -> s"${csvFileFormatConfig.delimiter}")).schema(SparkCSVAllDataType.schema).load(location)
    // debug: testDfCsv.show(false)
    // debug: savedDf.show(false)

    // 3. assertion: testDfCsv should match with the savedDf
    assert(savedDf.except(testDfCsv).count() == 0)

    // 4. assertion: null fields in dataframe should written in disk with empty value
    // wrong CSV writtern format: A|B|null|D
    // exepected CSV written format: A|B||D
    import reflect.io._
    import Path._
    s"$location".toDirectory.files.map(_.path).filter(name => name.endsWith(".csv")).foreach(x => {
      val dataLine = Source.fromFile(s"$x").getLines().toList(0)
      val dataLineColumns = dataLine.split(s"\\${csvFileFormatConfig.delimiter}", -1)
      // assert for empty DecimalType_Field
      assert("".equals(dataLineColumns(7)))
      // assert for empty StringType_Field
      assert("".equals(dataLineColumns(8)))
      // assert for empty TimestampType_Field
      assert("".equals(dataLineColumns(10)))
      // assert for empty DateType_Field
      assert("".equals(dataLineColumns(11)))
    }
    )
  }
}package hsbc.emf.infrastructure.io.readers

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.infrastructure.helper.FileUtility
import hsbc.emf.infrastructure.logging.EmfLogger.{debug, error}
import hsbc.emf.infrastructure.logging.MessageContext
import org.apache.hadoop.fs.Path

import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.functions.monotonically_increasing_id
import org.apache.spark.sql.types.StructType

class CsvFileReaderToDF(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends IFileReader[CsvFileFormatConfig, DataFrame] with MessageContext {

  @throws(classOf[EmfIoException])
  def read(fileFormatConfig: CsvFileFormatConfig, fileLocation: String, schema: Option[StructType], modeFailfast: Boolean = false): DataFrame = {
    try {
      debug(s"Starting reading ${fileFormatConfig.format} files from $fileLocation")
      var headerValue="false"
      if (fileFormatConfig.skipRows > 0) {
        // if skipRows set >0 ,set the show header as true, that means the first row data is header
        headerValue="true"
      }
      debug(s"show header value set as $headerValue")
      val fs = FileUtility.getFileSystem(fileLocation)
      val filePaths = fs.listStatus(new Path(s"$fileLocation"))
      filePaths
        .filter(_.getPath.toString.endsWith(fileFormatConfig.format))
        .map(csvFilePath => {
          val dataFrameCsv = schema match {
            case None => spark.read.format(fileFormatConfig.format)
              .options(Map("header" -> headerValue, "delimiter" -> fileFormatConfig.delimiter,
                "quote" -> fileFormatConfig.quoteCharacter, "multiLine" -> fileFormatConfig.multipleLine))
              .load(csvFilePath.getPath.toString)
            case _ => var optionsMap: Map[String, String] = Map("header" -> headerValue, "delimiter" -> fileFormatConfig.delimiter,
              "quote" -> fileFormatConfig.quoteCharacter, "multiLine" -> fileFormatConfig.multipleLine)
              if (modeFailfast)
                optionsMap = optionsMap ++ Map("mode" -> "FAILFAST","treatEmptyValuesAsNulls" -> "true", "nullValue" -> null)
              spark.read.format(fileFormatConfig.format).schema(schema.get).options(optionsMap).load(csvFilePath.getPath.toString)
          }
          // if the option "header" -> "true", the first line will treat as header, will not count into row.
          if (fileFormatConfig.skipRows > 1) {
            debug(s"Skipping ${fileFormatConfig.skipRows} lines from ${csvFilePath.getPath} ")
            dataFrameCsv.withColumn("__index__", monotonically_increasing_id())
              .filter(s"__index__ > ${fileFormatConfig.skipRows}-2")
              .drop("__index__")
          }
          else {
            dataFrameCsv
          }
        })
        .reduce(_ union _)
    } catch {
      case e: Throwable =>
        error(s"Encountered issue while reading ${fileFormatConfig.format} files from $fileLocation.Error Message - ${e.getMessage}")
        throw new EmfIoException(e.getMessage, e.getCause)

    }
  }
}
package hsbc.emf.infrastructure.helper


import hsbc.emf.infrastructure.exception.EmfIncompatibleSchemaException
import org.apache.avro.{LogicalTypes, Schema, SchemaBuilder}
import org.apache.spark.sql.types._
object CustomSchemaConverters {
  private lazy val nullSchema = Schema.create(Schema.Type.NULL)

  case class SchemaType(dataType: DataType, nullable: Boolean)

  def toAvroType(
                  catalystType: DataType,
                  nullable: Boolean = false,
                  recordName: String = "topLevelRecord",
                  nameSpace: String = "")
  : Schema = {
    val builder = SchemaBuilder.builder()

    val schema = catalystType match {
      case BooleanType => builder.booleanType()
      case ByteType | ShortType | IntegerType => builder.intType()
      case LongType => builder.longType()
      case DateType => builder.intType()
      case TimestampType => builder.longType()

      case FloatType => builder.floatType()
      case DoubleType => builder.doubleType()
      case StringType => builder.stringType()
      case d:DecimalType =>
        val avroType = LogicalTypes.decimal(d.precision, d.scale)
        avroType.addToSchema(SchemaBuilder.builder.bytesType())

      case BinaryType => builder.bytesType()
      case ArrayType(et, containsNull) =>
        builder.array()
          .items(toAvroType(et, containsNull, recordName, nameSpace))
      case MapType(StringType, vt, valueContainsNull) =>
        builder.map()
          .values(toAvroType(vt, valueContainsNull, recordName, nameSpace))
      case st: StructType =>
        val childNameSpace = if (nameSpace != "") s"$nameSpace.$recordName" else recordName
        val fieldsAssembler = builder.record(recordName).namespace(nameSpace).fields()
        st.foreach { f =>
          val fieldAvroType =
            toAvroType(f.dataType, f.nullable, f.name, childNameSpace)
          fieldsAssembler.name(f.name).`type`(fieldAvroType).noDefault()
        }
        fieldsAssembler.endRecord()
      case other => throw new EmfIncompatibleSchemaException(s"Unexpected type $other.")
    }
    if (nullable) {
      Schema.createUnion(schema, nullSchema)
    } else {
      schema
    }
  }
}
package hsbc.emf.infrastructure.serde

import java.sql.Timestamp

import org.json4s.CustomSerializer
import org.json4s.JsonAST.{JNull, JString}

case object CustomTimestampSerializer extends CustomSerializer[Timestamp](format =>
  ({
    case JString(x) => Timestamp.valueOf(x.toString)
    case JNull => null
  },
    {
      case date: Timestamp => JString(date.toString)
    }))
package hsbc.emf.service.orchestration

import scala.util.{Failure, Success, Try}

import hsbc.emf.command.ISparkCommand
import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.exception.EmfDagExecutionException
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit._
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import org.apache.spark.sql.SparkSession

class DagExecutor(sparkRunMessage: SparkRunMessage, sparkRunPlaceholderParameters: PlaceholderParameters)(implicit val messageInfo: MessageInfo)
  extends IDagExecutor with MessageContext {

  override def executeDag(sparkCommandsSplitByDependency: Seq[Seq[ISparkCommand]])(implicit sparkSession: SparkSession): ExecutionResult = {
    EmfLogger.info(s"Starting workflow ${sparkRunMessage.workflow} DAG execution")
    Try {
      var workflowFailed = false
      for (sparkCommands <- sparkCommandsSplitByDependency if !workflowFailed) {
        sparkCommands.par.foreach {
          sparkCommand =>
            val commandMessage: MessageInfo = sparkCommand._messageInfo
            val taskPrintString = s"Workflow=${commandMessage.workflow}, OrderId=${commandMessage.orderId}"
            EmfLogger.info(s"Executing Task : [$taskPrintString]")(commandMessage)
            //Message State Audit logging - set state to ACTIVE
            AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, InProgress))
            val executionResult = sparkCommand.run()
            executionResult match {
              case Failed =>
                EmfLogger.error(s"Task [$taskPrintString] execution failed. Skipping further execution.")(commandMessage)
                workflowFailed = true  // Continue to keep this to minimize the changes. There should be no data race in
                                       // this case (as workflowFailed is not read nor set to different values in foreach).
                AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Fail))

              case _ =>
                EmfLogger.info(s"Task [$taskPrintString] executed successfully")(commandMessage)
                AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Finish))
          }
        }
      }
      if (workflowFailed) Failed else Complete
    } match {
      case Success(executionResult) => executionResult
      case Failure(exception) =>
        throw new EmfDagExecutionException(s"DagExecutor failed to execute workflow ${sparkRunMessage.workflow}", exception)
    }
  }
}
package hsbc.emf.service.orchestration

import java.sql.Timestamp

import hsbc.emf.command.ISparkCommand
import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.exception.EmfDagExecutionException
import hsbc.emf.infrastructure.logging.MessageContextTestData
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class DagExecutorTest extends IntegrationTestSuiteBase with MockFactory with MessageContextTestData {

  private def fixture = new {
    val sparkRunMessage = SparkRunMessage("test-workflow", List.empty, new Timestamp(System.currentTimeMillis))
    val params: PlaceholderParameters = PlaceholderParameters(Map("run_uuid" -> "testing_run_uuid"))
    val testMessageInfo: MessageInfo = MessageInfo("test-run-uuid", "test-workflow", "order-id", "test-command", "test-parameters", parent = List.empty)
  }

  "Call executeDag() with set of commands, ISparkCommand.run()" should "called 2 times" in {
    val command: ISparkCommand = mock[ISparkCommand]
    command._messageInfo = fixture.testMessageInfo
    (command.run _).expects().returning(Complete).twice()
    val workflow = Seq(Seq(command, command))
    val result = new DagExecutor(fixture.sparkRunMessage, fixture.params).executeDag(workflow)
    assert(result == Complete)
  }

  "Call executeDag() with set of commands which fail to execute. ISparkCommand.run()" should "called only once. Rest command run will be skipped" in {
    val command: ISparkCommand = mock[ISparkCommand]
    command._messageInfo = fixture.testMessageInfo
    (command.run _).expects().returns(Failed).once()
    val workflow = Seq(Seq(command), Seq(command), Seq(command))
    val result = new DagExecutor(fixture.sparkRunMessage, fixture.params).executeDag(workflow)
    assert(result == Failed)
  }

  "Call executeDag() with three commands. Second command in list failed to execute. ISparkCommand.run()" should " called 2 times" in {
    val command1: ISparkCommand = mock[ISparkCommand]
    command1._messageInfo = fixture.testMessageInfo
    (command1.run _).expects().returns(Complete).once()
    val command2: ISparkCommand = mock[ISparkCommand]
    command2._messageInfo = fixture.testMessageInfo
    (command2.run _).expects().returns(Failed).once()
    val command3: ISparkCommand = mock[ISparkCommand]
    (command3.run _).expects().never()
    val workflow = Seq(Seq(command1), Seq(command2), Seq(command3))
    val result = new DagExecutor(fixture.sparkRunMessage, fixture.params).executeDag(workflow)
    assert(result == Failed)
  }

  "Call executeDag() with 2 commands. runtime exception thrown for first command execution. ISparkCommand.run()" should "throws exception" in {
    val command1: ISparkCommand = mock[ISparkCommand]
    command1._messageInfo = fixture.testMessageInfo
    (command1.run _).expects().throwing(new RuntimeException("runtimeexception during command execution"))
    val command2: ISparkCommand = mock[ISparkCommand]
    (command2.run _).expects().never()
    val workflow = List(Seq(command1), Seq(command2))
    val thrown = intercept[Exception] {
      new DagExecutor(fixture.sparkRunMessage, fixture.params).executeDag(workflow)
    }
    assert(thrown.getCause.getMessage == "runtimeexception during command execution")
    assert(thrown.getCause.isInstanceOf[RuntimeException])
    assert(thrown.getMessage === "DagExecutor failed to execute workflow test-workflow")
    assert(thrown.isInstanceOf[EmfDagExecutionException])
  }

  "Call executeDag() with 3 groups of commands, each have 2 commands in parallel. 1 command in 2nd group failed. ISparkCommand.run()" should
    "called 4 times" in {
    val command1a: ISparkCommand = mock[ISparkCommand]
    command1a._messageInfo = fixture.testMessageInfo
    (command1a.run _).expects().returns(Complete).once()
    val command1b: ISparkCommand = mock[ISparkCommand]
    command1b._messageInfo = fixture.testMessageInfo
    (command1b.run _).expects().returns(Complete).once()
    val command2a: ISparkCommand = mock[ISparkCommand]
    command2a._messageInfo = fixture.testMessageInfo
    (command2a.run _).expects().returns(Failed).once()
    val command2b: ISparkCommand = mock[ISparkCommand]
    command2b._messageInfo = fixture.testMessageInfo
    (command2b.run _).expects().returns(Failed).once()
    val command3a: ISparkCommand = mock[ISparkCommand]
    (command3a.run _).expects().never()
    val command3b: ISparkCommand = mock[ISparkCommand]
    (command3b.run _).expects().never()
    val workflow = Seq(Seq(command1a, command1b), Seq(command2a, command2b), Seq(command3a, command3b))
    val result = new DagExecutor(fixture.sparkRunMessage, fixture.params).executeDag(workflow)
    assert(result == Failed)
  }
}package hsbc.emf.infrastructure.helper

import hsbc.emf.infrastructure.config.EmfConfig
import org.apache.spark.sql.catalyst.encoders.RowEncoder
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.{DataFrame, Row, SparkSession}

object DataFrameUtils  {
  def coalesceColumnsLoadDataFrameWithSchema(df: DataFrame, schema: StructType) (implicit spark: SparkSession) : DataFrame = {
    import spark.implicits._
    // coalesce columns
    val coalescedColumns = df.columns.groupBy( _.toLowerCase )
      .map(t => coalesce(t._2.map(col):_*).as(t._1)).toArray

    val dfWithCoalescedColumns =  df.select( coalescedColumns: _*)
    val jsonValues: List[String] = dfWithCoalescedColumns.select(to_json(struct(col("*"))).alias("value")).select("value").as[String].collect().toList
    val dataSet = spark.createDataset(jsonValues)
    val repairDf = repairCorruptDataFrameBySchema(dataSet.toDF(), schema)
    spark.read.schema(schema).json(repairDf.map(row => row.get(0).toString))
  }

  def cleanCorruptRow(sourceDf: DataFrame): DataFrame = {

    if (sourceDf.columns.contains(EmfConfig.columnNameOfCorruptRecord)) {
      val repairColumnName = "REPAIRED_COLUMN"
      val corruptDf = sourceDf.filter(col(EmfConfig.columnNameOfCorruptRecord).isNotNull).cache()
        .select(col(EmfConfig.columnNameOfCorruptRecord).as(repairColumnName)).cache()
      val filteredDf = sourceDf.filter(col(EmfConfig.columnNameOfCorruptRecord).isNull).drop(EmfConfig.columnNameOfCorruptRecord)

      var repairDf = repairCorruptDataFrameBySchema(corruptDf, filteredDf.schema)

      repairDf = repairDf.withColumn(repairColumnName, from_json(col(repairColumnName), filteredDf.schema)).cache()
      repairDf = repairDf.select(s"$repairColumnName.*")
      filteredDf.union(repairDf).cache()
    } else {
      sourceDf
    }
  }

  def repairCorruptDataFrameBySchema(corruptDf: DataFrame, schema: StructType): DataFrame = {
    val delimiter = "."
    val splitDelimiter = "\\."
    val cleanItems = SchemaUtility.getCanUnquoteFieldNameByType(schema, delimiter)
    corruptDf.map(row => {
      var json = row.get(0).toString
      for (item <- cleanItems) {
        json = StringUtils.removeQuotesMatchByRegex(item, json, delimiter, splitDelimiter)
      }
      Row(json)
    }) (RowEncoder(corruptDf.schema))

  }
}
package hsbc.emf.infrastructure.helper

import hsbc.emf.infrastructure.config.{JsonFileFormatConfig}
import hsbc.emf.infrastructure.io.readers._
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.types._
import java.io._

case class tesArrayType(attribute: String, num: Long, child_array_type: List[Long])
case class testStructType(attribute: String, num: Long)
case class testData(string_type: String, binary_type: Boolean,
                      numeric_type: Double, float_type: Float,
                      long_type: Long, int_type: Integer,
                      array_type1: List[tesArrayType], array_type2: List[Long],
                      struct_type: testStructType)

class DataFrameUtilsTest extends IntegrationTestSuiteBase {

  "DataFrameUtilsTest: case type mismatch: given schema with case mismatch" should "load data correct" in {
    val actualDF = spark.read.json("tests/hsbc/emf/testingFiles/data/json/sample1.json")
    val config = JsonFileFormatConfig()
    val schema = StructType(List(StructField("key", IntegerType), StructField("value", StringType)))
    val dataFrameJson = SparkFileReaderService(config).read(config, "tests/hsbc/emf/testingFiles/data/json/", None)
    assert(dataFrameJson.count == 2)
    val fixedDf = DataFrameUtils.coalesceColumnsLoadDataFrameWithSchema(dataFrameJson, schema)
    assert(actualDF.except(fixedDf).count == 0)
  }

  "Repair Corrupt Data Frame By Schema" should "return correct schema" in {
    import spark.implicits._

    val jsonValues: List[String] = List(
      """
        | {"string_type":"test","binary_type":"true","numeric_type":"1.23","float_type":"1.23","long_type":"123","int_type":"123","array_type1":[{"attribute":"att1","num":"1","child_array_type":["1","3"]},{"attribute":"att1","num":2,"child_array_type":["1",2,3]}],"array_type2":["1",3],"struct_type":{"attribute":"att1","num":"1"}}
      """.stripMargin,
      """
        | {"string_type":"test","binary_type":"false","numeric_type":"-1.23","float_type":"-1.23","long_type":"-123","int_type":"-123","array_type1":[{"attribute":"att1","num":"-1","child_array_type":["-1","-3"]},{"attribute":"att1","num":"-2","child_array_type":["-1",-2,-3]}],"array_type2":["-1",-3],"struct_type":{"attribute":"att1","num":"-1"}}
      """.stripMargin
    )
    val schema = StructType(List(
      StructField("string_type", StringType, true),
      StructField("binary_type", BooleanType, false),
      StructField("numeric_type", DoubleType, false),
      StructField("float_type", FloatType, false),
      StructField("long_type", LongType, false),
      StructField("int_type", IntegerType, true),
      StructField("array_type1", ArrayType(StructType( List(
        StructField("attribute", StringType),
        StructField("num", LongType, false),
        StructField("child_array_type", ArrayType(LongType,false))
      )))),
      StructField("array_type2", ArrayType(LongType,false)),
      StructField("struct_type", StructType( List(
        StructField("attribute", StringType),
        StructField("num", LongType, false))))
    ))
    val dataSet = spark.createDataset(jsonValues)
    val repairStringDf = DataFrameUtils.repairCorruptDataFrameBySchema(dataSet.toDF(), schema)
    val repairDf = spark.read.schema(schema).json(repairStringDf.map(row => row.get(0).toString))

    val expectedDF = Seq(
      testData("test", true, 1.23, 1.23f, 123, 123, List(tesArrayType("att1",1,List(1,3)), tesArrayType("att1",2,List(1, 2, 3))),List(1,3),testStructType("att1",1)),
      testData("test", false, -1.23, -1.23f, -123, -123, List(tesArrayType("att1",-1,List(-1,-3)), tesArrayType("att1", -2, List(-1, -2, -3))),List(-1,-3),testStructType("att1",-1))
    ).toDF()
    assert(repairDf.except(expectedDF).isEmpty)
  }

}package hsbc.emf.infrastructure.helper

import hsbc.emf.data.ingestion.SchemaItem
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.exception.EmfDataFrameTypeCastException
import hsbc.emf.infrastructure.logging.EmfLogger

import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.functions._


object DataFrameValueHandler {

  def appendRowUUID(dataFrame: DataFrame): DataFrame = {
    val uuid = udf(() => java.util.UUID.randomUUID().toString)
    dataFrame.withColumn("__uuid", uuid())
  }

  def cleanAndCastTimeStampAndDate(fileTypeSchemaItems: List[SchemaItem], sourceDF: DataFrame)(implicit messageInfo: MessageInfo): DataFrame = {
    var finalDF = sourceDF
    val replacePattern = " UTC"
    try {
      fileTypeSchemaItems.foreach(f =>
        f.`type`.toUpperCase match {
          case "TIMESTAMP" | "DATETIME" | "DATE" => {
            if (f.mode.getOrElse("").equalsIgnoreCase("REPEATED")) {
              finalDF = replaceArrayColValue(finalDF, f.name, replacePattern, f.`type`.toUpperCase)
            } else {
              finalDF = replaceColValue(finalDF, f.name, replacePattern, f.`type`.toUpperCase)
            }
          }
          case "RECORD" => {
            f.fields match {
              case Some(subfields) =>
                if (f.mode.getOrElse("").equalsIgnoreCase("REPEATED")) {
                  subfields.foreach(subf => {
                    subf.`type`.toUpperCase match {
                      case "TIMESTAMP" | "DATETIME" | "DATE" => {
                        val columnsAll = finalDF.columns.map(m => col(m))
                        val subCols = finalDF.select(explode(col(f.name)).alias("explode")).select("explode.*")
                          .columns.map(colname => col(colname))
                        val exporeArrayDF = finalDF.select(columnsAll :+ explode(col(f.name)).alias(s"explode_${f.name}"): _*)
                        val exporeStructDF = exporeArrayDF.select("*", s"explode_${f.name}.*")
                        finalDF = cleanAndCastTimeStampAndDate(subfields, exporeStructDF)
                        finalDF = finalDF.withColumn(s"replaced_${f.name}", struct(subCols: _*))
                        finalDF = finalDF.groupBy(columnsAll: _*).agg(collect_list(s"replaced_${f.name}")
                          .alias(s"list_replaced_${f.name}"))
                        finalDF = finalDF.drop(f.name).withColumnRenamed(s"list_replaced_${f.name}", f.name)
                        finalDF = finalDF.select(columnsAll: _*)
                      }
                      case _ =>
                    }
                  }
                  )
                }
                else {
                  subfields.foreach(subf => {
                    subf.`type`.toUpperCase match {
                      case "TIMESTAMP" | "DATETIME" | "DATE" => {
                        val columnsAll = finalDF.columns.map(m => col(m))
                        val subCols = finalDF.select(s"${f.name}.*").columns.map(colname => col(colname))
                        val exporeDF = finalDF.select("*", s"${f.name}.*")
                        finalDF = cleanAndCastTimeStampAndDate(subfields, exporeDF)
                        finalDF = finalDF.withColumn(s"replaced_${f.name}", struct(subCols: _*))
                        finalDF = finalDF.drop(f.name).withColumnRenamed(s"replaced_${f.name}", f.name)
                        finalDF = finalDF.select(columnsAll: _*)
                      }
                      case _ =>
                    }
                  }

                  )

                }
              case None => EmfLogger.info(s"no sub fields in ${f.name} record field")
            }
          }
          case _ =>
        }
      )
      finalDF.select(sourceDF.columns.head, sourceDF.columns.tail: _*)
    }
    catch {
      case e: Exception =>
        val customMessage = "DataFrameValueHandler.cleanAndCastTimeStampAndDate cannot cast to TimeStamp or Date"
        throw new EmfDataFrameTypeCastException(s"$customMessage", e)
    }
  }

  def replaceStructCol(df: DataFrame, structFeildName: String, structFeildDF: DataFrame): DataFrame = {
    val replaced = df.union(structFeildDF.alias("replaced")).drop(structFeildName)
    replaced.withColumnRenamed("replaced", structFeildName)
  }

  def replaceArrayColValue(df: DataFrame, arrayFeildName: String, replacePattern: String, dataType: String): DataFrame = {
    val elements = df.withColumn("elements", explode(col(s"$arrayFeildName")))
    val replaced = replaceColValue(elements, s"elements", replacePattern, dataType)
    val columnsAll = df.columns.map(m => col(m))
    val solution = replaced.groupBy(columnsAll: _*).agg(collect_list("elements") as "after")
    val finalDF = solution.drop(s"$arrayFeildName").withColumnRenamed("after", arrayFeildName)
    finalDF
  }

  def replaceColValue(df: DataFrame, colName: String, replacePattern: String, dataType: String): DataFrame = {
    dataType.toUpperCase match {
      case "TIMESTAMP" | "DATETIME" => df.withColumn(colName, to_utc_timestamp(regexp_replace(col(colName),
        replacePattern, ""), "UTC"))
      case "DATE" => df.withColumn(colName, to_date(col(colName)))
    }
  }

}package hsbc.emf.infrastructure.helper

import hsbc.emf.data.ingestion.SchemaItem
import hsbc.emf.service.ingestion.data.DummyFileType
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class DataFrameValueHandlerTest extends IntegrationTestSuiteBase {
  override def beforeAll(): Unit = {
    super.beforeAll()
  }

  override def afterAll(): Unit = {
    spark.sql("DROP TABLE IF EXISTS replace_utc_value_table")
    super.afterAll()
  }

  val subfieldsF2 = List(
    new SchemaItem(None, "sub_field", "TIMESTAMP", None),
    new SchemaItem(None, "sub_date_field", "DATE", None),
    new SchemaItem(None, "component_key_expression", "STRING", None))

  val ssfF3 = List(
    new SchemaItem(None, "ssf1", "STRING", None),
    new SchemaItem(None, "ssf2", "TIMESTAMP", None),
    new SchemaItem(None, "ssf2_date", "DATE", None))

  val subfieldsF3 = List(
    new SchemaItem(None, "sub_field1", "TIMESTAMP", None),
    new SchemaItem(None, "sub_field2", "RECORD", Some(ssfF3)))

  val schema = List(
    new SchemaItem(None, "test_field", "TIMESTAMP", None),
    new SchemaItem(None, "test_date_field1", "DATE", None),
    new SchemaItem(Some("REPEATED"), "test_field2", "RECORD", Some(subfieldsF2)),
    new SchemaItem(None, "test_field3", "RECORD", Some(subfieldsF3)),
    new SchemaItem(Some("REPEATED"), "test_field4", "TIMESTAMP", None),
    new SchemaItem(Some("REPEATED"), "test_date_field4", "DATE", None)
  )

  it should "append __uuid column and populate it with diff uuid per row" in {
    import spark.implicits._
    val preDF = Seq(DummyFileType("fld1", 1), DummyFileType("fld2", 2), DummyFileType("fld3", 3)).toDF
    val postDF = DataFrameValueHandler.appendRowUUID(preDF)
    assert(postDF.schema.fieldIndex("__uuid") > 0)
    assert(postDF.select("__uuid").distinct.collect().size == 3)
  }

  it should s"replace UTC value when given schema item list with nested fields whose timestamp fileds with UTC" in {
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    val path = "tests/hsbc/emf/testingFiles/helper/dataFrameValueHandler/test_file_ts.json"
    val df = spark.read.json(path)
    val finalDF = DataFrameValueHandler.cleanAndCastTimeStampAndDate(schema, df)
    val expectedDFPath = "tests/hsbc/emf/testingFiles/helper/dataFrameValueHandler/test_file_ts_expected.json"
    val expectedDF = spark.read.json(expectedDFPath)
    val df_diff = expectedDF.exceptAll(finalDF)
    assert(df_diff.count() == 0)
  }

}package hsbc.emf.infrastructure.io.writers

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.EmfDataFrameWriterException
import hsbc.emf.infrastructure.helper.HiveUtils
import hsbc.emf.infrastructure.logging.EmfLogger.{debug, error, info}
import hsbc.emf.infrastructure.logging.MessageContext
import org.apache.spark.sql._
import org.apache.spark.sql.{DataFrame, DataFrameWriter, Row, SaveMode}

final class DataFrameWriterService[T <: FileFormatConfig](fileFormat: T)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo = null) extends IDataFrameWriterService with MessageContext {

  val dfWriter = DataFrameWriterService.apply(fileFormat)


  def save(dataFrame: DataFrame, fileCfsConfig: FileCfsConfig, mode: SaveMode = SaveMode.Append): Unit = {
    val dataFrameWriter = fileCfsConfig.numberOfFiles match {
      case None => this.dfWriter.getWriter(dataFrame)
      case Some(numPartitions) => this.dfWriter.getWriter(dataFrame.repartition(numPartitions))
    }
    dataFrameWriter.mode(mode).partitionBy(fileCfsConfig.partition: _*).save(fileCfsConfig.fileLocation)
    debug(s"${fileCfsConfig.numberOfFiles.getOrElse("")} ${fileFormat.format} files written successfully to ${fileCfsConfig.fileLocation}".trim)
  }

  def saveDFAsTable(dataFrame: DataFrame, tableName: String, databaseName: Option[String], mode: SaveMode = SaveMode.Append, partitions: List[String] = List.empty, location: Option[String] = None, external: Option[Boolean] = Some(false), createTableCommandFlow:Boolean = false): Unit = {

    if (!spark.catalog.tableExists(databaseName.getOrElse("default"), tableName)) {

      HiveUtils.createTableForDataFrame(fileFormat, dataFrame, databaseName, tableName, partitions, location, external, createTableCommandFlow)
    }
    // The below insertInto api changes is made for FCCC-11122
    // Noted. InsertInto requires that the schema of the DataFrame is the same as the schema of the table.
    dataFrame.write.format("hive").mode(mode).insertInto(s"${databaseName.getOrElse("default")}.${tableName}")

    info(s"$tableName is successfully saved. Save mode is $mode.")

    info(s"analyze table for $tableName started")
    HiveUtils.analyzeTable(databaseName.getOrElse("default"),tableName)
    info(s"analyze table for $tableName ended")

  }

  override def saveDFIntoTable(dataFrame: DataFrame, tableName: String, databaseName: String, mode: SaveMode, partitions: List[String]): Unit = {
    if (!spark.catalog.tableExists(databaseName, tableName)) {
      val customMsg = s"Required table ${databaseName}.${tableName} does not exist!!"
      error(customMsg)
      throw new EmfDataFrameWriterException(customMsg)
    } else {
      val targetOrderColumn = spark.table(s"${databaseName}.${tableName}").columns
      val reorderedDataFrame = dataFrame.select(targetOrderColumn.head, targetOrderColumn.tail: _*)
      val dataFrameWriter = this.dfWriter.getWriter(reorderedDataFrame)
      dataFrameWriter.mode(mode).insertInto(s"${databaseName}.${tableName}")
      info(s"data is successfully insert into ${databaseName}.${tableName}")
    }
  }
}

object DataFrameWriterService {

  def apply[T <: FileFormatConfig](fileFormat: T): EmfDataFrameWriter[T] = fileFormat match {
    // if T is a `CsvFileFormatConfig` it's a special case othewise create a vanilla IDataFrameWriter instance
    case csvFileFormat: CsvFileFormatConfig => new EmfDataFrameWriter[T](fileFormat) {
      override def getWriter(input: DataFrame): DataFrameWriter[Row] = CsvDataFrameWriter.apply(csvFileFormat).getWriter(input)
    }
    case _ => new EmfDataFrameWriter[T](fileFormat) {}
  }

}
package hsbc.emf.infrastructure.io.writers

import java.io.File

import hsbc.emf.infrastructure.config._
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode

final class DataFrameWriterServiceTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  "given a AvroFileFormatConfig and a Dataframe " should "write to Avro format" in {
    //create a test avro DF
    val testDfAvro = Seq(1, 2, 3, 4).toDF()
    val tempTableName = "testDfAvro2"
    val location = spark.conf.get("spark.sql.warehouse.dir") + s"/$tempTableName"

    // write to disk using `DataFrameWriterService`
    val avroFileFormatConfig = AvroFileFormatConfig()
    DataFrameWriterService.apply(avroFileFormatConfig).getWriter(testDfAvro).mode("overwrite").save(location)

    // read file from the table root path using avro format
    val savedDf = spark.read.format("avro").load(location)
    // testDfAvro should match with the savedDf
    assert(savedDf.except(testDfAvro).count() == 0)

  }

  "given a AvroFileFormatConfig to the constructor" should "return a Avro File Format type of dfWriter" in {
    val writerService = new DataFrameWriterService(AvroFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[AvroFileFormatConfig]])
  }

  "given a CsvFileFormatConfig to the constructor" should "return a CsvDataFrameWriter type of dfWriter" in {
    val writerService = new DataFrameWriterService(CsvFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[CsvFileFormatConfig]])
  }

  "given a JsonFileFormatConfig to the constructor" should "return a Json File Format type of dfWriter" in {
    val writerService = new DataFrameWriterService(JsonFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[JsonFileFormatConfig]])
  }

  "given a OrcFileFormatConfig to the constructor" should "return a Orc File Format type of dfWriter" in {
    val writerService = new DataFrameWriterService(OrcFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[OrcFileFormatConfig]])
  }

  "given a ParquetFileFormatConfig to the constructor" should "return a Parquet File Format type of dfWriter" in {
    val writerService = new DataFrameWriterService(ParquetFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[ParquetFileFormatConfig]])
  }

  "given a HiveFileFormatConfig to the constructor" should "return a Hive File Format type of dfWriter" in {
    val writerService = new DataFrameWriterService(HiveFileFormatConfig())
    assert(writerService.dfWriter != null && writerService.dfWriter.isInstanceOf[EmfDataFrameWriter[HiveFileFormatConfig]])
  }

  "given a sample dataframe and fileCfsConfig to call save" should "save the dataframe into target format" in {
    val tempTableName = "DataFrameWriterServiceTestTable"
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    import spark.implicits._
    val dataframe = Seq(
      DataFrameWriterServiceTestTable("fld1_val001", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val002", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val003", 1, "entity_uuid_002")
    ).toDF()
    val tempTableLocation = spark.conf.get("spark.sql.warehouse.dir") + s"/$tempTableName"
    val fileCfsConfig = FileCfsConfig(Seq("entityUuid").toList, tempTableLocation)
    val writerService = new DataFrameWriterService(CsvFileFormatConfig())
    writerService.save(dataframe, fileCfsConfig)
    // read file from the table root path using avro format
    val savedDf = spark.read.option("delimiter", "|").csv(tempTableLocation)
    // testDfAvro should match with the savedDf
    assert(savedDf.except(dataframe).count() == 0)
  }

  "given a sample dataframe and fileCfsConfig to call save" should "save the dataframe into target format with 3 files" in {
    val tempTableName = "DataFrameWriterServiceTestTable3"
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    import spark.implicits._
    val dataframe = Seq(
      DataFrameWriterServiceTestTable("fld1_val001", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val002", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val003", 1, "entity_uuid_002"),
      DataFrameWriterServiceTestTable("fld1_val004", 1, "entity_uuid_002")
    ).toDF()

    val tempTableLocation = spark.conf.get("spark.sql.warehouse.dir") + s"/$tempTableName"
    //    dataframe.repartition(10).write.partitionBy("entityUuid").format("csv").save(tempTableLocation)
    val fileCfsConfig = FileCfsConfig(List.empty, tempTableLocation, Some(3))
    val writerService = new DataFrameWriterService(CsvFileFormatConfig())
    writerService.save(dataframe, fileCfsConfig)
    // read file from the table root path using avro format
    val savedDf = spark.read.option("delimiter", "|").csv(tempTableLocation)
    // testDfAvro should match with the savedDf
    assert(savedDf.except(dataframe).count() == 0)
    // check if defined number of files been created.
    val d = new File(tempTableLocation)
    if (d.exists && d.isDirectory) {
      var fNames = d.listFiles.map(_.getName)
      fNames.foreach(println)
      assert(d.listFiles.filter(_.getName.endsWith(".csv")).toList.size == 3)
    } else {
      assert(false)
    }
  }

  "given a sample dataframe " should "save the dataframe as table" in {
    val tableName = "DataFrameWriterServiceTestTable1"
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    import spark.implicits._
    val dataframe = Seq(
      DataFrameWriterServiceTestTable("fld1_val001", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val002", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val003", 1, "entity_uuid_002")
    ).toDF()
    val dataframeAppend = Seq(
      DataFrameWriterServiceTestTable("fld1_val004", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val005", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTable("fld1_val006", 1, "entity_uuid_002")
    ).toDF()
    new DataFrameWriterService(ParquetFileFormatConfig()).saveDFAsTable(dataframe, tableName, None, SaveMode.Overwrite, List("entityuuid"), None, Some(true))
    val overwriteDF = spark.table(s"$tableName")
    assert(dataframe.except(overwriteDF).isEmpty)
    assert(overwriteDF.count() == 3)
    new DataFrameWriterService(ParquetFileFormatConfig()).saveDFAsTable(dataframeAppend, tableName, None, SaveMode.Append, List("entityuuid"), None, Some(true))
    val appendDF = spark.table(s"$tableName")
    assert(dataframeAppend.except(appendDF).isEmpty)
    assert(appendDF.count() == 6)
  }


  "given a dataframe and append mode and HiveFileFormatConfig to saveDFAsTable method" should "save the dataframe as table and table count is 3" in {
    val tableName = "DataFrameWriterServiceTestTableHive"
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    import spark.implicits._
    val dataframe = Seq(
      DataFrameWriterServiceTestTableHive("fld1_val001", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTableHive("fld1_val002", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTableHive("fld1_val003", 1, "entity_uuid_002")
    ).toDF()
    new DataFrameWriterService(HiveFileFormatConfig()).saveDFAsTable(dataframe, tableName, None, SaveMode.Append, List("entityuuid"), None, Some(true))
    val appendDF = spark.table(s"$tableName")
    assert(dataframe.except(appendDF).isEmpty)
    assert(appendDF.count() == 3)
  }

  "given a dataframe and Overwrite mode and HiveFileFormatConfig to saveDFAsTable method" should "save the dataframe as table and table count is 3" in {
    val tableName = "DataFrameWriterServiceTestTableHive"
    // set it for junit rerun purpose to avoid "the associated location already exists" exception
    spark.conf.set("spark.sql.legacy.allowCreatingManagedTableUsingNonemptyLocation", "true")
    import spark.implicits._
    val dataframe = Seq(
      DataFrameWriterServiceTestTableHive("fld1_val001", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTableHive("fld1_val002", 1, "entity_uuid_001"),
      DataFrameWriterServiceTestTableHive("fld1_val003", 1, "entity_uuid_002")
    ).toDF()
    new DataFrameWriterService(HiveFileFormatConfig()).saveDFAsTable(dataframe, tableName, None, SaveMode.Append, List("entityuuid"), None, Some(true))
    new DataFrameWriterService(HiveFileFormatConfig()).saveDFAsTable(dataframe, tableName, None, SaveMode.Overwrite, List("entityuuid"), None, Some(true))
    val appendDF = spark.table(s"$tableName")
    assert(dataframe.except(appendDF).isEmpty)
    assert(appendDF.count() == 3)
  }
}

case class DataFrameWriterServiceTestTable(fld1: String, fld2: Int, entityuuid: String)

case class DataFrameWriterServiceTestTableHive(fld1: String, fld2: Int, entityuuid: String)package hsbc.emf.udf.dateaddinternal

import hsbc.emf.udf.dateaddinternal.DateAddInternal.context
import hsbc.emf.udf.{SparkUdfRegisterableFunction3, UdfBuilder}
import hsbc.emf.udf.graalvm.DateProxy

private[udf] class DateAddInternal extends SparkUdfRegisterableFunction3[java.sql.Date, Long, String, java.sql.Date] {

  def apply(date: java.sql.Date, daysToAdd: Long, strType: String): java.sql.Date = {
    DateAddInternal.safeExecute {
      context.eval("js", DateAddInternalJavaScript.js)
      val bindings = DateAddInternal.context.getBindings("js")
      bindings.putMember("date", new DateProxy(date))
      bindings.putMember("daysToAdd", daysToAdd)
      bindings.putMember("strType", strType)
      val value = DateAddInternal.context
        // Note: JavaScript Function name differs form the UDF
        .eval("js", "date_add_function(date, daysToAdd, strType)")
      java.sql.Date.valueOf(value.asDate())
    }
  }

  override protected val functionName: String = "FOTC_UDF_DATE_ADD_INTERVAL"
}

private[udf] object DateAddInternal extends UdfBuilder[DateAddInternal] {

  override def apply: DateAddInternal = new DateAddInternal
}package hsbc.emf.udf.dateaddinternal

private[dateaddinternal] object DateAddInternalJavaScript {
  val js: String =
    """
      |function date_add_function(date,daysToAdd,strType){
      |    if(daysToAdd != null && date !=null){var d   = new Date(date);
      |        var strVal =    new String(strType);
      |        var interval =    new Number(daysToAdd);
      |        var local_time_ms =    d.getTime();// in msvar
      |        offset_ms =    d.getTimezoneOffset() *   (60 *   1000);
      |        var current_time_ms =    local_time_ms +    offset_ms;
      |        var result =    new Date(current_time_ms);
      |        if(strVal == "DAY"){
      |            result.setDate(result.getDate() +    interval);
      |        } else if(strVal == "MONTH"){
      |            result.setMonth(result.getMonth() +    interval);
      |        }else if(strVal == "YEAR"){
      |            result.setFullYear(result.getFullYear() +    interval);
      |        }else {
      |            throw (new Error("Illegal Parameter Passed"));}
      |        return result;
      |    }else{ return null;}
      |}
      |""".stripMargin
}
package hsbc.emf.udf.dateaddinternal

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalatest.FlatSpec

class DateAddInternalTest extends FlatSpec with IntegrationTestSuiteBase {

  val testInputData: Seq[InputTestData] = Seq(
    ("2021-02-28", 1, "DAY", "2021-03-01"),
    ("2021-02-28", -1, "DAY", "2021-02-27"),
    ("2021-02-28", 1, "MONTH", "2021-03-28"),
    ("2021-02-28", -1, "MONTH", "2021-01-28"),
    ("2021-02-28", 1, "YEAR", "2022-02-28"),
    ("2021-02-28", -1, "YEAR", "2020-02-28")

  ).map { i => InputTestData(java.sql.Date.valueOf(i._1), i._2, i._3, java.sql.Date.valueOf(i._4)) }
  behavior of "DateAddInternalTest"

  it should "convert the input date to a new date" in {
    val testObject = new DateAddInternal
    testInputData.foreach {
      a => assert(a.target == testObject.apply(a.date, a.daysToAdd, a.strType))
    }

  }

  it should "convert the input date to a new date inside a UDF" in {
    val testObject = new DateAddInternal()
    spark.udf.register("FOTC_UDF_DATE_ADD_INTERVAL", testObject.apply(_: java.sql.Date, _: Long, _: String))
    import spark.implicits._
    testInputData.toDF("date", "daysToAdd", "strType", "target").createOrReplaceTempView("DateAddInternalTest")
    val outcomes = spark.sql(
      """
        |select FOTC_UDF_DATE_ADD_INTERVAL( date, daysToAdd, strType) = target
        |from DateAddInternalTest
        |""".stripMargin).as[Boolean]
    assert(outcomes.collect().reduce(_ & _))
  }
}
package hsbc.emf.udf

import hsbc.emf.udf.graalvm.DateProxy
import org.graalvm.polyglot.Context
import org.scalatest.FlatSpec

class DateProxyTest extends FlatSpec {

  behavior of "DateProxyTest"
  val context = Context.newBuilder("js").allowExperimentalOptions(true).allowAllAccess(true).allowHostAccess(true).build()
  val example = new DateProxy(java.sql.Date.valueOf("2010-03-12"))

  // JS from Java/Scala
  context.getBindings("js").putMember("scalaDate", example)

  // Pure JS
  context.eval("js", "jsDate = new Date('2010-03-12')")

  private def jsEval = context.eval("js", _: String)

  it should "js date in pure javascript and Java should have equivalent method toISOString" in {

    assert(
      jsEval("scalaDate.toISOString()").toString == jsEval("jsDate.toISOString()").toString
    )
  }
  it should "js date in pure javascript and Java should have equivalent method getUTCDay" in {
    assert(
      jsEval("scalaDate.getUTCDay()").toString == jsEval("jsDate.getUTCDay()").toString
    )
  }
  it should "js date in pure javascript and Java should have equivalent method getUTCFullYear" in {
    assert(
      jsEval("scalaDate.getUTCFullYear()").toString == jsEval("jsDate.getUTCFullYear()").toString
    )
  }
  it should "js date in pure javascript and Java should have equivalent method getUTCMonth" in {
    assert(
      jsEval("scalaDate.getUTCMonth()").toString == jsEval("jsDate.getUTCMonth()").toString
    )
  }
  it should "js date in pure javascript and Java should have equivalent method getUTCDate" in {

    assert(
      jsEval("scalaDate.getUTCDate()").toString == jsEval("jsDate.getUTCDate()").toString
    )
  }


}
package hsbc.emf.service.resolution
import java.sql.{Date, Timestamp}

import scala.reflect.runtime.universe.TypeTag

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{NotImplementedComparableValue, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper._
import hsbc.emf.infrastructure.helper.StringUtils.{makeList, removeQuotes}

object DateTimeComparator extends IComparator {

  override def compare[T <: ComparableValue](entity: T)(inputString: String)(operator: ComparisonOperator): Boolean =
    entity match {
      case ComparableDate(dateValue) =>
        dateTimeComparePredicate[Date](dateValue, inputString, operator)
      case ComparableTimestamp(timeValue) =>
        dateTimeComparePredicate[Timestamp](timeValue,inputString, operator)
      case _ => throw new NotImplementedComparableValue(s"DateTimeComparator.compare - Not implemented DateTimeComparator value: $entity")
    }

  private def dateTimeComparePredicate[T <: java.util.Date](entityDateTime: T, inputString: String, operator: ComparisonOperator)
                                               (implicit tag: TypeTag[T]): Boolean = {

    val cleanedInputString = removeQuotes(inputString)

    cleanedInputStringNullCheck(operator, cleanedInputString)

    def equal(): Boolean = entityDateTime == parse[T](cleanedInputString)

    def in(): Boolean = makeList(inputString).map(parse[T](_)).find(_ == entityDateTime) match {
      case Some(_) => true
      case None => false
    }

    operator match {
      case Equal => equal()
      case NotEqual => !equal()
      case LessThan => entityDateTime.before(parse[T](cleanedInputString))
      case GreaterThan => parse[T](cleanedInputString).before(entityDateTime)
      case GreaterThanOrEqual => equal() || parse[T](cleanedInputString).before(entityDateTime)
      case LessThanOrEqual => equal() || entityDateTime.before(parse[T](cleanedInputString))
      case In => in()
      case NotIn => !in()
      case Is => false
      case IsNot => true
      case _ => throw new UnsupportedComparisonOperator(s"DateTimeComparator.compare - Not supported timeComparePredicate operator: $operator")
    }
  }
}
package hsbc.emf.service.resolution

import java.sql.{Date, Timestamp}

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper.parse
import org.scalatest.FlatSpec

class DateTimeComparatorTest extends FlatSpec {

  "given equal dates and Equal operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-01"
    assert(DateTimeComparator.compare(x)(y)(Equal))
  }

  "given equal Time and Equal operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y = "2021-01-01T01:01:01"
    assert(DateTimeComparator.compare(x)(y)(Equal))

    val x1 = ComparableTimestamp((Timestamp.valueOf("2021-01-01 01:01:01")))
    val y1 = "2021-01-01T01:01:01"
    assert(DateTimeComparator.compare(x1)(y1)(Equal))
  }


  "given unequal dates and Equal operator" should "return false" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-02"
    assert(!DateTimeComparator.compare(x)(y)(Equal))
  }

  "given unequal Time and Equal operator" should "return false" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-02T01:01:01"))
    val y = "2021-01-01T01:01:01"
    assert(!DateTimeComparator.compare(x)(y)(Equal))
  }

  "given equal dates and NotEqual operator" should "return false" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-01"
    assert(!DateTimeComparator.compare(x)(y)(NotEqual))
  }


  "given equal Time and NotEqual operator" should "return false" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y = "2021-01-01T01:01:01"
    assert(!DateTimeComparator.compare(x)(y)(NotEqual))
  }


  "given unequal dates and NotEqual operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-02"
    assert(DateTimeComparator.compare(x)(y)(NotEqual))
  }

  "given unequal time and NotEqual operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y = "2021-01-01T01:01:02"
    assert(DateTimeComparator.compare(x)(y)(NotEqual))
  }

  "given x < y dates and LessThan operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-02"
    assert(DateTimeComparator.compare(x)(y)(LessThan))
  }

  "given x < y time and LessThan operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y = "2021-01-01T01:01:02"
    assert(DateTimeComparator.compare(x)(y)(LessThan))
  }

  "given x > y dates and GreaterThan operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-02"))
    val y = "2021-01-01"
    assert(DateTimeComparator.compare(x)(y)(GreaterThan))
  }

  "given x > y time and GreaterThan operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:02"))
    val y = "2021-01-01T01:01:01"
    assert(DateTimeComparator.compare(x)(y)(GreaterThan))
  }

  "given x = y dates and LessThanOrEqual operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-01"
    assert(DateTimeComparator.compare(x)(y)(LessThanOrEqual))
  }

  "given x = y time and LessThanOrEqual operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y = "2021-01-01T01:01:01"
    assert(DateTimeComparator.compare(x)(y)(LessThanOrEqual))
  }

  "given x = y dates and GreaterThanOrEqual operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-02"))
    val y = "2021-01-02"
    assert(DateTimeComparator.compare(x)(y)(GreaterThanOrEqual))
  }

  "given x = y time and GreaterThanOrEqual operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:02"))
    val y = "2021-01-01T01:01:02"
    assert(DateTimeComparator.compare(x)(y)(GreaterThanOrEqual))
  }

  "given x in y dates and In operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-02"))
    val y = "[2021-01-01,2021-01-02]"
    assert(DateTimeComparator.compare(x)(y)(In))
  }

  "given x in y time and In operator" should "return true" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:02"))
    val y = "[2021-01-01T01:01:01,2021-01-01T01:01:02]"
    assert(DateTimeComparator.compare(x)(y)(In))
  }

  "given x in y dates and NotIn operator" should "return false" in {
    val x = ComparableDate(Date.valueOf("2021-01-02"))
    val y = "[2021-01-01,2021-01-02]"
    assert(!DateTimeComparator.compare(x)(y)(NotIn))
  }

  "given x in y time and NotIn operator" should "return false" in {
    val x = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:02"))
    val y = "[2021-01-01T01:01:01,2021-01-01T01:01:02]"
    assert(!DateTimeComparator.compare(x)(y)(NotIn))
  }


  "given invalid operator" should "return UnsupportedComparisonOperator error" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "2021-01-02"

    val caught = intercept[UnsupportedComparisonOperator] {
      DateTimeComparator.compare(x)(y)(Like)
    }
    assert(!caught.getMessage.isEmpty)

    val x1 = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y1 = "2021-01-01T01:01:01"

    val caught1 = intercept[UnsupportedComparisonOperator] {
      DateTimeComparator.compare(x1)(y1)(Is)
    }

    assert(!caught1.getMessage.isEmpty)

    val x2 = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y2 = "2021-01-01T01:01:01"

    val caught2 = intercept[UnsupportedComparisonOperator] {
      DateTimeComparator.compare(x2)(y2)(IsNot)
    }

    assert(!caught2.getMessage.isEmpty)
  }

  "given comparison against a non-date string" should "return InvalidCastError" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "!!"

    val caught = intercept[InvalidCastError] {
      DateTimeComparator.compare(x)(y)(Equal)
    }
    assert(!caught.getMessage.isEmpty)

    val x1 = ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01"))
    val y1 = "!!"

    val caught1 = intercept[InvalidCastError] {
      DateTimeComparator.compare(x1)(y1)(Equal)
    }
    assert(!caught1.getMessage.isEmpty)
  }

  "timestamp parsing supports ISO-8601 instant format YYYY-MM-DDTHH:mm:SS" should "return true" in {
    val y = "2021-01-01T01:01:01"
    val x = ComparableTimestamp(parse[Timestamp](y))
    assert(DateTimeComparator.compare(x)(y)(Equal))
  }

  "timestamp parsing supports ISO-8601 instant format YYYY-MM-DDTHH:mm:SSZ" should "return true" in {
    val y = "2021-01-01T01:01:01Z"
    val x = ComparableTimestamp(parse[Timestamp](y))
    assert(DateTimeComparator.compare(x)(y)(Equal))
  }

  "timestamp parsing supports ISO-8601 instant format YYYY-MM-DDTHH:mm:SS.FFF" should "return true" in {
    val y = "2020-01-01T01:01:01.111"
    val x = ComparableTimestamp(parse[Timestamp](y))
    assert(DateTimeComparator.compare(x)(y)(Equal))
  }

  "timestamp parsing supports YYYY-MM-DD" should "return true" in {
    val y = "2021-01-01"
    val x = ComparableTimestamp(parse[Timestamp](y))
    assert(DateTimeComparator.compare(x)(y)(Equal))
  }

  "given list of dates and In operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "[2022-01-01,2021-01-01]"
    assert(DateTimeComparator.compare(x)(y)(In))
  }


  "given list of dates with double quotes and In operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = s"""["2022-01-01","2021-01-01"]"""
    assert(DateTimeComparator.compare(x)(y)(In))
  }

  "given list of dates and NotIn operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = "[2022-01-01,2023-01-01]"
    assert(DateTimeComparator.compare(x)(y)(NotIn))
  }

  "given list of dates with double quotes and NotIn operator" should "return true" in {
    val x = ComparableDate(Date.valueOf("2021-01-01"))
    val y = s"""["2022-01-01","2023-01-01"]"""
    assert(DateTimeComparator.compare(x)(y)(NotIn))
  }


  "given a date/timestamp with Is null operator" should "return false" in {

    assert(!DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))(null)(Is))

    assert(!DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))(null)(Is))

    assert(!DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))("null")(Is))

    assert(!DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))("null")(Is))

    assert(!DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))("Null")(Is))

    assert(!DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))("Null")(Is))
  }

  "given a date/timestamp with IsNot null operator" should "return false" in {

    assert(DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))(null)(IsNot))

    assert(DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))(null)(IsNot)
    )

    assert(DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))("null")(IsNot))

    assert(DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))("null")(IsNot))

    assert(DateTimeComparator.compare(ComparableDate(Date.valueOf("2021-01-01")))("Null")(IsNot))

    assert(DateTimeComparator.compare(ComparableTimestamp(parse[Timestamp]("2021-01-01T01:01:01")))("Null")(IsNot))
  }
}package hsbc.emf.service.ingestion.data

case class DummyFileType(fld1: String, fld2: Int)
package hsbc.emf.infrastructure.exception

class EmfAssertEvaluationException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfAssertEvaluationException"
}
package hsbc.emf.infrastructure.config

import hsbc.emf.constants.{CloudType, Local}

object EmfConfig {
  val defaultLoadInfoTableName: String = "datahub.load_info"
  val loadInfoDatabaseName: String = "load_info"
  val loadInfoCacheView: String = "load_info_cache"
  val processTaskCacheView: String = "process_tasks_cache"
  val defaultAccessView: String = "access_view"
  val defaultTableName: String = "data"
  val defaultTablePartition: String = "entity_uuid"
  val catalogueDatabaseName: String = "catalogue"
  val catalogueTableName: String = "data"
  val catalogueTablePartitions: List[String] = "file_type" :: "created" :: "entity_uuid" :: Nil
  val processTasksDatabaseName = "process_tasks"
  val process_tasks = "process_tasks"
  val sparkRunGenerateDbPrefix: String = "zzz_"
  val sparkRunCatalogueFileType: String = "spark_run_info"
  val sparkRunGeneratedParamNameRunUuid: String = "run_uuid"
  val sparkRunGeneratedParamNameTargetDataset: String = "target_dataset"
  val defaultCurateFormat: String = "parquet"
  val curateFormatFieldInIngestionParameters: String = "curate_format"
  val isAdjustableInIngestionParameters: String = "is_adjustable"
  val dimQueueFileType: String = "dim_queue"
  val defaultWorkflowName: String = "GBLLIB_CURATE_AND_INGEST"
  val columnNameOfCorruptRecord = "column_name_of_corrupt_record"
  val real_meta_chunk_token = "__metadata_chunk_token__"
  val spark_readable_meta_chunk_token = "x__metadata_chunk_token__"
  val runtime_uuid_column = "x__uuid"

  // Temp workaround for this env-specific config. It should be moved to external config file once the functionality is implemented.
  // This config affects cloud-specific operations (e.g. the logic to prepend protocol prefix to bucket).
  // It will be changed by SparkEmfRunner for cluster run. Default to Local here to avoid breaking any local and ci tests.
  var cloudType: CloudType = Local

  // SparkConf used by SparkEmfRunner.
  // The values used in cluster level are set here at the moment. They should be read from config file, to be implemented.
  // For local and ci tests, the var (namely sparkConfigMasterUrl and sparkConfig) will be overridden in the test classes
  val sparkConfAppName: String = "emf-spark"

  // https://spark.apache.org/docs/2.4.5/configuration.html#dynamic-allocation

  val sparkConfSparkLogConfName: String = "spark.logConf"
  val sparkConfSparkLogConfValue: String = "true"
  val sparkConfHiveExecDynamicPartitionModeName: String = "hive.exec.dynamic.partition.mode"
  val sparkConfHiveExecDynamicPartitionModeValue: String = "nonstrict"
  val sparkConfSqlSourcesPartitionOverwriteModeName: String = "spark.sql.sources.partitionOverwriteMode"
  val sparkConfSqlSourcesPartitionOverwriteModeValue: String = "dynamic"
  val sparkConfSqlCrossJoinEnabledName: String = "spark.sql.crossJoin.enabled"
  val sparkConfSqlCrossJoinEnabledValue: String = "true"
  var sparkConfMasterUrl: String = "yarn"
  // val sparkautoBroadcastJoinThresholdName = "spark.sql.autoBroadcastJoinThreshold"
  // val sparkautoBroadcastJoinThresholdValue = "-1"
  val sparkbroadcastTimeoutName = "spark.sql.broadcastTimeout"
  val sparkbroadcastTimeoutValue = "36000"
  val sparkConfSqlCodegenWholeStageName = "spark.sql.codegen.wholeStage"
  val sparkConfSqlCodegenWholeStageValue = "false"
  var sparkConfMap: Map[String, String] = Map(
    sparkConfSparkLogConfName -> sparkConfSparkLogConfValue,
    sparkConfHiveExecDynamicPartitionModeName -> sparkConfHiveExecDynamicPartitionModeValue,
    sparkConfSqlSourcesPartitionOverwriteModeName -> sparkConfSqlSourcesPartitionOverwriteModeValue,
    sparkConfSqlCrossJoinEnabledName -> sparkConfSqlCrossJoinEnabledValue,
    // sparkautoBroadcastJoinThresholdName -> sparkautoBroadcastJoinThresholdValue,
    sparkbroadcastTimeoutName -> sparkbroadcastTimeoutValue,
    sparkConfSqlCodegenWholeStageName -> sparkConfSqlCodegenWholeStageValue
  )

  val loggingTable: String = "emf_log"
  val loggingDb: String = "logging"
  val errorLogTable: String = "emf_exceptions"
  val workflowSpawnInfoTable: String = "workflow_spawn_info"
  val resolutionLogTable: String = "resolutions_info"
  val assertLogTable: String = "assert_info"
  val messageStateLogTable: String = "message_state_info"
  val metadataLogTable: String = "metadata_info"
}
package hsbc.emf.infrastructure.exception

class EmfCrmCustomException(message: String) extends EmfException(message: String)

final class EmfCrmZeroRecordsReturnedException(message: String) extends EmfCrmCustomException(message: String) {
  val category = "EmfCrmZeroRecordsReturnedException"
}
package hsbc.emf.infrastructure.exception

class EmfCrmReadWriteException (message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfCrmReadWriteException"
}

final class EmfCrmReadException(message: String, cause: Throwable) extends EmfCrmReadWriteException(message: String, cause: Throwable) {
  override val category = "EmfCrmReadException"
}

final class EmfCrmWriteException(message: String, cause: Throwable) extends EmfCrmReadWriteException(message: String, cause: Throwable) {
  override val category = "EmfCrmWriteException"
}package hsbc.emf.infrastructure.exception

class EmfDagBuilderException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfDagBuilderException"
}

class EmfDagExecutionException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfDagExecutionException"
}
package hsbc.emf.infrastructure.exception

class EmfDaoException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfDaoException"
}

final class EmfLoadInfoDaoException(message: String, cause: Throwable) extends EmfDaoException(message: String, cause: Throwable) {
  override val category = "EmfLoadInfoDaoException"
}package hsbc.emf.infrastructure.exception

class EmfDataFrameTypeCastException (message: String, cause: Throwable = None.orNull) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfDataFrameTypeCastException"
}
package hsbc.emf.infrastructure.io.writers

import hsbc.emf.infrastructure.config. FileFormatConfig
import org.apache.spark.sql.{DataFrame, DataFrameWriter, Row}

abstract class EmfDataFrameWriter[T<:FileFormatConfig](fileFormat: T) {


   def getWriter(input: DataFrame): DataFrameWriter[Row] = {
    input.write.format(fileFormat.format)
  }
}
package hsbc.emf.infrastructure.exception

class EmfDataFrameWriterException(message: String) extends EmfException(message: String) {
  val category = "EmfDataFrameWriterException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}package hsbc.emf.infrastructure.exception

abstract class EmfException(message: String) extends Exception(message) {
  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }

  def this(cause: Throwable) = {
    this(Option(cause).map(_.toString).orNull)
    initCause(cause)
  }
}

final class EmfSqlException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfSqlException"
}

final class EmfSqlAnalysisException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfSqlAnalysisException"
}

final case class EmfIoException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfIoException"
}

final case class EmfUnsupportedFileFormatException(message: String) extends EmfException(message: String) {
  val category = "EmfUnsupportedFileFormatException"
}

final case class EmfInvalidInputException(message: String) extends EmfException(message: String) {
  val category = "EmfInvalidInputException"
}

final case class EmfIncompatibleSchemaException(message: String) extends EmfException(message: String) {
  val category = "EmfIncompatibleSchemaException"
}
package hsbc.emf.infrastructure.exception

class EmfFieldException(message: String) extends EmfException(message: String) {
  val category = "EmfFieldException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

class EmfFieldNotFoundException(message: String)  extends EmfFieldException(message: String) {
  override val category: String = "EmfFieldNotFoundException"
}

class EmfPartitionFieldNotFoundException(message: String)  extends EmfFieldNotFoundException(message: String) {
  override val category: String = "EmfPartitionFieldNotFoundException"
}
package hsbc.emf.infrastructure.exception

class EmfFieldTypeException(message: String) extends EmfException(message: String) {
  val category = "EmfFieldTypeException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}
package hsbc.emf.infrastructure.exception

class EmfJsonDeserializeException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfJsonDeserializeException"
}
package hsbc.emf.infrastructure.exception

class EmfJsonSerializeException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfJsonSerializeException"
}
package hsbc.emf.infrastructure.exception

class EmfLoadInfoException(message: String) extends EmfException(message: String)

final class MultipleLoadInfo(message: String) extends EmfLoadInfoException(message: String) {
  val category = "MultipleLoadInfo"
}

final class MissingLoadInfo(message: String) extends EmfLoadInfoException(message: String) {
  val category = "MissingLoadInfo"
}

package hsbc.emf.infrastructure.logging

import hsbc.emf.data.logging._
import org.apache.logging.log4j.{Logger, LogManager}

object EmfLogger {

  private val loggerName = System.getProperty("loggerName", "Console") //TODO: Read it from config file

  private val logger: Logger = {
    LogManager.getLogger(loggerName)
  }

  private def log(entry: LogEntry): Unit = {
    val logMessage = LoggingUtils.serializeLogEntry(entry)
    entry.severity match {
      case Info() => logger.info(logMessage)
      case Error() => logger.error(logMessage)
      case Debug() => logger.debug(logMessage)
      case Warning() => logger.warn(logMessage)
      case Fatal() => logger.fatal(logMessage)
      case _ => throw new Exception("Invalid Severity Type")
    }
  }

  def log(severity: Severity)(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(LogEntry(message, severity = severity, contextMap = Map("MESSAGE_INFO" -> messageInfo) ++ contextMap))

  def info(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(Info())(message, contextMap)

  def debug(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(Debug())(message, contextMap)

  def warn(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(Warning())(message, contextMap)

  def error(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(Error())(message, contextMap)

  def fatal(message: String, contextMap: Map[String, Any] = Map.empty)(implicit messageInfo: MessageInfo): Unit =
    log(Fatal())(message, contextMap)
}
package hsbc.emf.infrastructure.exception

class EmfMapperException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfMapperException"
}

class EmfLoadInfoMapperException(message: String, cause: Throwable) extends EmfMapperException(message: String, cause: Throwable) {
  override val category = "EmfLoadInfoMapperException"
}

final class EmfSchemaMapperException(message: String, cause: Throwable) extends EmfLoadInfoMapperException(message: String, cause: Throwable) {
  override val category = "EmfSchemaMapperException"
}

final class EmfIngestionParametersMapperException(message: String, cause: Throwable) extends EmfLoadInfoMapperException(message: String, cause: Throwable) {
  override val category = "EmfIngestionParametersMapperException"
}

final class EmfCrmInputMapperException(message: String, cause: Throwable) extends EmfMapperException(message: String, cause: Throwable) {
  override val category = "EmfCrmInputMapperException"
}

final class EmfCrmOutputMapperException(message: String, cause: Throwable) extends EmfMapperException(message: String, cause: Throwable) {
  override val category = "EmfCrmOutputMapperException"
}
package hsbc.emf.infrastructure.exception

class EmfResolveServiceException(message: String, prefixMessage: String) extends EmfException(prefixMessage: String) {

  def this(message: String) {
    this(message, "EmfResolveServiceException ".concat(message))
  }

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }

}

final class UnsupportedComparisonOperator(message: String) extends EmfResolveServiceException(message: String) {
  val category = "UnsupportedComparisonOperator"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class NotImplementedComparableValue(message: String) extends EmfResolveServiceException(message: String) {
  val category = "NotImplementedComparableValue"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class UnknownTypeConversion(message: String) extends EmfResolveServiceException(message: String) {
  val category = "UnknownTypeConversion"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class InvalidCastError(message: String) extends EmfResolveServiceException(message: String) {
  val category = "InvalidCastError"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class ResolveError(message: String) extends EmfResolveServiceException(message: String) {
  val category = "ResolveError"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class InvalidSourceEntity(message: String) extends EmfResolveServiceException(message: String) {
  val category = "InvalidSourceEntity"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class UnsupportedDataType(message: String) extends EmfResolveServiceException(message: String) {
  val category = "UnsupportedDataType"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class InputReqRawToInputReqMapperException(message: String) extends EmfResolveServiceException(message: String) {
  val category = "InputReqRawToInputReqMapperException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class SparkResolveMessageMapperException(message: String) extends EmfResolveServiceException(message: String) {
  val category = "SparkResolveMessageMapperException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class ResolutionConstraintMapperException(message: String) extends EmfResolveServiceException(message: String) {
  val category = "ResolutionConstraintMapperException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}

final class SparkRunMessageMapperException(message: String) extends EmfResolveServiceException(message: String) {
  val category = "SparkRunMessageMapperException"

  def this(message: String, cause: Throwable) = {
    this(message)
    initCause(cause)
  }
}package hsbc.emf.infrastructure.exception

class EmfServiceException(message: String, cause: Throwable) extends EmfException(message: String, cause: Throwable) {
  val category = "EmfServiceException"
}

final class SparkTriggerServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkTriggerServiceException"
}

final class SparkIngestServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkIngestServiceException"
}

final class SparkLoadTableFromFileServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkLoadTableFromFileServiceException"
}

final class SparkExportServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkExportServiceException"
}

final class SparkCurateServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkCurateServiceException"
}

final class SparkCreateTableServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkCreateTableServiceException"
}

final class SparkCrmServiceException(message: String, cause: Throwable) extends EmfServiceException(message: String, cause: Throwable) {
  override val category = "SparkCrmServiceException"
}
package hsbc.emf.infrastructure.exception

class EmfUnknownCommandException (message: String) extends EmfException(message: String) {
  val category = "EmfUnknownCommandException"
}

package hsbc.emf.infrastructure.exception

class EmfValidationException(message: String) extends EmfException(message: String)

final class EmfSchemaValidationException(message: String) extends EmfValidationException(message: String) {
  val category = "EmfSchemaValidationException"
}

final class EmfMissingAttributeException(message: String) extends EmfValidationException(message: String) {
  val category = "EmfMissingAttributeException"
}
package hsbc.emf.udf.evalexpression

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}

private[udf] class EvaluateExpression extends SparkUdfRegisterableFunction1[String, Double] {

  def apply(input: String): Double = {
    EvaluateExpression.safeExecute {
      val jsObj = EvaluateExpression.context.eval("js", input)
      jsObj.asDouble()
    }
  }

  override val functionName: String = "eval_expression"
}

private[udf] object EvaluateExpression extends UdfBuilder[EvaluateExpression] {

  override def apply: EvaluateExpression = new EvaluateExpression
}package hsbc.emf.udf.evalexpression

import org.scalatest.FlatSpec

class EvaluateExpressionTest extends FlatSpec {
  behavior of "EvaluateExpression"
  it should "execute a piece of JavaScript and return a double" in {

    val target = Math.sqrt(0.111 * 100 + 7e-2)

    // When:
    val result = new EvaluateExpression().apply("Math.sqrt(0.111 * 100 +7e-2)")

    // Then:
    assert(target == result)
  }
}
package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.EmfLogger
import org.apache.commons.lang.exception.ExceptionUtils

import org.apache.spark.sql.SparkSession

object ExceptionHandler {

  def handle(message: String, exception: Throwable)(implicit sparkSession: SparkSession, messageInfo: MessageInfo): Unit = {
    EmfLogger.error(s"$message. Reason: ${ExceptionUtils.getMessage(exception)}")
    val stackTrace = ExceptionUtils.getStackTrace(exception)
    EmfLogger.error(s"Stacktrace: $stackTrace")
    val exceptionInfo: ExceptionInfo = ExceptionInfo(messageInfo, message, stackTrace, new Timestamp(System.currentTimeMillis()))
    AuditLogger().audit[ExceptionInfo](exceptionInfo)
  }
}

package hsbc.emf.infrastructure.logging.audit
import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo

case class ExceptionInfo(message: MessageInfo, exceptionMessage: String, stacktrace: String, created: Timestamp) extends ContextInfopackage hsbc.emf.constants

sealed trait ExecutionResult

object Complete extends ExecutionResult

object Failed extends ExecutionResultpackage hsbc.emf.data.crm

final case class Exposure (
  key : String,
  id : String,
  undrawnFlag : String,
  originalExposure : Double
)
package hsbc.emf.service.orchestration

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.EmfLogger._

import org.apache.spark.sql.SparkSession

object ExternalParametersReader {

  var paramMap: Map[String, String] = Map()

  def read(implicit spark: SparkSession, messageInfo: MessageInfo): Map[String, String] = {
    val externalParameterFilePath = System.getProperty("externalParametersFilePath")
    if (externalParameterFilePath == null || externalParameterFilePath.isEmpty) {
      warn("External Parameters file path is empty. External Parameters cannot be read.")
      Map.empty
    } else {
      info(s"Reading external parameters from path $externalParameterFilePath")
      if (this.paramMap.isEmpty) {
        val df = spark.read.option("multiline", true).json(externalParameterFilePath)
        this.paramMap = df.head().getValuesMap[String](df.schema.fieldNames)
        info(s"External Parameters List : $paramMap")
      }
      this.paramMap
    }
  }
}
package hsbc.emf.service.orchestration

import java.sql.Timestamp

import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.resolution.ResolutionConstraint
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.sql.ISqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class ExternalParametersReaderTest extends IntegrationTestSuiteBase {


  "give external json file " should "read correctly" in {
    System.setProperty("externalParametersFilePath", "tests/resources/workflowTest/external_parameters2.json")

    val paraMap = Map("city_filter" -> "NewYork", "customer_db" -> "test_db", "customer_from_newyork_tbl" -> "customer_newyork")
    val externalParametersMap = ExternalParametersReader.read
    assert(externalParametersMap == paraMap)
  }

}
package hsbc.emf.infrastructure.config

final case class FileCfsConfig(
                                partition: List[String],
                                fileLocation: String,
                                numberOfFiles: Option[Int] = None)
package hsbc.emf.infrastructure.config

sealed trait FileFormatConfig {
  val format: String
}

final case class CsvFileFormatConfig(delimiter: String = "|", skipRows: Int = 0,
                                     quoteCharacter: String = "", multipleLine: String = "true",
                                     printHeader: Boolean = false) extends FileFormatConfig {
  override val format: String = "csv"
}

final case class JsonFileFormatConfig() extends FileFormatConfig {
  override val format: String = "json"
}

final case class AvroFileFormatConfig( useAvroLogicalType: Boolean = false) extends FileFormatConfig {
  override val format: String = "avro"
}

final case class OrcFileFormatConfig() extends FileFormatConfig {
  override val format: String = "orc"
}

final case class ParquetFileFormatConfig() extends FileFormatConfig {
  override val format: String = "parquet"
}

final case class TextFileFormatConfig() extends FileFormatConfig {
  override val format: String = "text"
}
final case class HiveFileFormatConfig() extends FileFormatConfig {
  override val format: String = "hive"
}

final case class MetaDataTextFileFormatConfig() extends FileFormatConfig {
  override val format: String = ""
}
final case class UnsupportedFormatConfig() extends FileFormatConfig {
  override val format: String = "unsupported"
}

package hsbc.emf.infrastructure.helper

import hsbc.emf.infrastructure.exception.EmfIoException
import org.apache.commons.io.FilenameUtils
import org.apache.hadoop.fs.{FileSystem, Path}

import org.apache.spark.sql.SparkSession

object FileUtility {

  def cleanDirectoryIfExists(directory: String) (implicit spark: SparkSession): Unit = {
    val fs = getFileSystem(directory)
    val outPutPath = new Path(directory)
    if (fs.exists(outPutPath)) getFilePaths(fs, outPutPath).foreach(fs.delete(_, false))
  }

  def getBaseName(fileName: String): String = FilenameUtils.getBaseName(fileName)

  def getFullPathNoEndSeparator(fileName: String): String =
    FilenameUtils.getFullPathNoEndSeparator(fileName)

  def getFullPath(fileName: String): String =
    FilenameUtils.getFullPath(fileName)

  def concatFilePaths(bucketName: String, targetFileName: String): String =
    FilenameUtils.concat(bucketName, targetFileName)

  def renameFiles(sourceFileLocation: String, sourceFileFormat: String,
                 targetFileName: String, isMetadataFile: Boolean) (implicit spark: SparkSession): Unit = {
    val fs = getFileSystem(sourceFileLocation)
    val filePaths = getFilePaths(fs, new Path(sourceFileLocation))
      .filter(_.getName.contains("part-"))
      .filter(_.getName.endsWith(sourceFileFormat))
    if (isMetadataFile) {
      if (filePaths.length == 1) {
        filePaths
          .foreach { fileAbsolutePath =>
            val newFilePath = getFullPath(fileAbsolutePath.toString) + targetFileName
            fs.rename(fileAbsolutePath, new Path(newFilePath))
          }
      }
      else {
        val customMessage = s"FileUtility.renameFiles there are multiple part- files found:- ${filePaths.length} " +
          s"while renaming metadata file in sourceFileLocation: $sourceFileLocation for sourceFileFormat: $sourceFileFormat"
        throw EmfIoException(customMessage, None.orNull)
      }
    }
    else {
      filePaths
        .foreach{ fileAbsolutePath =>
          val newFilePath = getFullPath(fileAbsolutePath.toString) +
            targetFileName + "-" + HelperUtility.generateRunUUID + "." + sourceFileFormat
          fs.rename(fileAbsolutePath, new Path(newFilePath))
        }
    }
  }

  def getFileSystem(sourceFileLocation: String) (implicit spark: SparkSession): FileSystem = {
    val path = new Path(sourceFileLocation)
    path.getFileSystem(spark.sparkContext.hadoopConfiguration)
  }

  def getFilePaths(fs: FileSystem, sourceFilePath: Path): Array[Path] = {
    fs.listStatus(sourceFilePath).map(_.getPath)
  }
}

package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{ResolveError, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper._

object FilterExpression {

  def makeFilterString(rest: ResolutionConstraint, columnTypes: Array[(String, String)]): String = {
    columnTypes.find(_._1 == rest.attribute) match {
      case Some(x) => cleanedInputStringNullCheck(rest.operator, rest.value)
        rest.operator match {
          case Is | IsNot =>
            if (x._2 == "BooleanType") {
              throw new UnsupportedComparisonOperator(s"FilterExpression.makeFilterString - Not supported BooleanComparator operator in makeFilterString: ${rest.operator}")
            }
            else s"${rest.attribute} ${rest.operator} null"
          case _ => val valueFilterString = ResolutionFilterStringBuilder.buildFilterExpression(rest.value, x._2, rest.operator)
            s"${rest.attribute} ${rest.operator} $valueFilterString"
        }
      case None => // scalastyle:off throwerror
        throw new ResolveError(s"FilterExpression.makeFilterString - Attribute:${rest.attribute} column not found in data table")
      // scalastyle:on throwerror
    }
  }
}
package hsbc.emf.service.resolution

import java.sql.{Date, Timestamp}

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.UnsupportedComparisonOperator
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class FilterExpressionTest extends IntegrationTestSuiteBase {

  import spark.implicits._
  private var dataDF: org.apache.spark.sql.DataFrame = _
  private var dTypes: Array[(String, String)] = _

  override  def beforeAll(): Unit = {
    super.beforeAll()
    dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25,
      Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    dTypes = dataDF.dtypes
  }

  "given a String with Equal operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("location", "HK", Equal)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with NotEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("location", "HK", NotEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with Like operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("location", "HK", Like)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with NotLike operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("location", "HK", NotLike)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with In operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25,
      Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("location", "HK", In)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with NotIn operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25,
      Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("location", "HK", NotIn)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with Is operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T4", null, active = false, 0, 0.0, null, null, null))
      .toDF()
    val whereClause = ResolutionConstraint("location", null, Is)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with IsNot operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25,
      Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("location", null, IsNot)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a String with an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught = intercept[UnsupportedComparisonOperator] {
      val whereClause = ResolutionConstraint("location", "HK", LessThanOrEqual)
      FilterExpression.makeFilterString(whereClause, dTypes)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a Boolean with Equal operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25,
      Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("active", "false", Equal)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Boolean with NotEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25,
      Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("active", "true", NotEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Boolean with an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught = intercept[UnsupportedComparisonOperator] {
      val whereClause = ResolutionConstraint("active", null, Is)
      FilterExpression.makeFilterString(whereClause, dTypes)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a Date with Equal operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25,
      Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-01-01", Equal)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with NotEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25,
      Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-01-01", NotEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }


  "given a Date with LessThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-02-01", LessThan)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with LessThanOrEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-01-01", LessThanOrEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with GreaterThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-01-01", GreaterThan)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with GreaterThanOrEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "2021-01-01", GreaterThanOrEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with In operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "[2021-01-01,2021-02-02]", In)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with NotIn operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1"))).toDF()
    val whereClause = ResolutionConstraint("run_date", "[2021-01-01,2021-02-02]", NotIn)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }


  "given a Date with Is operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("run_date", null, Is)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with IsNot operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("run_date", null, IsNot)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Date with an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught = intercept[UnsupportedComparisonOperator] {
      val whereClause = ResolutionConstraint("run_date", "2021-01-01", Like)
      FilterExpression.makeFilterString(whereClause, dTypes)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a Timestamp with Equal operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", Equal)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with NotEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", NotEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }


  "given a Timestamp with LessThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", LessThan)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)

    val expectedDF1 = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause1 = ResolutionConstraint("created", "2021-03-02 00:00:00", LessThan)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF1).isEmpty)
  }

  "given a Timestamp with LessThanOrEqual operator in where clause" should "return a matching rows" +
    " from data dataframe" in {

    val expectedDF = Seq(
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", LessThanOrEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with GreaterThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", GreaterThan)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with GreaterThanOrEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", GreaterThanOrEqual)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with In operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
      Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("created", "[2021-01-01 00:00:00,2021-03-02 00:00:00]", In)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with NotIn operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1"))).toDF()
    val whereClause = ResolutionConstraint("created", "[2021-01-01 00:00:00,2021-03-02 00:00:00]", NotIn)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with Is operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause = ResolutionConstraint("created", null, Is)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with IsNot operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause = ResolutionConstraint("created", null, IsNot)
    val filterExpression = FilterExpression.makeFilterString(whereClause, dTypes)
    val actualDF = dataDF.filter(filterExpression)
    assert(actualDF != null)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a Timestamp with an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught = intercept[UnsupportedComparisonOperator] {
      val whereClause = ResolutionConstraint("created", "2021-01-01 00:00:00", Like)
      FilterExpression.makeFilterString(whereClause, dTypes)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a Numeric with Equal operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause1 = ResolutionConstraint("md5", "15", Equal)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", Equal)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.5", Equal)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }

  "given a Numeric with NotEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val expectedDF3 = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00"))).toDF()

    val whereClause1 = ResolutionConstraint("md5", "15", NotEqual)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", NotEqual)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.25", NotEqual)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF3).isEmpty)
  }

  "given a Numeric with LessThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause1 = ResolutionConstraint("md5", "15", LessThan)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", LessThan)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.25", LessThan)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }

  "given a Numeric with GreaterThan operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause1 = ResolutionConstraint("md5", "10", GreaterThan)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "10.5", GreaterThan)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "100.25", GreaterThan)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }


  "given a Numeric with LessThanOrEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()
    val whereClause1 = ResolutionConstraint("md5", "15", LessThanOrEqual)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", LessThanOrEqual)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.25", LessThanOrEqual)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }

  "given a Numeric with GreaterThanOrEqual operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val expectedDF2 = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val expectedDF3 = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()

    val whereClause1 = ResolutionConstraint("md5", "10", GreaterThanOrEqual)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "10.5", GreaterThanOrEqual)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF2).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "100.25", GreaterThanOrEqual)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF3).isEmpty)
  }


  "given a Numeric with In operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
      Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()
    val whereClause1 = ResolutionConstraint("md5", "15", In)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", In)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.25", In)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }


  "given a Numeric with NotIn operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val whereClause1 = ResolutionConstraint("md5", "15", NotIn)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", "20.5", NotIn)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", "200.25", NotIn)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }

  "given a Numeric with Is operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val whereClause1 = ResolutionConstraint("md5", null, Is)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", null, Is)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF1.isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", null, Is)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF).isEmpty)
  }

  "given a Numeric with IsNot operator in where clause" should "return a matching rows from data dataframe" in {

    val expectedDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00")),
      curatedData("T4", null, active = false, 0, 0.0, null, null, null)).toDF()

    val expectedDF3 = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T2", "US", active = true, 10, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T3", "HK", active = false, 15, 20.5, 200.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()

    val whereClause1 = ResolutionConstraint("md5", null, IsNot)
    val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
    val actualDF1 = dataDF.filter(filterExpression1)
    assert(actualDF1 != null)
    assert(actualDF1.except(expectedDF).isEmpty)

    val whereClause2 = ResolutionConstraint("doubleCol", null, IsNot)
    val filterExpression2 = FilterExpression.makeFilterString(whereClause2, dTypes)
    val actualDF2 = dataDF.filter(filterExpression2)
    assert(actualDF2 != null)
    assert(actualDF2.except(expectedDF).isEmpty)

    val whereClause3 = ResolutionConstraint("bigDecCol", null, IsNot)
    val filterExpression3 = FilterExpression.makeFilterString(whereClause3, dTypes)
    val actualDF3 = dataDF.filter(filterExpression3)
    assert(actualDF3 != null)
    assert(actualDF3.except(expectedDF3).isEmpty)
  }

  "given a Numeric with an unsupported operator" should "return UnsupportedComparisonOperator error" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      val whereClause1 = ResolutionConstraint("md5", "10", Like)
      val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
      dataDF.filter(filterExpression1)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      val whereClause1 = ResolutionConstraint("doubleCol", "10.0", Like)
      val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
      dataDF.filter(filterExpression1)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[UnsupportedComparisonOperator] {
      val whereClause1 = ResolutionConstraint("bigDecCol", "100.25", Like)
      val filterExpression1 = FilterExpression.makeFilterString(whereClause1, dTypes)
      dataDF.filter(filterExpression1)
    }
    assert(!caught3.getMessage.isEmpty)
  }

}package hsbc.emf.service.ingestion.data

case class FotcCarmFFacSnapshotV0800(fld1: String, fld2: Int)package hsbc.emf.udf.graalvm

import java.text.SimpleDateFormat

import org.graalvm.polyglot.Value

// Converts a polyglot Value object that is the output of JS to a case class R
private[udf] trait GraalVmValueConverter[R] extends (Value => R) with Serializable {

  import scala.reflect._

  // convert polyglot Value to sql Date coping with nulls
  def safeConvert[T: ClassTag](v: Value): Option[T] = {
    val classOfT: java.lang.Class[T] = implicitly[ClassTag[T]].runtimeClass.asInstanceOf[Class[T]]
    v.isNull match {
      case true => None
      case false => Some(v.as(classOfT))
    }

  }
  def safeConvertToDate(v:Value):Option[java.sql.Date] = {
    v.isNull match {
      case true => None
      case false => v.isDate() match {
        case true => Some(java.sql.Date.valueOf(v.asDate()))
        case false => Some(new java.sql.Date((new SimpleDateFormat("yyyy-MM-dd").parse(v.toString())).getTime()))
      }
    }
  }
}
package hsbc.emf.infrastructure.logging

import java.sql.Date

import scala.collection.JavaConverters._
import scala.util.{Failure, Success, Try}

import hsbc.emf.data.logging.LogEntry
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.EmfUnsupportedFileFormatException
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import org.apache.logging.log4j.LogManager

import org.apache.spark.sql.{Row, SaveMode, SparkSession}

class HDFSBulkLogSender(hdfsLocation: String, format: String) extends SparkSessionWrapper {

  override lazy implicit val spark: SparkSession = createSparkSession(applicationName = "CuratedLoggerSparkContext")


  private def writerService = new DataFrameWriterService[FileFormatConfig](format.toLowerCase() match {
    case "json" => JsonFileFormatConfig()
    case "orc" => OrcFileFormatConfig()
    case "parquet" => ParquetFileFormatConfig()
    case _ => throw EmfUnsupportedFileFormatException(s"HDFSBulkLoggerSender runs into an error. " +
      s"extension='$format' is not supported for curated storage logger.")
  })

  def saveToHdfs(logs: java.util.List[(String, LogEntry)]): Unit = {
    HDFSBulkLogSender.save(logs, hdfsLocation, writerService)
  }

}

object HDFSBulkLogSender {
  private val logger = LogManager.getLogger(HDFSBulkLogSender.getClass)

  def save(logs: java.util.List[(String, LogEntry)], hdfsLocation: String,
           writerService: DataFrameWriterService[FileFormatConfig])(implicit spark: SparkSession): Unit = {
    Try {
      val logsData = logs.asScala
      val rdd = spark.sparkContext.parallelize(logsData)
      var messageInfoRow: Row = null
      var runUUID: String = null
      val rowRDD = rdd.map(entry => {
        if (entry._2.contextMap.contains("MESSAGE_INFO")) {
          val messageInfoMap = entry._2.contextMap("MESSAGE_INFO").asInstanceOf[Map[String, Any]]
          runUUID = messageInfoMap("runUUID").toString
          messageInfoRow = MessageInfoToRowMapper.map(messageInfoMap)
        }
        Row(entry._2.message, entry._2.timestamp, messageInfoRow, new Date(entry._2.timestamp.getTime), runUUID, entry._1)
      })
      val logsDataFrame = spark.createDataFrame(rowRDD, LoggingSchemas.logTableSchema)
      writerService.saveDFIntoTable(logsDataFrame, EmfConfig.loggingTable, EmfConfig.loggingDb, SaveMode.Append)
    } match {
      case Success(_) =>
      case Failure(ex) =>
        logger.error(s"HDFSBulkLogSender runs into an error. Reason: ${ex.getMessage}")
        throw ex
    }
  }
}package hsbc.emf.infrastructure.helper

import java.util.UUID

object HelperUtility {

  def generateEntityUUID(): String = {
    UUID.randomUUID.toString
  }

  def generateRunUUID(): String = {
    UUID.randomUUID.toString
  }

  def generateDatabaseNameUUID(): String = {
    UUID.randomUUID().toString.replace('-', '_')
  }
}
package hsbc.emf.infrastructure.hive

import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import org.apache.spark.sql.SparkSession

import scala.util.Try


class HiveRepair(implicit val spark: SparkSession) extends SparkSessionWrapper {

  // Repairs a hive table
  def run(dataBase: String, tableName: String): Boolean = {
    Try(new SqlExecutor().execute(s"MSCK REPAIR TABLE $dataBase.$tableName")).isSuccess
  }

  def validate(dataBase: String, tableName: String): Boolean = ???

}
package hsbc.emf.infrastructure.hive

import hsbc.emf.sparkutils.{IntegrationTestSuiteBase}
import org.scalatest.FlatSpec

class HiveRepairTest extends IntegrationTestSuiteBase {

  var hiveRepair:HiveRepair = _

  override def beforeAll(): Unit = {
    super.beforeAll()
    try {
      HiveRepairTest.buildTestHiveTable()
    } catch {
      case _: org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException =>
      case e: Exception => throw e
    }
     hiveRepair = new HiveRepair()
  }


  it should s"return true if 'msck repair table hiveRepairTestTable' executes successfully" in {
    assert(hiveRepair.run("default", "hiveRepairTestTable"))
  }

  it should s"return false if 'msck repair table' executes unsuccessfully" in {
    assert(!hiveRepair.run("default", ""))
  }

}

object HiveRepairTest {

  import org.apache.spark.sql.SparkSession

  val temporaryFileName = "hiveRepairTestFile"
  val temporaryhiveTableName = "hiveRepairTestTable"

  def buildTestHiveTable(): Unit = {

    // Create a spark session with hive support
    val spark: SparkSession = {
      SparkSession
        .builder()
        .master("local").enableHiveSupport()
        .appName("create hive table for HiveRepairTest")
        .config("spark.testing.memory", "2147480000")
        .getOrCreate()
    }
    spark.sparkContext.setLogLevel("WARN")
    // Create a test parquet file on disk; lifted from
    // https://github.com/apache/spark/blob/3a299aa6480ac22501512cd0310d31a441d7dfdc/sql/hive/src/test/scala/org/apache/spark/sql/hive/HiveMetadataCacheSuite.scala#L77

    spark.range(5).selectExpr("id", "id as f1", "id as f2").write
      .partitionBy("f1", "f2")
      .mode("overwrite")
      .parquet(temporaryFileName)

    // Create a table from the file
    spark.sql(
      s"""
         |create external table $temporaryhiveTableName (id long)
         |partitioned by (f1 int, f2 int)
         |stored as parquet
         |location '$temporaryFileName'""".stripMargin)

  }
}package hsbc.emf.infrastructure.helper

import scala.util.{Failure, Success, Try}

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.logging.EmfLogger._

import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}
import org.apache.spark.sql.catalyst.TableIdentifier
import org.apache.spark.sql.catalyst.analysis.TableAlreadyExistsException
import org.apache.spark.sql.catalyst.catalog.{CatalogTable, CatalogTableType}
import org.apache.spark.sql.execution.datasources.{CreateTable, DataSource}
import org.apache.spark.sql.types.{DecimalType, DoubleType, StructField, StructType}

object HiveUtils {

  def checkTableInCatalogue(tableName: String)(implicit spark: SparkSession): Boolean =
    spark.catalog.tableExists(tableName)

  def createDatabase(databaseName: String, location: Option[String])(implicit spark: SparkSession): Unit = {
    val dbLocation = s"${location.getOrElse(spark.conf.get("spark.sql.warehouse.dir"))}/$databaseName.db"
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${databaseName} LOCATION '${dbLocation}'")
  }

  def createTableForDataFrame(fileFormat: FileFormatConfig, dataFrame: DataFrame, databaseName: Option[String], tableName: String, partitions: List[String] = List.empty, location: Option[String], external: Option[Boolean], createTableCommandFlow: Boolean)(implicit spark: SparkSession, messageInfo: MessageInfo) = {
    import org.apache.spark.sql.functions.col

    // 1. create the database if not exists
    val dbName = databaseName.getOrElse("default")
    if (!spark.catalog.databaseExists(dbName)) {
      createDatabase(dbName, location)
    }

    // 2. define table location
    val tableLocation = s"${location.getOrElse(spark.conf.get("spark.sql.warehouse.dir"))}/${dbName}.db/${tableName}/"

    //this is special handling for ORC table creation to avoid table read issue. TODO ( technical debt ) - update  this code for  other formats or find query approach to have consistent approach to create table
    if (fileFormat.isInstanceOf[OrcFileFormatConfig]) {
      debug(s"###DDL for ORC table $dbName.$tableName : ${dataFrame.schema.toDDL}, Partition : $partitions, Location: $tableLocation")
      Try(createExternalTable(dbName, s"$tableName", s"$tableLocation", dataFrame.schema, partitions, "orc", createTableCommandFlow)) match {
        case Success(_) => debug(s"###DDL ORC table $dbName.$tableName created successfully")
        case Failure(exception) => exception match {
          case ex: TableAlreadyExistsException => //ignore
          case other => error(s"###DDL Error while creating table $dbName.$tableName. Error : ${other.getMessage}")
            throw other
        }
      }
    } else {
      val formatSegment = fileFormat match {
        case csvFileFormat: CsvFileFormatConfig =>
          s"ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.OpenCSVSerde' WITH SERDEPROPERTIES ('separatorChar'='${csvFileFormat.delimiter}', 'quoteChar'='${if (!csvFileFormat.quoteCharacter.isEmpty) s"\\${csvFileFormat.quoteCharacter}"}')"
        case parquetFileFormat: ParquetFileFormatConfig =>
          "STORED AS PARQUET"
        case jsonFileFormat: JsonFileFormatConfig =>
          "ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe' STORED AS TEXTFILE"
        case avroFileFormat: AvroFileFormatConfig =>
          "STORED AS AVRO"
        case _ => ""
      }
      // 3. define the DDL segments for common fields and partition fields
      val dfWithOutPartitionFields = dataFrame.drop(partitions: _*)
      val dfOnlyWithPartitionFields = dataFrame.select(partitions.map(col): _*)
      val fieldDdlSegment = dfWithOutPartitionFields.schema.toDDL
      val partitionDdlSegment = dfOnlyWithPartitionFields.schema.toDDL

      // 4. concat the final DDL and execute
      // location should not always given, otherwise external table created as per following article
      // https://stackoverflow.com/questions/36922836/in-spark-does-create-table-command-create-an-external-table
      val ddl = if (partitionDdlSegment.trim.isEmpty) {
        s"CREATE ${if (external.getOrElse(false)) "EXTERNAL" else ""} TABLE IF NOT EXISTS ${dbName}.${tableName} (${fieldDdlSegment}) ${formatSegment} ${if (external.getOrElse(false)) s"LOCATION '${tableLocation}'" else ""}"
      } else {
        s"CREATE ${if (external.getOrElse(false)) "EXTERNAL" else ""} TABLE IF NOT EXISTS ${dbName}.${tableName} (${fieldDdlSegment}) PARTITIONED BY (${partitionDdlSegment}) ${formatSegment} ${if (external.getOrElse(false)) s"LOCATION '${tableLocation}'" else ""}"
      }
      debug(s"###DDL create is: ${ddl}")
      spark.sql(ddl)
      debug(s"###DDL is executed successfully: ${ddl}")
    }
  }

  def analyzeTable(databaseName: String, tableName: String)(implicit spark: SparkSession): Unit = {
    spark.sql(s"ANALYZE TABLE ${databaseName}.${tableName} COMPUTE STATISTICS")
  }

  private def createExternalTable(databaseName: String, tableName: String, location: String,
                                  schema: StructType, partitionCols: Seq[String], source: String, createTableCommandFlow: Boolean)(implicit spark: SparkSession): Unit = {
    val tableIdent = new TableIdentifier(tableName, Some(databaseName))
    val storage = DataSource.buildStorageFormatFromOptions(Map("path" -> location))
    val schemaFinal = createTableCommandFlow match {
      case true => schema
      case false => {
        val schemaUpdated = schema.map(field =>
          field.dataType match {
            case _: DecimalType | _: DoubleType => StructField(field.name, DecimalType.SYSTEM_DEFAULT, field.nullable, field.metadata)
            case _ => field
          }
        ).toList
        StructType(schemaUpdated)
      }
    }
    val tableDesc = CatalogTable(
      identifier = tableIdent,
      tableType = CatalogTableType.EXTERNAL,
      storage = storage,
      schema = schemaFinal,
      partitionColumnNames = partitionCols,
      provider = Some(source)
    )
    if (!spark.sessionState.catalog.tableExists(tableIdent)) {
      val plan = CreateTable(tableDesc, SaveMode.Ignore, None)
      spark.sessionState.executePlan(plan).toRdd
    }
  }
}
package hsbc.emf.dao.ingestion

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry, MetadataRaw}

trait ICatalogueDAO {
  def readById(entityUuid: String): List[CatalogueEntity]

  def readByFileType(fileType: String): List[CatalogueEntity]

  def write(metadataRawList: List[MetadataRaw]): Unit

  def writeMetadataFile(metadataEntryList: List[MetadataEntry], fileLoc: String, tokenFileName: Option[String]): Unit
}package hsbc.emf.service.resolution

import hsbc.emf.data.resolution.{ComparableValue, ComparisonOperator}

trait IComparator {
  def compare[T <: ComparableValue](entity: T) (inputString: String) (operator: ComparisonOperator): Boolean
}
package hsbc.emf.infrastructure

import scala.reflect.runtime.universe._

trait IContainer {

  def resolveType[T: TypeTag](): T

}
package hsbc.emf.service.orchestration

import hsbc.emf.command.ISparkCommand
import hsbc.emf.constants.ExecutionResult

import org.apache.spark.sql.SparkSession

trait IDagExecutor {
  def executeDag(sparkCommands: Seq[Seq[ISparkCommand]])(implicit sparkSession: SparkSession):  ExecutionResult
}
package hsbc.emf.infrastructure.io.writers

import hsbc.emf.infrastructure.config._
import org.apache.spark.sql.{DataFrame, SaveMode}

trait IDataFrameWriterService {
  def save(input: DataFrame, fileCfsConfig: FileCfsConfig, mode: SaveMode = SaveMode.Append): Unit

  /**
   * Call "saveAsTable" method to create table/insert if table exists by given DataFrame
   * -- it's mainly used by the intemediate table creation
   * -- reference link: https://www.programmersought.com/article/11606867563/
   *
   * @param dataFrame
   * @param tableName
   * @param databaseName
   * @param mode
   * @param partitions
   * @param location
   * @param external
   */
  def saveDFAsTable(dataFrame: DataFrame, tableName: String, databaseName: Option[String], mode: SaveMode = SaveMode.Append, partitions: List[String] = List.empty, location: Option[String] = None, external: Option[Boolean], createTableCommandFlow:Boolean = false ): Unit

  /**
   * Call "insertInto" method to write dataframe into table (mainly for curated table)
   * -- it's to avoid cureate table been overwrite as per the dataframe layout by given mode 'overwrite'
   * -- reference link: https://www.programmersought.com/article/11606867563/
   *
   * @param dataFrame
   * @param tableName
   * @param databaseName
   * @param mode
   * @param partitions
   */
  def saveDFIntoTable(dataFrame: DataFrame, tableName: String, databaseName: String, mode: SaveMode = SaveMode.Append, partitions: List[String] = List.empty): Unit
}
package hsbc.emf.infrastructure.io.readers

import org.apache.spark.sql.types.StructType

trait IFileReader[A, B] {
  def read(fileFormatConfig: A, fileLocation: String, schema: Option[StructType], modeFailfast:Boolean): B
}
package hsbc.emf.udf.ilmcalcmonetisation

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}
import org.apache.spark.sql.Row
import org.graalvm.polyglot.proxy.ProxyArray

private[udf] class IlmCalcMonetisation extends SparkUdfRegisterableFunction1[Seq[Row], Seq[IlmCalcMonetisationOutput]] {

  import IlmCalcMonetisation._

  def apply(input: Seq[Row]): Seq[IlmCalcMonetisationOutput] = {
    IlmCalcMonetisation.safeExecute {
      context.eval("js", IlmCalcMonetisationJavaScript.js)
      val ilmMonetisation: Seq[IlmCalcMonetisationInput] = IlmCalcMonetisationInput.apply(input)
      val proxyArray: ProxyArray = ProxyArray.fromArray(ilmMonetisation: _*)
      context.getBindings("js").putMember("myO", proxyArray)
      val value = context.eval("js", "calcMonetisation(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => IlmCalcMonetisationOutput.apply(value.getArrayElement(i)) }
    }
  }

  override protected val functionName: String = "FOTC_UDF_ilm_calc_monetisation"
}

object IlmCalcMonetisation extends UdfBuilder[IlmCalcMonetisation] {
  override def apply: IlmCalcMonetisation = new IlmCalcMonetisation()
}package hsbc.emf.udf.ilmcalcmonetisation

import hsbc.emf.udf.SeqRowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject
import org.apache.spark.sql.Row

private[udf] case class IlmCalcMonetisationInput(
                                                  partition_key: String,
                                                  instrument_partition_key: String,
                                                  order_key: Long,
                                                  balance_sheet: Option[Double],
                                                  off_balance_sheet: Option[Double],
                                                  cumulative_contractual_balance_sheet: Option[Double],
                                                  working_day_number: Long,
                                                  sale_start_days: Option[Double],
                                                  sale_cap: Option[Double],
                                                  repo_start_days: Option[Double],
                                                  overnight_repo_total_cap: Option[Double],
                                                  overnight_repo_daily_cap: Option[Double],
                                                  maximum_daily_bucket: Long,
                                                  maximum_balance_sheet_day: Long,
                                                  my_check: Long
                                   ) extends ScalaProxyObject

object IlmCalcMonetisationInput extends SeqRowToJSCollection[IlmCalcMonetisationInput] {

  override def apply(v1: Seq[Row]): Seq[IlmCalcMonetisationInput] = {
    v1.map { e =>
      IlmCalcMonetisationInput(
        e.getString(0),
        e.getString(1),
        e.getLong(2),
        Option(e.getAs(3)),
        Option(e.getAs(4)),
        Option(e.getAs(5)),
        e.getLong(6),
        Option(e.getAs(7)),
        Option(e.getAs(8)),
        Option(e.getAs(9)),
        Option(e.getAs(10)),
        Option(e.getAs(11)),
        e.getLong(12),
        e.getLong(13),
        e.getLong(14)
      )
      // This is needed because the bigquery SQL calling this function orders the input set by order_id
    }.sortBy(a => (a.order_key, a.balance_sheet))

  }
}

package hsbc.emf.udf.ilmcalcmonetisation

private[udf] object IlmCalcMonetisationJavaScript {
  val js =
    """
      |
      |function calcMonetisation(part){
      |	var repo_move = 0.0;
      |	var sale_cap_used = 0.0;
      |	var repo_cap_left = 0.0;
      |	var sale_cap_left = 0.0;
      |	var result = [];
      |	var result_left = [];
      |	var absolute_move;
      |	var absolute_left;
      |	var result_length = 0;
      |	var list_days = [];
      |	var current_balance_sheet = 0.0;
      |	var current_off_balance_sheet = 0.0;
      |	var opening_monetised_by_repo = 0.0;
      |	var contractual_balance_sheet_move = 0.0;
      |	var contractual_off_balance_sheet_move = 0.0;
      |	var contractual_balance_sheet = 0.0;
      |	var overnight_repo_current_cap = 0.0;
      |	var iDay;
      |	var recheck = 1;
      |
      |	//create a list of days. Have allowed for (21-14)= 7  non daily buckets after the daily list which fits to PRA110
      |	var no_of_non_daily_buckets = 7;
      |	var max_daily_day = part[0].maximum_daily_bucket * 1;
      |	for (var i = 1; i<= max_daily_day +no_of_non_daily_buckets; i++){
      |		list_days.push(i);
      |	}
      |
      |	var daily_sale_cap = part[0].sale_cap; //these variables are identical for all items in the group so can just set it once
      |	var sale_start_days = part[0].sale_start_days * 1;
      |	var repo_start_days = part[0].repo_start_days * 1;
      |	var overnight_repo_total_cap = part[0].overnight_repo_total_cap;
      |	var overnight_repo_daily_cap = part[0].overnight_repo_daily_cap;
      |	var iLastInputParameter = 0;
      |	var result_left = [];
      |	var result_left_current_day = [];
      |	var repo_cap_used = 0;  //doesn't reset for a new day
      |
      |	for(var x = 0; x < list_days.length; x++){
      |
      |		iDay = list_days[x];
      |		sale_cap_used = 0;  //reset for a new day
      |		result_left = result_left_current_day; // this sets it to what was filled at the end of the prev day, on the first run it's empty
      |		result_left_current_day =[]; //clear the current results
      |
      |		if (iDay  > max_daily_day) {
      |			overnight_repo_current_cap = overnight_repo_total_cap;
      |		}
      |		else {
      |			overnight_repo_current_cap = Math.min(overnight_repo_total_cap , overnight_repo_daily_cap * (iDay - repo_start_days + 1)); //cap increases by the daily, surplus unused from prior carried over
      |		}
      |
      |		var this_working_day_number = -1;
      |		if (iLastInputParameter < part.length) {
      |			this_working_day_number = part[iLastInputParameter].working_day_number;
      |		}
      |
      |		//get list of the input parameters for the iDay
      |		var z = iLastInputParameter;
      |		var parameters_current_day = []
      |		while (z < part.length && part[z].working_day_number == iDay){
      |			parameters_current_day.push(part[z]);
      |			z++;
      |			iLastInputParameter = z;
      |		}
      |
      |		var iResultLeft = 0;
      |		while (iResultLeft < result_left.length){
      |
      |			var item = result_left[iResultLeft];
      |
      |			opening_monetised_by_repo = item.current_monetised_by_repo;
      |			current_off_balance_sheet = item.current_off_balance_sheet - opening_monetised_by_repo; //this matures the monetised repo
      |			current_balance_sheet = item.current_balance_sheet  ;
      |			repo_cap_left = overnight_repo_current_cap + repo_cap_used - Math.min(0,opening_monetised_by_repo); //add back the monetised repo (CACL-7881 not rr)now matured
      |		    sale_cap_left = daily_sale_cap + sale_cap_used;
      |
      |			//check through parameters_current_day to see if the isin exists on it
      |
      |			var z= 0;
      |			var test = "Day: " + iDay + " result leftover:" + iResultLeft ;
      |			contractual_balance_sheet_move = 0.0;
      |			contractual_off_balance_sheet_move = 0.0;
      |			contractual_balance_sheet  = item.cumulative_contractual_balance_sheet;
      |			while (z < parameters_current_day.length){
      |				var itemInput = parameters_current_day[z];
      |				if (itemInput.instrument_partition_key == item.instrument_partition_key){
      |					contractual_balance_sheet_move = itemInput.balance_sheet_move;
      |					contractual_off_balance_sheet_move = itemInput.off_balance_sheet_move;
      |					contractual_balance_sheet = itemInput.cumulative_contractual_balance_sheet
      |					current_off_balance_sheet = current_off_balance_sheet + contractual_off_balance_sheet_move;
      |					current_balance_sheet = current_balance_sheet + contractual_balance_sheet_move;
      |					parameters_current_day[z].my_check = 0; //this will stop checking this in the new deal only part
      |					var test = test + " found_it_in_new:" + z;
      |					z = parameters_current_day.length; //this will break the check through input parameters
      |
      |				}
      |				z++;
      |
      |			}
      |
      |			var result_sold = monetise_position(
      |				  item.working_day_number_original
      |				, iDay
      |				, item.instrument_partition_key
      |				, contractual_balance_sheet
      |				, current_balance_sheet
      |				, current_off_balance_sheet
      |				, sale_cap_left
      |				, sale_cap_used
      |				, repo_cap_left
      |				, repo_cap_used
      |				, sale_start_days
      |				, repo_start_days
      |				, max_daily_day
      |				, item.maximum_balance_sheet_day
      |				, opening_monetised_by_repo
      |				, result_left_current_day
      |				, result
      |				, test);
      |
      |			repo_cap_used = result_sold.repo_cap_used;
      |			sale_cap_used = result_sold.sale_cap_used;
      |			iResultLeft++;
      |		} //end while (iResultLeft < result_left.length)
      |
      |
      |		//go through the new inputs for the day and check for anything not already dealt with
      |		var z = 0;
      |		while (z < parameters_current_day.length ){
      |			var item = parameters_current_day[z];
      |			if (item.my_check == 1) { //this ensures we don't look at records that were dealt with in the leftover section
      |
      |				contractual_balance_sheet = item.cumulative_contractual_balance_sheet
      |				current_off_balance_sheet = item.off_balance_sheet_move;
      |				current_balance_sheet = item.balance_sheet_move ;
      |				opening_monetised_by_repo = 0.0;
      |				repo_cap_left = overnight_repo_current_cap + repo_cap_used;
      |				sale_cap_left = daily_sale_cap + sale_cap_used;
      |
      |				var test = "Day: " + iDay + " new input " ;
      |				//everything here on replicates the previous while loop. Not sure if passing the array in would use memory
      |				var result_sold = monetise_position(
      |				  item.working_day_number
      |				, iDay
      |				, item.instrument_partition_key
      |				, contractual_balance_sheet
      |				, current_balance_sheet
      |				, current_off_balance_sheet
      |				, sale_cap_left
      |				, sale_cap_used
      |				, repo_cap_left
      |				, repo_cap_used
      |				, sale_start_days
      |				, repo_start_days
      |				, max_daily_day
      |				, item.maximum_balance_sheet_day
      |				, opening_monetised_by_repo
      |				, result_left_current_day
      |				, result
      |				, test);
      |
      |				repo_cap_used = result_sold.repo_cap_used;
      |				sale_cap_used = result_sold.sale_cap_used;
      |
      |			}
      |			z++; //increment the while loop
      |		}//end of while (z < parameters_current_day.length )
      |
      |	}//end of look for the list of days
      |
      |	function monetise_position (
      |		working_day_number_original
      |		,working_day_number
      |		,instrument_partition_key
      |		,contractual_balance_sheet
      |		,current_balance_sheet //the position passed in should include all contractual moves
      |		,current_off_balance_sheet   //the position passed in should be after maturing any monetisation overnight repo and all contractual moves
      |		,sale_cap_left
      |		,sale_cap_used
      |		,repo_cap_left
      |		,repo_cap_used
      |		,sale_start_days
      |		,repo_start_days
      |		,max_daily_day
      |		,maximum_balance_sheet_day
      |		,opening_monetised_by_repo //this is the amount of any monetisation overnight repo at the start of day (before they mature..)
      |		,result_left_current_day
      |		,result
      |		,test)
      |		{
      |
      |		var current_position = current_balance_sheet + current_off_balance_sheet;
      |		var repo_move_incl_rolls = 0.0;
      |		var repo_cap_used_by_action = 0.0;
      |		var sale_cap_used_by_action = 0.0;
      |		var sale_move = 0.0;
      |		var repo_move =0.0;
      |		var current_monetised_by_repo = 0.0;
      |		var available_for_sale = 0.0;
      |
      |		test = test + ', current_position prior to sales is ' + current_position;
      |
      |		if (sale_start_days <= working_day_number ){
      |			available_for_sale = Math.max(0, current_balance_sheet +  Math.min(0,current_off_balance_sheet));
      |			test = test + ', available_for_sale is ' + available_for_sale;
      |
      |			if (available_for_sale > 0) {
      |				if (iDay  > max_daily_day) {
      |					sale_move = - available_for_sale;
      |					test = test + ' ,sell off without checking cap';
      |				}
      |				else {
      |					sale_move =-Math.min(available_for_sale,sale_cap_left);
      |					test = test + ' ,sell off subject to cap ' + sale_cap_left;
      |				}
      |			}
      |
      |
      |			//deal with short balance sheet
      |			if (Math.round(current_balance_sheet) < 0 ) {
      |				if (maximum_balance_sheet_day == working_day_number && Math.round(contractual_balance_sheet) >= 0 ) { //indicates maturity of the bond
      |					sale_move = - current_balance_sheet ; //flatten the whole balance sheet
      |					test = test + ' ,buy back at maturity';
      |				}
      |				else if (contractual_balance_sheet >= 0 && current_position < 0) { //if the monetisation created the short then flatten the balance sheet
      |						sale_move = - current_balance_sheet //flatten the whole balance sheet this is a short balance sheet created by the actions
      |						test = test + ' ,buy back to reverse short created by monetisation';
      |				}
      |				else if (current_position < 0) {
      |						sale_move = - (current_balance_sheet + Math.max( 0, current_off_balance_sheet)) ; //buy back just enough to flatten the position
      |						test = test + ' ,buy back to flatten position';
      |				}
      |			}
      |
      |		}
      |		current_balance_sheet = current_balance_sheet + sale_move;
      |		current_position = current_balance_sheet + current_off_balance_sheet;
      |		sale_cap_used_by_action = Math.min(0,sale_move); //a positive here means a buy back so no cap consumed. cacl-7782
      |		test = test + ', current_position after sales is: ' + current_position;
      |
      |		if (current_position < 0 ) {
      |			repo_move_incl_rolls = - current_position;  //need to cover short add in extra field to indicate it's cover of short rather than maturing of repo
      |			test = test + ' ,add in repo roll if short';
      |		}
      |		else if (current_position > 0) {
      |			if (repo_start_days <= working_day_number) {
      |				repo_move_incl_rolls =-Math.min(current_position,repo_cap_left);
      |				test = test + ' ,repo subject to cap left ' + repo_cap_left;
      |			}
      |		}
      |
      |		repo_move = repo_move_incl_rolls - opening_monetised_by_repo; //just pick up the additional above rolls
      |		current_off_balance_sheet = current_off_balance_sheet + repo_move_incl_rolls;
      |		current_monetised_by_repo = repo_move_incl_rolls;
      |
      |		if (current_monetised_by_repo <= 0){ //i.e. the position is a net repo
      |			if (opening_monetised_by_repo <= 0 ){
      |				repo_cap_used_by_action = repo_move;
      |				test = test + ' ,alter the repo cap by the repo move';
      |			}
      |			else { //open monetised was postive so a net rev repo, the unwind of the rev repo doesn't consume cap, only the additional repo
      |				repo_cap_used_by_action = current_monetised_by_repo;
      |				test = test + ' ,reduce the repo cap by the additional repo'
      |			}
      |		}
      |		else if (opening_monetised_by_repo <= 0 ){ //is open is net repo and close is net rr then we must have unwound all the repos so it frees up the cap
      |			repo_cap_used_by_action =  - opening_monetised_by_repo;
      |			test = test + ' ,increase the repo cap by the unwound monetisation repo'
      |		}
      |
      |		current_position = current_balance_sheet + current_off_balance_sheet;
      |		repo_cap_used = repo_cap_used + repo_cap_used_by_action;
      |		sale_cap_used = sale_cap_used + sale_cap_used_by_action;
      |		absolute_move = Math.abs(repo_move)+ Math.abs(sale_move);
      |		absolute_left = Math.abs(current_off_balance_sheet)+ Math.abs(current_balance_sheet) + Math.abs(current_monetised_by_repo);
      |
      |		if (absolute_move > 0) { //create results if a move
      |			result.push({partition_key: item.partition_key
      |				,instrument_partition_key : instrument_partition_key
      |				,order_key : item.order_key //I didn't pass in item but it seems to read it..
      |				,repo_post_cap : repo_move
      |				,sale_post_cap : sale_move
      |				,working_day_number_original : working_day_number_original
      |				,working_day_number : working_day_number
      |				,cumulative_contractual_balance_sheet : contractual_balance_sheet
      |				,current_balance_sheet: current_balance_sheet
      |				,current_off_balance_sheet : current_off_balance_sheet
      |				,opening_monetised_by_repo : opening_monetised_by_repo
      |				,current_monetised_by_repo : current_monetised_by_repo
      |				,overnight_repo_current_cap : overnight_repo_current_cap
      |				,repo_cap_used : repo_cap_used
      |				,sale_cap_used : sale_cap_used
      |				,test : test
      |				});
      |		}
      |
      |		if (absolute_left > 0) { //create to look at the next day
      |
      |			result_left_current_day.push({partition_key: item.partition_key
      |				,instrument_partition_key : instrument_partition_key
      |				,order_key : item.order_key
      |				,working_day_number_original : working_day_number_original
      |				,working_day_number : working_day_number
      |				,current_balance_sheet : current_balance_sheet
      |				,current_off_balance_sheet : current_off_balance_sheet
      |				,current_monetised_by_repo : current_monetised_by_repo
      |				,repo_start_days : repo_start_days
      |				,overnight_repo_current_cap : overnight_repo_current_cap
      |				,current_balance_sheet : current_balance_sheet
      |				,sale_start_days : sale_start_days
      |				,maximum_balance_sheet_day : maximum_balance_sheet_day
      |				,test:'HERE4'
      |				});
      |		}
      |
      |		var caps_used = {repo_cap_used: repo_cap_used, sale_cap_used:sale_cap_used}; // need to check the scope
      |		return caps_used;
      |	}
      |
      |    return result;
      |}
      |
      |//$FlowIgnore
      |if (typeof module !== 'undefined') {
      |    //$FlowIgnore
      |	module.exports = {
      |        calcMonetisation
      |	}
      |}
      |""".stripMargin
}
package hsbc.emf.udf.ilmcalcmonetisation

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

private[udf] case class IlmCalcMonetisationOutput(partition_key: String,
                                     instrument_partition_key: String,
                                     order_key: Int,
                                     repo_post_cap: Double,
                                     sale_post_cap: Double,
                                     working_day_number_original: Int,
                                     working_day_number: Int,
                                     contractual_balance_sheet_move: Option[Double],
                                     contractual_off_balance_sheet_move: Option[Double],
                                     cumulative_contractual_balance_sheet: Option[Double],
                                     current_off_balance_sheet: Double,
                                     opening_monetised_by_repo: Double,
                                     current_monetised_by_repo: Double,
                                     overnight_repo_current_cap: Double,
                                     repo_cap_used: Double,
                                     current_balance_sheet: Double,
                                     sale_cap_used: Double,
                                     test: String
                                    )

object IlmCalcMonetisationOutput extends GraalVmValueConverter[IlmCalcMonetisationOutput] {

  override def apply(v1: Value): IlmCalcMonetisationOutput = {

    val helper = (name: String) => v1.getMember(name)

    def helperNull(name: String): Option[Double] = {

      Option(helper(name)) match {
        case Some(value) => if (value.isNull) {
          None
        } else {
          Option(value.asDouble())
        }
        case _ => None
      }

    }

    new IlmCalcMonetisationOutput(
      helper("partition_key").asString(),
      helper("instrument_partition_key").asString(),
      helper("order_key").asInt(),
      helper("repo_post_cap").asDouble(),
      helper("sale_post_cap").asDouble(),
      helper("working_day_number_original").asInt(),
      helper("working_day_number").asInt(),
      helperNull("contractual_balance_sheet_move"),
      helperNull("contractual_off_balance_sheet_move"),
      helperNull("cumulative_contractual_balance_sheet"),
      helper("current_off_balance_sheet").asDouble(),
      helper("opening_monetised_by_repo").asDouble(),
      helper("current_monetised_by_repo").asDouble(),
      helper("overnight_repo_current_cap").asDouble(),
      helper("repo_cap_used").asDouble(),
      helper("current_balance_sheet").asDouble(),
      helper("sale_cap_used").asDouble(),
      helper("test").asString()
    )
  }
}package hsbc.emf.udf.ilmcalcmonetisation

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.Row
import org.apache.spark.sql.functions._
import org.scalatest.FlatSpec

class IlmCalcMonetisationTest extends FlatSpec with IntegrationTestSuiteBase {

  behavior of "CalcIlmMonetisation"

  it should "execute the FOTC_UDF_ilm_calc_monetisation UDF in spark" in {
    val testObj = new IlmCalcMonetisation()
    spark.udf.register("FOTC_UDF_ilm_calc_monetisation", testObj.apply(_ :Seq[Row]))
    val sqlStatement =
      """
        |select FOTC_UDF_ilm_calc_monetisation(
        | collect_list(
        |   struct(
        |      partition_key,
        |      instrument_partition_key,
        |      order_key,
        |      balance_sheet,
        |      off_balance_sheet,
        |      cumulative_contractual_balance_sheet,
        |      working_day_number,
        |      sale_start_days,
        |      sale_cap,
        |      repo_start_days,
        |      overnight_repo_total_cap,
        |      overnight_repo_daily_cap,
        |      maximum_daily_bucket,
        |      maximum_balance_sheet_day,
        |      my_check
        |    )
        |  )
        | ) as result
        |  from CalcIlmMonetisationTest
        |  group by partition_key
        |
        |""".stripMargin
    import spark.implicits._

    data.CalcIlmMonetisationTestData.input.toDF.createOrReplaceTempView("CalcIlmMonetisationTest")

     val results = spark.sql(sqlStatement)
      .select(explode(col("result")))
      .select("col.*")
      .as[IlmCalcMonetisationOutput]
      .collect().sortBy { a => (a.order_key, a.contractual_balance_sheet_move) }
    val paired = results zip data.CalcIlmMonetisationTestData.output.sortBy { a => (a.order_key, a.contractual_balance_sheet_move) }

    paired.foreach { case (res, target) =>
      assert(res == target)
    }

  }
}
package hsbc.emf.dao.ingestion

import hsbc.emf.data.ingestion.LoadInfo
import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import org.apache.spark.sql.SparkSession

trait ILoadInfoDAO {
  def readByType(fileType: String): Option[LoadInfo]
}
package hsbc.emf.infrastructure.logging

import hsbc.emf.data.logging.LogEntry

trait ILogger {
  def log(entry: LogEntry): Unit
}

package hsbc.emf.infrastructure.services.mapper

trait IMapper[A, B] {
  def map(a: A): B
}
package hsbc.emf.data.ingestion

case class IngestionHierarchy(hierarchy: List[String])

object IngestionHierarchy {
  def apply(hierarchyString: Option[String]): IngestionHierarchy = {
    val entityUuidPartition = "entity_uuid"
    val trimmedHierarchyString = hierarchyString.getOrElse("").trim
    val hierarchy: List[String] = trimmedHierarchyString match {
      case "" => List(entityUuidPartition)
      case _ => trimmedHierarchyString.split("/").toList :+ entityUuidPartition
    }
    IngestionHierarchy(hierarchy)
  }
}
package hsbc.emf.data.ingestion

import org.scalatest.FlatSpec

class IngestionHierarchyTest extends FlatSpec {
  val entityUuidPartition = "entity_uuid"

  "give a non hierarchyString" should "return an IngestionHierarchy object with default partition" in {
    val hierarchyHierarchy: IngestionHierarchy = IngestionHierarchy(None)
    assert(hierarchyHierarchy.hierarchy.size == 1 && hierarchyHierarchy.hierarchy.head.equals(entityUuidPartition))
  }

  "give a hierarchyString with 2 partitions" should "return an IngestionHierarchy object with 3 partitions" in {
    val partition1 = "partition1"
    val partition2 = "partition2"
    val hierarchyString = s"${partition1}/${partition2}"
    val hierarchyHierarchy: IngestionHierarchy = IngestionHierarchy(Some(hierarchyString))
    assert(hierarchyHierarchy.hierarchy.size == 3 && hierarchyHierarchy.hierarchy.head.equals(partition1) && hierarchyHierarchy.hierarchy {
      1
    }.equals(partition2) && hierarchyHierarchy.hierarchy {
      2
    }.equals(entityUuidPartition))
  }
}
package hsbc.emf.infrastructure.services.mapper

import java.sql.Timestamp

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.InputReqRawToInputReqMapperException

object InputReqRawToInputReqMapper extends IMapper[InputRequirementRaw, InputRequirement] {
  @throws(classOf[InputReqRawToInputReqMapperException])
  override def map(inpReqRaw: InputRequirementRaw): InputRequirement = {
    try {
      val constraints: List[ResolutionConstraint] = mapConstraints(inpReqRaw.constraints)
      val where_clause: List[ResolutionConstraint] = mapConstraints(inpReqRaw.where_clause)
      val created_from: Option[Timestamp] = mapCreatedFrom(inpReqRaw.created_from)
      val created_to: Option[Timestamp] = mapCreatedTo(inpReqRaw.created_to)
      /*     val retry_count: Int = inpReqRaw.retry_count.getOrElse(0)
           val inter_retry_interval: Int = inpReqRaw.inter_retry_interval.getOrElse(0) */
      val min_matches = inpReqRaw.min_matches.getOrElse(0L)
      val source_entity_type = mapSourceEntityType(inpReqRaw.source_entity_type)

      val resCriteria: ResolutionCriteria = ResolutionCriteria(
        file_type = inpReqRaw.file_type,
        constraints = constraints,
        created_from = created_from,
        created_to = created_to,
        /*   retry_count = retry_count,
           inter_retry_interval = inter_retry_interval,
           as_view = inpReqRaw.as_view, */
        latest_only = inpReqRaw.latest_only,
        min_matches = min_matches)

      val resTarget: ResolutionTarget = ResolutionTarget(
        table_name = inpReqRaw.table_name,
        source_entity_type = source_entity_type,
        where_clause = where_clause
        /*  dataset_name = inpReqRaw.dataset_name */
      )
      InputRequirement(resCriteria, resTarget)
    }
    catch {
      case ex: Throwable =>
        val customMessage = "InputReqRawToInputReqMapper.map fails"
        throw new InputReqRawToInputReqMapperException(customMessage, ex)
    }
  }


  private def mapConstraints(resConstraint: Option[List[ResolutionConstraintRaw]]): List[ResolutionConstraint] = {
    resConstraint match {
      case Some(list) => list.map(constraintRaw => transformConstraints(constraintRaw))
      case None => List.empty
    }
  }

  private def mapCreatedFrom(createdFrom: Option[Timestamp]): Option[Timestamp] = {
    Some(createdFrom match {
      case Some(timestamp) => timestamp
      case None => Timestamp.valueOf("1900-01-01 00:00:00")
    })
  }

  private def mapCreatedTo(createdTo: Option[Timestamp]): Option[Timestamp] = {
    Some(createdTo match {
      case Some(timestamp) => timestamp
      case None => Timestamp.valueOf("2100-01-01 00:00:00")
    })
  }

  @throws(classOf[InputReqRawToInputReqMapperException])
  private def mapSourceEntityType(sourceEntityType: String): ISourceEntityType = {
    if (sourceEntityType == null || sourceEntityType.trim.isEmpty || sourceEntityType.toUpperCase() == "DATA") {
      DATA
    }
    else {
      sourceEntityType.toUpperCase() match {
        case "ADJUSTED_UNAPPROVED" => ADJUSTED_UNAPPROVED
        case "ADJUSTED_APPROVED" => ADJUSTED_APPROVED
        case _ => throw new InputReqRawToInputReqMapperException(s"SparkResolveService - InputReqRawToInputReqMapper: source_entity_type= $sourceEntityType is not Valid")
      }

    }
  }

  @throws(classOf[InputReqRawToInputReqMapperException])
  private def transformConstraints(constraint: ResolutionConstraintRaw): ResolutionConstraint = {

    if (constraint.attribute == null || constraint.attribute.trim.isEmpty) {
      throw new InputReqRawToInputReqMapperException(s"SparkResolveService InputReqRawToInputReqMapper: null or empty attribute in constraint:" +
        s" ${constraint.attribute}")
    }

    if (constraint.value == null || constraint.value.trim.isEmpty) {
      throw new InputReqRawToInputReqMapperException(s"SparkResolveService InputReqRawToInputReqMapper: null or empty value in constraint:" +
        s" ${constraint.value}")
    }

    val op =
      if (constraint.operator == null) {
        Equal
      }
      else {
        constraint.operator match {
          case x if x.toUpperCase() == Equal.toString => Equal
          case x if x.toUpperCase() == NotEqual.toString => NotEqual
          case x if x.toUpperCase() == GreaterThan.toString => GreaterThan
          case x if x.toUpperCase() == GreaterThanOrEqual.toString => GreaterThanOrEqual
          case x if x.toUpperCase() == LessThanOrEqual.toString => LessThanOrEqual
          case x if x.toUpperCase() == LessThan.toString => LessThan
          case x if x.toUpperCase() == In.toString => In
          case x if x.toUpperCase() == NotIn.toString => NotIn
          case x if x.toUpperCase() == Like.toString => Like
          case x if x.toUpperCase() == NotLike.toString => NotLike
          case x if x.toUpperCase() == Is.toString => Is
          case x if x.toUpperCase() == IsNot.toString => IsNot
          case _ => Equal
        }
      }
    ResolutionConstraint(constraint.attribute, constraint.value, op)
  }

}package hsbc.emf.data.resolution

final case class InputRequirement(criteria: ResolutionCriteria,
                                  target: ResolutionTarget)package hsbc.emf.data.resolution
import java.sql.Timestamp

final case class InputRequirementRaw(
                                      file_type: String,
                                      table_name: String,
                                      constraints: Option[List[ResolutionConstraintRaw]],
                                      created_to: Option[Timestamp],
                                      created_from: Option[Timestamp],
                                      latest_only: Boolean,
                                      min_matches: Option[Long],
                                      source_entity_type: String,
                                      where_clause: Option[List[ResolutionConstraintRaw]]
                          /*            dataset_name: Option[String],
                                      retry_count: Option[Int],
                                      inter_retry_interval: Option[Int],
                                      as_view: Boolean  */
                                    )package hsbc.emf.udf.dateaddinternal

// Holds input and target tests data
case class InputTestData(date: java.sql.Date,
                         daysToAdd: Int,
                         strType: String,
                         target: java.sql.Date)
package hsbc.emf.sparkutils


import hsbc.emf.data.ingestion.LoadInfoRaw

import java.io.File
import java.util.UUID
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.logging.MessageContextTestData
import org.apache.commons.io.FileUtils
import org.apache.spark.{SparkConf, SparkContext}
import org.scalatest.{BeforeAndAfterAll, BeforeAndAfterEach, FlatSpec, Suite}
import org.apache.spark.sql.{SQLContext, SQLImplicits, SparkSession}
import org.apache.spark.sql.catalyst.optimizer.ConvertToLocalRelation
import org.apache.spark.sql.internal.SQLConf

trait IntegrationTestSuiteBase extends FlatSpec with BeforeAndAfterEach with BeforeAndAfterAll with MessageContextTestData {
  this: Suite =>

  private var _spark: SparkSession = _
  private var warehouseDir: String = _
  private var metastoreDbDir: String = _

  protected var path: String = _

  implicit lazy val spark = _spark

  protected def sparkContext: SparkContext = _spark.sparkContext

  protected def sparkConf: SparkConf = {
    val randomUUID = UUID.randomUUID.toString
    val tmpDir = System.getProperty("java.io.tmpdir")
    warehouseDir = s"${tmpDir}${File.separator}spark-warehouse${File.separator}$randomUUID"
    val warehousePath = new File(warehouseDir).getAbsolutePath

    metastoreDbDir = s"${tmpDir}${File.separator}metastore_db${File.separator}$randomUUID"
    val matastoreDbPath = new File(metastoreDbDir).getAbsolutePath

    new SparkConf()
      // Required spark conf; SparkEmfRunner took them from EmfConfig.sparkConfMap when running on cluster
      .set(EmfConfig.sparkConfSparkLogConfName, EmfConfig.sparkConfSparkLogConfValue)
      .set(EmfConfig.sparkConfHiveExecDynamicPartitionModeName, EmfConfig.sparkConfHiveExecDynamicPartitionModeValue)
      .set(EmfConfig.sparkConfSqlCrossJoinEnabledName, EmfConfig.sparkConfSqlCrossJoinEnabledValue)
      // Additional spark conf for local and ci tests
      .set("spark.unsafe.exceptionOnMemoryLeak", "true")
      .set("spark.ui.enabled", "false")
      .set("hive.stats.jdbc.timeout", "80")
      .set("spark.sql.session.timeZone", "UTC")
      .set("spark.sql.shuffle.partitions", "1")
      .set("spark.testing.memory", "471859200")
      .set("spark.sql.warehouse.dir", warehousePath)
      .set("javax.jdo.option.ConnectionURL", s"jdbc:derby:memory:;databaseName=$matastoreDbPath;create=true")
      .set("spark.sql.test", "")
      .set(SQLConf.CODEGEN_FALLBACK.key, "false")
      .set("spark.sql.hive.metastore.barrierPrefixes",
        "org.apache.spark.sql.hive.execution.PairSerDe")
      // Disable ConvertToLocalRelation for better test coverage. Test cases built on
      // LocalRelation will exercise the optimization rules better by disabling it as
      // this rule may potentially block testing of other optimization rules such as
      // ConstantPropagation etc.
      .set(SQLConf.OPTIMIZER_EXCLUDED_RULES.key, ConvertToLocalRelation.ruleName)
      .set("spark.sql.sources.partitionOverwriteMode", "dynamic")
  }

  override def beforeAll(): Unit = {
    import spark.implicits._
    _spark = SparkSession
      .builder()
      .master("local")
      .appName("spark unit tests")
      .config(sparkConf)
      .enableHiveSupport()
      .getOrCreate()
    _spark.sparkContext.setLogLevel("WARN")
    // create catalogue table and access_view
    spark.sql(s"create database if not exists ${EmfConfig.catalogueDatabaseName}")
    spark.sql(
      s"""create table if not exists ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}
         | (reporting_date timestamp,
         | domain string,
         | attribute string,
         | value string,
         | data_type string)
         | partitioned by
         | (file_type string,
         | created timestamp,
         | entity_uuid string)
         | stored as orc
       """.stripMargin)
    spark.sql(
      s"""create view if not exists ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView} as select m.entity_uuid as table_uuid,
         |max(m.file_type) as file_type, max(m.reporting_date) as reporting_date,
         |min(m.created) as created, m.entity_uuid as entity_uuid,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata
         |from catalogue.data m group by m.entity_uuid
      """.stripMargin)

    // create load_info table and access_view
    spark.sql(s"create database if not exists ${EmfConfig.loadInfoDatabaseName}")
    spark.sql(
      s"""create table if not exists ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}
         |(file_type String, schema String, primary_key String,
         |extension String, delimiter String, prefix String,
         |skip_rows String, quote_character String, dataset_name String,
         |dynamic_flag Boolean, max_bad_records String, schema_json String,
         |file_description String, file_category String, labels Array<String>,
         |write_disposition String, ingestion_workflow_name String,
         |ingest_hierarchy String, expiry_days Int, archive_days Int,
         |ingestion_parameters String, allow_quoted_newlines Boolean)
         |partitioned by
         |(entity_uuid String)
         |stored as parquet""".stripMargin)
    spark.sql(
      s"""create view if not exists ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultAccessView} as
         | select
         | d.*, m.created, m.metadata as metadata
         | from
         | ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} d
         | left outer join
         | (select
         | entity_uuid, created, metadata,
         |  DENSE_RANK() OVER(PARTITION BY file_type ORDER BY created DESC) AS rank
         |  from
         |  ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}) m on m.entity_uuid = d.entity_uuid and m.rank = 1
         |
       """.stripMargin)
    val loadInfoRawList = List(
      LoadInfoRaw(file_type = EmfConfig.catalogueDatabaseName,
        schema = Some("key:Long,value:String"),
        extension = Some("json"),
        ingest_hierarchy = Some("file_type/created"),
        ingestion_parameters = Some("{\"curate_format\":\"orc\",\"is_adjustable\":\"false\"}"),
        max_bad_records = Some("1"))
    )
    loadInfoRawList.toDF().write.mode("overwrite").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  }

  protected override def afterAll(): Unit = {
    //spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultAccessView}")
    //spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}")
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.loadInfoDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    cleanUpSparkSession()
  }

  protected object testImplicits extends SQLImplicits {
    protected override def _sqlContext: SQLContext = _spark.sqlContext
  }

  protected def createProcessTaskView(): Unit = {
    spark.sql(
      s"""create view if not exists ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView} as
         | select
         | d.*, m.created, m.metadata as metadata
         | from
         | ${EmfConfig.process_tasks}.${EmfConfig.defaultTableName} d
         | left outer join
         | (select
         | entity_uuid, created, metadata,
         |  DENSE_RANK() OVER(PARTITION BY file_type ORDER BY created DESC) AS rank
         |  from
         |  ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}) m on m.entity_uuid = d.entity_uuid and m.rank = 1
         |
       """.stripMargin)
  }

  private def cleanUpSparkSession(): Unit = {
    if (!_spark.sparkContext.isStopped) {
      _spark.sparkContext.stop()
      _spark.close()
      SparkSession.clearActiveSession()
      SparkSession.clearDefaultSession()
    }


    val warehousePath = new File(warehouseDir).getAbsolutePath
    FileUtils.deleteDirectory(new File(warehousePath))

    val matastoreDbPath = new File(metastoreDbDir).getAbsolutePath
    try {
      FileUtils.deleteDirectory(new File(matastoreDbPath))
    }
    catch {
      case e: Exception =>
        println(s"Error has occurred on delete metastore due to ${e.getMessage}")
    }
  }
}
package hsbc.emf.udf.Iinversenormaldistribution

import hsbc.emf.udf.{SparkUdfRegisterableFunction1, UdfBuilder}

private[udf] class InverseNormalDistribution extends SparkUdfRegisterableFunction1[Double, Option[Double]] {

  import InverseNormalDistribution.context

  def apply(v1: Double): Option[Double] = {
    InverseNormalDistribution.safeExecute {
      context.eval("js", InverseNormalDistributionJavaScript.js)
      context
        .getBindings("js").putMember("p", v1)
      val value = context.eval("js", s"$functionName(p)")
      Option(value.asDouble())
    }
  }

  override val functionName: String = "INVERSE_NORMAL_DISTRIBUTION"
}

private[udf] object InverseNormalDistribution extends UdfBuilder[InverseNormalDistribution]{
  override def apply: InverseNormalDistribution = new InverseNormalDistribution()
}package hsbc.emf.udf.Iinversenormaldistribution

private[Iinversenormaldistribution] object InverseNormalDistributionJavaScript {
 val js: String =
   """
     |INVERSE_NORMAL_DISTRIBUTION = function (p) {
     |    var s = Math.sqrt(2);
     |    var x = 2 * p - 1;
     |    var w = -Math.log((1.0 - x) * (1.0 + x));
     |    if (w < 6.25) {
     |        w -= 3.125;
     |        p = -3.6444120640178196996e-21;
     |        p = -1.685059138182016589e-19 + p * w;
     |        p = 1.2858480715256400167e-18 + p * w;
     |        p = 1.115787767802518096e-17 + p * w;
     |        p = -1.333171662854620906e-16 + p * w;
     |        p = 2.0972767875968561637e-17 + p * w;
     |        p = 6.6376381343583238325e-15 + p * w;
     |        p = -4.0545662729752068639e-14 + p * w;
     |        p = -8.1519341976054721522e-14 + p * w;
     |        p = 2.6335093153082322977e-12 + p * w;
     |        p = -1.2975133253453532498e-11 + p * w;
     |        p = -5.4154120542946279317e-11 + p * w;
     |        p = 1.051212273321532285e-09 + p * w;
     |        p = -4.1126339803469836976e-09 + p * w;
     |        p = -2.9070369957882005086e-08 + p * w;
     |        p = 4.2347877827932403518e-07 + p * w;
     |        p = -1.3654692000834678645e-06 + p * w;
     |        p = -1.3882523362786468719e-05 + p * w;
     |        p = 0.0001867342080340571352 + p * w;
     |        p = -0.00074070253416626697512 + p * w;
     |        p = -0.0060336708714301490533 + p * w;
     |        p = 0.24015818242558961693 + p * w;
     |        p = 1.6536545626831027356 + p * w;
     |    } else if (w < 16.0) {
     |        w = Math.sqrt(w) - 3.25;
     |        p = 2.2137376921775787049e-09;
     |        p = 9.0756561938885390979e-08 + p * w;
     |        p = -2.7517406297064545428e-07 + p * w;
     |        p = 1.8239629214389227755e-08 + p * w;
     |        p = 1.5027403968909827627e-06 + p * w;
     |        p = -4.013867526981545969e-06 + p * w;
     |        p = 2.9234449089955446044e-06 + p * w;
     |        p = 1.2475304481671778723e-05 + p * w;
     |        p = -4.7318229009055733981e-05 + p * w;
     |        p = 6.8284851459573175448e-05 + p * w;
     |        p = 2.4031110387097893999e-05 + p * w;
     |        p = -0.0003550375203628474796 + p * w;
     |        p = 0.00095328937973738049703 + p * w;
     |        p = -0.0016882755560235047313 + p * w;
     |        p = 0.0024914420961078508066 + p * w;
     |        p = -0.0037512085075692412107 + p * w;
     |        p = 0.005370914553590063617 + p * w;
     |        p = 1.0052589676941592334 + p * w;
     |        p = 3.0838856104922207635 + p * w;
     |    } else if (isFinite(w)) {
     |        w = Math.sqrt(w) - 5.0;
     |        p = -2.7109920616438573243e-11;
     |        p = -2.5556418169965252055e-10 + p * w;
     |        p = 1.5076572693500548083e-09 + p * w;
     |        p = -3.7894654401267369937e-09 + p * w;
     |        p = 7.6157012080783393804e-09 + p * w;
     |        p = -1.4960026627149240478e-08 + p * w;
     |        p = 2.9147953450901080826e-08 + p * w;
     |        p = -6.7711997758452339498e-08 + p * w;
     |        p = 2.2900482228026654717e-07 + p * w;
     |        p = -9.9298272942317002539e-07 + p * w;
     |        p = 4.5260625972231537039e-06 + p * w;
     |        p = -1.9681778105531670567e-05 + p * w;
     |        p = 7.5995277030017761139e-05 + p * w;
     |        p = -0.00021503011930044477347 + p * w;
     |        p = -0.00013871931833623122026 + p * w;
     |        p = 1.0103004648645343977 + p * w;
     |        p = 4.8499064014085844221 + p * w;
     |    } else if (!isFinite(w)) {
     |        p = 0.0;
     |        x = 0.0;
     |    }
     |
     |    return (p * x * s);
     |}
     |""".stripMargin
}
package hsbc.emf.udf.Iinversenormaldistribution

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.Row
import org.scalactic.{Equality, TolerantNumerics}
import org.scalatest.FlatSpec

class InverseNormalDistributionTest extends FlatSpec with IntegrationTestSuiteBase {
  private implicit val doubleEquality: Equality[Double] = TolerantNumerics.tolerantDoubleEquality(1e-12)

  val inputVsTarget = Seq(
    (Some(0.19), Some(-0.87789629505122868)),
    (Some(0.042), Some(-1.7279343223884189)),
    (Some(0.13), Some(-1.1263911290388007)),
    (Some(0.1), Some(-1.2815515655446006)),
    (Some(0.0), Some(0.0)),
    (None, None)
  )

  behavior of "InverseNormalDistribution"

  it should "return the inverse normal distribution at value x within 1e-12 tolerance in a UDF" in {

    val testObj = new InverseNormalDistribution()
    spark.udf.register("INVERSE_NORMAL_DISTRIBUTION", testObj.apply _)
    import spark.implicits._
    inputVsTarget.toDF("input", "target").createOrReplaceTempView("inputVsTarget")

    val results = spark
      .sql("select INVERSE_NORMAL_DISTRIBUTION(input) as result,target from inputVsTarget")


    val equals = results.collect().map {
      case Row(result: Double, target: Double) => result === target
      // needed when input/output is null
      case Row(result, target) => result == target
    }

    assert(equals.reduce(_ & _))
  }

}
package hsbc.emf.service.orchestration

import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage

trait IProcessTasksResolver {
  /** Resolved process tasks into a List of ProcessTask */
  def resolveProcessTasks(sparkRunMessage: SparkRunMessage): Seq[ProcessTask]
}
package hsbc.emf.service.orchestration

import hsbc.emf.data.orchestration.ProcessTask

trait IProcessTasksSorter {
  /** Sort the Seq of ProcessTask by parent-child relationships to represent the DAG and return the sorted process tasks
    * split by sorting pass so that parallel execution is possible. Each Seq[ProcessTask] in result Seq[Seq[ProcessTask]
    * is the subset that can be run in parallel. */
  def sortProcessTasks(processTasks: Seq[ProcessTask]): Seq[Seq[ProcessTask]]
}
package hsbc.emf.data.resolution

sealed trait ISourceEntityType
case object DATA extends ISourceEntityType
case object ADJUSTED_UNAPPROVED extends  ISourceEntityType
case object ADJUSTED_APPROVED extends ISourceEntityTypepackage hsbc.emf.service.ingestion

import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import org.apache.spark.sql.DataFrame

trait ISparkCatalougeService extends SparkSessionWrapper {
  def write(metaDataDF: DataFrame,UUID:String): Unit
}
package hsbc.emf.service.loadtablefromfile


import hsbc.emf.data.ingestion.LoadInfo
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import org.apache.spark.sql.DataFrame

trait ISparkChunkedStorageService {
  def write(loadInfo: LoadInfo, dataDF: DataFrame, partitions : Long,message:SparkLoadTableFromFileMessage): Unit
}package hsbc.emf.command

import hsbc.emf.constants.ExecutionResult
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

abstract class ISparkCommand {
  def run(): ExecutionResult

  def messageValidate(message: ISparkCommandMessage): Boolean

  // To avoid affecting the constructor contract of each command, provide a var in superclass and let user call the setter when needed
  var placeholderParams: PlaceholderParameters = PlaceholderParameters(Map.empty[String, Any])

  // Add new PlaceholderParameters to the existing PlaceholderParameters.
  // For parameters with same name, the value in the new PlaceholderParameters will replace the value in the existing PlaceholderParameters.
  // For normal workflow, this means the value in the command will replace the value from SparkRun (dim_queue parameters).
  // For Workflow of Workflow, this means the value in sub-workflow will replace the value from parent workflow.
  // This is the same behavior as EMF1.
  def addPlaceholderParams(newPlaceholderParams: PlaceholderParameters): Unit = {
    placeholderParams = PlaceholderParameters(placeholderParams.paramMap ++ newPlaceholderParams.paramMap)
  }

  // Based on Process task, MessageInfo object created and to be set by Orchestration Framework for logging.
  // It needs to be var at least in concrete class level so that it can be set after the command is constructed.
  // If we followed the usual practice to define it as def here and then implemented it as var in the command class,
  // it can only be set via subclass reference but couldn't be set via superclass reference.
  var _messageInfo: MessageInfo = _
}package hsbc.emf.command

trait ISparkCommandMessagepackage hsbc.emf.service.createtable

import hsbc.emf.infrastructure.exception.EmfServiceException


trait ISparkCreateTableService {

  @throws(classOf[EmfServiceException])
  def createTableFromFileType(file_type: String,
                              target_database: String,
                              target_table: String,
                              inject_metadata: Boolean,
                              adjustable_override: Boolean): Unit

}
package hsbc.emf.service.crm.calculators

import hsbc.emf.data.crm.{Approach, CrmInput, CrmOutput}

trait ISparkCrmCalculator {
  def calculate(approach: Approach, crmInputsList: List[CrmInput]): List[CrmOutput]
}
package hsbc.emf.service.crm

import hsbc.emf.data.sparkcmdmsg.SparkRwaCrmMessage

trait ISparkCrmService {
  def calculate(message: SparkRwaCrmMessage) : Unit
}
package hsbc.emf.service.ingestion

import hsbc.emf.data.ingestion.LoadInfo
import org.apache.spark.sql.{DataFrame, SaveMode}

trait ISparkCuratedStorageService {
  /**
   * write dataframe into the curation storage table location
   * 2021-07-05: it's been deprecated because directly written a dataframe as file(s) onto CFS location
   * will result in schema inconsistent problem ( issue defected during 10908 testing:
   * the decimal field(s) in table mismatches with the double field(s) of the saved file(s)/dataframe from source )
   *
   * @param loadInfo
   * @param dataDF
   * @param metadata
   * @param uuid
   * @param mode
   */
  @deprecated("it's been deprecated because directly written a dataframe as file(s) onto CFS location will result in schema inconsistent problem","2021-07-05")
  def write(loadInfo: LoadInfo, dataDF: DataFrame, metadata: DataFrame, uuid: String, mode: SaveMode = SaveMode.Append): Unit

  /**
   * insert dataframe into the curation storage table
   *
   * @param loadInfo
   * @param dataDF
   * @param metadata
   * @param uuid
   * @param mode
   */
  def insert(loadInfo: LoadInfo, dataDF: DataFrame, metadata: DataFrame, uuid: String, mode: SaveMode = SaveMode.Append): Unit
}
package hsbc.emf.service.curate

import hsbc.emf.data.sparkcmdmsg.SparkCurateMessage


trait ISparkCurateService {
  def curate(msg: SparkCurateMessage): Unit
}




package hsbc.emf.service.orchestration

import hsbc.emf.command.ISparkCommand
import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

trait ISparkDagBuilder {
  def buildDag(processTasksSplitByDependency: Seq[Seq[ProcessTask]],
               workflowParameters: PlaceholderParameters,
               enabled: Map[String, List[String]] = Map.empty,
               disabled: Map[String, List[String]] = Map.empty,
               workflow: String,
               runUUID: String): Seq[Seq[ISparkCommand]]
}package hsbc.emf.service.export

import hsbc.emf.data.sparkcmdmsg.SparkExportAllResolutionsMessage


trait ISparkExportAllResolutionsService {
  def resolveAndExport(message: SparkExportAllResolutionsMessage): Unit
}package hsbc.emf.service.export

import hsbc.emf.data.sparkcmdmsg.SparkExportMessage

trait ISparkExportService {
  def export(msg: SparkExportMessage): Unit
}
package hsbc.emf.service.ingestion

import hsbc.emf.data.sparkcmdmsg.SparkIngestMessage
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.types.StructType
import hsbc.emf.data.ingestion.Schema

trait ISparkIngestService {
  def ingest(message: SparkIngestMessage): Unit
  //def validate(dfSchema:StructType, loadInfoSchema:Schema, recordCountFromMetadata:Long, dfRecordCount:Long): Boolean
}
package hsbc.emf.service.loadtablefromfile

import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage

trait ISparkLoadTableFromFileService {

  def loadTableFromFile(message: SparkLoadTableFromFileMessage): Unit

}
package hsbc.emf.service.orchestration

import hsbc.emf.constants.ExecutionResult
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

trait ISparkOrchestrateService {

  def executeWorkFlow(sparkRunMessage: SparkRunMessage, workflowParameters: PlaceholderParameters): ExecutionResult

}
package hsbc.emf.service.resolution

import hsbc.emf.data.ingestion.CatalogueEntity
import hsbc.emf.data.resolution.ResolutionCriteria
import hsbc.emf.data.sparkcmdmsg.{SparkResolveFromInputRequirementsMessage, SparkResolveMessage}
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

trait ISparkResolveService {

  def resolve(resolveMessage: SparkResolveMessage): Unit
  def resolveFromTable(sparkResolveFromInputRequirementsMessage: SparkResolveFromInputRequirementsMessage,
                       placeholderParams: PlaceholderParameters): Unit
  def constructCatalogue4Uuids(criteria: ResolutionCriteria, latestOnly: Boolean): (List[CatalogueEntity], String)

}
package hsbc.emf.service.ingestion

trait SparkService
package hsbc.emf.service.sqleval

import hsbc.emf.data.sparkcmdmsg.{SparkAssertMessage, SparkMessagesFromQueryMessage, SparkSqlEvalMessage, SparkSqlFromFileMessage}
import hsbc.emf.infrastructure.exception.EmfServiceException


trait ISparkSqlEvalService {
  @throws(classOf[EmfServiceException])
  def sqlEval(msg: SparkSqlEvalMessage): Unit

  @throws(classOf[EmfServiceException])
  def sqlFromFile(msg: SparkSqlFromFileMessage): String

  @throws(classOf[EmfServiceException])
  def evalQueryToGetMessageDetails(message: SparkMessagesFromQueryMessage): List[SparkSqlEvalMessage]

  @throws(classOf[EmfServiceException])
  def sqlAssert(message: SparkAssertMessage): Boolean
}package hsbc.emf.service.trigger

import hsbc.emf.data.sparkcmdmsg.SparkTriggerMessage

trait ISparkTriggerService {
  def trigger(message: SparkTriggerMessage): Unit
  }
package hsbc.emf.infrastructure.sql

import hsbc.emf.infrastructure.exception.{EmfSqlAnalysisException, EmfSqlException}
import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import org.apache.spark.sql.DataFrame

trait ISqlExecutor extends SparkSessionWrapper {
  @throws(classOf[EmfSqlAnalysisException])
  @throws(classOf[EmfSqlException])
  def execute(sql: String): DataFrame
}
package hsbc.emf.service.orchestration

import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

trait IWorkflowExecEnvInitializer {
  def generateRunUuidAndZzzDb(sparkRunMessage: SparkRunMessage, placeholderParameters: PlaceholderParameters): PlaceholderParameters
}
package hsbc.emf.infrastructure.helper

import scala.reflect.runtime.universe.typeOf

import hsbc.emf.infrastructure.exception.{EmfJsonDeserializeException, EmfJsonSerializeException}
import hsbc.emf.infrastructure.serde._
import org.json4s.{DefaultFormats, Formats}
import org.json4s.jackson.Serialization.{read, write}

object JsonReader {
  val serializers = List(WriteDispositionSerializer, SeveritySerializer,
    SparkCommandAllParametersSerializer, ComparisonOperatorSerializer, MessageInfoSerializer, CustomTimestampSerializer, ApproachSerializer)
  implicit val formats: Formats = DefaultFormats ++ serializers


  def deserializeWithCheck[T: Manifest](jsonString: String): T = {
    val jsonEitherObject = deserialize[T](jsonString)
    if (jsonEitherObject.isLeft) throw jsonEitherObject.left.get
    jsonEitherObject.right.get
  }

  def deserialize[T: Manifest](jsonString: String): Either[EmfJsonDeserializeException, T] = {
    try {
      Right(read[T](jsonString))
    } catch {
      case ex: Exception =>
        val exceptionMessage = s"${typeOf[T].typeSymbol.name.toString} Deserialization Failed. Reason: ${ex.getMessage} JsonString: $jsonString"
        Left(new EmfJsonDeserializeException(exceptionMessage, ex.getCause))
    }
  }

  def serialize[T: Manifest](instance: AnyRef): Either[EmfJsonSerializeException, String] = {
    try {
      Right(write(instance))
    } catch {
      case ex: Exception =>
        val exceptionMessage = s"${typeOf[T].typeSymbol.name.toString} serialization Failed. Reason: ${ex.getMessage}"
        Left(new EmfJsonSerializeException(exceptionMessage, ex.getCause))
    }
  }
}package hsbc.emf.data.ingestion

import hsbc.emf.infrastructure.config.FileFormatConfig

final case class LoadInfo(
                           fileType: String,
                           schema: Schema,
                           primaryKey: Option[String] = None,
                           fileFormatConfig: FileFormatConfig,
                           curateFormatConfig: FileFormatConfig,
                           prefix: Option[String] = None,
                           datasetName: Option[String] = None,
                           dynamicFlag: Option[Boolean] = None,
                           maxBadRecords: Option[Int] = None,
                           fileDescription: Option[String] = None,
                           fileCategory: Option[String] = None,
                           labels: Option[Array[String]] = None,
                           writeDisposition: Option[String] = None,
                           ingestHierarchy: IngestionHierarchy,
                           expiryDays: Option[Int] = None,
                           archiveDays: Option[Int] = None,
                           ingestionParameters: Map[String, Any] = Map.empty[String, Any],
                           allowQuotedNewlines: Option[Boolean] = None,
                           isAdjustable: Option[Boolean] = None,
                           ingestionWorkflowName: Option[String] = None
                         ) {

  def changeCurateFormatConfig(format: FileFormatConfig): LoadInfo = this.copy(curateFormatConfig = format)

}


package hsbc.emf.dao.ingestion

import hsbc.emf.data.ingestion.{LoadInfo, LoadInfoRaw}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, MissingLoadInfo, MultipleLoadInfo}
import hsbc.emf.infrastructure.helper.HiveUtils
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.infrastructure.spark.SparkSessionWrapper
import hsbc.emf.infrastructure.sql.ISqlExecutor

import org.apache.spark.sql.SparkSession

class LoadInfoDAO(sqlExecutor: ISqlExecutor)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ILoadInfoDAO with SparkSessionWrapper with MessageContext {
  var loadInfoSchema = EmfConfig.loadInfoDatabaseName
  var loadInfoTable = EmfConfig.defaultAccessView
  val loadInfoCacheTable = EmfConfig.loadInfoCacheView

  @throws(classOf[EmfLoadInfoDaoException])
  def readByType(fileType: String): Option[LoadInfo] = {
    if (!HiveUtils.checkTableInCatalogue(loadInfoCacheTable)) {
      val sql =
        s"""SELECT
           | file_type, schema, primary_key, extension, delimiter,
           | prefix, skip_rows, quote_character, dataset_name,
           | dynamic_flag, max_bad_records, schema_json, file_description,
           | file_category, labels, write_disposition, ingestion_workflow_name,
           | ingest_hierarchy, expiry_days, archive_days, ingestion_parameters,
           | allow_quoted_newlines, entity_uuid
           | FROM ${loadInfoSchema}.${loadInfoTable}""".stripMargin
      sqlExecutor.execute(sql).createOrReplaceTempView(loadInfoCacheTable)
      spark.catalog.cacheTable(loadInfoCacheTable)
    }
    val executionResult = sqlExecutor.execute(s"select * from $loadInfoCacheTable where upper(file_type)=upper('$fileType')")
    import spark.implicits._
    val loadInfoList = executionResult.as[LoadInfoRaw].collect().toList
    if (loadInfoList.length == 1) {
      try {
        Some(LoadInfoRawToLoadInfoMapper.map(loadInfoList.head))
      } catch {
        case e: Exception =>
          val customMessage = "LoadInfoDAO.readByType fails on calling the LoadInfoRawToLoadInfoMapper.map with cause: " + e.getMessage
          EmfLogger.error(customMessage)
          throw new EmfLoadInfoDaoException(customMessage, e.getCause)
      }
    }
    else if (loadInfoList.length > 1) {
      throw new MultipleLoadInfo(s"${fileType} has multi entries returned from ${loadInfoSchema}.${loadInfoTable}")
    }
    else {
      throw new MissingLoadInfo(s"${fileType} has no entity returned from ${loadInfoSchema}.${loadInfoTable}")
    }


  }
}
package hsbc.emf.dao.ingestion

import hsbc.emf.data.ingestion.{LoadInfoRaw, MetadataRaw}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, MissingLoadInfo, MultipleLoadInfo}
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.{SaveMode, SparkSession}

class LoadInfoDAOTest extends IntegrationTestSuiteBase {

  val tableName = EmfConfig.defaultTableName
  val databaseName = EmfConfig.loadInfoDatabaseName

  override def beforeAll(): Unit = {
    super.beforeAll()
  }

  override def afterAll(): Unit = {
    super.afterAll()
  }


  "given a non-exist file type" should "throw MissingLoadInfo" in {
    val caught = intercept[MissingLoadInfo] {
      val nonExistFileType = "nonexit"
      val loadInfoDAO = new LoadInfoDAO(new SqlExecutor())
      loadInfoDAO.loadInfoSchema = databaseName
      loadInfoDAO.readByType(nonExistFileType)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given an existence file type with mutli-rows returned" should "throw MultipleLoadInfo" in {
    val mutilExistFileType = "multiexist"
    val loadInfoRawList = List(LoadInfoRaw(file_type = s"$mutilExistFileType"), LoadInfoRaw(file_type = s"$mutilExistFileType"))
    import spark.implicits._
    loadInfoRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"$databaseName.$tableName")
    val caught = intercept[MultipleLoadInfo] {
      val loadInfoDAO = new LoadInfoDAO(new SqlExecutor())
      loadInfoDAO.loadInfoSchema = databaseName
      loadInfoDAO.readByType(mutilExistFileType)
    }
    assert(!caught.getMessage.isEmpty)
  }
  "given an only existence file type with no attributes defined" should "throw EmfLoadInfoDaoException" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val existFileTypeWithoutAttr = "existwithoutattr"
    val loadInfoRawList = List(LoadInfoRaw(entity_uuid = Some("dummy_id"), file_type = s"$existFileTypeWithoutAttr"))
    val metadataRawList = List(MetadataRaw("dummy_id", existFileTypeWithoutAttr, new java.sql.Timestamp(System.currentTimeMillis()), "file_type", "dummy2", "dummy3", "dummy4", None))
    import spark.implicits._
    loadInfoRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"$databaseName.$tableName")
    metadataRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")
    val caught = intercept[EmfLoadInfoDaoException] {
      val loadInfoDAO = new LoadInfoDAO(new SqlExecutor())
      loadInfoDAO.loadInfoSchema = databaseName
      loadInfoDAO.readByType(existFileTypeWithoutAttr)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given an only existence file type" should "not throw Exception" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val existFileType = "existFileType"

    val uuid = generateEntityUUID()
    // prepare load_info entries
    val loadInfoRawList = List(LoadInfoRaw(file_type = s"$existFileType", schema = Some("fieldName1:String,fieldName2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("entity_uuid|created_date"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"), entity_uuid = Some(uuid)))
    import spark.implicits._
    loadInfoRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"$databaseName.$tableName")
    // prepare catalogue entries
//    val metadataRaw = MetadataRaw(uuid, existFileType, new java.sql.Timestamp(System.currentTimeMillis()), "file_type", "dummy2", "dummy3", "dummy4", None)
//    val metadataRawList = List(metadataRaw)
//    new CatalogueDAO(new SqlExecutor()).write(metadataRawList)
    // actual test perform
    val loadInfoDAO = new LoadInfoDAO(new SqlExecutor())
    loadInfoDAO.loadInfoSchema = databaseName
    loadInfoDAO.readByType(existFileType)
    val loadInfoDf = spark.sql(s"select * from $databaseName.$tableName where file_type = '${existFileType}'")
    assert(loadInfoDf.collectAsList().size() == 1)

  }
}
package hsbc.emf.data.ingestion

final case class LoadInfoRaw(
                              file_type: String,
                              schema: Option[String] = None,
                              primary_key: Option[String] = None,
                              extension: Option[String] = None,
                              delimiter: Option[String] = None,
                              prefix: Option[String] = None,
                              skip_rows: Option[String] = None,
                              quote_character: Option[String] = None,
                              dataset_name: Option[String] = None,
                              dynamic_flag: Option[Boolean] = None,
                              max_bad_records: Option[String] = None,
                              schema_json: Option[String] = None,
                              file_description: Option[String] = None,
                              file_category: Option[String] = None,
                              labels: Option[Array[String]] = None,
                              write_disposition: Option[String] = None,
                              ingestion_workflow_name: Option[String] = None,
                              ingest_hierarchy: Option[String] = None,
                              expiry_days: Option[Int] = None,
                              archive_days: Option[Int] = None,
                              ingestion_parameters: Option[String] = None,
                              allow_quoted_newlines: Option[Boolean] = None,
                              entity_uuid: Option[String] = None)


package hsbc.emf.infrastructure.services.mapper

import hsbc.emf.data.ingestion._
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception._
import hsbc.emf.infrastructure.helper.JsonReader

object LoadInfoRawToLoadInfoMapper extends IMapper[LoadInfoRaw, LoadInfo] {
  @throws(classOf[EmfLoadInfoMapperException])
  override def map(loadInfoRaw: LoadInfoRaw): LoadInfo = {
    try {
      val (ingestionParameters: Map[String, Any], isAdjustable: Option[Boolean]) = transformIngestionParameters(loadInfoRaw.ingestion_parameters)
      val schema: Schema = Schema(loadInfoRaw.schema, loadInfoRaw.schema_json)
      val maxBadRecords: Int = loadInfoRaw.max_bad_records.getOrElse(0).toString.toInt
      val expiryDays: Int = loadInfoRaw.expiry_days.getOrElse(-1)
      val archiveDays: Int = loadInfoRaw.archive_days.getOrElse(-1)
      val ingestionHierarchy: IngestionHierarchy = IngestionHierarchy(loadInfoRaw.ingest_hierarchy)
      val fileFormatConfig: FileFormatConfig = transformFileFormatConfig(loadInfoRaw)
      val curateFormatConfig: FileFormatConfig = transformCurateFormatConfig(loadInfoRaw)

      LoadInfo(loadInfoRaw.file_type,
        schema,
        loadInfoRaw.primary_key,
        fileFormatConfig,
        curateFormatConfig,
        loadInfoRaw.prefix,
        loadInfoRaw.dataset_name,
        loadInfoRaw.dynamic_flag,
        Some(maxBadRecords),
        loadInfoRaw.file_description,
        loadInfoRaw.file_category,
        loadInfoRaw.labels,
        loadInfoRaw.write_disposition,
        ingestionHierarchy,
        Some(expiryDays),
        Some(archiveDays),
        ingestionParameters,
        loadInfoRaw.allow_quoted_newlines,
        isAdjustable,
        loadInfoRaw.ingestion_workflow_name
      )
    } catch {
      case e: EmfIngestionParametersMapperException =>
        throw e
      case e: Throwable =>
        val customMessage = "LoadInfoRawToLoadInfoMapper.map fails with other reason: " + e.getMessage
        throw new EmfLoadInfoMapperException(customMessage, e)
    }
  }

  @throws(classOf[EmfIngestionParametersMapperException])
  def transformIngestionParameters(ingestionParametersString: Option[String]): (Map[String, Any], Option[Boolean]) = {
    var isAdjustable: Option[Boolean] = None
    try {
      if (ingestionParametersString.getOrElse("").trim.isEmpty) {
        (Map.empty[String, Any], isAdjustable)
      } else {
        val result = JsonReader.deserialize[Map[String, Any]](ingestionParametersString.get)
        val error = result.left.exists(e => e match {
          case e1: EmfJsonDeserializeException => true
          case _ => true
        })
        if (error) {
          throw result.left.get
        } else {
          if (result.right.get.filter(entry => entry._1 == EmfConfig.isAdjustableInIngestionParameters).size > 0) {
            isAdjustable = Some(result.right.get.filter(entry => entry._1.equalsIgnoreCase(EmfConfig.isAdjustableInIngestionParameters)).head._2.toString.toBoolean)
          }
          (result.right.get, isAdjustable)
        }
      }
    } catch {
      case e: EmfException => {
        val customMessage = s"""LoadInfoRawToLoadInfoMapper.transformIngestionParameters: unable to construct the IngestionParameters [Map[String, Any]] object by deserializing from ingestion_parameters ${ingestionParametersString} with cause ${e.getMessage}"""
        throw new EmfIngestionParametersMapperException(customMessage, e.getCause)
      }
    }
  }

  @throws(classOf[EmfUnsupportedFileFormatException])
  def transformFileFormatConfig(loadInfoRaw: LoadInfoRaw): FileFormatConfig = {
    var useAvroLogicalType: Boolean = false
    val (ingestionParameters: Map[String, Any], isAdjustable: Option[Boolean]) = transformIngestionParameters(loadInfoRaw.ingestion_parameters)

    if (ingestionParameters.filter(entry => entry._1 == "use_avro_logical_types").size > 0) {
      useAvroLogicalType = ingestionParameters.filter(entry => entry._1.equalsIgnoreCase("use_avro_logical_types")).head._2.toString.toBoolean
    }

    val fileFormatConfig: FileFormatConfig = loadInfoRaw.extension match {
      case Some("csv") => CsvFileFormatConfig(
        loadInfoRaw.delimiter.get, loadInfoRaw.skip_rows.map(_.toInt).get, loadInfoRaw.quote_character.get)
      case Some("json") => JsonFileFormatConfig()
      case Some("avro") => AvroFileFormatConfig(useAvroLogicalType)
      case Some("orc") => OrcFileFormatConfig()
      case Some("parquet") => ParquetFileFormatConfig()
      case Some("") => ParquetFileFormatConfig()
      case None => ParquetFileFormatConfig()
      case other => throw new EmfUnsupportedFileFormatException(s"LoadInfoRawToLoadInfoMapper.transformFileFormatConfig - extension='${other}' is not supported for source reader.")
    }
    fileFormatConfig
  }

  @throws(classOf[EmfUnsupportedFileFormatException])
  def transformCurateFormatConfig(loadInfoRaw: LoadInfoRaw): FileFormatConfig = {
    val (ingestionParameters: Map[String, Any], isAdjustable: Option[Boolean]) = transformIngestionParameters(loadInfoRaw.ingestion_parameters)
    // default curate format is "parquet"
    var curateFormatString: String = EmfConfig.defaultCurateFormat
    if (!ingestionParameters.isEmpty) {
      if (ingestionParameters.filter(entry => entry._1 == EmfConfig.curateFormatFieldInIngestionParameters).size > 0) {
        curateFormatString = ingestionParameters.filter(entry => entry._1.equalsIgnoreCase(EmfConfig.curateFormatFieldInIngestionParameters)).head._2.toString
      }
     }
    val curateFormat: FileFormatConfig = curateFormatString.toLowerCase match {
      case "csv" => CsvFileFormatConfig(
        loadInfoRaw.delimiter.get, loadInfoRaw.skip_rows.map(_.toInt).get, loadInfoRaw.quote_character.get)
      case "json" => JsonFileFormatConfig()
      case "avro" => AvroFileFormatConfig()
      case "orc" => OrcFileFormatConfig()
      case "parquet" => ParquetFileFormatConfig()
      case other => throw new EmfUnsupportedFileFormatException(s"LoadInfoRawToLoadInfoMapper.transformCurateFormatConfig - extension='${other}' is not supported for curation writer.")
    }
    curateFormat
  }
}package hsbc.emf.infrastructure.services.mapper

import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.{EmfIngestionParametersMapperException, EmfLoadInfoMapperException, EmfUnsupportedFileFormatException}
import org.scalatest.FlatSpec

class LoadInfoRawToLoadInfoMapperTest extends FlatSpec {
  "transformFileFormatConfig test: give a csv extension" should "return a CsvFileFormatConfig" in {
    val fileType = "ft_csv"
    val extension = "csv"
    val delimiterValue = ","
    val skipRowsValue = "2"
    val quoteCharacterValue = "'"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension), delimiter = Some(delimiterValue), skip_rows = Some(skipRowsValue), quote_character = Some(quoteCharacterValue)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[CsvFileFormatConfig])
    val csvFileFormatConfig = fileFormatConfig.asInstanceOf[CsvFileFormatConfig]
    assert(csvFileFormatConfig.delimiter.equals(delimiterValue) && csvFileFormatConfig.skipRows.equals(skipRowsValue.toInt) && csvFileFormatConfig.quoteCharacter.equals(quoteCharacterValue))
  }

  "transformFileFormatConfig test: give an orc extension" should "return a OrcFileFormatConfig" in {
    val fileType = "ft_orc"
    val extension = "orc"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[OrcFileFormatConfig])
  }

  "transformFileFormatConfig test: give a json extension" should "return a JsonFileFormatConfig" in {
    val fileType = "ft_json"
    val extension = "json"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[JsonFileFormatConfig])
  }

  "transformFileFormatConfig test: give a avro extension" should "return a AvroFileFormatConfig" in {
    val fileType = "ft_avro"
    val extension = "avro"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[AvroFileFormatConfig])
  }

  "transformFileFormatConfig test: give a parquet extension" should "return a ParquetFileFormatConfig" in {
    val fileType = "ft_parquet"
    val extension = "parquet"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[ParquetFileFormatConfig])
  }

  "transformFileFormatConfig test: give an empty extension" should "return a ParquetFileFormatConfig as default" in {
    val fileType = "ft_parquet"
    val extension = "parquet"
    val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    assert(fileFormatConfig.format.equals(extension) && fileFormatConfig.isInstanceOf[ParquetFileFormatConfig])
  }

  "transformFileFormatConfig test: give an unsupported extension" should "throw EmfUnsupportedFileFormatException" in {
    val fileType = "ft_unsupported"
    val extension = "unsupported"
    val caught = intercept[EmfUnsupportedFileFormatException] {
      val fileFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformFileFormatConfig(LoadInfoRaw(file_type = fileType, extension = Some(extension)))
    }
    assert(!caught.getMessage.isEmpty)
  }

  "transformCurateFormatConfig test: value ingestion parameter 'curate_format' with orc" should "return a OrcFileFormatConfig" in {
    val fileType = "ft_orc"
    val extension = "parquet"
    val curateFormat = "orc"
    val ingestion_parameters =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"${curateFormat}"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(file_type = fileType, schema = Some("fieldName1:String,fieldName2:Int"), extension = Some(s"${extension}"), ingest_hierarchy = Some("entity_uuid/created_date"), ingestion_parameters = Some(ingestion_parameters), max_bad_records = Some("1"))
    val curateFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformCurateFormatConfig(loadInfoRaw)
    assert(curateFormatConfig.format.equals(curateFormat) && curateFormatConfig.isInstanceOf[OrcFileFormatConfig])
  }

  "transformCurateFormatConfig test: give no ingestion parameter 'curate_format'" should "return a ParquetFileFormatConfig" in {
    val fileType = "ft_parquet"
    val extension = "parquet"
    val ingestion_parameters =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(file_type = fileType, schema = Some("fieldName1:String,fieldName2:Int"), extension = Some(s"${extension}"), ingest_hierarchy = Some("entity_uuid/created_date"), ingestion_parameters = Some(ingestion_parameters), max_bad_records = Some("1"))
    val curateFormatConfig: FileFormatConfig = LoadInfoRawToLoadInfoMapper.transformCurateFormatConfig(loadInfoRaw)
    assert(curateFormatConfig.format.equals("parquet") && curateFormatConfig.isInstanceOf[ParquetFileFormatConfig])
  }

  "transformIngestionParameters test: give a valid ingestionParametersString" should "return a Map[String, Any] object" in {
    val ingestionParametersString = "{\"is_adjustable\": \"false\"}"
    val (ingestionParameters: Map[String, Any], isAdjustable: Option[Boolean]) = LoadInfoRawToLoadInfoMapper.transformIngestionParameters(Some(ingestionParametersString))
    assert(isAdjustable.get.equals(false))
  }

  "transformIngestionParameters test: give an invalid ingestionParametersString" should "throw EmfIngestionParametersMapperException" in {
    val ingestionParametersString = "{\"is_adjustable\"}"
    val caught = intercept[EmfIngestionParametersMapperException] {
      val (ingestionParameters: Map[String, Any], isAdjustable: Option[Boolean]) = LoadInfoRawToLoadInfoMapper.transformIngestionParameters(Some(ingestionParametersString))
    }
    assert(!caught.getMessage.isEmpty)
  }

  "map test: give an invalid LoadInfoRaw" should "throw EmfLoadInfoMapperException" in {
    val ingestionParametersString = "{\"is_adjustable\"}"
    val loadInfoRaw1 = LoadInfoRaw(file_type = "invalid_case", ingestion_parameters = Some(ingestionParametersString))
    val caught1 = intercept[EmfLoadInfoMapperException] {
      LoadInfoRawToLoadInfoMapper.map(loadInfoRaw1)
    }
    assert(!caught1.getMessage.isEmpty)

    val extension = "unsupported"
    val loadInfoRaw2 = LoadInfoRaw(file_type = "invalid_case", schema = Some("fieldName1:String,fieldName2:Int"), extension = Some(extension), max_bad_records = Some("1"))
    val caught2 = intercept[EmfLoadInfoMapperException] {
      LoadInfoRawToLoadInfoMapper.map(loadInfoRaw2)
    }
    assert(!caught2.getMessage.isEmpty)
  }

  "map test: give a valid LoadInfoRaw" should "return a LoadInfo object" in {
    val fileType1 = "file_type_1"
    val loadInfoRaw1 = LoadInfoRaw(file_type = fileType1, schema = Some("fieldName1:String,fieldName2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("entity_uuid/created_date"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo1 = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw1)
    assert(loadInfo1.fileType.equals(fileType1) && loadInfo1.schema.schema.size == 2 && loadInfo1.fileFormatConfig.isInstanceOf[ParquetFileFormatConfig] && loadInfo1.ingestHierarchy.hierarchy.size == 3 && loadInfo1.ingestionParameters.size == 1 && loadInfo1.maxBadRecords.get == 1)
  }
}
package hsbc.emf.data.logging

import java.sql.Timestamp

final case class LogEntry(message: String, timestamp: Timestamp = new Timestamp(System.currentTimeMillis()), severity: Severity = Info(),
                          contextMap: Map[String, Any] = Map.empty)package hsbc.emf.infrastructure.logging

import org.apache.spark.sql.types.DataTypes.{DateType, StringType, TimestampType}
import org.apache.spark.sql.types._

object LoggingSchemas {

  private[logging] val messageSchema = StructType(List(
    StructField("run_uuid", StringType),
    StructField("workflow", StringType),
    StructField("order_id", StringType),
    StructField("command", StringType),
    StructField("parameters", StringType),
    StructField("parents", ArrayType(StringType)),
    StructField("message_id", StringType),
    StructField("run_date", TimestampType)
  ))

  private[logging] val logTableSchema = StructType(List(
    StructField("log_message", StringType),
    StructField("received_timestamp", TimestampType),
    StructField("message", messageSchema),
    StructField("log_date", DateType),
    StructField("run_uuid", StringType),
    StructField("log_level", StringType)
  ))

  private[logging] val exceptionsSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("error_message", StringType),
    StructField("stacktrace", StringType),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))

  private[logging] val workflowSpawnInfoSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("spawn_message", messageSchema),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))

  private[logging] val constraintSchema = StructType(List(
    StructField("attribute", StringType),
    StructField("value", StringType),
    StructField("operator", StringType)
  ))

  private[logging] val criteriaSchema = StructType(List(
    StructField("file_type", StringType),
    StructField("constraints", ArrayType(constraintSchema)),
    StructField("created_from", TimestampType),
    StructField("created_to", TimestampType),
    StructField("retry_count", IntegerType),
    StructField("inter_retry_interval", IntegerType),
    StructField("as_view", BooleanType),
    StructField("latest_only", BooleanType),
    StructField("min_matches", LongType)
  ))

  private[logging] val resolutionTargetSchema = StructType(List(
    StructField("table_name", StringType),
    StructField("source_entity_type", StringType),
    StructField("where_clause", ArrayType(constraintSchema)),
    StructField("dataset_name", StringType)
  ))

  private[logging] val metadataSchema = StructType(List(
    StructField("attribute", StringType),
    StructField("value", StringType),
    StructField("data_type", StringType),
    StructField("domain", StringType)
  ))

  private[logging] val catalogueEntitySchema = StructType(List(
    StructField("entity_uuid", StringType),
    StructField("file_type", StringType),
    StructField("created", TimestampType),
    StructField("metadata", ArrayType(metadataSchema))
  ))

  private[logging] val resolutionInfoSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("criteria", criteriaSchema),
    StructField("resolutions", ArrayType(catalogueEntitySchema)),
    StructField("resolution_count", IntegerType),
    StructField("resolution_target", resolutionTargetSchema),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))

  private[logging] val assertInfoSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("assertion", StringType),
    StructField("assertion_result", BooleanType),
    StructField("assertion_message", StringType),
    StructField("severity", StringType),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))

  private[logging] val metadataInfoSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("entity_uuid", StringType),
    StructField("file_type", StringType),
    StructField("attribute", StringType),
    StructField("value", StringType),
    StructField("data_type", StringType),
    StructField("domain", StringType),
    StructField("reporting_date", TimestampType),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))

  private[logging] val messageStateInfoSchema = StructType(List(
    StructField("message", messageSchema),
    StructField("state", StringType),
    StructField("created", TimestampType),
    StructField("log_date", DateType)
  ))
}
package hsbc.emf.infrastructure.logging

import hsbc.emf.data.logging.LogEntry
import hsbc.emf.infrastructure.helper.JsonReader

object LoggingUtils {

  def deserializeLogEntry(jsonString: String): LogEntry = {
    val logEntry = JsonReader.deserialize[LogEntry](jsonString).right.get
    logEntry
  }

  def serializeLogEntry(logEntry: LogEntry): String = {
    val jsonLogEntry = JsonReader.serialize[LogEntry](logEntry).right.get
    jsonLogEntry
  }
}
package hsbc.emf.service.resolution

import java.sql.{Date, Timestamp}

import scala.util.{Failure, Success, Try}

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, NotImplementedComparableValue}
import hsbc.emf.infrastructure.helper.ResolutionHelper.{callUnsupportedComparisonException, nullCheck, parse}

object Match {

  def run(catalogueEntity: CatalogueEntity, resCriteria: ResolutionCriteria): (CatalogueEntity, Boolean) = {

    if ((catalogueEntity.file_type.toUpperCase == resCriteria.file_type.toUpperCase) &&
      resCriteria.created_from.forall(_.before(catalogueEntity.created)) &&
      resCriteria.created_to.forall(_.after(catalogueEntity.created)) &&
      resCriteria.constraints.forall(hasMatching(_, catalogueEntity.metadata))) {
      (catalogueEntity, true)
    }
    else (catalogueEntity, false)
  }


  private def hasMatching(constraint: ResolutionConstraint, metadata: List[MetadataEntry]): Boolean =
    isMatch(constraint)(metadata)

  private def isMatch(constraint: ResolutionConstraint)(metadata: List[MetadataEntry]): Boolean =
    metadata
      .filter(_.attribute == constraint.attribute)
      .exists(adheresTo(_, constraint))


  private def adheresTo(entry: MetadataEntry, constraint: ResolutionConstraint): Boolean =
    compare(entry.value, constraint.value, entry.data_type, constraint.operator)


  private def compare(entityString: String, inputString: String, dataType: String, operator: ComparisonOperator): Boolean =
    castTo(entityString, dataType) match {
      case Success(casted) => compareTo(casted, inputString, operator)
      case Failure(err) => throw new Exception(s"Match.compare InvalidCastError in compare: $entityString dataType= $dataType", err)
    }


  private def compareTo(comparableX: ComparableValue, inputString: String, operator: ComparisonOperator = Equal): Boolean =
    comparableX match {
      case ComparableString(stringValue) => StringComparator.compare(ComparableString(stringValue))(inputString)(operator)
      case ComparableBoolean(boolValue) => BooleanComparator.compare(ComparableBoolean(boolValue))(inputString)(operator)
      case ComparableInt(intValue) => NumericComparator.compare(ComparableInt(intValue))(inputString)(operator)
      case ComparableDouble(doubleValue) => NumericComparator.compare(ComparableDouble(doubleValue))(inputString)(operator)
      case ComparableDecimal(decimalValue) => NumericComparator.compare(ComparableDecimal(decimalValue))(inputString)(operator)
      case ComparableDate(dateValue) => DateTimeComparator.compare(ComparableDate(dateValue))(inputString)(operator)
      case ComparableTimestamp(timeValue) => DateTimeComparator.compare(ComparableTimestamp(timeValue))(inputString)(operator)
      case ComparableNull() => nullCompare(inputString, operator)
      case _ => throw new NotImplementedComparableValue(s"Match.compareTo Not implemented comparable value in compareTo:  $comparableX")
    }

  private def castTo(value: String, dataType: String): Try[ComparableValue] = {

    Try {
      if (value == null || value == "Null" || value == "null") ComparableNull()
      else dataType.toLowerCase() match {
        case "integer" | "int" => ComparableInt(parse[Int](value))
        case "double" => ComparableDouble(parse[Double](value))
        case "decimal" => ComparableDecimal(parse[BigDecimal](value))
        case "boolean" => ComparableBoolean(parse[Boolean](value))
        case "string" => ComparableString(parse[String](value))
        case "date" => ComparableDate(parse[Date](value))
        case "timestamp" => ComparableTimestamp(parse[Timestamp](value))
        case _ => throw new InvalidCastError(s"Match.castTo - InvalidCastError in castTo: $dataType")
      }
    }
  }

  private def nullCompare(inputString: String, operator: ComparisonOperator): Boolean = {
    if (nullCheck(inputString)) {
      operator match {
        case Is => true
        case IsNot => false
        case _ => callUnsupportedComparisonException(operator.toString)
      }
    }
    else {
      callUnsupportedComparisonException(operator.toString)
    }
  }
}
package hsbc.emf.service.resolution

import java.sql.Timestamp

import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.resolution._
import org.scalatest.FlatSpec

class MatchTest  extends FlatSpec {

  val t1: Timestamp = Timestamp.valueOf("2021-03-01 00:00:00")
  val t2: Timestamp = Timestamp.valueOf("2021-03-02 00:00:00")
  val t3: Timestamp = Timestamp.valueOf("2021-03-03 00:00:00")

  "equal file_type alone" should "pass without additional constraints" in {
    val entity = CatalogueEntity("1", "abc", t1, List.empty)
    val criteria = ResolutionCriteria(file_type = "abc")
    assert(Match.run(entity, criteria) == (entity, true))

  }

  "no entities with created dates before created_from" should "be matched" in {
    val entity = CatalogueEntity("1", "abc", t1, List.empty)
    val criteria = ResolutionCriteria("abc", created_from = Some(t2))
    assert(Match.run(entity, criteria) == (entity, false))
  }

  "no entities with created dates after created_to" should "be matched" in {
    val entity = CatalogueEntity("1", "abc", t2, List.empty)
    val criteria = ResolutionCriteria("abc", created_to = Some(t1))
    assert(Match.run(entity, criteria) == (entity, false))
  }


  "criteria with file_type, created_from and created_to" should "match string entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2, List(MetadataEntry("a", "a", "string", "")))
    val criteria = ResolutionCriteria("abc", List(ResolutionConstraint("a", "a", Equal)), created_to = Some(t3),
      created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }

  "criteria with file_type, created_from and created_to" should "match boolean entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2, List(MetadataEntry("a", "false", "boolean", ""),
      MetadataEntry("a", "a", "string", "")))
    val criteria = ResolutionCriteria("abc", List(ResolutionConstraint("a", "false", Equal)),
      created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }


  "criteria with file_type, created_from and created_to" should "match numeric entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2, List(MetadataEntry("i", "1", "integer", ""),
      MetadataEntry("d", "1.2", "double", ""), MetadataEntry("de", "1.3", "decimal", ""),
      MetadataEntry("a", "false", "boolean", ""), MetadataEntry("a", "a", "string", "")))
    val criteria = ResolutionCriteria("abc", List(ResolutionConstraint("i", "1", Equal),
      ResolutionConstraint("d", "1.2", Equal), ResolutionConstraint("de", "1.3", Equal)), created_to = Some(t3),
      created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }

  "criteria with file_type, created_from and created_to" should "match Date and Timestamp entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("date", "2021-02-01", "date", ""),
        MetadataEntry("time", "2021-02-01T01:00:00", "timestamp", ""),
        MetadataEntry("i", "1", "integer", ""), MetadataEntry("d", "1.2", "double", ""),
        MetadataEntry("de", "1.3", "decimal", ""), MetadataEntry("a", "false", "boolean", ""),
        MetadataEntry("a", "a", "string", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("date", "2021-02-01", GreaterThanOrEqual),
        ResolutionConstraint("time", "2021-02-01T01:00:00", Equal),
        ResolutionConstraint("i", "1", Equal),
        ResolutionConstraint("d", "1.2", Equal),
        ResolutionConstraint("de", "1.3", Equal)), created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }


  "criteria with file_type, created_from and created_to" should "match multiple entities between these dates" in {
    val entity1 = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("date", "2021-02-01", "date", ""),
        MetadataEntry("time", "2021-02-01T01:00:00", "timestamp", ""),
        MetadataEntry("i", "1", "integer", ""), MetadataEntry("d", "1.2", "double", ""),
        MetadataEntry("de", "1.3", "decimal", ""), MetadataEntry("a", "false", "boolean", ""),
        MetadataEntry("a", "a", "string", "")))
    val entity2 = CatalogueEntity("2", "abc", t2, List(MetadataEntry("date", "2021-02-01", "date", ""),
      MetadataEntry("time", "2021-02-01T01:00:00", "timestamp", "")))

    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("date", "2021-02-01", GreaterThanOrEqual),
        ResolutionConstraint("time", "2021-02-01T01:00:00", Equal)),
      created_to = Some(t3), created_from = Some(t1))
    val resultList = List(entity1, entity2).map(Match.run(_, criteria))
      .filter(_._2).map(_._1.entity_uuid)
    assert(resultList.nonEmpty)
    assert(resultList == List("1", "2"))
  }

  "criteria with file_type, created_from and created_to" should "not match any entities between these dates" in {
    val entity1 = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("date", "2021-02-01", "date", ""),
        MetadataEntry("time", "2021-02-01T01:00:00", "timestamp", ""),
        MetadataEntry("i", "1", "integer", ""), MetadataEntry("d", "1.2", "double", ""),
        MetadataEntry("de", "1.3", "decimal", ""), MetadataEntry("a", "false", "boolean", ""),
        MetadataEntry("a", "a", "string", "")))
    val entity2 = CatalogueEntity("2", "abc", t2,
      List(MetadataEntry("date", "2021-02-01", "date", ""),
        MetadataEntry("time", "2021-02-01T01:00:00", "timestamp", "")))

    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("date", "2021-03-01", GreaterThanOrEqual),
        ResolutionConstraint("time", "2021-02-03T01:00:00", Equal)),
      created_to = Some(t3), created_from = Some(t1))
    val resultList = List(entity1, entity2).map(Match.run(_, criteria))
      .filter(_._2).map(_._1.entity_uuid)
    assert(resultList.isEmpty)
  }

  "criteria with file_type, created_from and created_to" should "match null entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", null, "boolean", ""), MetadataEntry("b", null, "date", "")))
    val criteria = ResolutionCriteria("abc", List(ResolutionConstraint("a", null, Is)),
      created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }


  "criteria with file_type, created_from and created_to" should "match 'null' entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", "null", "boolean", ""), MetadataEntry("b", "null", "date", "")))
    val criteria = ResolutionCriteria("abc", List(ResolutionConstraint("a", "null", Is)),
      created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }


  "criteria with file_type, created_from and created_to" should "match 'Null' entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", "Null", "boolean", ""), MetadataEntry("b", "Null", "date", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("a", "Null", Is)),
      created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }

  "criteria with file_type, created_from and created_to ,'null' " should "match null entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", null, "boolean", ""), MetadataEntry("b", null, "date", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("a", "null", Is)), created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }

  "criteria with file_type, created_from and created_to ,'Null' " should "match null entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", null, "boolean", ""), MetadataEntry("b", null, "date", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("a", "Null", Is)),
      created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }


  "criteria with file_type, created_from and created_to ,not null " should "match not null entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", "1", "integer", ""), MetadataEntry("b", "abc", "string", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("a", "Null", IsNot)), created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, true))
  }
  "criteria with file_type, created_from and created_to ,not null " should "not match null entries between these dates" in {
    val entity = CatalogueEntity("1", "abc", t2,
      List(MetadataEntry("a", "1", "integer", ""), MetadataEntry("b", "abc", "string", "")))
    val criteria = ResolutionCriteria("abc",
      List(ResolutionConstraint("a", "Null", Is)), created_to = Some(t3), created_from = Some(t1))
    assert(Match.run(entity, criteria) == (entity, false))
  }

  "criteria with file_type and YYYY-MM-DD format resolution constraint" should "match the entries with YYYY-MM-DD format Timestamp metadata" in {
    val testEntityUuid = "eda0ca30-2dbb-4fe5-8371-e79d9f5335da"
    val testFileType = "abc"
    val entity = CatalogueEntity(testEntityUuid, testFileType, t2, List(MetadataEntry("reporting_date", "2021-06-30", "timestamp", "")))
    val criteria1 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30", Equal)))
    assert(Match.run(entity, criteria1) == (entity, true))
    val criteria2 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-01", GreaterThanOrEqual)))
    assert(Match.run(entity, criteria2) == (entity, true))
    val criteria3 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30", GreaterThanOrEqual)))
    assert(Match.run(entity, criteria3) == (entity, true))
    val criteria4 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-07-01", LessThanOrEqual)))
    assert(Match.run(entity, criteria4) == (entity, true))
    val criteria5 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30", LessThanOrEqual)))
    assert(Match.run(entity, criteria5) == (entity, true))
  }

  "criteria with file_type and timestamp format resolution constraint" should "match the entries with YYYY-MM-DD format Timestamp metadata" in {
    val testEntityUuid = "eda0ca30-2dbb-4fe5-8371-e79d9f5335da"
    val testFileType = "abc"
    val entity = CatalogueEntity(testEntityUuid, testFileType, t2, List(MetadataEntry("reporting_date", "2021-06-30", "timestamp", "")))
    val criteria1 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30T00:00:00", Equal)))
    assert(Match.run(entity, criteria1) == (entity, true))
    val criteria2 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-01T00:00:00", GreaterThanOrEqual)))
    assert(Match.run(entity, criteria2) == (entity, true))
    val criteria3 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30T00:00:00", GreaterThanOrEqual)))
    assert(Match.run(entity, criteria3) == (entity, true))
    val criteria4 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-07-01T00:00:00", LessThanOrEqual)))
    assert(Match.run(entity, criteria4) == (entity, true))
    val criteria5 = ResolutionCriteria(testFileType, List(ResolutionConstraint("reporting_date", "2021-06-30T00:00:00", LessThanOrEqual)))
    assert(Match.run(entity, criteria5) == (entity, true))
 }
}package hsbc.emf.infrastructure.logging

import hsbc.emf.data.logging.MessageInfo

trait MessageContext {
    implicit val messageInfo : MessageInfo
}
package hsbc.emf.infrastructure.logging
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.helper.HelperUtility.generateRunUUID

trait MessageContextTestData extends MessageContext{
  override implicit val messageInfo: MessageInfo = MessageInfo(generateRunUUID(), "test-workflow", "order-id", "test-command", "test-parameters", parent = List.empty)
}
package hsbc.emf.data.logging

import java.sql.Timestamp

import hsbc.emf.infrastructure.helper.HelperUtility

case class MessageInfo(runUUID: String, workflow: String, orderId: String, command: String, parameterJson: String, parent: List[String] = List.empty, messageId: String = HelperUtility.generateRunUUID(), runDate: Timestamp = new Timestamp(System.currentTimeMillis()))package hsbc.emf.infrastructure.serde

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo
import org.json4s.CustomSerializer
import org.json4s.JsonAST._


object MessageInfoSerializer extends CustomSerializer[MessageInfo](implicit format => ( {
  case JObject(
  JField("messageId", JString(messageId)) ::
    JField("runUUID", JString(runUUID)) ::
    JField("workflow", JString(workflow)) ::
    JField("orderId", JString(orderId)) ::
    JField("command", JString(command)) ::
    JField("parameterJson", JString(parameterJson)) ::
    JField("parent", JArray(parent)) ::
    JField("runDate", JString(runDate)) :: Nil) =>
    MessageInfo(runUUID, workflow, orderId, command, parameterJson, parent.map(_.extract[String]), messageId, Timestamp.valueOf(runDate))
}, {
  case x: MessageInfo => JObject(
    JField("messageId", JString(x.messageId)) ::
      JField("runUUID", JString(x.runUUID)) ::
      JField("workflow", JString(x.workflow)) ::
      JField("orderId", JString(x.orderId)) ::
      JField("command", JString(x.command)) ::
      JField("parameterJson", JString(x.parameterJson)) ::
      JField("parent", JArray(Option(x.parent).getOrElse(List.empty).map(each => JString(each)))) ::
      JField("runDate", JString(x.runDate.toString)) :: Nil)
}
)
)
package hsbc.emf.infrastructure.logging

import java.sql.Timestamp

import hsbc.emf.infrastructure.services.mapper.IMapper

import org.apache.spark.sql.Row

object MessageInfoToRowMapper extends IMapper[Map[String, Any], Row] {
  override def map(map: Map[String, Any]): Row = {
    Row(map("runUUID"), map("workflow"), map("orderId"), map("command"), map("parameterJson"), map("parent"), map("messageId"), Timestamp.valueOf(map("runDate").toString))
  }
}
package hsbc.emf.infrastructure.logging.audit

sealed trait MessageState

object Active extends MessageState {
  override def toString: String = "ACTIVE"
}

object InProgress extends MessageState {
  override def toString: String = "INPROGRESS"
}

object Finish extends MessageState {
  override def toString: String = "COMPLETE"
}

object Fail extends MessageState {
  override def toString: String = "FAILED"
}

package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo

case class MessageStateInfo(message: MessageInfo, state: MessageState, created: Timestamp = new Timestamp(System.currentTimeMillis())) extends ContextInfo
package hsbc.emf.data.ingestion

final case class MetadataEntry(
                                attribute: String,
                                value: String,
                                data_type: String,
                                domain : String
                              )package hsbc.emf.infrastructure.helper

import java.sql.{Date, Timestamp}
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatter.ISO_DATE_TIME

import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.ingestion._
import hsbc.emf.infrastructure.helper.StringUtils._
import scala.collection.mutable.ListBuffer
import scala.util.control.Exception.allCatch
import scala.util.{Failure, Success, Try}

object MetadataHelper {
  def convertMetadata(metadata: Map[String, String]): List[MetadataEntry] = {
    val mapList = metadata.toList
    if (mapList.isEmpty) {
      List.empty[MetadataEntry]
    }
    else {
      var metadataEntryList = new ListBuffer[MetadataEntry]()
      mapList.flatMap { mapItem =>
        if (mapItem._2.startsWith("[") & mapItem._2.endsWith("]")) {
          makeList(mapItem._2).foreach(
            valueItem =>
              // FCCC-10932: Bug Fix for 10920: domain as empty string rather than null
              metadataEntryList += MetadataEntry(mapItem._1, valueItem, valueType(valueItem).toString, "")
          )
          metadataEntryList
        }
        else {
          // FCCC-10932: Bug Fix for 10920: domain as empty string rather than null
          List(MetadataEntry(mapItem._1, mapItem._2, valueType(mapItem._2).toString, ""))
        }
      }
    }
  }

  def isInt(value: String): Boolean = (allCatch opt value.toInt).isDefined
  def isDouble(value: String): Boolean = (allCatch opt value.toDouble).isDefined
  def isBoolean(value: String): Boolean = (allCatch opt value.toBoolean).isDefined
  def isDate(value: String): Boolean = (allCatch opt Date.valueOf(value)).isDefined
  def isTimestamp(value: String): Boolean = (allCatch opt {
    val localDateTime = Try(LocalDateTime.parse(value,
      DateTimeFormatter.ofPattern("[yyyy-MM-dd HH:mm:ss.n][yyyy-MM-dd HH:mm:ss]")))
    match {
      case Success(value) => value
      case Failure(ex) => LocalDateTime.parse(value, ISO_DATE_TIME)
    }
    Timestamp.valueOf(localDateTime)
  }).isDefined

  def isValidType(value: String): Boolean = {
    List(isInt(value), isDouble(value), isBoolean(value), isDate(value), isTimestamp(value) )
      .foldLeft(false)(_ || _)
  }

  def valueType(value: String): MetadataType = {
    if (isValidType(value)) {
      value match {
        case int if isInt(int) => IntegerMetadataType()
        case double if isDouble(double) => DoubleMetadataType()
        case boolean if isBoolean(boolean) => BooleanMetadataType()
        case date if isDate(date) => DateMetadataType()
        case timestamp if isTimestamp(timestamp) => TimestampMetadataType()
        case _ => StringMetadataType()
      }
    }
    else StringMetadataType()
  }

}
package hsbc.emf.infrastructure.helper
import hsbc.emf.data.ingestion.MetadataEntry

import org.scalatest.FlatSpec

class MetadataHelperTest extends FlatSpec{

  "given date values in MAP" should "return a correct date type" in {
    assert(MetadataHelper.convertMetadata(Map("run_date" -> "2021-05-31")) ==
      List(MetadataEntry("run_date", "2021-05-31", "date", "")))
  }

  "given timestamp values in MAP" should "return a correct timestamp type" in {

    assert(MetadataHelper.convertMetadata(Map("run_timestamp" -> "2021-05-31T00:00:00")) ==
      List(MetadataEntry("run_timestamp", "2021-05-31T00:00:00", "timestamp", "")))

    assert(MetadataHelper.convertMetadata(Map("run_timestamp" -> "2021-05-31T00:00:00.123")) ==
      List(MetadataEntry("run_timestamp", "2021-05-31T00:00:00.123", "timestamp", "")))

    assert(MetadataHelper.convertMetadata(Map("run_timestamp" -> "2021-05-31 00:00:00")) ==
      List(MetadataEntry("run_timestamp", "2021-05-31 00:00:00", "timestamp", "")))

    assert(MetadataHelper.convertMetadata(Map("run_timestamp" -> "2021-05-31 00:00:00.123")) ==
      List(MetadataEntry("run_timestamp", "2021-05-31 00:00:00.123", "timestamp", "")))
  }

  "given integer values in MAP" should "return a correct integer type" in {
    assert(MetadataHelper.convertMetadata(Map("md5" -> "1234556")) ==
      List(MetadataEntry("md5", "1234556", "integer", "")))

    assert(MetadataHelper.convertMetadata(Map("md5" -> "-1234556")) ==
      List(MetadataEntry("md5", "-1234556", "integer", "")))
  }

  "given float values in MAP" should "return a correct double type" in {
    assert(MetadataHelper.convertMetadata(Map("md5" -> "1234556.1234")) ==
      List(MetadataEntry("md5", "1234556.1234", "double", "")))

    assert(MetadataHelper.convertMetadata(Map("md5" -> "-1234556.1234")) ==
      List(MetadataEntry("md5", "-1234556.1234", "double", "")))
  }

  "given boolean values in MAP" should "return a correct boolean type" in {
    assert(MetadataHelper.convertMetadata(Map("flag" -> "true")) ==
      List(MetadataEntry("flag", "true", "boolean", "")))

    assert(MetadataHelper.convertMetadata(Map("flag" -> "false")) ==
      List(MetadataEntry("flag", "false", "boolean", "")))

    assert(MetadataHelper.convertMetadata(Map("flag" -> "TRUE")) ==
      List(MetadataEntry("flag", "TRUE", "boolean", "")))

    assert(MetadataHelper.convertMetadata(Map("flag" -> "FALSE")) ==
      List(MetadataEntry("flag", "FALSE", "boolean", "")))
  }

  "given string values in MAP" should "return a correct string type" in {
    assert(MetadataHelper.convertMetadata(Map("location" -> "UK")) ==
      List(MetadataEntry("location", "UK", "string", "")))

    assert(MetadataHelper.convertMetadata(Map("string" -> "\"12\"")) ==
      List(MetadataEntry("string", "\"12\"", "string", "")))

    assert(MetadataHelper.convertMetadata(Map("string" -> "\"12.12\"")) ==
      List(MetadataEntry("string", "\"12.12\"", "string", "")))

    assert(MetadataHelper.convertMetadata(Map("string" -> "\"12.12\"")) ==
      List(MetadataEntry("string", "\"12.12\"", "string", "")))

    assert(MetadataHelper.convertMetadata(Map("string" -> "\"2021-05-01\"")) ==
      List(MetadataEntry("string", "\"2021-05-01\"", "string", "")))

    assert(MetadataHelper.convertMetadata(Map("string" -> "\"2021-05-01 00:00:00\"")) ==
      List(MetadataEntry("string", "\"2021-05-01 00:00:00\"", "string", "")))
  }

  "given array values in MAP" should "return a correct datatype" in {

    assert(MetadataHelper.convertMetadata(Map("run_time" -> "[\"2021-02-28T14:01:03\",\"2021-01-29T14:01:03\"]")).toSet ==
      List(MetadataEntry("run_time","2021-02-28T14:01:03","timestamp",""),
        MetadataEntry("run_time","2021-01-29T14:01:03","timestamp","")).toSet)

    assert(MetadataHelper.convertMetadata(Map("run_date" -> "[\"2021-02-28\",\"2021-01-29\"]")).toSet ==
      List(MetadataEntry("run_date","2021-02-28","date",""),
        MetadataEntry("run_date","2021-01-29","date","")).toSet)

    assert(MetadataHelper.convertMetadata(Map("md5" -> "[\"100\",\"200\"]")).toSet ==
      List(MetadataEntry("md5","100","integer",""),
        MetadataEntry("md5","200","integer","")).toSet)

    assert(MetadataHelper.convertMetadata(Map("float" -> "[\"100.50\",\"200.40\"]")).toSet ==
      List(MetadataEntry("float","100.50","double",""),
        MetadataEntry("float","200.40","double","")).toSet)

    assert(MetadataHelper.convertMetadata(Map("flag" -> "[\"true\",\"false\"]")).toSet ==
      List(MetadataEntry("flag","true","boolean",""),
        MetadataEntry("flag","false","boolean","")).toSet)

    assert(MetadataHelper.convertMetadata(Map("loc" -> "[\"UK\",\"US\"]")).toSet ==
      List(MetadataEntry("loc","UK","string",""),
        MetadataEntry("loc","US","string","")).toSet)
  }

  "given multiple values in MAP" should "return a correct datatypes" in {
    assert(MetadataHelper.convertMetadata(Map("location" -> "UK","flag" -> "true","number" -> "1234556",
      "float" -> "1234556.1234","run_date" -> "2021-05-31","run_timestamp" -> "2021-05-31 00:00:00",
      "array" -> "[\"UK\",\"US\"]")).toSet == List(MetadataEntry("location","UK","string",""),
      MetadataEntry("flag","true","boolean",""),
        MetadataEntry("number","1234556","integer",""),
        MetadataEntry("float","1234556.1234","double",""),
        MetadataEntry("run_date","2021-05-31","date",""),
        MetadataEntry("run_timestamp","2021-05-31 00:00:00","timestamp",""),
        MetadataEntry("array","UK","string",""), MetadataEntry("array","US","string","")).toSet)
  }
}
package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo

case class MetadataInfo(message: MessageInfo, entityUUID: String, fileType: String, attribute: String, value: String, dataType: String, domain: String, reportingDate: Timestamp, created: Timestamp = new Timestamp(System.currentTimeMillis())) extends ContextInfo
package hsbc.emf.data.ingestion

import java.sql.Timestamp

final case class MetadataRaw(
                              entity_uuid: String,
                              file_type: String,
                              created: Timestamp,
                              attribute: String,
                              value: String,
                              data_type: String,
                              domain: String,
                              reporting_date: Option[Timestamp]
                            )
package hsbc.emf.infrastructure.io.readers

import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.infrastructure.config.{EmfConfig, MetaDataTextFileFormatConfig}
import hsbc.emf.infrastructure.exception.EmfIoException
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.{DataFrame, SparkSession}

class MetaDataTextFileReaderToDF(implicit val spark: SparkSession) extends IFileReader[MetaDataTextFileFormatConfig, DataFrame] {

  val fileName: String = s"*${EmfConfig.real_meta_chunk_token}*"

  @throws(classOf[EmfIoException])
  def read(fileFormatConfig: MetaDataTextFileFormatConfig, fileLocation: String, schema: Option[StructType], modeFailfast: Boolean = false): DataFrame = {

    import org.apache.spark.sql.Encoders
    val metaDataSchema = Encoders.product[MetadataEntry].schema

    try {
      spark.read.format("json")
        .schema(metaDataSchema)
        .load(s"$fileLocation/${fileName}")
    }
    catch {
      case e: Throwable => throw new EmfIoException(e.getMessage, e.getCause)
    }
  }
}

package hsbc.emf.data.ingestion

sealed trait MetadataType

final case class StringMetadataType() extends MetadataType {
override def toString: String = "string"
}

final case class IntegerMetadataType() extends MetadataType {
  override def toString: String = "integer"
}

final case class BooleanMetadataType() extends MetadataType {
  override def toString: String = "boolean"
}

final case class DoubleMetadataType() extends MetadataType {
  override def toString: String = "double"
}

final case class DateMetadataType() extends MetadataType {
  override def toString: String = "date"
}

final case class TimestampMetadataType() extends MetadataType {
  override def toString: String = "timestamp"
}package hsbc.emf.infrastructure.container.exceptions

import scala.reflect.runtime.universe.Type

final case class MissingRegistrationException(typeName: Type)
  extends Exception(s"Missing registration: '$typeName'") {
}

package hsbc.emf.data.crm

final case class Mitigant(
                           key: String,
                           id: String,
                           grossAmount: Double
                         )
package hsbc.emf.service.resolution

import scala.reflect.runtime.universe.TypeTag

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{NotImplementedComparableValue, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper._
import hsbc.emf.infrastructure.helper.StringUtils.{makeList, removeQuotes}

object NumericComparator extends IComparator {

  override def compare[T <: ComparableValue](entity: T)(inputString: String)(operator: ComparisonOperator): Boolean =
    entity match {
      case ComparableInt(intValue) => numericComparePredicate[Int](intValue)(inputString)(operator)
      case ComparableDouble(doubleValue) => numericComparePredicate[Double](doubleValue)(inputString)(operator)
      case ComparableDecimal(decimalValue) => numericComparePredicate[BigDecimal](decimalValue)(inputString)(operator)
      case _ => throw new NotImplementedComparableValue(s"NumericComparator.compare - Not implemented NumericComparator value: $entity")
    }

  private def numericComparePredicate[T: Numeric](entityValue: T)(inputString: String)(operator: ComparisonOperator)
                                                 (implicit tag: TypeTag[T]): Boolean = {

    val cleanedInputString = removeQuotes(inputString)

    cleanedInputStringNullCheck(operator, cleanedInputString)

    val num = implicitly[Numeric[T]]

    def equal(): Boolean = num.equiv(entityValue, parse[T](cleanedInputString))

    def in(): Boolean = makeList(inputString).map(parse[T](_)).find(x => num.equiv(entityValue, x)) match {
      case Some(_) => true
      case None => false
    }

    operator match {
      case Equal => equal()
      case NotEqual => !equal()
      case LessThan => num.lt(entityValue, parse[T](cleanedInputString))
      case GreaterThan => num.gt(entityValue, parse[T](cleanedInputString))
      case LessThanOrEqual => num.lteq(entityValue, parse[T](cleanedInputString))
      case GreaterThanOrEqual => num.gteq(entityValue, parse[T](cleanedInputString))
      case In => in()
      case NotIn => !in()
      case Is => false
      case IsNot => true
      case _ => throw new UnsupportedComparisonOperator(s"NumericComparator.numericComparePredicate - Not supported numericComparePredicate operator: $operator")
    }
  }
}package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, UnsupportedComparisonOperator}
import org.scalatest.FlatSpec

class NumericComparatorTest extends  FlatSpec {

  "given equal numbers and Equal operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("1")(Equal))
    assert(NumericComparator.compare(ComparableInt(1))("\"1\"")(Equal))
    assert(NumericComparator.compare(ComparableInt(1))("\" 1\"")(Equal))
    assert(NumericComparator.compare(ComparableInt(1))("\" 1 \"")(Equal))
    assert(NumericComparator.compare(ComparableDouble(1))("1")(Equal))
    assert(NumericComparator.compare(ComparableDouble(1))("\"1\"")(Equal))
    assert(NumericComparator.compare(ComparableDouble(1))("\" 1\"")(Equal))
    assert(NumericComparator.compare(ComparableDouble(1))("\" 1 \"")(Equal))
    assert(NumericComparator.compare(ComparableDouble(1.1))("1.1")(Equal))
    assert(NumericComparator.compare(ComparableDecimal(1))("1")(Equal))
    assert(NumericComparator.compare(ComparableDecimal(1))("\"1\"")(Equal))
    assert(NumericComparator.compare(ComparableDecimal(1))("\" 1\"")(Equal))
    assert(
      NumericComparator.compare(ComparableDecimal(1))("\" 1 \"")(Equal))
    assert(NumericComparator.compare(ComparableDecimal(1.1))("1.1")(Equal))
  }

  "given 0 and -0 and Equal operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(0))("-0")(Equal))
    assert(NumericComparator.compare(ComparableDouble(0.0))("-0.0")(Equal))
    assert(NumericComparator.compare(ComparableDecimal(0.0))("-0.0")(Equal))
  }

  "given unequal numbers and Equal operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(1))("2")(Equal))
    assert(!NumericComparator.compare(ComparableDouble(1))("2")(Equal))
    assert(!NumericComparator.compare(ComparableDecimal(1))("2")(Equal))
    assert(!NumericComparator.compare(ComparableDouble(1.1))("2.1")(Equal))
    assert(!NumericComparator.compare(ComparableDecimal(1.1))("2.1")(Equal))
  }

  "given equal numbers and NotEqual operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(1))("1")(NotEqual))
    assert(!NumericComparator.compare(ComparableDouble(1))("1")(NotEqual))
    assert(!NumericComparator.compare(ComparableDecimal(1))("1")(NotEqual))
    assert(
      !NumericComparator.compare(ComparableDouble(1.1))("1.1")(NotEqual)
    )
    assert(
      !NumericComparator.compare(ComparableDecimal(1.1))("1.1")(NotEqual))
  }

  "given unequal numbers and NotEqual operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("2")(NotEqual))
    assert(NumericComparator.compare(ComparableDouble(1))("2")(NotEqual))
    assert(NumericComparator.compare(ComparableDecimal(1))("2")(NotEqual))
    assert(NumericComparator.compare(ComparableDouble(1.1))("2.1")(NotEqual)
    )
    assert(NumericComparator.compare(ComparableDecimal(1.1))("2.1")(NotEqual))
  }

  "given non-numeric string" should "return InvalidCastError" in {
    val str = "!"
    val caught1 = intercept[InvalidCastError] {
      NumericComparator.compare(ComparableInt(1))(str)(Equal)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[InvalidCastError] {
      NumericComparator.compare(ComparableDouble(1))(str)(Equal)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[InvalidCastError] {
      NumericComparator.compare(ComparableDecimal(1))(str)(Equal)
    }
    assert(!caught3.getMessage.isEmpty)
  }

  "given an invalid operator" should "return UnsupportedComparisonOperator" in {

    val caught = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("1")(Like)
    }
    assert(!caught.getMessage.isEmpty)


    val caught2 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("1")(NotLike)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("1")(Is)
    }
    assert(!caught3.getMessage.isEmpty)

    val caught4 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("1")(IsNot)
    }
    assert(!caught4.getMessage.isEmpty)

    val caught5 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))(null)(Equal)
    }
    assert(!caught5.getMessage.isEmpty)

    val caught6 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("null")(NotIn)
    }
    assert(!caught6.getMessage.isEmpty)

    val caught7 = intercept[UnsupportedComparisonOperator] {
      NumericComparator.compare(ComparableInt(1))("Null")(GreaterThanOrEqual)
    }
    assert(!caught7.getMessage.isEmpty)
  }

  "given A < B with LessThan operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("2")(LessThan))
    assert(NumericComparator.compare(ComparableDouble(1))("2")(LessThan))
    assert(NumericComparator.compare(ComparableDecimal(1))("2")(LessThan))
  }

  "given A <= B with LessThanOrEqual operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("2")(LessThanOrEqual))
    assert(NumericComparator.compare(ComparableDouble(1))("2")(LessThanOrEqual))
    assert(NumericComparator.compare(ComparableDecimal(1))("2")(LessThanOrEqual))
    assert(NumericComparator.compare(ComparableInt(1))("1")(LessThanOrEqual))
    assert(NumericComparator.compare(ComparableDouble(1))("1")(LessThanOrEqual))
    assert(NumericComparator.compare(ComparableDecimal(1))("1")(LessThanOrEqual))

  }

  "given A > B with LessThan operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(3))("2")(LessThan))
    assert(!NumericComparator.compare(ComparableDouble(3))("2")(LessThan))
    assert(!NumericComparator.compare(ComparableDecimal(3))("2")(LessThan))
  }

  "given A > B with LessThanOrEqual operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(3))("2")(LessThanOrEqual))
    assert(!NumericComparator.compare(ComparableDouble(3))("2")(LessThanOrEqual))
    assert(!NumericComparator.compare(ComparableDecimal(3))("2")(LessThanOrEqual))

  }

  "given A > B with GreaterThan operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(3))("2")(GreaterThan))
    assert(NumericComparator.compare(ComparableDouble(3))("2")(GreaterThan))
    assert(NumericComparator.compare(ComparableDecimal(3))("2")(GreaterThan))
  }

  "given A >= B with GreaterThanOrEqual operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(3))("2")(GreaterThanOrEqual))
    assert(NumericComparator.compare(ComparableDouble(3))("2")(GreaterThanOrEqual))
    assert(NumericComparator.compare(ComparableDecimal(3))("2")(GreaterThanOrEqual))
    assert(NumericComparator.compare(ComparableInt(3))("1")(GreaterThanOrEqual))
    assert(NumericComparator.compare(ComparableDouble(3))("1")(GreaterThanOrEqual))
    assert(NumericComparator.compare(ComparableDecimal(3))("1")(GreaterThanOrEqual))

  }

  "given A < B with GreaterThan operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(1))("2")(GreaterThan))
    assert(!NumericComparator.compare(ComparableDouble(1))("2")(GreaterThan))
    assert(!NumericComparator.compare(ComparableDecimal(1))("2")(GreaterThan))
  }

  "given A < B with GreaterThanOrEqual operator" should "return false" in {
    assert(!NumericComparator.compare(ComparableInt(1))("2")(GreaterThanOrEqual))
    assert(!NumericComparator.compare(ComparableDouble(1))("2")(GreaterThanOrEqual))
    assert(!NumericComparator.compare(ComparableDecimal(1))("2")(GreaterThanOrEqual))

  }

  "given list of numbers and In operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("[1,2,3]")(In))
    assert(NumericComparator.compare(ComparableInt(1))("[\"1\",\"2\",\"3\"]")(In))
    assert(NumericComparator.compare(ComparableInt(1))("[\" 1 \",\" 2 \",\" 3 \"]"
    )(In))

    assert(NumericComparator.compare(ComparableDouble(1))("[1,2,3]")(In))
    assert(NumericComparator.compare(ComparableDouble(1))("[\"1\",\"2\",\"3\"]")(In))
    assert(NumericComparator.compare(ComparableDouble(1))("[\" 1 \",\" 2 \",\" 3 \"]")(In))

    assert(NumericComparator.compare(ComparableDecimal(1))("[1,2,3]")(In))
    assert(NumericComparator.compare(ComparableDecimal(1))("[\"1\",\"2\",\"3\"]")(In))
    assert(NumericComparator.compare(ComparableDecimal(1))("[\" 1 \",\" 2 \",\" 3 \"]")(In))
  }

  "given list of numbers and NotIn operator" should "return true" in {
    assert(NumericComparator.compare(ComparableInt(1))("[4,2,3]")(NotIn))
    assert(NumericComparator.compare(ComparableInt(1))("[\"4\",\"2\",\"3\"]")(NotIn))
    assert(NumericComparator.compare(ComparableInt(1))("[\" 4 \",\" 2 \",\" 3 \"]"
    )(NotIn))

    assert(NumericComparator.compare(ComparableDouble(1))("[4,2,3]")(NotIn))
    assert(NumericComparator.compare(ComparableDouble(1))("[\"4\",\"2\",\"3\"]")(NotIn))
    assert(NumericComparator.compare(ComparableDouble(1))("[\" 4 \",\" 2 \",\" 3 \"]")(NotIn))

    assert(NumericComparator.compare(ComparableDecimal(1))("[4,2,3]")(NotIn))
    assert(NumericComparator.compare(ComparableDecimal(1))("[\"4\",\"2\",\"3\"]")(NotIn))
    assert(NumericComparator.compare(ComparableDecimal(1))("[\" 4 \",\" 2 \",\" 3 \"]")(NotIn))
  }

  "given a numeric with Is null operator" should "return false" in {
    val result = NumericComparator.compare(ComparableInt(1))(null)(Is)
    assert(!result)
    val result1 = NumericComparator.compare(ComparableInt(1))("null")(Is)
    assert(!result1)
    val result2 = NumericComparator.compare(ComparableInt(1))("Null")(Is)
    assert(!result2)
    val result3 = NumericComparator.compare(ComparableDouble(1.0))(null)(Is)
    assert(!result3)
    val result4 = NumericComparator.compare(ComparableDouble(1.0))("null")(Is)
    assert(!result4)
    val result5 = NumericComparator.compare(ComparableDouble(1.0))("Null")(Is)
    assert(!result5)
    val result6 = NumericComparator.compare(ComparableDecimal(1.0))(null)(Is)
    assert(!result6)
    val result7 = NumericComparator.compare(ComparableDecimal(1.0))("null")(Is)
    assert(!result7)
    val result8 = NumericComparator.compare(ComparableDecimal(1.0))("Null")(Is)
    assert(!result8)
  }


  "given a numeric with IsNot null operator" should "return true" in {
    val result = NumericComparator.compare(ComparableInt(1))(null)(IsNot)
    assert(result)
    val result1 = NumericComparator.compare(ComparableInt(1))("null")(IsNot)
    assert(result1)
    val result2 = NumericComparator.compare(ComparableInt(1))("Null")(IsNot)
    assert(result2)
    val result3 = NumericComparator.compare(ComparableDouble(1.0))(null)(IsNot)
    assert(result3)
    val result4 = NumericComparator.compare(ComparableDouble(1.0))("null")(IsNot)
    assert(result4)
    val result5 = NumericComparator.compare(ComparableDouble(1.0))("Null")(IsNot)
    assert(result5)
    val result6 = NumericComparator.compare(ComparableDecimal(1.0))(null)(IsNot)
    assert(result6)
    val result7 = NumericComparator.compare(ComparableDecimal(1.0))("null")(IsNot)
    assert(result7)
    val result8 = NumericComparator.compare(ComparableDecimal(1.0))("Null")(IsNot)
    assert(result8)
  }

}package hsbc.emf.command

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

object PlaceholderParameterisation {
  // Takes a placeholder, and returns the pattern as it should occur in the template
  def placeholderPattern(parameter: String): String = s"[$$$parameter]"

  // Replaces any occurrence of a key from placeholderParams in the placeholder Template with the corresponding value
  def insertParams(placeholderParams: PlaceholderParameters, placeholderTemplate: String)(implicit messageInfo: MessageInfo): String = {

    placeholderParams.format.foldLeft(placeholderTemplate) {
      case (string, (k, v)) =>
        if (!string.contains(placeholderPattern(k))) {
          string
        } else {
          EmfLogger.debug(s"replaced occurrences of $k with $v in placeholder template '$string'")
          string.replaceAllLiterally(placeholderPattern(k), v)
        }
    }
  }

}
package hsbc.emf.command

import hsbc.emf.constants.ExecutionResult
import hsbc.emf.infrastructure.logging.MessageContextTestData
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import org.scalatest.FlatSpec

class PlaceholderParameterisationTest extends FlatSpec with MessageContextTestData {

  case class TestClassPlaceholderParameterisation(testArg1: String)
    extends ISparkCommand {
    override def run(): ExecutionResult = throw new NotImplementedError()

    override def messageValidate(message: ISparkCommandMessage): Boolean = throw new NotImplementedError()
  }

  "placeholderPattern" should "given any string return the placedholder pattern" in {
    //var params: PlaceholderParameters = PlaceholderParameters(Map())
    //val newTestCase = TestClassPlaceholderParameterisation("arg1")
    //newTestCase.placeholderParams = params
    // Given:
    val input = "variableName"
    // When:
    val result: String = PlaceholderParameterisation.placeholderPattern(input)
    // Then:
    assert(result == "[$variableName]")
  }

  behavior of "insertParams"

  it should "replace all occurences of parameter placeholder with the corresonding value from Placeholder Parameters" in {
    val params = PlaceholderParameters(Map("name" -> "Stapley"))

    // Given:
    val input =
      """Select thing from table where someField = '[$name]' and someotherField = '[$name]'"""
    // When:
    val result: String = PlaceholderParameterisation.insertParams(params, input)
    // Then:
    assert(result == """Select thing from table where someField = 'Stapley' and someotherField = 'Stapley'""")
  }

  it should "replace multiple parameter placeholders with the corresonding values from Placeholder Parameters" in {
    val params = PlaceholderParameters(Map("name" -> "Stapley", "age" -> 104))

    // Given:
    val input =
      """Select thing from table where someField = '[$name]' and age = [$age]"""
    val result: String = PlaceholderParameterisation.insertParams(params, input)

    assert(result == """Select thing from table where someField = 'Stapley' and age = 104""")
  }

  it should ",if a parameter is missing from the placedholder Template, issue a warning and skip the replacement" in {
    val params = PlaceholderParameters(Map("name" -> "Stapley", "age" -> 104))

    // Given:
    val input =
      """Select thing, age from table where someField = '[$name]'"""
    // When :
    val result: String = PlaceholderParameterisation.insertParams(params, input)

    assert(result == """Select thing, age from table where someField = 'Stapley'""")
  }

  "Complex Type Parameterisation - Scenario 1" should "replace Map type parameter values from Placeholder Parameters" in {
    val params = PlaceholderParameters(Map("disabledTask" -> "{\"task_name\":[\"generic_finalise_results\"]}"))

    // Given:
    val input =
      """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "disabled":[$disabledTask]}"""
    val result: String = PlaceholderParameterisation.insertParams(params, input)

    assert(result == """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "disabled":{"task_name":["generic_finalise_results"]}}""")
  }

  "Complex Type Parameterisation - Scenario 2" should "replace List type parameter values from Placeholder Parameters" in {
    val params = PlaceholderParameters(Map("input_metadata" -> "[{\"attribute\":\"file_type\",\"value\":\"test_file_type\",\"data_type\":\"String\",\"domain\":\"domain\"}]"))

    // Given:
    val input =
      """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "metadata":[$input_metadata]}"""
    val result: String = PlaceholderParameterisation.insertParams(params, input)

    assert(result == """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "metadata":[{"attribute":"file_type","value":"test_file_type","data_type":"String","domain":"domain"}]}""")
  }

  "Complex Type Parameterisation - Scenario 3" should "replace parameter value in Map type parameter" in {
    val params = PlaceholderParameters(Map("task1" -> "my_task1", "task2" -> "my_task2"))

    // Given:
    val input =
      """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "disabled":{"task_name":["[$task1]", "[$task2]"]}}"""
    val result: String = PlaceholderParameterisation.insertParams(params, input)

    assert(result == """{"source_dataset_name": "testingdb", "source_table_name": "source_table", "disabled":{"task_name":["my_task1", "my_task2"]}}""")
  }

}
package hsbc.emf.infrastructure.orchestration.placeholderparams

case class PlaceholderParameters(paramMap: Map[String, Any]) {

  def format: Map[String, String] = paramMap.map {
    // Future proofing if different value types need different formats
    // case (k: String ,v : String) => ( k, escapeSql(v))
    case (k: String, v: Any) => (k, v.toString)
  }
}
package hsbc.emf.data.orchestration

final case class ProcessTask(
                              order_id: String,
                              command: String,
                              parents: List[String],
                              parameters: String,
                              topic: String
                            )
package hsbc.emf.data.orchestration

case class ProcessTaskData(order_id: String,
                           command: String,
                           parents: List[String],
                           parameters: String,
                           topic: String,
                           entity_uuid: String)

package hsbc.emf.data.orchestration

import org.apache.spark.sql.SparkSession

object ProcessTaskHelper {

 val pathToProcessTaskTestCases = "application\\tests\\resources\\ProcessTaskTestCases\\"

  /* given a file name in the application\tests\resources\ProcessTaskTestCases directory,
   returns a sequence of ProcessTask's. If  filename is undefined return them all
   */
  def getATestProcessTask(fileName: String = "")(implicit spark: SparkSession): Seq[ProcessTask] = {
    import spark.implicits._
    val path = pathToProcessTaskTestCases +fileName
    spark.read.option("multiline", "true").
      json(path).as[ProcessTask].collect().toSeq

  }
}
package hsbc.emf.data.orchestration

/** For deserializing the labels parameter from the parameters json string of a process task.
  *
  * @param labels Stores the deserialized labels. Uses Option because the labels parameter can be omitted in the parameters json string.
  */
case class ProcessTaskLabelsParameter(labels: Option[Map[String, List[String]]])package hsbc.emf.service.orchestration

import hsbc.emf.data.orchestration.ProcessTask

object ProcessTasksParametersHandler {
  def removeQuotesForConstraints(processTasks: Seq[ProcessTask]): Seq[ProcessTask] = {
    processTasks.map(task =>
      task.command.toUpperCase match {
        case "SPARK-RESOLVE" | "GBQ-RESOLVE" =>
          removeQuotesForConstraints(task, List("constraints", "where_clauses"))
        case "SPARK-RUN" | "OE-RUN" =>
          removeQuotesForConstraints(task, List("process_tasks_constraints"))
        case _ =>
          task
      })
  }

  def removeQuotesForConstraints(task: ProcessTask, keyList: List[String]): ProcessTask = {
    val cleanedParameter = cleanParameters(task.parameters, keyList)
    ProcessTask(order_id = task.order_id, command = task.command, parents = task.parents, parameters = cleanedParameter, topic = task.topic)
  }

  def cleanParameters(parameters: String, keyWord: List[String]): String = {
    var resultParameter = parameters
    keyWord.foreach(key => {
      val startPoint = resultParameter.toLowerCase.indexOf(key.toLowerCase())
      if (startPoint>0) {
        val temp = resultParameter.substring(startPoint)
        val constraintsPoint = temp.indexOf(":")
        var needReplace = true
        var isEnd = false
        var firstMarker = true
        var newParameters = ""
        temp.substring(constraintsPoint).foreach(u =>
          if (!needReplace) {
            newParameters += u
          }
          else if (u.equals('[') && firstMarker) {
            firstMarker = false
            needReplace = false
            newParameters += u
          }
          else if (u.equals('\"') && (firstMarker || isEnd)) {
            firstMarker = false
            isEnd = false
          }
          else if (u.equals(']')) {
            isEnd = true
            newParameters += u
          }
          else {
            newParameters += u
          }
        )
        newParameters = resultParameter.substring(0, startPoint + constraintsPoint) + newParameters
        resultParameter = newParameters
      }
    })
    resultParameter
  }
}
package hsbc.emf.service.orchestration

import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class ProcessTasksParametersHandlerTest extends IntegrationTestSuiteBase {
  "add double quotes in normal constrains" should "return correct format" in {
    val str = """ {"constraints": "[{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]"} """
    val result=ProcessTasksParametersHandler.cleanParameters(str, List("constraints"))
    assert(result==""" {"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]} """)
  }

  "add double quotes in longer constrains" should "return correct format" in {
    val str = """ {"constraints": "[{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"}]"} """
    val result=ProcessTasksParametersHandler.cleanParameters(str, List("constraints", "where_clause"))
    assert(result==""" {"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"},{"attribute":"location","value":"UK"}]} """)
  }

  "add double quotes in constrains which already contains double quotes in attribute" should "return correct format" in {
    val str = """ {"constraints": "[{"attribute":"location_"UK"","value":"London"}]"} """
    val result=ProcessTasksParametersHandler.cleanParameters(str, List("constraints", "where_clause"))
    assert(result==""" {"constraints": [{"attribute":"location_"UK"","value":"London"}]} """)
  }

  "add double quotes in constrains which already contains double quotes in value" should "return correct format" in {
    val str = """ {"constraints": "[{"attribute":"location","value":"UK_"London""}]"} """
    val result = ProcessTasksParametersHandler.cleanParameters(str, List("constraints", "where_clause"))
    assert(result ==""" {"constraints": [{"attribute":"location","value":"UK_"London""}]} """)
  }

  "add double quotes in normal constrains and where_clause" should "return correct format" in {
    val str = """ {"constraints": "[{"attribute":"location","value":"UK"}]", "where_clause": "[{"attribute":"attribute1","value":"value1","operator":"NOT IN"}]"} """
    val result=ProcessTasksParametersHandler.cleanParameters(str, List("constraints", "where_clause"))
    assert(result==""" {"constraints": [{"attribute":"location","value":"UK"}], "where_clause": [{"attribute":"attribute1","value":"value1","operator":"NOT IN"}]} """)
  }

  "add double quotes in normal where_clause" should "return correct format" in {
    val str = """ {"constraints": [{"attribute":"location","value":"UK"}], "where_clause": "[{"attribute":"attribute1","value":"value1","operator":"NOT IN"}]"} """
    val result=ProcessTasksParametersHandler.cleanParameters(str, List("constraints", "where_clause"))
    assert(result==""" {"constraints": [{"attribute":"location","value":"UK"}], "where_clause": [{"attribute":"attribute1","value":"value1","operator":"NOT IN"}]} """)
  }

}
package hsbc.emf.service.orchestration

import scala.util.{Failure, Success, Try}

import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.logging._
import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.data.resolution.{Equal, ResolutionConstraint, ResolutionCriteria}
import hsbc.emf.data.sparkcmdmsg.{SparkResolveMessage, SparkRunMessage}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.helper.HelperUtility
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.resolution.SparkResolveService

import org.apache.spark.sql.SparkSession

class ProcessTasksResolver(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends IProcessTasksResolver with MessageContext {

  /** Call SparkResolutionService to resolve process tasks into a List of ProcessTask.
    *
    * @param sparkRunMessage The message containing the process_tasks_constraint for resolution
    * @return The List of sorted process tasks representing the DAG. The list is sorted by parent-child relationships.
    */
  override def resolveProcessTasks(sparkRunMessage: SparkRunMessage): Seq[ProcessTask] = {
    Try {
      val resolveMessage = constructResolveMessage(sparkRunMessage)
      val sqlExecutor = new SqlExecutor()
      new SparkResolveService(sqlExecutor, new CatalogueDAO(sqlExecutor)).resolve(resolveMessage)
      val dbTblName = resolveMessage.dataset_name match {
        case Some(datasetName) => s"$datasetName.${resolveMessage.table_name}"
        case None => resolveMessage.table_name
      }
      import spark.implicits._
      val processTasks = spark.table(dbTblName).drop("entity_uuid").as[ProcessTask].collect().toList
      EmfLogger.info(s"Resolved ${processTasks.size} process tasks")
      processTasks
    }
    match {
      case Success(v) => v
      // It is expected the caller of this method, i.e. SparkOrchestrateService.executeWorkflow(), have exception
      // handling covering this method, so we log the exception and rethrow the same error. We may throw a new type
      // of EmfException if needed.
      case Failure(exception) =>
        EmfLogger.error("ProcessTasksResolver.resolveAndSortProcessTasks failed with cause: " + exception.getMessage)
        throw new RuntimeException("ProcessTasksResolver.resolveAndSortProcessTasks failed", exception)
    }
  }

  /** Read the sparkRunMessage and construct SparkResolveMessage for SparkResolveService()
    *
    * @param sparkRunMessage SparkRunMessage
    * @return sparkResolveMessage
    */
  private def constructResolveMessage(sparkRunMessage: SparkRunMessage): SparkResolveMessage = {

    val constraints =
      if (sparkRunMessage.process_tasks_constraints == null ||
        sparkRunMessage.process_tasks_constraints.isEmpty) {
        List(ResolutionConstraint("workflow", sparkRunMessage.workflow, Equal))
      }
      else {
        sparkRunMessage.process_tasks_constraints ++
          List(ResolutionConstraint("workflow", sparkRunMessage.workflow, Equal))
      }

    val criteria = ResolutionCriteria(
      file_type = EmfConfig.process_tasks,
      constraints = constraints,
      min_matches = 1)

    // Change to use as_view (true) and get rid of the "zzz" DB (and EmfConfig.defaultDatasetName).
    // We may revisit later to pass in the generated ZZZ_ DB later if needed, in which case we will need to
    // change the method signature to pass in the SparkRun PlaceholderParameters.
    // The resolution table_name (a view in our case, as as_view = true) is also changed to add a db-specific uuid
    // because resolution will append data to an existing view, which may cause issue when there are process task
    // resolution for more than 1 time, e.g. during unit tests, or FF team running SparkRun multiple times in same
    // spark-shell session.
    SparkResolveMessage(criteria = criteria,
      table_name = s"${EmfConfig.process_tasks}_${HelperUtility.generateDatabaseNameUUID()}",
      as_view = true)
  }
}
package hsbc.emf.service.orchestration

import hsbc.emf.data.orchestration.{ProcessTask, ProcessTaskData}
import hsbc.emf.data.resolution.{Equal, ResolutionConstraint}
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.EmfResolveServiceException
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

import org.apache.spark.sql.SaveMode

class ProcessTasksResolverTest extends IntegrationTestSuiteBase {
  val testCommand = "SPARK-SQL-EVAL"
  val testParameters = """{query": "select * from source_table", "table": "result_table"}"""
  val testTopic = ""
  import spark.implicits._

  // Database setup mainly for the resolution part of resolveAndSortProcessTasks
  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.catalogueDatabaseName}")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.process_tasks}")
    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue3.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS ${EmfConfig.process_tasks}.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '${EmfConfig.process_tasks}' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.process_tasks} CASCADE")
    super.afterAll()
  }

  "given a valid sparkRunMessage, resolveAndSortProcessTasks" should
    "return a resolved process tasks" in {

    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("T01", testCommand, List.empty, testParameters, testTopic, "T1"))
    val expectedResultProcessTasks: Seq[ProcessTask] = List(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive").saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
    val sparkRunMessage = SparkRunMessage("CA_ALM_R6", resConstraint, spark_version = None, run_uuid = None)
    val actualResultProcessTasks: Seq[ProcessTask] = new ProcessTasksResolver().resolveProcessTasks(sparkRunMessage)
    assert(actualResultProcessTasks == expectedResultProcessTasks)
  }

  "given a valid sparkRunMessage, resolveAndSortProcessTasks" should
    "return a resolved list of process tasks in correct topological order" in {

    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("T01", testCommand, List.empty, testParameters, testTopic, "T1"),
      ProcessTaskData("T02", testCommand, List("T01"), testParameters, testTopic, "T1"),
      ProcessTaskData("R01", testCommand, List.empty, testParameters, testTopic, "T1"))
    val expectedResultProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("R01", testCommand, List.empty, testParameters, testTopic))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive").saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
    val sparkRunMessage = SparkRunMessage(workflow = "CA_ALM_R6", List.empty, spark_version = None, run_uuid = None)
    val actualResultProcessTasks: Seq[ProcessTask] = new ProcessTasksResolver().resolveProcessTasks(sparkRunMessage)
    assert(actualResultProcessTasks == expectedResultProcessTasks)
  }

  "given a valid sparkRunMessage, resolveAndSortProcessTasks" should
    "return a empty resolved list of process tasks" in {

    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("T01", testCommand, List.empty, testParameters, testTopic, "T2"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive").saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
    val sparkRunMessage = SparkRunMessage("CA_ALM_R6", List.empty, spark_version = None, run_uuid = None)
    val actualResultProcessTasks: Seq[ProcessTask] = new ProcessTasksResolver().resolveProcessTasks(sparkRunMessage)
    assert(actualResultProcessTasks.isEmpty)
  }

  "given a invalid sparkRunMessage, resolveAndSortProcessTasks" should
    "return EmfResolveServiceException error" in {

    val sparkRunMessage = SparkRunMessage("", List.empty, spark_version = None, run_uuid = None)
    val caught = intercept[RuntimeException] {
      new ProcessTasksResolver().resolveProcessTasks(sparkRunMessage)
    }
    assert(caught.getCause.isInstanceOf[EmfResolveServiceException])
    assert(!caught.getMessage.isEmpty)
  }
}
package hsbc.emf.service.orchestration

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}

class ProcessTasksSorter(implicit val messageInfo: MessageInfo) extends IProcessTasksSorter with MessageContext {
  /** Sort the Seq of ProcessTask according to their parent-child relationships to represent the DAG.
    *
    * ProcessTasks that have no parent are top level tasks and will go into the sorted list first.
    * ProcessTasks that have parents will go into the sorted list after all their parents went into the list already.
    * ProcessTasks that are siblings can be in any order amongst themselves without affecting the correctness but they
    * are sorted by order_id to have consistent sorting result across multiple runs on same set of ProcessTasks.
    *
    * In MVP, it is assumed that the parent-child relationships between ProcessTasks in a workflow is acyclic and valid.
    * Validation will be implemented post MVP.
    *
    * @param processTasks Original list of process tasks before sorting
    * @return The Sequence of Sequence of sorted process tasks representing the DAG.
    *         Each Seq[ProcessTask] in result Seq[Seq[ProcessTask] is the subset that can be run in parallel.
    */
  def sortProcessTasks(processTasks: Seq[ProcessTask]): Seq[Seq[ProcessTask]] = {
    // If input is empty list, stop and return the empty list
    if (processTasks.isEmpty) {
      Seq.empty[Seq[ProcessTask]]
    }
    else {
      // Split the process tasks into 2 lists, one for process tasks without parents and the other for those with parents.
      // Those without parents will be handled first, while those with parents will be handled by the loop.
      // In addition to empty list check, null check is also added because null is the usual workaround for the error blocking
      // inserting empty list/array/map into partitioned Hive parquet table (the format that process tasks table is using).
      val (processTasksWithoutParents, processTasksWithParents) = processTasks.partition(task => task.parents == null || task.parents.isEmpty)

      // The list to hold the sorted result. Initially assigned the process tasks without parents, sorted by order_id.
      var sortedProcessTasksSpiltByDependency = Seq(processTasksWithoutParents.sortBy(_.order_id))

      // The list to hold the order_id of the sorted results to facilitate easier check whether all parents are sorted
      var sortedProcessTasksOrderIds = sortedProcessTasksSpiltByDependency.head.map(_.order_id)
      EmfLogger.debug(s"Sorted Process Tasks (order_id): $sortedProcessTasksOrderIds")

      // The list to hold the remaining tasks to be sorted.
      var remainingProcessTasks = processTasksWithParents

      // Handle remaining process tasks. For each iteration, move all eligible process tasks to sortedProcessTask.
      // Eligible process tasks are those with all their parents sorted (picked) already.
      while (remainingProcessTasks.nonEmpty) {
        EmfLogger.debug(s"remainingProcessTasks non empty (count: ${remainingProcessTasks.length}), continue to loop")

        val (remainingProcessTasksWithAllParentsSorted, remainingProcessTasksWithSomeParentsNotSorted) =
          remainingProcessTasks.partition(_.parents.forall(sortedProcessTasksOrderIds.contains))

        if (remainingProcessTasksWithAllParentsSorted.isEmpty) {
          EmfLogger.error("Some process tasks have parent that doesn't exist")
          throw new IllegalArgumentException("Some process tasks have parent that doesn't exist")
        }

        val remainingProcessTasksToBeAddedToSorted = remainingProcessTasksWithAllParentsSorted.sortBy(_.order_id)
        sortedProcessTasksSpiltByDependency ++= Seq(remainingProcessTasksToBeAddedToSorted)
        sortedProcessTasksOrderIds ++= remainingProcessTasksToBeAddedToSorted.map(_.order_id)
        remainingProcessTasks = remainingProcessTasksWithSomeParentsNotSorted
        EmfLogger.debug(s"Sorted Process Tasks (order_id): $sortedProcessTasksOrderIds")
      }
      EmfLogger.info(s"Sorted Process Tasks (order_id): $sortedProcessTasksOrderIds")
      sortedProcessTasksSpiltByDependency
    }
  }
}
package hsbc.emf.service.orchestration

import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.infrastructure.logging.MessageContextTestData

import org.scalatest.FlatSpec

class ProcessTasksSorterTest extends FlatSpec with MessageContextTestData {
  // The sorting only depends on order_id and parents. Any command and parameters, even invalid, doesn't affect the sorting.
  // So we use same command and parameter for all tests to simplify the test data.
  val testCommand = "SPARK-SQL-EVAL"
  val testParameters = """{query": "select * from source_table", "table": "result_table"}"""
  val testTopic = ""

  "given an empty list of process tasks, sortProcessTasks" should "return an empty list of process task" in {
    val sourceProcessTasks = Seq.empty[ProcessTask]
    val expectedResultProcessTasks = Seq.empty[Seq[ProcessTask]]
    val actualResultProcessTasks = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    assert(actualResultProcessTasks == expectedResultProcessTasks)
  }

  "given a list of process tasks all without parents, sortProcessTasks" should "return a list of process tasks sorted by order_id" in {
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T03", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic))
    val expectedResultProcessTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T03", testCommand, List.empty, testParameters, testTopic)))
    val actualResultProcessTasks: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    assert(actualResultProcessTasks == expectedResultProcessTasks)

    val sourceProcessTasks2: Seq[ProcessTask] = Seq(
      ProcessTask("T03", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, null, testParameters, testTopic),
      ProcessTask("T01", testCommand, null, testParameters, testTopic))
    val expectedResultProcessTasks2: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("T01", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, null, testParameters, testTopic),
      ProcessTask("T03", testCommand, null, testParameters, testTopic)))
    val actualResultProcessTasks2: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks2)
    assert(actualResultProcessTasks2 == expectedResultProcessTasks2)
  }

  "given a list of process tasks forming a straight sequence of parent-child relationship, sortProcessTasks" should
    "return a list of process tasks following the parent-child relationship" in {
    // The source data is chosen so that there will be sorting happened,
    // i.e. won't be same order of original list; and not following order_id lexical order
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic))
    val expectedResultProcessTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("T01", testCommand, List.empty, testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic)),
      Seq(ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic)))
    val actualResultProcessTasks: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    assert(actualResultProcessTasks == expectedResultProcessTasks)

    val sourceProcessTasks2: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic))
    val expectedResultProcessTasks2: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("T01", testCommand, null, testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic)),
      Seq(ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic)))
    val actualResultProcessTasks2: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks2)
    assert(actualResultProcessTasks2 == expectedResultProcessTasks2)
  }

  "given a list of process tasks with one having multiple parents, sortProcessTasks" should
    "return a list of process tasks with all parents before that task" in {
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("R01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("R02", testCommand, List("R01"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T02", "R02"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic))
    val expectedResultProcessTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("R01", testCommand, List.empty, testParameters, testTopic),
          ProcessTask("T01", testCommand, List.empty, testParameters, testTopic)),
      Seq(ProcessTask("R02", testCommand, List("R01"), testParameters, testTopic),
          ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("T02", "R02"), testParameters, testTopic)),
      Seq(ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic)))
    val actualResultProcessTasks: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    assert(actualResultProcessTasks == expectedResultProcessTasks)

    val sourceProcessTasks2: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("R01", testCommand, null, testParameters, testTopic),
      ProcessTask("R02", testCommand, List("R01"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T02", "R02"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic))
    val expectedResultProcessTasks2: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("R01", testCommand, null, testParameters, testTopic),
          ProcessTask("T01", testCommand, null, testParameters, testTopic)),
      Seq(ProcessTask("R02", testCommand, List("R01"), testParameters, testTopic),
          ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("T02", "R02"), testParameters, testTopic)),
      Seq(ProcessTask("A02", testCommand, List("A01"), testParameters, testTopic)))
    val actualResultProcessTasks2: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks2)
    assert(actualResultProcessTasks2 == expectedResultProcessTasks2)
  }

  "given a list of process tasks with multiple children and a bypass" should
    "return a list of process tasks in correct topological order" in {
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("R01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("R02", testCommand, List("R01", "T02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("R02"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("R02"), testParameters, testTopic))
    val expectedResultProcessTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("R01", testCommand, List.empty, testParameters, testTopic),
          ProcessTask("T01", testCommand, List.empty, testParameters, testTopic)),
      Seq(ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("R02", testCommand, List("R01", "T02"), testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("R02"), testParameters, testTopic),
          ProcessTask("A02", testCommand, List("R02"), testParameters, testTopic)))
    val actualResultProcessTasks: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    assert(actualResultProcessTasks == expectedResultProcessTasks)

    val sourceProcessTasks2: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("R01", testCommand, null, testParameters, testTopic),
      ProcessTask("R02", testCommand, List("R01", "T02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("R02"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("R02"), testParameters, testTopic))
    val expectedResultProcessTasks2: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("R01", testCommand, null, testParameters, testTopic),
          ProcessTask("T01", testCommand, null, testParameters, testTopic)),
      Seq(ProcessTask("T02", testCommand, List("T01"), testParameters, testTopic)),
      Seq(ProcessTask("R02", testCommand, List("R01", "T02"), testParameters, testTopic)),
      Seq(ProcessTask("A01", testCommand, List("R02"), testParameters, testTopic),
          ProcessTask("A02", testCommand, List("R02"), testParameters, testTopic)))
    val actualResultProcessTasks2: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks2)
    assert(actualResultProcessTasks2 == expectedResultProcessTasks2)
  }

  "given a list of process tasks with all with parents (i.e. no task can start), sortProcessTasks" should "throw an exception" in {
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List("Z01"), testParameters, testTopic),
      ProcessTask("T01", testCommand, List("T01"), testParameters, testTopic))
    assertThrows[Exception]{
      new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    }
  }

  "given a list of process tasks with some tasks having parents not exist in the process task lists, sortProcessTasks" should
    "throw an exception" in {
    val sourceProcessTasks: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, List.empty, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("Z01"), testParameters, testTopic))
    assertThrows[Exception]{
      new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks)
    }

    val sourceProcessTasks2: Seq[ProcessTask] = Seq(
      ProcessTask("T01", testCommand, null, testParameters, testTopic),
      ProcessTask("T02", testCommand, List("A02"), testParameters, testTopic),
      ProcessTask("A01", testCommand, List("T01"), testParameters, testTopic),
      ProcessTask("A02", testCommand, List("Z01"), testParameters, testTopic))
    assertThrows[Exception] {
      new ProcessTasksSorter().sortProcessTasks(sourceProcessTasks2)
    }
  }
}package hsbc.emf.infrastructure.io.readers

import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.types._

class ReadCsvFileTest extends IntegrationTestSuiteBase {

  "given a valid csv file path and skiprows count 0" should "read the file" in {

    val actualDF = spark.read.csv("tests/hsbc/emf/testingFiles/*.csv")
    val config = CsvFileFormatConfig(delimiter = ",")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles", None)
    assert(dataFrameCsv != null)
    assert(actualDF.except(dataFrameCsv).isEmpty)
  }

  "given a valid csv file path and skiprows count 2" should "read the file after skipping the first 2 lines" in {

    val actualDF = spark.read.csv("tests/hsbc/emf/testingFiles/data/csv/testresult12.csv")
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 2)
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles", None)
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 10)
    assert(actualDF.except(dataFrameCsv).isEmpty)
  }

  "given an invalid csv file path" should "return EmfIoException" in {

    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 2)
    val caught = intercept[EmfIoException] {
      new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/Testing", None)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given an valid csv file path with default CsvFileFormatConfig " should "read the file with default configs" in {

    val dataFrameCsv = new CsvFileReaderToDF()
      .read(CsvFileFormatConfig(), "tests/hsbc/emf/testingFiles/data/csv/test3.csv", None)

    assert(dataFrameCsv != null)
    assert(dataFrameCsv.rdd.map(_ (0)).collect().head.toString.toInt == 23)
    assert(dataFrameCsv.rdd.map(_ (1)).collect().head.toString == "Sai")
    assert(dataFrameCsv.rdd.map(_ (2)).collect().head.toString.toInt == 3355)
    assert(dataFrameCsv.rdd.map(_ (3)).collect().head.toString == "b12345")
    assert(dataFrameCsv.count() == 2)
  }

  "given an valid csv file path with quotecharacter=\" " should "read the file with quoteCharacter doublequote" in {

    val dataFrameCsv = new CsvFileReaderToDF()
      .read(CsvFileFormatConfig(quoteCharacter = "\""), "tests/hsbc/emf/testingFiles/data/csv/test4.csv", None)

    assert(dataFrameCsv != null)
    assert(dataFrameCsv.rdd.map(_ (0)).collect().head.toString.toInt == 23)
    assert(dataFrameCsv.rdd.map(_ (1)).collect().head.toString == "Sai")
    assert(dataFrameCsv.rdd.map(_ (2)).collect().head.toString.toInt == 3355)
    assert(dataFrameCsv.rdd.map(_ (3)).collect().head.toString == "b12345")
    assert(dataFrameCsv.count() == 2)
  }

  "given an valid csv file path with delimiter=','" should "read the file with comma delimiter" in {

    val dataFrameCsv = new CsvFileReaderToDF()
      .read(CsvFileFormatConfig(delimiter = ",", quoteCharacter = "\""), "tests/hsbc/emf/testingFiles/data/csv/test5.csv", None)

    assert(dataFrameCsv != null)
    assert(dataFrameCsv.rdd.map(_ (0)).collect().head.toString.toInt == 23)
    assert(dataFrameCsv.rdd.map(_ (1)).collect().head.toString == "Sai,")
    assert(dataFrameCsv.rdd.map(_ (2)).collect().head.toString.toInt == 3355)
    assert(dataFrameCsv.rdd.map(_ (3)).collect().head.toString == "b,12345")
    assert(dataFrameCsv.count() == 2)
  }

  "given a valid csv file path with multiple files, multiple headers and skiprows count 3" should "read the file after skipping the first 3 lines" in {

    val actualDF = spark.read.csv("tests/hsbc/emf/testingFiles/data/csv/testresult67.csv")
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 3)
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/data/csv/skipRows", None)
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 3)
    assert(actualDF.except(dataFrameCsv).isEmpty)
  }
  "given a valid csv file path schema,skip rows is 1" should "dataframe can be read and convert the value correctly " in {
    val schema=StructType(List(
      StructField("radar_file_seq_num", LongType, true),
      StructField("radar_reporting_date", DateType, true),
      StructField("radar_extracted_date", TimestampType, true),
      StructField("booking_entity_identifier", StringType, true),
      StructField("cashflow_schedule_identifier", StringType, true),
      StructField("cashflow_date_offset_number", DecimalType(38,9), true),
      StructField("account_or_deal_arrangement_local_number", DecimalType(38,9), true),
      StructField("local_number_double", DoubleType, true),
      StructField("support_flag", BooleanType, true)
    ))
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 1)
    val expectedDF = spark.read.format("csv").option("header", "true").load("tests/hsbc/emf/testingFiles/data/csv/test8result.csv")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/data/csv/test8.csv", Some(schema))
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 1)
    assert(expectedDF.select("radar_file_seq_num","radar_reporting_date","radar_extracted_date","booking_entity_identifier","cashflow_schedule_identifier","cashflow_date_offset_number","account_or_deal_arrangement_local_number","local_number_double")
      .except(dataFrameCsv.select("radar_file_seq_num","radar_reporting_date","radar_extracted_date","booking_entity_identifier","cashflow_schedule_identifier","cashflow_date_offset_number","account_or_deal_arrangement_local_number","local_number_double")).isEmpty)
    assert(dataFrameCsv.select("support_flag").collectAsList().get(0).get(0)==false)
  }
  "given a valid csv file which has 6 rows and 1 header , schema,skip rows is 3" should "return 4 rows" in {
    val schema=StructType(List(
      StructField("radar_file_seq_num", LongType, true),
      StructField("radar_reporting_date", DateType, true),
      StructField("radar_extracted_date", TimestampType, true),
      StructField("booking_entity_identifier", StringType, true),
      StructField("cashflow_schedule_identifier", StringType, true),
      StructField("cashflow_date_offset_number", DecimalType(38,9), true),
      StructField("account_or_deal_arrangement_local_number", DecimalType(38,9), true),
      StructField("local_number_double", DoubleType, true)
    ))
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 3)
    val expectedDF = spark.read.format("csv").option("header", "true").load("tests/hsbc/emf/testingFiles/data/csv/test9result.csv")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/data/csv/csv_with_schema/test9.csv", Some(schema))
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 4)
    assert(expectedDF.except(dataFrameCsv).isEmpty)
  }
  "given 2 valid csv files which has 7 rows and 2 rows, schema,skip rows is 1" should "return 7 rows" in {
    val schema=StructType(List(
      StructField("radar_file_seq_num", LongType, true),
      StructField("radar_reporting_date", DateType, true),
      StructField("radar_extracted_date", TimestampType, true),
      StructField("booking_entity_identifier", StringType, true),
      StructField("cashflow_schedule_identifier", StringType, true),
      StructField("cashflow_date_offset_number", DecimalType(38,9), true),
      StructField("account_or_deal_arrangement_local_number", DecimalType(38,9), true),
      StructField("local_number_double", DoubleType, true)
    ))
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 1)
    val expectedDF = spark.read.format("csv").option("header", "true").load("tests/hsbc/emf/testingFiles/data/csv/test10result.csv")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/data/csv/csv_with_schema", Some(schema))
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 7)
    assert(expectedDF.except(dataFrameCsv).isEmpty)
  }
  "given 2 valid csv files which has 7 rows and 2 rows, schema,skip rows is 2" should "return 5 rows" in {
    val schema=StructType(List(
      StructField("radar_file_seq_num", LongType, true),
      StructField("radar_reporting_date", DateType, true),
      StructField("radar_extracted_date", TimestampType, true),
      StructField("booking_entity_identifier", StringType, true),
      StructField("cashflow_schedule_identifier", StringType, true),
      StructField("cashflow_date_offset_number", DecimalType(38,9), true),
      StructField("account_or_deal_arrangement_local_number", DecimalType(38,9), true),
      StructField("local_number_double", DoubleType, true)
    ))
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 2)
    val expectedDF = spark.read.format("csv").option("header", "true").load("tests/hsbc/emf/testingFiles/data/csv/test11result.csv")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "tests/hsbc/emf/testingFiles/data/csv/csv_with_schema", Some(schema))
    assert(dataFrameCsv != null)
    assert(dataFrameCsv.count() == 5)
    assert(expectedDF.except(dataFrameCsv).isEmpty)
  }
  "given valid csv files with multiLine inputs and multiLine is true " should "read correctly" in {
    val schema=StructType(List(
      StructField("Id",LongType , true),
      StructField("Address", StringType, true),
       StructField("City", StringType, true),
      StructField("State", StringType, true),
      StructField("Zipcode", LongType, true)
    ))
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 1, multipleLine = "true")
    val expectedDF = spark.read.option("header", "true").option("multiLine","true").option("escape", "\"")
      .csv("application/tests/hsbc/emf/testingFiles/data/csv/multiline/test3.csv")
    val dataFrameCsv = new CsvFileReaderToDF().read(config, "application/tests/hsbc/emf/testingFiles/data/csv/multiline",Some(schema))
    expectedDF.show()
    dataFrameCsv.show()
  }
}
package hsbc.emf.udf.reevalexpression

import hsbc.emf.udf.{SparkUdfRegisterableFunction2, UdfBuilder}

private[udf] class ReEvaluateExpression extends SparkUdfRegisterableFunction2[String, String, ReEvaluateExpressionOutput] {

  import ReEvaluateExpression._

  override val functionName: String = "re_eval_expression"

  override def apply(v1: String, v2: String): ReEvaluateExpressionOutput = {
    ReEvaluateExpression.safeExecute {
      context.eval("js", ReEvaluateExpressionJavaScript.js)
      val bindings = context.getBindings("js")
      bindings.putMember("v1", v1)
      bindings.putMember("v2", v2)
      val value = context.eval("js", s"$functionName(v1,v2)")
      ReEvaluateExpressionOutput.apply(value)
    }
  }
}

private[udf] object ReEvaluateExpression extends UdfBuilder[ReEvaluateExpression] {
  override def apply: ReEvaluateExpression = new ReEvaluateExpression()
}
package hsbc.emf.udf.reevalexpression

private[udf] object ReEvaluateExpressionJavaScript{

 val js: String =
   """
     |re_eval_expression = function(json_row, str_eval)
     |{
     |    row = JSON.parse(json_row);
     |    str = str_eval;
     |    for (key in row) {
     |        str = str.replace(key, row[key])
     |    }
     |    try {
     |        return {"value": eval(str), "err": null}
     |    } catch (err) {
     |        return {"value": null, "err": str_eval + ' with params ' + json_row + ' : ' + err.message}
     |    }
     |}
     |""".stripMargin
}

package hsbc.emf.udf.reevalexpression

import hsbc.emf.udf.graalvm.GraalVmValueConverter
import org.graalvm.polyglot.Value

private[udf] case class ReEvaluateExpressionOutput(
                                                    value: String,
                                                    err: String
                                                  )

private[udf] object ReEvaluateExpressionOutput extends GraalVmValueConverter[ReEvaluateExpressionOutput] {
  override def apply(v1: Value): ReEvaluateExpressionOutput = {
    ReEvaluateExpressionOutput(
      v1.getMember("value").toString,
      v1.getMember("err").asString()
    )
  }
}package hsbc.emf.udf.reevalexpression

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.udf.reevalexpression.ReEvaluateExpressionTestData.TestData
import org.scalatest.FlatSpec

class ReEvaluateExpressionTest extends FlatSpec with IntegrationTestSuiteBase {

  behavior of "ReEvaluateExpressionTest"

  it should "apply the javascript function and return the target value" in {
    val testClass = new ReEvaluateExpression()
    ReEvaluateExpressionTestData.testCasesInput.map {
      case TestData(v1, v2, target) => assert(testClass.apply(v1, v2) == ReEvaluateExpressionOutput(target, null))

    }

  }
  it should "execute the JavaScript inside a UDF" in {

    val testObject = new ReEvaluateExpression()
    spark.udf.register("re_eval_expression", testObject.apply(_: String, _: String))
    import spark.implicits._
    ReEvaluateExpressionTestData.testCasesInput.toDS.createOrReplaceTempView("ReEvaluateExpressionTest")

    val result = spark.sql("select re_eval_expression(json,string_evl) as result, target from ReEvaluateExpressionTest")
      .as[((String, String), String)]

    assert(result.collect().forall { case (result, target) => target == result._1 })
  }
}
package hsbc.emf.udf.reevalexpression

object ReEvaluateExpressionTestData {

  private[reevalexpression] case class TestData(json: String, string_evl: String, target: String)

  val testCasesInput = Seq(
    TestData("{ \"[$a]\": \"1000\", \"[$b]\": \"1100\"}", "'[$a]' - '[$b]'", "-100"),
    TestData("{ \"[$a]\": \"1300\", \"[$b]\": \"1300\"}", "'[$a]' - '[$b]'", "0"),
    TestData("{ \"[$a]\": \"2000\", \"[$b]\": \"2000\"}", "'[$a]' - '[$b] '", "0"),
    TestData("{ \"[$a]\": \"2800\", \"[$b]\": \"2700\"}", "'[$a]' - '[$b] '", "100"),
    TestData("{ \"[$a]\": \"4444\"}", "'[$a]' - '[$b] '", "NaN"),
    TestData("{ \"[$b]\": \"2500\"}", "'[$a]' - '[$b] '", "NaN"),
    TestData("{ \"[$a]\": \"UK\", \"[$b]\": \"GB\"}", "'[$a]' != '[$b]'", "true"),
    TestData("{ \"[$a]\": \"3.2\", \"[$b]\": \"3.2\"}", "'[$a]' != '[$b]'", "false"),
    TestData("{ \"[$a]\": \"GBP\", \"[$b]\": \"GBP\"}", "'[$a]' != '[$b]'", "false")
  )

}
package hsbc.emf.udf.cashflows

import hsbc.emf.udf.RowToJSCollection
import hsbc.emf.udf.graalvm.ScalaProxyObject

import org.apache.spark.sql.Row

private[cashflows] case class ReferenceCurve(date: java.sql.Date, rate: Double) extends ScalaProxyObject

private[cashflows] object ReferenceCurve extends RowToJSCollection[ReferenceCurve] {
  override def apply(v1: Row): ReferenceCurve = {
    ReferenceCurve(
      v1.getAs[java.sql.Date]("date"),
      v1.getAs[Double]("rate")
    )
  }
}package hsbc.emf.data.crm

final case class Relation(
                           efficiency: Double,
                           order: String,
                           cstar: Double
                         )
package hsbc.emf.data.resolution

final case class ResolutionConstraint(attribute: String,
                                      value: String,
                                      operator: ComparisonOperator = Equal)package hsbc.emf.infrastructure.services.mapper

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.ResolutionConstraintMapperException

object ResolutionConstraintMapper extends IMapper[List[ResolutionConstraintRaw], List[ResolutionConstraint]] {
  @throws(classOf[ResolutionConstraintMapperException])
  override def map(resConstraint: List[ResolutionConstraintRaw]): List[ResolutionConstraint] = {
    resConstraint match {
      case list: List[ResolutionConstraintRaw] => list.map(constraintRaw => tranformConstraint(constraintRaw))
      case _ => List.empty
    }
  }

  private def tranformConstraint(constraint: ResolutionConstraintRaw): ResolutionConstraint = {
    try {
      if (constraint.attribute == null || constraint.attribute.trim.isEmpty) {
        throw new ResolutionConstraintMapperException(s"SparkResolveService ResolutionConstraintMapper: null or empty attribute in constraint:" +
          s" ${constraint.attribute}")
      }

      if (constraint.value == null || constraint.value.trim.isEmpty) {
        throw new ResolutionConstraintMapperException(s"SparkResolveService ResolutionConstraintMapper: null or empty value in constraint:" +
          s" ${constraint.value}")
      }

      val op =
        if (constraint.operator == null) {
          Equal
        }
        else {
          constraint.operator match {
            case x if x.toUpperCase() == Equal.toString => Equal
            case x if x.toUpperCase() == NotEqual.toString => NotEqual
            case x if x.toUpperCase() == GreaterThan.toString => GreaterThan
            case x if x.toUpperCase() == GreaterThanOrEqual.toString => GreaterThanOrEqual
            case x if x.toUpperCase() == LessThanOrEqual.toString => LessThanOrEqual
            case x if x.toUpperCase() == LessThan.toString => LessThan
            case x if x.toUpperCase() == In.toString => In
            case x if x.toUpperCase() == NotIn.toString => NotIn
            case x if x.toUpperCase() == Like.toString => Like
            case x if x.toUpperCase() == NotLike.toString => NotLike
            case x if x.toUpperCase() == Is.toString => Is
            case x if x.toUpperCase() == IsNot.toString => IsNot
            case _ => Equal
          }
        }
      new ResolutionConstraint(constraint.attribute, constraint.value, op)
    }
    catch {
      case e: Exception =>
        val customMessage = "ResolutionConstraintMapper.tranformConstraint - fails with reason: " + e
        throw new ResolutionConstraintMapperException(customMessage, e)
    }
  }

}
package hsbc.emf.data.resolution

final case class ResolutionConstraintRaw(attribute: String,
                                         value: String,
                                         operator: String = "=")package hsbc.emf.data.resolution

import java.sql.Timestamp

final case class ResolutionCriteria(
                                     file_type: String,
                                     constraints: List[ResolutionConstraint] = List.empty,
                                     created_from: Option[Timestamp] = Some(Timestamp.valueOf("1900-01-01 00:00:00")),
                                     created_to: Option[Timestamp]
                                     = Some(Timestamp.valueOf("2100-01-01 00:00:00")),
                                     retry_count: Int = 0,
                                     inter_retry_interval: Int = 0,
                                     as_view: Boolean = false,
                                     latest_only: Boolean = true,
                                     min_matches: Long = 0L
                                   )package hsbc.emf.data.resolution

case class ResolutionCriteriaRaw(    file_type: String,
                                     constraints: List[ResolutionConstraintRaw] = List.empty,
                                     created_from: Option[String]
                                      = Some("1900-01-01 00:00:00"),
                                     created_to: Option[String]
                                      = Some("2100-01-01 00:00:00"),
                                     retry_count: Int = 0,
                                     inter_retry_interval: Int = 0,
                                     as_view: Boolean = false,
                                     latest_only: Boolean = true,
                                     min_matches: Long = 0L
                                   )package hsbc.emf.service.resolution

import java.sql.{Date, Timestamp}

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{UnsupportedComparisonOperator, UnsupportedDataType}
import hsbc.emf.infrastructure.helper.ResolutionHelper.parse
import hsbc.emf.infrastructure.helper.StringUtils.{encloseQuotes, removeBraces, removeQuotes, splitIntoList}

class ResolutionFilterStringBuilder {

  def stringTypeFilter(value: String, operator: ComparisonOperator): String = {

    val valueList = operator match {
      case Equal | NotEqual | Like | NotLike | In | NotIn => splitIntoList(removeBraces(value))
        .map(x => encloseQuotes(x))
      case _ => throw new UnsupportedComparisonOperator(s"Not supported operator in stringTypeFilter of" +
        s"ResolutionFilterStringBuilder: $operator")
    }

    operator match {
      case In | NotIn => s"""(${valueList.reduce(_ concat "," concat _)})"""
      case _ =>
        if (valueList.length > 1) {
          throw new UnsupportedComparisonOperator(s"Unsupported operator: $operator in stringTypeFilter" +
            s" of ResolutionFilterStringBuilder for values: $value")
        }
        else {
          valueList.head
        }
    }
  }

  def booleanTypeFilter(value: String, operator: ComparisonOperator): String = {

    val valueList = operator match {
      case Equal | NotEqual => splitIntoList(removeBraces(value)).map(parse[Boolean](_).toString)
      case _ => throw new UnsupportedComparisonOperator(s"Not supported operator in booleanTypeFilter of" +
        s" ResolutionFilterStringBuilder: $operator")
    }
    if (valueList.length > 1) {
      throw new UnsupportedComparisonOperator(s"Unsupported operator: $operator in booleanTypeFilter of " +
        s"ResolutionFilterStringBuilder for values: $value")
    }
    else {
      valueList.head
    }
  }

  def dateTimeTypeFilter(value: String, dataType: String, operator: ComparisonOperator): String = {

    val splitList = splitIntoList(removeBraces(value))
    val valueList = operator match {
      case Equal | NotEqual | LessThan | GreaterThan | GreaterThanOrEqual | LessThanOrEqual | In | NotIn =>
        dataType match {
          case "DateType" => splitList.map(x => removeQuotes(x))
            .map(parse[Date](_).toString)
            .map(x => encloseQuotes(x))
            .map(value => s"Date$value")
          case "TimestampType" => splitList.map(x => removeQuotes(x))
            .map(x => removeQuotes(x))
            .map(parse[Timestamp](_).toString.substring(0, 19))
            .map(x => encloseQuotes(x))
          case _ => throw new UnsupportedDataType(s"UnsupportedDataType $dataType in dateTimeTypeFilter of " +
            s"ResolutionFilterStringBuilder")
        }
      case _ => throw new UnsupportedComparisonOperator(s"Not supported operator in dateTimeTypeFilter of " +
        s"ResolutionFilterStringBuilder: $operator")
    }
    operator match {
      case In | NotIn => s"""(${valueList.reduce(_ concat "," concat _)})"""
      case _ =>
        if (valueList.length > 1) {
          throw new UnsupportedComparisonOperator(s"Unsupported operator: $operator in dateTimeTypeFilter of " +
            s"ResolutionFilterStringBuilder for values: $value")
        }
        else {
          valueList.head
        }
    }
  }

  def numericTypeFilter(value: String, dataType: String, operator: ComparisonOperator): String = {
    val splitList = splitIntoList(removeBraces(value))
    val valueList = operator match {
      case Equal | NotEqual | LessThan | GreaterThan | LessThanOrEqual | GreaterThanOrEqual | In | NotIn =>
        dataType match {
          case "IntegerType" => splitList.map(parse[Int](_).toString)
          case "DoubleType" => splitList.map(parse[Double](_).toString)
          case x if x.contains("DecimalType") => splitList.map(parse[BigDecimal](_).toString)
          case _ =>
            throw new UnsupportedDataType(s"UnsupportedDataType $dataType in numericTypeFilter of " +
              s"ResolutionFilterStringBuilder")
        }
      case _ =>
        throw new UnsupportedComparisonOperator(s"Not supported operator in numericTypeFilter of " +
          s"ResolutionFilterStringBuilder: $operator")
    }
    operator match {
      case In | NotIn => s"""(${valueList.reduce(_ concat "," concat _)})"""
      case _ =>
        if (valueList.length > 1) {
          throw new UnsupportedComparisonOperator(s"Unsupported operator: $operator in numericTypeFilter of " +
            s"ResolutionFilterStringBuilder for values: $value")
        }
        else {
          valueList.head
        }
    }
  }
}

object ResolutionFilterStringBuilder {
  private def instance: ResolutionFilterStringBuilder = new ResolutionFilterStringBuilder()

  def buildFilterExpression(value: String, dataType: String, operator: ComparisonOperator): String = {
    dataType match {
      case "StringType" => instance.stringTypeFilter(value, operator)
      case "BooleanType" => instance.booleanTypeFilter(value, operator)
      case "DateType" | "TimestampType" => instance.dateTimeTypeFilter(value, dataType, operator)
      case "IntegerType" | "DoubleType" => instance.numericTypeFilter(value, dataType, operator)
      case x if x.contains("DecimalType") => instance.numericTypeFilter(value, dataType, operator)
      case _ => throw new UnsupportedDataType(s"ResolutionFilterStringBuilder.buildFilterExpression - UnsupportedDataType $dataType in data dataframe")
    }
  }
}
package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, UnsupportedComparisonOperator, UnsupportedDataType}
import org.scalatest.FlatSpec

class ResolutionFilterStringBuilderTest extends FlatSpec{
  
  "given a boolean value with Equal,NotEqual operator" should "return valid buildFilterExpression" in {
    assert(ResolutionFilterStringBuilder.buildFilterExpression("true", "BooleanType", Equal).equals("true"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("false", "BooleanType", Equal).equals("false"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("true", "BooleanType", NotEqual).equals("true"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("false", "BooleanType", NotEqual).equals("false"))
  }

  "given a invalid boolean value with valid operator" should "return an InvalidCastError error" in {

    val caught1 = intercept[InvalidCastError] {
      assert(ResolutionFilterStringBuilder.buildFilterExpression("123", "BooleanType", Equal).equals("true"))
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[InvalidCastError] {
      assert(ResolutionFilterStringBuilder.buildFilterExpression("456", "BooleanType", Equal).equals("false"))
    }
    assert(!caught2.getMessage.isEmpty)
  }

  "given any boolean value with an unsupported dataType" should "return an UnsupportedDataType error from buildFilterExpression" in {

    val caught = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("true", "Bool", Equal)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given any string with an unsupported operator" should "return an UnsupportedComparisonOperator error" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("true", "BooleanType", In)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("[true,false]", "BooleanType", Equal)
    }
    assert(!caught2.getMessage.isEmpty)
  }

  "given a date value with valid operator" should "return valid buildFilterExpression enclosed in double quotes with Date prefix" in {
    val expected = "Date\"2021-03-01\""
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "DateType", Equal).equals(expected))
  }

  "given a timestamp value with valid operator" should "return valid buildFilterExpression enclosed in double quotes" in {
    val expected = "\"2021-03-01 00:00:00\""
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01T00:00:00", "TimestampType", Equal).equals(expected))
  }

  "given a date value with In, NotIn operator" should "return valid buildFilterExpression enclosed in paranthesis and Date prefix double quotes" in {
    val expected1 = "(Date\"2021-03-01\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "DateType", In).equals(expected1))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "DateType", NotIn).equals(expected1))
    val expected2 = "(Date\"2021-03-01\",Date\"2021-03-02\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01,2021-03-02]", "DateType", In).equals(expected2))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01,2021-03-02]", "DateType", NotIn).equals(expected2))
  }

  "given a timestamp value with In, NotIn operator" should "return valid buildFilterExpression enclosed in paranthesis and double quotes" in {
    val expected1 = "(\"2021-03-01 00:00:00\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01T00:00:00", "TimestampType", In).equals(expected1))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01T00:00:00", "TimestampType", NotIn).equals(expected1))
    val expected2 = "(\"2021-03-01 00:00:00\",\"2021-03-02 00:00:00\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01T00:00:00,2021-03-02T00:00:00]", "TimestampType", In).equals(expected2))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01T00:00:00,2021-03-02T00:00:00]", "TimestampType", NotIn).equals(expected2))
  }


  "given a invalid Date/Timestamp value with valid operator" should "return an InvalidCastError error" in {

    val caught1 = intercept[InvalidCastError] {
      ResolutionFilterStringBuilder.buildFilterExpression("!!", "DateType", Equal)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[InvalidCastError] {
      ResolutionFilterStringBuilder.buildFilterExpression("!!", "TimestampType", Equal)
    }
    assert(!caught2.getMessage.isEmpty)
  }


  "given any Date/Timestamp with an unsupported dataType" should "return an UnsupportedDataType error from buildFilterExpression" in {

    val caught1 = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "Date", Equal)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "Time", Equal)
    }

    assert(!caught2.getMessage.isEmpty)
  }

  "given any Date/Timestamp with an unsupported operator" should "return an UnsupportedComparisonOperator error from buildFilterExpression" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01", "DateType", Like)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("2021-03-01T00:00:00", "TimestampType", Like)
    }
    assert(!caught2.getMessage.isEmpty)


    val caught3 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01,2021-03-02]", "DateType", Equal)
    }
    assert(!caught3.getMessage.isEmpty)

    val caught4 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("[2021-03-01T00:00:00,2021-03-02T00:00:00]", "TimestampType", Equal)
    }
    assert(!caught4.getMessage.isEmpty)
  }
  
  "given a numeric value with valid operator" should "return valid buildFilterExpression" in {
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1", "IntegerType", Equal).equals("1"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.1", "DoubleType", Equal).equals("1.1"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.0", "DecimalType", Equal).equals("1.0"))
  }
  
  "given a numeric value with In, NotIn operator" should "return valid buildFilterExpression enclosed in paranthesis" in {
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1", "IntegerType", In).equals("(1)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.1", "DoubleType", In).equals("(1.1)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.0", "DecimalType", In).equals("(1.0)"))

    assert(ResolutionFilterStringBuilder.buildFilterExpression("1", "IntegerType", NotIn).equals("(1)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.1", "DoubleType", NotIn).equals("(1.1)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("1.0", "DecimalType", NotIn).equals("(1.0)"))

    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1,2]", "IntegerType", In).equals("(1,2)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1.1,1.2]", "DoubleType", In).equals("(1.1,1.2)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1.0,2.0]", "DecimalType", In).equals("(1.0,2.0)"))


    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1,2]", "IntegerType", NotIn).equals("(1,2)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1.1,1.2]", "DoubleType", NotIn).equals("(1.1,1.2)"))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[1.0,2.0]", "DecimalType", NotIn).equals("(1.0,2.0)"))
  }


  "given a invalid numeric value with valid operator" should "return an InvalidCastError error" in {

    val caught1 = intercept[InvalidCastError] {
      ResolutionFilterStringBuilder.buildFilterExpression("a", "IntegerType", Equal)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[InvalidCastError] {
      ResolutionFilterStringBuilder.buildFilterExpression("a", "DoubleType", Equal)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[InvalidCastError] {
      ResolutionFilterStringBuilder.buildFilterExpression("a", "DecimalType", Equal)
    }
    assert(!caught3.getMessage.isEmpty)
  }


  "given any numeric with an unsupported dataType" should "return an UnsupportedDataType error from buildFilterExpression" in {

    val caught1 = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("1", "Int", Equal)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("1.1", "Float", Equal)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("1.2", "Decimal", Equal)
    }
    assert(!caught3.getMessage.isEmpty)

  }

  "given any numeric with an unsupported operator" should "return an UnsupportedComparisonOperator error from buildFilterExpression" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("1", "IntegerType", Like)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("1.1", "DoubleType", Like)
    }
    assert(!caught2.getMessage.isEmpty)


    val caught3 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("1.0", "DecimalType", Like)
    }
    assert(!caught3.getMessage.isEmpty)
  }

  "given a string value with Equal,NotEqual,Like,NotLike operator" should "return valid buildFilterExpression enclosed in double quotes" in {
    val expected = "\"UK\""
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", Equal).equals(expected))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", NotEqual).equals(expected))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", Like).equals(expected))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", NotLike).equals(expected))

  }

  "given a string value with In, NotIn operator" should "return valid buildFilterExpression enclosed in paranthesis and double quotes" in {
    val expected1 = "(\"UK\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", In).equals(expected1))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", NotIn).equals(expected1))
    val expected2 = "(\"UK\",\"US\")"
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[UK,US]", "StringType", In).equals(expected2))
    assert(ResolutionFilterStringBuilder.buildFilterExpression("[UK,US]", "StringType", NotIn).equals(expected2))
  }

  "given any string with an unsupported dataType" should "return an UnsupportedDataType error from buildFilterExpression" in {

    val caught = intercept[UnsupportedDataType] {
      ResolutionFilterStringBuilder.buildFilterExpression("UK", "Int", In)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given any string with an unsupported operator" should "return an UnsupportedComparisonOperator error from buildFilterExpression" in {

    val caught1 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("UK", "StringType", LessThanOrEqual)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      ResolutionFilterStringBuilder.buildFilterExpression("[UK,US]", "StringType", Equal)
    }
    assert(!caught2.getMessage.isEmpty)
  }
}
package hsbc.emf.infrastructure.helper

import java.sql.{Date, Timestamp}
import java.time.{LocalDate, LocalDateTime}
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeFormatter.ISO_DATE_TIME

import scala.reflect.runtime.universe.{TypeTag, typeOf}
import scala.util.{Failure, Success, Try}
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{InvalidCastError, UnknownTypeConversion, UnsupportedComparisonOperator}

object ResolutionHelper {

  def nullCheck(inputString: String): Boolean = inputString == null || inputString == "null" || inputString == "Null"

  def cleanedInputStringNullCheck(operator: ComparisonOperator, cleanedInputString: String): Any = {
    if (operator == Is || operator == IsNot) {
      if (!nullCheck(cleanedInputString)) {callUnsupportedComparisonException(operator.toString)}
    }
    else {
      if (nullCheck(cleanedInputString)) {callUnsupportedComparisonException(operator.toString)}
    }
  }
  def callUnsupportedComparisonException(operator: String): Nothing = {
    throw new UnsupportedComparisonOperator(s"Unsupported operator for the input constraint(s): $operator")
  }

  def parse[T: TypeTag](value: String): T = {
    val mapper: String => Any = x => typeOf[T] match {
      case t if t =:= typeOf[Int] => x.toInt
      case t if t =:= typeOf[Double] => x.toDouble
      case t if t =:= typeOf[BigDecimal] => BigDecimal.apply(x)
      case t if t =:= typeOf[Boolean] => x.toBoolean
      case t if t =:= typeOf[String] => x
      case t if t =:= typeOf[Date] => Date.valueOf(x)
      case t if t =:= typeOf[Timestamp] =>
        // FCCC-10925: Fix FCCC-10785 - Add code to parse "yyyy-MM-dd" string to be timestamp
        val localDateTime =
          if (x.length == 10) {
            val localDate = LocalDate.parse(x, DateTimeFormatter.ofPattern("yyyy-MM-dd"))
            LocalDateTime.of(localDate, LocalDateTime.MIN.toLocalTime)
          }
          else {
            Try(LocalDateTime.parse(x, DateTimeFormatter.ofPattern("[yyyy-MM-dd HH:mm:ss.n][yyyy-MM-dd HH:mm:ss]")))
            match {
              case Success(value) => value
              case Failure(ex) => LocalDateTime.parse(x, ISO_DATE_TIME)
            }
          }
        Timestamp.valueOf(localDateTime)
      case _ => throw new UnknownTypeConversion(s"Unknown type conversion of type: ${typeOf[T]}")
    }
    Try(mapper(value).asInstanceOf[T]) match {
      case Success(result) => result
      case Failure(ex) => throw new InvalidCastError(s"Invalid type conversion for $value of type: ${typeOf[T]} => $ex")
    }
  }

}package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.ingestion.CatalogueEntity
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution.{ResolutionCriteria, ResolutionTarget}

case class ResolutionInfo(message: MessageInfo, criteria: ResolutionCriteria, resolutions: Seq[CatalogueEntity], resolutionCount: Int, resolutionTarget: ResolutionTarget, created: Timestamp = new Timestamp(System.currentTimeMillis())) extends ContextInfo
package hsbc.emf.data.resolution

final case class ResolutionTarget(
                                   table_name: String,
                                   source_entity_type: ISourceEntityType = DATA,
                                   where_clause: List[ResolutionConstraint] = List.empty,
                                   dataset_name: Option[String] = None,
                                   inject_metadata: Boolean = false
                                 )
package hsbc.emf.udf

import org.apache.spark.sql.Row

// convert in coming data to object
private[udf] trait RowToJSCollection[T] extends (Row => T) with Serializable

// used when input is an array
private[udf] trait SeqRowToJSCollection[T] extends (Seq[Row] => Seq[T]) with Serializablepackage hsbc.emf.udf

import org.apache.spark.sql.catalyst.expressions.GenericRowWithSchema
import org.apache.spark.sql.{Encoders, Row}
import org.scalatest.FlatSpec

case class TestCase(name: String, age: Option[Int], DoB: Option[java.sql.Date], height: Option[Double])

class RowToJSCollectionTest extends FlatSpec {

  val testClass = new RowToJSCollection[TestCase] {
    override def apply(v1: Row): TestCase = {
      TestCase(
        v1.getAs[String]("name"),
        v1.getAs[Option[Int]]("age"),
        v1.getAs[Option[java.sql.Date]]("DoB"),
        v1.getAs[Option[Double]]("height")
      )
    }
  }
  val testCase = new TestCase("Ben", None, Some(java.sql.Date.valueOf("2010-09-09")), Some(14.7))
  val testCase2 = new TestCase(null, Some(14), null, null)

  behavior of "convert a row back to a case class"

  it should s"should extract correct values when age is None}" in {
    val row = new GenericRowWithSchema(testCase.productIterator.toArray, Encoders.product[TestCase].schema)

    assert(testClass.apply(row) === testCase)

  }

  it should s"convert a row back to a case class with nulls/ None}" in {
    val row = new GenericRowWithSchema(testCase2.productIterator.toArray, Encoders.product[TestCase].schema)

    assert(testClass.apply(row) === testCase2)
  }


}
package hsbc.emf.udf.graalvm

import org.graalvm.polyglot.Value

import scala.collection.JavaConverters._
import scala.collection.mutable

class ScalaProxyObject extends org.graalvm.polyglot.proxy.ProxyObject {

  private val getCCParams: mutable.Map[String, AnyRef] =
    this.getClass.getDeclaredFields.foldLeft(mutable.Map.empty[String, AnyRef]) { (a, f) =>
      f.setAccessible(true)
      a + (f.getName -> f.get(this))
    }

  override def getMember(key: String): AnyRef = getCCParams.getOrElse(key, null) match {
    // see: https://stackoverflow.com/questions/36435492/unsupportedoperationexception-why-cant-you-call-toinstant-on-a-java-sql-dat/36435570
    case x: java.sql.Date => new DateProxy(x)
    case Some(x: AnyRef) => x
    case None => null
    case x => x
  }

  override def getMemberKeys: AnyRef = {
    this.getClass.getDeclaredFields.map {
      _.getName()
    }.toList.asJava.toArray
  }

  override def hasMember(key: String): Boolean = getCCParams.contains(key)

  override def putMember(key: String, value: Value): Unit = getCCParams.put(key, value)
}
package hsbc.emf.data.ingestion

import hsbc.emf.infrastructure.exception.EmfSchemaMapperException
import hsbc.emf.infrastructure.helper.JsonReader

case class Schema(schema: List[SchemaItem])

object Schema {
  def apply(schema: Option[String], schemaJson: Option[String]): Schema = {
    try {
      if (schemaJson.isDefined && !schemaJson.get.trim.equals("")) {
        applySchemaJson(schemaJson.get)
      } else if (schema.isDefined && !schema.get.trim.equals("")) {
        applySchema(schema.get)
      } else {
        throw new IllegalArgumentException("Missing both schema and schemaJson")
      }
    }
    catch {
      case e: Throwable =>
        val customMessage =
          s"""Schema.apply: unable to construct the Schema
             |object by deserializing schema string '$schema'
             |/ schemaJson string '$schemaJson' with cause ${e.getMessage}""".stripMargin
        throw new EmfSchemaMapperException(customMessage, e)

    }
  }

  private def applySchemaJson(schemaJson: String): Schema = {
    JsonReader.deserializeWithCheck[Schema](s"""{"schema": $schemaJson}""")
  }

  private def applySchema(schema: String): Schema = {
    // schema format is "fieldName1:fieldType1,fieldName2:fieldType2,..." so on so forth
    // val fieldTypePairs: List[String] = schema.split(",").toList

    // fix for FCCC-10840: to cover the decimal field splitting
    // schema format with decimal field type is
    // "Group_System_ID:STRING,Sys_Country_Code:STRING,Exposure_Type:STRING,Months_In_Default:decimal(38,9),ICE_STAGE_RAND_NO:DOUBLE"
    val fieldTypePairs: List[String] = schema.split("(?<!\\(.[0-9]),").toList
    val schemaItems: List[SchemaItem] =
      for (fieldTypePair: String <- fieldTypePairs) yield {
        val pair: Array[String] = fieldTypePair.split(":")
        val fieldName = pair(0).trim
        val fieldType = pair(1).trim
        SchemaItem(None, fieldName, fieldType.trim.toLowerCase, None)
      }
    Schema(schemaItems)
  }

}package hsbc.emf.data.ingestion

final case class SchemaItem(mode: Option[String], name: String, `type`: String, fields:Option[List[SchemaItem]] = None)
package hsbc.emf.data.ingestion

import hsbc.emf.infrastructure.exception.EmfSchemaMapperException
import org.scalatest.FlatSpec

class SchemaTest extends FlatSpec {
  "give a valid schema string but none schemaJson" should "return a Schema object" in {
    val schemaStr = "fieldName1:String,fieldName2:Int"
    val schema: Schema = Schema(Some(schemaStr), None)
    assert(None.equals(schema.schema.head.mode) && "fieldName1".equals(schema.schema.head.name) && "string".equals(schema.schema.head.`type`))
    assert(None.equals(schema.schema {
      1
    }.mode) && "fieldName2".equals(schema.schema {
      1
    }.name) && "int".equals(schema.schema {
      1
    }.`type`))
  }

  "give a none schema string but valid schemaJson" should "return a Schema object" in {
    val schemaJsonStr = "[{\"mode\":\"REQUIRED\",\"name\":\"fieldName1\",\"type\":\"String\"},{\"mode\":\"NULLABLE\",\"name\":\"fieldName2\",\"type\":\"Int\"}]"
    val schema: Schema = Schema(None, Some(schemaJsonStr))
    assert("REQUIRED".equals(schema.schema.head.mode.get) && "fieldName1".equals(schema.schema.head.name) && "String".equals(schema.schema.head.`type`))
    assert("NULLABLE".equals(schema.schema {
      1
    }.mode.get) && "fieldName2".equals(schema.schema {
      1
    }.name) && "Int".equals(schema.schema {
      1
    }.`type`))
  }

  "give a valid schema string and a valid schemaJson" should "return a Schema object per given schemaJson" in {
    val schemaStr = "fieldName1:String,fieldName2:Int"
    val schemaJsonStr = "[{\"mode\":\"REQUIRED\",\"name\":\"fieldName1\",\"type\":\"String\"},{\"mode\":\"NULLABLE\",\"name\":\"fieldName2\",\"type\":\"Int\"}]"
    val schema: Schema = Schema(Some(schemaStr), Some(schemaJsonStr))
    assert("REQUIRED".equals(schema.schema.head.mode.get) && "fieldName1".equals(schema.schema.head.name) && "String".equals(schema.schema.head.`type`))
    assert("NULLABLE".equals(schema.schema {
      1
    }.mode.get) && "fieldName2".equals(schema.schema {
      1
    }.name) && "Int".equals(schema.schema {
      1
    }.`type`))
  }

  "give none schema string and none schemaJson" should "throw EmfSchemaParsingException" in {
    val caught = intercept[EmfSchemaMapperException] {
      val schema: Schema = Schema(None, None)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "give an invalid schema string and none schemaJson" should "throw EmfSchemaParsingException" in {
    val caught = intercept[EmfSchemaMapperException] {
      val schemaStr = "fieldName1"
      val schema: Schema = Schema(Some(schemaStr), None)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "give a invalid schemaJson" should "throw EmfSchemaParsingException" in {
    val caught = intercept[EmfSchemaMapperException] {
      val schemaJson = "fieldName1"
      val schema: Schema = Schema(None, Some(schemaJson))
    }
    assert(!caught.getMessage.isEmpty)
  }

  "FCCC-10840: give a valid schema string with decimal(38,9) field" should "return a Schema object" in {
    // 1. given a schema string to construct a schema object by Schema.apply()
    val schemaStr = "fieldName1:String,fieldName2:decimal,fieldName3:decimal(38,9),fieldName4:Int"
    val schema: Schema = Schema(Some(schemaStr), None)
    // 2. assertion: verify attributes (mode,name,type) for each field
    assert(None.equals(schema.schema{0}.mode) && "fieldName1".equals(schema.schema{0}.name) && "string".equals(schema.schema{0}.`type`))
    assert(None.equals(schema.schema{1}.mode) && "fieldName2".equals(schema.schema{1}.name) && "decimal".equals(schema.schema{1}.`type`))
    assert(None.equals(schema.schema{2}.mode) && "fieldName3".equals(schema.schema{2}.name) && "decimal(38,9)".equals(schema.schema{2}.`type`))
    assert(None.equals(schema.schema {3}.mode) && "fieldName4".equals(schema.schema {3}.name) && "int".equals(schema.schema {3}.`type`))
  }
}
package hsbc.emf.infrastructure.helper

import hsbc.emf.data.ingestion.{Schema, SchemaItem}
import hsbc.emf.infrastructure.config.{FileFormatConfig, OrcFileFormatConfig, ParquetFileFormatConfig}
import hsbc.emf.infrastructure.exception.EmfFieldTypeException
import org.apache.spark.sql.DataFrame
import org.apache.spark.sql.types._

import scala.collection.mutable.ListBuffer

/**
  * It's an utility object to support hsbc.emf.data.ingestion.Schema opeartions
  */
object SchemaUtility {
  val delimiter = "|||"

  @throws(classOf[EmfFieldTypeException])
  def convertSchemaToStructType(schema: Schema): StructType = {
    var structType = new StructType()
    try {
      for (si: SchemaItem <- schema.schema) {
        if (si.mode.getOrElse("").equalsIgnoreCase("repeated")){
          structType = si.`type`.toLowerCase match {
            case "record" | "struct"| "list" =>
              structType.add(si.name, ArrayType(StructType(si.fields.get.map(
                subField => mapStructType(subField.mode, subField.name, subField.`type`, subField.fields, false))),isNullable(si.mode))
              )
            case _=>
              structType.add(StructField(si.name.toLowerCase, ArrayType(getFieldType(si.`type`, false)), true))
          }
        } else {
          structType = si.`type`.toLowerCase match {
            //Non-hive types
            case "record" | "struct"| "list" =>
              structType.add(si.name, ArrayType(StructType(si.fields.get.map(
                subField => mapStructType(subField.mode, subField.name, subField.`type`, subField.fields, false))),isNullable(si.mode))
              )
            // hive-types
            case _ =>
              structType.add(si.name, getFieldType(si.`type`, false), isNullable(si.mode))
          }
        }
      }
    } catch {
      case e: Exception => throw new EmfFieldTypeException(s"Unexpected error found when transform Schema ${schema} to StructField", e)
    }
    structType
  }

  def mapStructType(mode: Option[String], name: String, `type`: String, subfields: Option[List[SchemaItem]], timeStampDateAsString: Boolean) : StructField = {
    `type`.toLowerCase match {
      case "record" | "struct" =>
        if (mode.getOrElse("").equalsIgnoreCase("repeated")) {
          StructField(name.toLowerCase, ArrayType(StructType(subfields.getOrElse(List[SchemaItem]())
            .map(
              subField => mapStructType(subField.mode, subField.name, subField.`type`, subField.fields, timeStampDateAsString)))), isNullable(mode))
        }
        else {
          StructField(name.toLowerCase, StructType(subfields.getOrElse(List[SchemaItem]())
            .map(
              subField => mapStructType(subField.mode, subField.name, subField.`type`, subField.fields, timeStampDateAsString))), isNullable(mode))
        }
      case _ =>
        if (mode.getOrElse("").equalsIgnoreCase("repeated")) {
          StructField(name.toLowerCase, ArrayType(getFieldType(`type`, timeStampDateAsString)), isNullable(mode))
        }
        else {
          StructField(name.toLowerCase, getFieldType(`type`, timeStampDateAsString), isNullable(mode))
        }
    }
  }

  def checkSchemaContainTimestampOrDate(fileTypeSchemaItems: List[SchemaItem]): Boolean ={
    var result=false
    fileTypeSchemaItems.foreach { f =>
      if (f.`type`.equalsIgnoreCase("TIMESTAMP")
        | f.`type`.equalsIgnoreCase("DATETIME")
        | f.`type`.equalsIgnoreCase("DATE")) {
        result = true
        return  result
      }
      else if (f.`type`.equalsIgnoreCase("RECORD")) {
        f.fields match {
          case Some(subfields) => result = checkSchemaContainTimestampOrDate(subfields)
          case None => None
        }
      }
    }
    result
  }

  def isNullable(mode: Option[String]): Boolean = {
    mode.getOrElse("").toLowerCase match {
      case "required" => false
      case _ => true
    }
  }

  def createDecimalType(fieldDecType: String): DecimalType = {
    if (fieldDecType.equals("decimal")){
      DecimalType(10, 0)
    } else {
      val precision_scale_str = StringUtils.removeBrackets(
        fieldDecType.toLowerCase.replaceFirst("decimal", ""))
      val precision_scale_list = StringUtils.splitIntoList(precision_scale_str)
      DecimalType(precision_scale_list.head.toInt, precision_scale_list(1).toInt)
    }
  }

  def getFieldType(fieldType: String, timeStampDateAsString: Boolean): DataType = {
    val tokens: Array[String] = fieldType.trim.split("<")
    val typeName = tokens(0)
    typeName.trim.toLowerCase match {
      case "array" => ArrayType(getFieldType(fieldType.substring(fieldType.indexOf("<") + 1, fieldType.length - 1), timeStampDateAsString), false)
      case "map" => MapType(getFieldType(fieldType.substring(fieldType.indexOf("<") + 1, fieldType.indexOf(",")), timeStampDateAsString),
        getFieldType(fieldType.substring(fieldType.indexOf(",") + 1, fieldType.length - 1), timeStampDateAsString),
        false)
      case "binary" => BinaryType
      case "tinyint" | "bytes" => ByteType
      case "smallint" => ShortType
      case "bigint" | "int64" | "long" =>  LongType
      case "string" | "char" | "varchar" => StringType
      case "int" | "integer" => IntegerType
      case "date" => if(timeStampDateAsString) StringType else DateType
      case "float"  => FloatType
      case "double" | "float64" => DoubleType
      case "timestamp" | "datetime" => if(timeStampDateAsString) StringType else TimestampType
      case "time" => LongType
      case "boolean" | "bool" => BooleanType
      case "numeric" | "bignumeric" => DecimalType(38, 9)
      case fieldDecType if fieldDecType.startsWith("decimal") => createDecimalType(fieldDecType)
      case _ =>
        val errorMessage = s"Unsupported field type $fieldType is given to transform to Spark DataTypes"
        throw new EmfFieldTypeException(errorMessage)
    }
  }

  def listAllSchemaFieldsByType(schema: StructType): Seq[String] = {
    def traverse(sType: StructType, prefix: String): Seq[String] = sType.fields.flatMap {
      case StructField(name: String, dataType: StructType, _, _) =>
        traverse(dataType, s"$prefix$name.")
      case StructField(name: String, dataType: ArrayType, _, _) if dataType.elementType.isInstanceOf[StructType] =>
        traverse(dataType.elementType.asInstanceOf[StructType], s"$prefix$name.")
      case field @ StructField(name: String, _, _, _) =>
        Seq(s"$prefix${name}_${field.dataType.typeName}".toLowerCase)
      case _ =>
        Seq.empty[String]
    }
    traverse(schema, "").sorted
  }

  def compareSchema(dfSchema: StructType, loadInfoSchema: Schema): Boolean = {
    val loadInfoStructType = convertSchemaToStructType(loadInfoSchema)
    val loadInfoFieldsSet = listAllSchemaFieldsByType(loadInfoStructType).toSet
    val dfFieldsSet = listAllSchemaFieldsByType(dfSchema).toSet
    loadInfoFieldsSet.equals(dfFieldsSet)
  }


  /***
    *
    * handle the field info, generate the result as a list.
    * The result will be flattened in the outer layer.
    *
    * @param parentName the name inherited by the last call
    * @param fieldlInfo current filed info
    * @return list of (field Name, field Type)
    * */
  private def calFieldInfo(parentName:String, fieldlInfo:Map[String,Any]):List[(String,String)] = {
    var itemName = if (parentName!="") s"${parentName}${SchemaUtility.delimiter}".concat(fieldlInfo("name").asInstanceOf[String]) else fieldlInfo("name").asInstanceOf[String]
    if (fieldlInfo("type").getClass.toString.toLowerCase.contains("collection")) {
      val mapItem = fieldlInfo("type").asInstanceOf[Map[String, Any]]
      val eleType = mapItem.getOrElse("elementType","")
      if (eleType.toString !="") {
        itemName = itemName + delimiter + mapItem("type").asInstanceOf[String]
        if (eleType.getClass.toString.toLowerCase.contains("collection")) {
          return getFields(itemName, mapItem("elementType").asInstanceOf[Map[String, Any]])
        }else {
          return List((itemName,eleType.asInstanceOf[String]))
        }
      }
      val fields = mapItem.getOrElse("fields","")
      if (fields.toString !="") {
        return mapItem("fields").asInstanceOf[List[Map[String,Any]]].flatMap(item => calFieldInfo(itemName, item))
      }
      List.empty
    } else {
      List((itemName, fieldlInfo("type").asInstanceOf[String]))
    }
  }


  /**
    *
    * According to field info, the func will generate the reulst with specific format in a list,
    * also apply to its child items.
    *
    * @param parentName the name inherited by the last call
    * @param fieldInfo current filed info
    * @return list of (field Name, field Type)
    */
  private def getFields(parentName:String, fieldInfo:Map[String, Any]):List[(String,String)] = {
    if( fieldInfo.contains("fields") ) {
      fieldInfo("fields").asInstanceOf[List[Map[String, Any]]].flatMap(f => calFieldInfo(parentName, f))
    } else {
      List.empty
    }
  }

  def getFieldTypeName(fieldType: DataType) : String = {
    fieldType.typeName match {
      case "array" => s"array<${getFieldTypeName(fieldType.asInstanceOf[ArrayType].elementType)}>"
      case "map" =>
        s"map<${getFieldTypeName(fieldType.asInstanceOf[MapType].keyType)},${getFieldTypeName(fieldType.asInstanceOf[MapType].valueType)}>"
      case _ => fieldType.typeName
    }
  }

  /**
    *
    * According to Load Info Schema info,
    * the func will generate the result with specific format in a list, also apply to its child items.
    *
    * @param parentName the name inherited by the last call
    * @param schemaItem current Load Info Schema Item
    * @return list of (field Name, field Type)
    */
  private def getLoadInfoSchemaFields(parentName:String, schemaItem: SchemaItem): List[(String,String)] = {
    var itemName = if (parentName!="") s"${parentName}${SchemaUtility.delimiter}".concat(schemaItem.name) else schemaItem.name
    if (schemaItem.mode.getOrElse("").toUpperCase=="REPEATED")
      itemName= itemName+delimiter + "array"
    if (schemaItem.fields.isDefined && schemaItem.fields.get.nonEmpty) {
      schemaItem.fields.get.flatMap(f => getLoadInfoSchemaFields(itemName, f))
    } else {
      val fieldType: DataType =  getFieldType(schemaItem.`type`, false)
      List(( itemName , getFieldTypeName(fieldType)))
    }
  }


  def compareFields(dfS: List[(String, String)], loadInfoS: List[(String, String)]): Boolean = {
    (dfS.zip(loadInfoS).forall {
      case (x, y) =>
        (x._1.toLowerCase() == y._1.toLowerCase() &&
          (
            if (!x._2.toLowerCase.startsWith("decimal")) {
              x._2.toLowerCase() == y._2.toLowerCase()
            } else {
              x._2.toLowerCase().split("\\(")(0) == y._2.toLowerCase().toLowerCase().split("\\(")(0)
            }
            )
          )
    }
      )
  }

  def getTheCurateFormatBySchema(sourceDF: DataFrame, currentCurateFormat: FileFormatConfig): FileFormatConfig = {
    if (sourceDF.schema.exists(sf => {
      sf.dataType.toString.startsWith("ArrayType")|| sf.dataType.toString.startsWith("StructType") || sf.dataType.equals(DateType)}
    )) {
      OrcFileFormatConfig()
    } else if (currentCurateFormat != null) {
      currentCurateFormat
    } else {
      ParquetFileFormatConfig()
    }
  }

  /**
    * Based on the schema, get all the fields that can be remove the quotes.
    * Add delimiter if it's a complex type.
    * @param schema
    * @param delimiter
    * @return
    */
  def getCanUnquoteFieldNameByType(schema: StructType, delimiter: String = ".") : List[String] = {
    val cleanItems: ListBuffer[String] = new ListBuffer[String]()
    val regex = """StructField\(([^\,]*)\,([^\,]*)\,([^\,]*)\)""".r
    val regexForComplex = """ArrayType\((LongType|DecimalType|BooleanType|LongType|ShortType|IntegerType|FloatType|DoubleType)""".r
    for (sf <- schema) {
      sf.dataType.toString match {
        case "BooleanType" | "LongType" | "ShortType" | "IntegerType" | "FloatType" | "DoubleType" => cleanItems += sf.name
        case "StringType" =>
        case _ =>

          if (sf.dataType.toString.startsWith("DecimalType")) {
            cleanItems += sf.name
          } else {
          if (regexForComplex.findFirstMatchIn(sf.dataType.toString.substring(0,22)).isDefined) {
            cleanItems += "[" + sf.name + "]"
          } else {
            val matchItems = regex.findAllMatchIn(sf.dataType.toString)
            matchItems.foreach(mItem => {
              mItem.group(2) match {
                case "BooleanType" | "LongType" | "ShortType" | "IntegerType" | "FloatType" | "DoubleType" => cleanItems += sf.name + delimiter + mItem.group(1)
                case "ArrayType(BooleanType" | "ArrayType(LongType" |
                     "ArrayType(ShortType" | "ArrayType(IntegerType" |
                     "ArrayType(FloatType" | "ArrayType(DoubleType" =>
                  cleanItems += sf.name + delimiter + "[" + mItem.group(1) + "]"
                case _ =>
              }
            })
          }
        }
      }
    }
    cleanItems.toList
  }


}package hsbc.emf.infrastructure.helper

import hsbc.emf.data.ingestion.{LoadInfoRaw, Schema, SchemaItem}
import hsbc.emf.infrastructure.config.{JsonFileFormatConfig, OrcFileFormatConfig, ParquetFileFormatConfig}
import hsbc.emf.infrastructure.exception.EmfFieldTypeException
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.functions.col
import org.apache.spark.sql.types._

class SchemaUtilityTest extends IntegrationTestSuiteBase {
  "given valid primitive fields" should "return a correct StructType" in {
    val loadInfoRaw = LoadInfoRaw(file_type = s"dummy_file_type", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"},{\"mode\":\"NULLABLE\",\"name\":\"arrayFld\",\"type\":\"RECORD\",\"fields\": [{\"mode\":\"REQUIRED\",\"name\":\"stringFld\",\"type\":\"String\"}] },{\"mode\":\"NULLABLE\",\"name\":\"bigintFld\",\"type\":\"BigInt\"} ]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val structType = SchemaUtility.convertSchemaToStructType(loadInfo.schema)
    assert(structType(0).name.equals("binaryFld") && structType(0).dataType.equals(BooleanType))
    assert(structType(1).name.equals("numericFld") && structType(1).dataType.equals(DecimalType(33, 9)))
    assert(structType(2).name.equals("intFld") && structType(2).dataType.equals(LongType))
    assert(structType(3).name.equals("floatFld") && structType(3).dataType.equals(DoubleType))
    assert(structType(4).name.equals("dateFld") && structType(4).dataType.equals(DateType))
    assert(structType(5).name.equals("datatimeFld") && structType(5).dataType.equals(TimestampType))
    assert(structType(6).name.equals("arrayFld") && structType(6).dataType.toString.contains("ArrayType")) // ArrayType(StructType(StructField(stringFld,StringType,true)),true)
    assert(structType(7).name.equals("bigintFld") && structType(7).dataType.equals(LongType))
  }

  "given valid array fields case 1" should "return a correct StructType" in {
    val loadInfoRaw = LoadInfoRaw(file_type = s"dummy_file_type", schema_json = Some("[{\"mode\":\"NULLABLE\",\"name\":\"arrayFld\",\"type\":\"RECORD\",\"fields\": [] } ]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val structType = SchemaUtility.convertSchemaToStructType(loadInfo.schema)
    assert(structType(0).name.equals("arrayFld") && structType(0).dataType.toString.contains("ArrayType"))
  }

  "given valid array fields case 2" should "return a correct StructType" in {
    val loadInfoRaw = LoadInfoRaw(file_type = s"dummy_file_type", schema_json = Some("[\n{\"type\": \"STRING\", \"name\": \"rule_id\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"rule_expression\", \"mode\": \"NULLABLE\"}, \n{\"fields\": [{\"type\": \"STRING\", \"name\": \"attribute\", \"mode\": \"NULLABLE\"}, {\"type\": \"STRING\", \"name\": \"value\", \"mode\": \"NULLABLE\"}], \"type\": \"RECORD\", \"name\": \"rule_metadata\", \"mode\": \"REPEATED\"}, \n{\"fields\": [{\"type\": \"STRING\", \"name\": \"source_table\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"component_key_expression\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"metric_name\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"alias\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"metric_expression\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"where_condition\", \"mode\": \"NULLABLE\"}, \n{\"type\": \"STRING\", \"name\": \"join_clause\", \"mode\": \"NULLABLE\"}], \"type\": \"RECORD\", \"name\": \"component\", \"mode\": \"REPEATED\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val structType = SchemaUtility.convertSchemaToStructType(loadInfo.schema)

    assert(structType(2).name.equals("rule_metadata") && structType(2).dataType.toString.contains("ArrayType"))
    assert(structType(3).name.equals("component") && structType(3).dataType.toString.contains("ArrayType"))
  }

  "given invalid primitive fields" should "throw EmfFieldTypeException" in {
    val loadInfoRaw = LoadInfoRaw(file_type = s"dummy_file_type", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"DummyType\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val caught = intercept[EmfFieldTypeException] {
      val structType = SchemaUtility.convertSchemaToStructType(loadInfo.schema)
    }
    assert(caught.getMessage.contains(s"Unexpected error found when transform Schema"))
  }

  "compareSchema cases 1 - based on file_type= fotc_rd_consolidated_input_requirements" should "compare successfully" in {
    val fileType = "success_case_test_json001"
    val sourceFormat = "json"
    val schemaJsonString =
      """
        |[{"mode":"REQUIRED","name":"file_type","type":"STRING"},
        |{"mode":"REQUIRED","name":"table_name","type":"STRING"},
        |{"mode":"NULLABLE","name":"created_to","type":"TIMESTAMP"},
        |{"mode":"NULLABLE","name":"created_from","type":"TIMESTAMP"},
        |{"mode":"REQUIRED","name":"latest_only","type":"BOOLEAN"},
        |{"mode":"REQUIRED","name":"min_matches","type":"INT64"},
        |{"mode":"REPEATED","name":"constraints","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"operator","type":"STRING"},
        |   {"mode":"REQUIRED","name":"value","type":"STRING"}
        |   ]},
        |{"mode":"NULLABLE","name":"source_entity_type","type":"STRING"},
        |{"mode":"REPEATED","name":"where_clause","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"operator","type":"STRING"},
        |   {"mode":"REQUIRED","name":"value","type":"STRING"}
        |   ]},
        |{"mode":"REPEATED","name": "site","type":"STRING"},
        |{"mode":"REPEATED","name":"run_group","type":"STRING"},
        |{"mode":"REPEATED","name":"daily_monthly","type":"STRING"},
        |{"mode":"REQUIRED","name":"batch_layer","type":"STRING"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    val res = SchemaUtility.compareSchema(
      StructType(
        List(
          StructField("file_type",StringType,false),
          StructField("table_name",StringType,false),
          StructField("created_to",TimestampType,true),
          StructField("created_from",TimestampType,true),
          StructField("latest_only",BooleanType,false),
          StructField("min_matches",LongType,false),
          StructField("constraints",
            ArrayType(
              StructType(
                List(
                  StructField("attribute",StringType,false),
                  StructField("operator",StringType,false),
                  StructField("value",StringType,false)
                )
              ),true
            ),true),
          StructField("source_entity_type",StringType,true),
          StructField("where_clause",
            ArrayType(
              StructType(
                List(
                  StructField("attribute",StringType,false),
                  StructField("operator",StringType,false),
                  StructField("value",StringType,false)
                )
              ),true
            ),true),
          StructField("site",ArrayType(StringType),false),
          StructField("run_group",ArrayType(StringType),false),
          StructField("daily_monthly",ArrayType(StringType),false),
          StructField("batch_layer",StringType,false)
        )
      ),
      loadInfo.schema
    )
    assert(res)
  }

  "compareSchema cases 2" should "compare successfully" in {
    val fileType = "success_case_test_json002"
    val loadInfoRaw = LoadInfoRaw(file_type = fileType,
      schema = Some("key0:integer, key1:int64,key2:int,key3:float64,key4:float,key5:string,key6:boolean,key7:date,key8:timestamp,key9:bigint,key10:long"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val res = SchemaUtility.compareSchema(
      StructType(
        List(
          StructField("key0",IntegerType,false),
          StructField("key1",LongType,false),
          StructField("key2",IntegerType,false),
          StructField("key3",DoubleType,true),
          StructField("key4",FloatType,true),
          StructField("key5",StringType,true),
          StructField("key6",BooleanType,true),
          StructField("key7",DateType,true),
          StructField("key8",TimestampType,true),
          StructField("key9",LongType, false),
          StructField("key10",LongType, false)
        )
      ),
      loadInfo.schema
    )
    assert(res)
  }

  "compareSchema cases 3" should "return true when schemas match (array)" in {
    val res = SchemaUtility.compareSchema(
      StructType(
        List(
          StructField("rule_id",StringType,true),
          StructField("rule_expression",StringType,true),
          StructField("rule_metadata",
            ArrayType(
              StructType(
                List(
                  StructField("attribute",StringType,true),
                  StructField("value",StringType,true)
                )
              ),true
            ),true),
          StructField("component",
            ArrayType(
              StructType(
                List(
                  StructField("source_table",StringType,true),
                  StructField("component_key_expression",StringType,true),
                  StructField("metric_name",StringType,true),
                  StructField("alias",StringType,true),
                  StructField("metric_expression",StringType,true),
                  StructField("where_condition",StringType,true),
                  StructField("join_clause",StringType,true))
              ),true
            ),true),
          StructField("entity_uuid",StringType,true)
        )
      ),
      Schema(
        List(
          SchemaItem(None, "rule_id", "String", None),
          SchemaItem(None, "rule_expression", "String", None),
          SchemaItem(Some("REPEATED"), "rule_metadata", "RECORD", Option(List(
            SchemaItem(None, "attribute", "String", None),
            SchemaItem(None, "value", "String", None)
          ))
          ),
          SchemaItem(Some("REPEATED"), "component", "RECORD", Option(List(
            SchemaItem(None, "source_table", "String", None),
            SchemaItem(None, "component_key_expression", "String", None),
            SchemaItem(None, "metric_name", "String", None),
            SchemaItem(None, "alias", "String", None),
            SchemaItem(None, "metric_expression", "String", None),
            SchemaItem(None, "where_condition", "String", None),
            SchemaItem(None, "join_clause", "String", None))
          )
          ),
          SchemaItem(None, "entity_uuid", "String", None)
        )
      )
    )
    assert(res)
  }

  "compareSchema cases 4 - multiple level nested array" should "return true when schemas match (complex array)" in {
    val res = SchemaUtility.compareSchema(
      StructType(
        List(
          StructField("rule_id",StringType,true),
          StructField("rule_metadata",
            ArrayType(
              StructType(
                List(
                  StructField("attribute1",StringType,true),
                  StructField("collections1",
                    ArrayType(
                      StructType(
                        List(
                          StructField("attribute2",StringType,true),
                          StructField("collections2",
                            ArrayType(
                              StructType(
                                List(
                                  StructField("attribute3",StringType,true),
                                  StructField("value3",StringType,true)
                                )
                              ),true
                            ),true)
                        )
                      ),true
                    )
                    ,true)
                )
              ),true
            ),true)
        )
      ),
      Schema(
        List(
          SchemaItem(None, "rule_id", "String", None),
          SchemaItem(Some("REPEATED"), "rule_metadata", "RECORD", Option(List(
            SchemaItem(None, "attribute1", "String", None),
            SchemaItem(Some("REPEATED"), "collections1", "RECORD", Option(List(
              SchemaItem(None, "attribute2", "String", None),
              SchemaItem(Some("REPEATED"), "collections2", "RECORD", Option(List(
                SchemaItem(None, "attribute3", "String", None),
                SchemaItem(None, "value3", "String", Option(List()))
              )))
            ))
            ))
          ))
        )
      ))
    assert(res)
  }

  "given valid complex fields" should "return true" in {

    val schemaJsonString = """[{"type": "STRING", "name": "name", "mode": "NULLABLE"},
                             | {"type": "STRING", "name": "name2", "mode": "REPEATED"},
                             | {"fields": [{"type": "STRING", "name": "attribute3", "mode": "NULLABLE"},
                             |             {"type": "STRING", "name": "value3", "mode": "NULLABLE"}],
                             |  "type": "RECORD", "name": "name3", "mode": "NULLABLE"},
                             | {"fields": [{"type": "STRING", "name": "attribute4", "mode": "NULLABLE"},
                             |             {"type": "STRING", "name": "value4", "mode": "NULLABLE"}],
                             | "type": "RECORD", "name": "name4", "mode": "REPEATED"},
                             |  {"fields": [{"type": "STRING", "name": "attribute5", "mode": "NULLABLE"},
                             |			  {"type": "STRING", "name": "value5", "mode": "NULLABLE"},
                             |			  {"fields": [{"type": "STRING", "name": "attribute511", "mode": "NULLABLE"},
                             |						  {"type": "STRING", "name": "value511", "mode": "NULLABLE"}],
                             |			  "type": "RECORD", "name": "value51", "mode": "NULLABLE"}],
                             | "type": "RECORD", "name": "name5", "mode": "REPEATED"},
                             |	{"fields": [{"type": "STRING", "name": "attribute3", "mode": "NULLABLE"},
                             |				{"type": "STRING", "name": "value3", "mode": "NULLABLE"},
                             |					{"fields": [{"type": "STRING", "name": "attribute62", "mode": "NULLABLE"},
                             |								{"type": "STRING", "name": "value62", "mode": "NULLABLE"},
                             |									{"fields": [{"type": "STRING", "name": "attribute6211", "mode": "NULLABLE"},
                             |												{"type": "STRING", "name": "value6211", "mode": "NULLABLE"}],
                             |								"type": "RECORD", "name": "value621", "mode": "NULLABLE"}],
                             |				"type": "RECORD", "name": "name62", "mode": "REPEATED"}],
                             | "type": "RECORD", "name": "name6", "mode": "NULLABLE"}]""".stripMargin

    //below is schemaJsonString.printTreeString of above schema
    """root
      | |-- name: string (nullable = true)
      | |-- name2: array (nullable = true)
      | |    |-- element: string (containsNull = true)
      | |-- name3: struct (nullable = true)
      | |    |-- attribute3: string (nullable = true)
      | |    |-- value3: string (nullable = true)
      | |-- name4: array (nullable = true)
      | |    |-- element: struct (containsNull = true)
      | |    |    |-- attribute4: string (nullable = true)
      | |    |    |-- value4: string (nullable = true)
      | |-- name5: array (nullable = true)
      | |    |-- element: struct (containsNull = true)
      | |    |    |-- attribute5: string (nullable = true)
      | |    |    |-- value5: string (nullable = true)
      | |    |    |-- value51: struct (nullable = true)
      | |    |    |    |-- attribute511: string (nullable = true)
      | |    |    |    |-- value511: string (nullable = true)
      | |-- name6: struct (nullable = true)
      | |    |-- attribute3: string (nullable = true)
      | |    |-- value3: string (nullable = true)
      | |    |-- name62: array (nullable = true)
      | |    |    |-- element: struct (containsNull = true)
      | |    |    |    |-- attribute62: string (nullable = true)
      | |    |    |    |-- value62: string (nullable = true)
      | |    |    |    |-- value621: struct (nullable = true)
      | |    |    |    |    |-- attribute6211: string (nullable = true)
      | |    |    |    |    |-- value6211: string (nullable = true)"""

    val schema = StructType(List(StructField("name2", ArrayType(StringType)), StructField("name", StringType),
      StructField("name3", StructType(List( StructField("value3", StringType), StructField("attribute3", StringType)))),
      StructField("name4", ArrayType(StructType(List(StructField("value4", StringType),
        StructField("attribute4", StringType))))),StructField("name6",
        StructType(List(StructField("attribute3", StringType), StructField("value3", StringType),
          StructField("name62", ArrayType(StructType(List(StructField("value62", StringType),
            StructField("attribute62", StringType), StructField("value621",
              StructType(List(StructField("value6211", StringType), StructField("attribute6211", StringType))))))))))),
      StructField("name5", ArrayType(StructType(List(StructField("value5", StringType),
        StructField("attribute5", StringType), StructField("value51", StructType(List(StructField("value511", StringType),
          StructField("attribute511", StringType)))))))) ))

    val fileType = "successCase6TestJson001"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    assert(SchemaUtility.compareSchema(schema, loadInfo.schema))
  }

  "compareSchema cases 5 - with map and array types" should "return true when schemas match" in {
    val dfSchema = StructType(List(
        StructField("id",StringType,true),
        StructField("map",MapType(IntegerType, ArrayType(StringType, false),true),true),
        StructField("array",ArrayType(MapType(IntegerType, ArrayType(StringType, false),true), true), false)
        )
      )
    val schema = Schema(List(SchemaItem(None, "id", "string"),
       SchemaItem(None, "map", "map<integer,array<string>>"),
       SchemaItem(None, "array", "array<map<integer,array<string>>>")))
    val sType = SchemaUtility.convertSchemaToStructType(schema)
    assert(SchemaUtility.compareSchema(dfSchema, schema))
  }


  "getFieldType case map" should "return MapType" in {
    var mapType: MapType = SchemaUtility.getFieldType("map<string, string>", false).asInstanceOf[MapType]
    assert(mapType.keyType.typeName == "string")
    assert(mapType.valueType.typeName == "string")

    mapType = SchemaUtility.getFieldType("map<string, map<string, string>>", false).asInstanceOf[MapType]
    assert(mapType.keyType.typeName == "string")
    assert(mapType.valueType.asInstanceOf[MapType].keyType.typeName == "string")

    mapType = SchemaUtility.getFieldType("map<string, map<string, array<map<string, string>>>>", false).asInstanceOf[MapType]

    assert(mapType.valueType.asInstanceOf[MapType].valueType.typeName == "array")
    assert(mapType.valueType.asInstanceOf[MapType].valueType.asInstanceOf[ArrayType].elementType.typeName == "map")
  }

  "getFieldType case decimal" should "return DecimalType" in {
    var decimalType: DecimalType = SchemaUtility.getFieldType("decimal", false).asInstanceOf[DecimalType]
    assert(decimalType.typeName == "decimal(10,0)")

    decimalType = SchemaUtility.getFieldType("decimal(20,10)", false).asInstanceOf[DecimalType]
    assert(decimalType.typeName == "decimal(20,10)")

  }

  "getFieldTypeName case " should "return correct type name" in {
    assert(SchemaUtility.getFieldTypeName(StringType) == "string")
    assert(SchemaUtility.getFieldTypeName(LongType) == "long")
    assert(SchemaUtility.getFieldTypeName(DecimalType(20, 10)) == "decimal(20,10)")

    assert(SchemaUtility.getFieldTypeName(ArrayType(ArrayType(StringType))) == "array<array<string>>")

    assert(SchemaUtility.getFieldTypeName(MapType(LongType, MapType(StringType, ArrayType(StringType)))) == "map<long,map<string,array<string>>>")

    assert(SchemaUtility.getFieldTypeName(ArrayType(MapType(IntegerType, ArrayType(StringType)))) == "array<map<integer,array<string>>>")
  }

	"listAllSchemaFieldsByType case " should "list all fields with types" in {
    val dfSchema = StructType(List(
      StructField("id", StringType, true),
      StructField("map", MapType(IntegerType, StringType, true), true)
      ))
    val fieldSeq = SchemaUtility.listAllSchemaFieldsByType(dfSchema)
    assert(Seq("id_string", "map_map").toSet.equals(fieldSeq.toSet))
	}

  "DataFrame with struct type" should "return OrcFileFormatConfig" in {
    import spark.implicits._

    val sample = """{"rule_id":"rule_1","component":{"timestamp3":"2023-01-01 18:00:00.000000 UTC","date3":"2023-05-01","alias":"a","source_table":"test_table_01","component_key_expression":"__uuid","metric_name":"Country_Of_Incorporation","metric_expression":"COALESCE(Country_Of_Incorporation, '')","where_condition":"TRUE"}}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.printSchema()
    assert(SchemaUtility.getTheCurateFormatBySchema(df, ParquetFileFormatConfig()).equals(OrcFileFormatConfig()))
  }

  "DataFrame with array type" should "return OrcFileFormatConfig" in {
    import spark.implicits._

    val sample = """{"rule_id":"rule_1","component":[{"timestamp3":"2023-01-01 18:00:00.000000 UTC","date3":"2023-05-01","alias":"a","source_table":"test_table_01","component_key_expression":"__uuid","metric_name":"Country_Of_Incorporation","metric_expression":"COALESCE(Country_Of_Incorporation, '')","where_condition":"TRUE"},{"alias":"b","source_table":"test_table_02","component_key_expression":"__uuid","metric_name":"Country_Of_Incorporation","metric_expression":"COALESCE(Country_Of_Incorporation, '')","where_condition":"TRUE"}]}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.printSchema()
    assert(SchemaUtility.getTheCurateFormatBySchema(df, ParquetFileFormatConfig()).equals(OrcFileFormatConfig()))
  }

  "DataFrame with date type" should "return OrcFileFormatConfig" in {
    import spark.implicits._

    val sample = """{"rule_id":"rule_2","date3":"2023-05-01"}"""
    var df = spark.read.json(Seq(sample).toDS())
    df = df.withColumn("date3", col("date3").cast("date"))
    df.printSchema()
    assert(SchemaUtility.getTheCurateFormatBySchema(df, ParquetFileFormatConfig()).equals(OrcFileFormatConfig()))
  }

  "DataFrame with common type" should "return ParquetFileFormatConfig" in {
    import spark.implicits._

    val sample = """{"rule_id":"rule_2","date3":"2023-05-01"}"""
    val df = spark.read.json(Seq(sample).toDS())
    assert(SchemaUtility.getTheCurateFormatBySchema(df, JsonFileFormatConfig()).equals(JsonFileFormatConfig()))
    assert(SchemaUtility.getTheCurateFormatBySchema(df, null).equals(ParquetFileFormatConfig()))
  }

  "get Can Unquote Field Name ByType case " should "return correct field name" in {

    val delimiter = "."
    val schema = StructType(List(
      StructField("binary_type", BooleanType),
      StructField("string_type", StringType),
      StructField("long_type", LongType),
      StructField("short_type", ShortType),
      StructField("integer_type", IntegerType),
      StructField("double_type", DoubleType),
      StructField("array_binary_type", ArrayType(BooleanType)),
      StructField("array_string_type", ArrayType(StringType)),
      StructField("array_long_type", ArrayType(LongType)),
      StructField("array_short_type", ArrayType(ShortType)),
      StructField("array_integer_type", ArrayType(IntegerType)),
      StructField("array_double_type", ArrayType(DoubleType)),
      StructField("array_struct_type", ArrayType(StructType( List(
          StructField("array_struct_string_type", StringType),
          StructField("array_struct_long_type", LongType),
          StructField("array_struct_binary_type", LongType)
      )))),
      StructField("struct_type", StructType( List(
          StructField("struct_string_type", StringType),
          StructField("struct_long_type", LongType))))

    ))

    val list = SchemaUtility.getCanUnquoteFieldNameByType(schema, delimiter)
    assert(list.toSet.diff(Set("binary_type","long_type","short_type","integer_type","double_type","[array_binary_type]","[array_long_type]","[array_short_type]","[array_integer_type]","[array_double_type]","array_struct_type.array_struct_long_type","array_struct_type.array_struct_binary_type","struct_type.struct_long_type")).isEmpty)

  }

}
package hsbc.emf.data.logging

sealed trait Severity

//TODO: Think these should be objects
final case class Debug() extends Severity

final case class Info() extends Severity

final case class Warning() extends Severity

final case class Error() extends Severity

final case class Fatal() extends Severity

//TODO: make this better (i.e. get rid of it
object Severity {
  def apply(severityString: String): Severity =
    severityString.toLowerCase() match {
      case "debug" => Debug()
      case "info" => Info()
      case "warning" => Warning()
      case "error" => Error()
      case "fatal" => Fatal()
      case x => throw new NotImplementedError(s"No log level associated with string $x")
    }

}
package hsbc.emf.infrastructure.serde

import hsbc.emf.data.logging._
import org.json4s.CustomSerializer
import org.json4s.JsonAST.{JNull, JString}

object SeveritySerializer extends CustomSerializer[Severity](format => (
  {
    case JString(severity) => severity match {
      case "Debug" => Debug()
      case "Info" => Info()
      case "Warning" => Warning()
      case "Error" => Error()
      case "Fatal" => Fatal()
    }
    case JNull => null
  },
  {
    case severity: Severity => JString(severity.getClass.getSimpleName.replace("$", ""))
  }
))
package hsbc.emf.data

import org.apache.spark.sql.types._

// cover all spark field types listed in https://spark.apache.org/docs/2.4.5/sql-reference.html#data-types
case class SparkAllDataType(
                             ID: String,
                             ByteType_Field: Byte = 0,
                             ShortType_Field: Short = 0,
                             IntegerType_Field: Int = 0,
                             LongType_Field: Long = 0,
                             FloatType_Field: Float = 0,
                             DoubleType_Field: Double = 0,
                             DecimalType_Field: java.math.BigDecimal = null,
                             StringType_Field: String = null,
                             // Notice: CSV Reader - Unsupported type: binary
                             BinaryType_Field: Array[Byte] = null,
                             BooleanType_Field: Boolean = true,
                             TimestampType_Field: java.sql.Timestamp = null,
                             DateType_Field: java.sql.Date = null,
                             // Notice: org.apache.spark.sql.AnalysisException: CSV data source does not support array<string> data type
                             ArrayType_Field: scala.collection.Seq[String] = null,
                             // Notice: org.apache.spark.sql.AnalysisException: CSV data source does not support map<int,string> data type.;
                             MapType_Field: scala.collection.Map[Int, String] = null
                           )

object SparkAllDataType {
  val schema = StructType(
    StructField("ID", StringType, false) ::
      StructField("ByteType_Field", ByteType, true) ::
      StructField("ShortType_Field", ShortType, true) ::
      StructField("IntegerType_Field", IntegerType, true) ::
      StructField("LongType_Field", LongType, true) ::
      StructField("FloatType_Field", FloatType, true) ::
      StructField("DoubleType_Field", DoubleType, true) ::
      StructField("DecimalType_Field", DecimalType(38, 18), true) ::
      StructField("StringType_Field", StringType, true) ::
      // Notice: CSV Reader - Unsupported type: binary
      StructField("BinaryType_Field", BinaryType, true) ::
      StructField("BooleanType_Field", BooleanType, true) ::
      StructField("TimestampType_Field", TimestampType, true) ::
      StructField("DateType_Field", DateType, true) ::
      StructField("ArrayType_Field", ArrayType(StringType, true), true) ::
      StructField("MapType_Field", MapType(IntegerType, StringType), true) ::
      StructField("StructType_Field", StructType(List(
        StructField("Field1", StringType, true),
        StructField("Field2", IntegerType, true)
      )), true)
      :: Nil)
}

// cover all spark field types listed (CSV does not support subfield of types) in https://spark.apache.org/docs/2.4.5/sql-reference.html#data-types
case class SparkCSVAllDataType(
                                ID: String,
                                ByteType_Field: Byte = 0,
                                ShortType_Field: Short = 0,
                                IntegerType_Field: Int = 0,
                                LongType_Field: Long = 0,
                                FloatType_Field: Float = 0,
                                DoubleType_Field: Double = 0,
                                DecimalType_Field: java.math.BigDecimal = null,
                                StringType_Field: String = null,
                                // Notice: CSV Reader - Unsupported type: binary
                                // BinaryType_Field: Array[Byte] = null,
                                BooleanType_Field: Boolean = true,
                                TimestampType_Field: java.sql.Timestamp = null,
                                DateType_Field: java.sql.Date = null
                                // Notice: org.apache.spark.sql.AnalysisException: CSV data source does not support array<string> data type
                                // ArrayType_Field: scala.collection.Seq[String] = null,
                                // Notice: org.apache.spark.sql.AnalysisException: CSV data source does not support map<int,string> data type.;
                                // MapType_Field: scala.collection.Map[Int, String] = null
                              )

object SparkCSVAllDataType {
  val schema = StructType(
    StructField("ID", StringType, false) ::
      StructField("ByteType_Field", ByteType, true) ::
      StructField("ShortType_Field", ShortType, true) ::
      StructField("IntegerType_Field", IntegerType, true) ::
      StructField("LongType_Field", LongType, true) ::
      StructField("FloatType_Field", FloatType, true) ::
      StructField("DoubleType_Field", DoubleType, true) ::
      StructField("DecimalType_Field", DecimalType(38, 18), true) ::
      StructField("StringType_Field", StringType, true) ::
      // Notice: CSV Reader - Unsupported type: binary
      //      StructField("BinaryType_Field", BinaryType, true) ::
      StructField("BooleanType_Field", BooleanType, true) ::
      StructField("TimestampType_Field", TimestampType, true) ::
      StructField("DateType_Field", DateType, true)
      // For complex type, refer to https://mungingdata.com/apache-spark/dataframe-schema-structfield-structtype/
      //      StructField("ArrayType_Field", ArrayType(StringType, true), true) ::
      //      StructField("MapType_Field", MapType(IntegerType, StringType), true) ::
      //      StructField("StructType_Field", StructType(List(
      //        StructField("Field1", StringType, true),
      //        StructField("Field2", IntegerType, true)
      //      )), true)
      :: Nil)
}
package hsbc.emf.command

import hsbc.emf.constants._
import hsbc.emf.data.logging._
import hsbc.emf.data.sparkcmdmsg.SparkAssertMessage
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.sqleval.SparkSqlEvalService

import org.apache.spark.sql.SparkSession
import scala.util.{Failure, Success, Try}

import hsbc.emf.infrastructure.logging.audit.ExceptionHandler

class SparkAssert(val assertion: String, val message: String, val logLevel: String = "error")(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo)
  extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    Try {
      val level = Try {
        Severity(logLevel)
      } match {
        case Success(value) => value
        case Failure(e) => throw e
      }
      val assertMessage = SparkAssertMessage(assertion, message, logLevel)
      val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
      if (sparkSqlEvalService.sqlAssert(assertMessage)) {
        EmfLogger.log(level)(s"SparkAssert command executed successfully for query: '$message'")
        Complete
      } else {
        EmfLogger.log(level)(s"SparkAssert command execution failed for query: '$message'")
        Failed
      }
    } match {
      case Success(value) => value
      case Failure(exception) =>
        ExceptionHandler.handle("SparkAssert command execution failed", exception)
        Failed
    }

  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkAssertMessage(assertion: String, message: String, log_level: String= "error") extends ISparkCommandMessage
package hsbc.emf.data.sparkcmdmsg


import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkAssertMessageTest extends IntegrationTestSuiteBase {

  "given json with required fields" should "return message object" in {

    val params = """{"assertion" : "data1", "message": "msgData1"}"""

    val sparkAssertMessage = JsonReader.deserialize[SparkAssertMessage](params).right.get
    assert(sparkAssertMessage.isInstanceOf[SparkAssertMessage])

    //Optional parameters, values not passed in json and default values are set
    assert(sparkAssertMessage.log_level.equals("error"))
  }

  "given json with all fields" should "return message object" in {

    val params = """{"assertion" : "data2", "message": "msgData2","log_level":"debug"}"""

    val sparkAssertMessage = JsonReader.deserialize[SparkAssertMessage](params).right.get
    assert(sparkAssertMessage.isInstanceOf[SparkAssertMessage])

    assert(sparkAssertMessage.assertion.equals("data2"))
    assert(sparkAssertMessage.message.equals("msgData2"))
    assert(sparkAssertMessage.log_level.equals("debug"))

  }
}
package hsbc.emf.command

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.sparkutils.{IntegrationTestSuiteBase, TableUtils}
import org.scalatest.FlatSpec


class SparkAssertTest extends FlatSpec with IntegrationTestSuiteBase{

  import spark.implicits._

  "run(), if the sql query fails and throws an exception" should "fail the command" in {
    val tableName = "sqlAsserTestTabe"
    val testQuery = s"select _col1 from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "error")

    assert(sparkAssert.run()== Failed)
  }

  "run(), if the first column of the returned dataframe is not a boolean." should "fail the command" in {
    val tableName = TableUtils.createTable(Seq((1.0, 1, "something")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "error")

    assert(sparkAssert.run()==Failed)
  }

  "run(),If the LogLevel is not one of  \"debug\", \"info\", \"warning\", \"error\", \"fatal\"\t" should "fail the command" in {
    val tableName =  TableUtils.createTable(Seq((false, 1, "something")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "not a log level")

    assert(sparkAssert.run()==Failed)
  }
  //If the query returns a dataframe of size not equal to one and the log level is "error", "fatal",	return Failed/false
  "run(),If the LogLevel is \"error\" and dataframe has number of rows not equal to one," should "return Failed" in {
    val tableName =  TableUtils.createTable(Seq((false, 1, "something"), (true, 1, "somethingElse")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "error")
    assert(sparkAssert.run() == Failed)
  }

  "run(),If the LogLevel is in \"debug\", \"info\", \"warning\",  and dataframe has number of rows not equal to one," should "return Complete" in {
    val tableName =  TableUtils.createTable(Seq((false, 1, "something"), (true, 1, "somethingElse")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "info")
    assert(sparkAssert.run() == Complete)
  }

  "run(),in other circumstances" should "return Complete" in {
    val tableName =  TableUtils.createTable(Seq((false, 1, "something")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "info")

    assert(sparkAssert.run() == Complete)
   }

  "run(),If the log_level is \"fatal\", and has value false," should "return false" in {
    val tableName =  TableUtils.createTable(Seq((false, 1, "something")))

    val testQuery = s"select * from $tableName"
    val sparkAssert = new SparkAssert(testQuery, "some log message", "fatal")

    assert(sparkAssert.run() == Failed)
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler

import org.apache.spark.sql.SparkSession

class SparkCatalogue(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    Try {
      EmfLogger.info(s"SparkCatalogue command executed successfully")
    } match {
      case Success(_) => Complete
      case Failure(exception) =>
        ExceptionHandler.handle("SparkCatalogue command execution failed", exception)
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true

}
package hsbc.emf.service.ingestion

import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.ingestion.{MetadataEntry, MetadataRaw}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.MessageContext
import hsbc.emf.infrastructure.logging.audit.{AuditLogger, MetadataInfo}
import hsbc.emf.infrastructure.sql.SqlExecutor

import org.apache.spark.sql.{DataFrame, SparkSession}

class SparkCatalougeService(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCatalougeService with MessageContext {

  import spark.implicits._

  def write(metaDataDF: DataFrame, uuid: String): Unit = {
    val metadataEntryList = metaDataDF.as[MetadataEntry].collect().toList
    val fileType = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").first().value

    var metadataRawList = List.empty[MetadataRaw]
    for (entry <- metadataEntryList) {
      val metadataRaw = MetadataRaw(uuid, fileType, new java.sql.Timestamp(System.currentTimeMillis()), entry.attribute, entry.value, entry.data_type, entry.domain, None)
      metadataRawList = metadataRawList :+ metadataRaw
    }

    val catalogueDAO = new CatalogueDAO(new SqlExecutor())
    catalogueDAO.write(metadataRawList)
    //Log audit for Metadata
    metadataRawList.foreach(metadata => {
      val metadataInfo = MetadataInfo(messageInfo, metadata.entity_uuid, metadata.file_type, metadata.attribute, metadata.value, metadata.data_type, metadata.domain, metadata.reporting_date.orNull, metadata.created)
      AuditLogger().audit(metadataInfo)
    })
  }
}
package hsbc.emf.service.loadtablefromfile

import hsbc.emf.constants.Azure
import hsbc.emf.data.ingestion.LoadInfo
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}

import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}

class SparkChunkedStorageService()(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkChunkedStorageService with MessageContext {
  def write(loadInfo: LoadInfo, dataDF: DataFrame, partitions: Long, message: SparkLoadTableFromFileMessage): Unit = {
    try {

      //new SqlExecutor().execute(s"CREATE DATABASE IF NOT EXISTS ${message.dataset_name}")
      val partitionList: List[String] = loadInfo.ingestHierarchy.hierarchy.filter(_ != "entity_uuid")

      val writerService = new DataFrameWriterService(loadInfo.fileFormatConfig)
      // FCCC-10704 Implementation: auto switch to external table if Azure CSP coz it's using load_info.fileFormatConfig to create table in particular format
        writerService.saveDFAsTable(dataDF, message.table_name, Some(message.dataset_name), SaveMode.Append, partitionList, None, Some(true))
    } catch {
      case ex: Exception =>
        EmfLogger.error(s"SparkChunkedStorageService.write failed with error: ${ex.getMessage}")
        throw ex
    }
  }
}
package hsbc.emf.service.loadtablefromfile

import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.service.ingestion.data.DummyFileType
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class SparkChunkedStorageServiceTest extends IntegrationTestSuiteBase with MockFactory {

  import spark.implicits._

  val databaseName = "exampleDB"
  val dummyFileType = "dummyFileType"


  override def beforeAll(): Unit = {
    super.beforeAll()
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists ${databaseName} cascade")
    super.afterAll()
  }
  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
//  "given valid params" should "throw no Exception" in {
//    val msg = SparkLoadTableFromFileMessage("bucket", "filePath", "fileType", "testTable1", s"${databaseName}")
//    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${msg.dataset_name}.db/${msg.table_name}")
//    val loadInfoRaw = LoadInfoRaw(file_type = dummyFileType, schema = Some("fld1:String,fld2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("fld1"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//    val dummyFileTypeObjects = List(DummyFileType("dummy_id_001", 1), DummyFileType("dummy_id_001", 2), DummyFileType("dummy_id_002", 3))
//    val dummyFileTypeDF = dummyFileTypeObjects.toDF
//    new SparkChunkedStorageService().write(loadInfo, dummyFileTypeDF, 1, msg)
//    val dummyFileTypeTableDF = spark.sql(s"select fld1, fld2 from ${msg.dataset_name}.${msg.table_name}")
//    assert(dummyFileTypeDF.except(dummyFileTypeTableDF).isEmpty)
//  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
//  "given valid params and cloud-type equals Azure" should "throw no Exception" in {
//    EmfConfig.cloudType = Azure
//    val msg = SparkLoadTableFromFileMessage("bucket", "filePath", "fileType", "testTable_external", s"${databaseName}")
//    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${msg.dataset_name}.db/${msg.table_name}")
//    val loadInfoRaw = LoadInfoRaw(file_type = dummyFileType, schema = Some("fld1:String,fld2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("fld1"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//    val dummyFileTypeObjects = List(DummyFileType("dummy_id_001", 1), DummyFileType("dummy_id_001", 2), DummyFileType("dummy_id_002", 3))
//    val dummyFileTypeDF = dummyFileTypeObjects.toDF
//    new SparkChunkedStorageService().write(loadInfo, dummyFileTypeDF, 1, msg)
//    val dummyFileTypeTableDF = spark.sql(s"select fld1, fld2 from ${msg.dataset_name}.${msg.table_name}")
//    assert(dummyFileTypeDF.except(dummyFileTypeTableDF).isEmpty)
//    EmfConfig.cloudType = Local
//  }

  "given invalid params" should "throw Exception" in {
    val msg = SparkLoadTableFromFileMessage("bucket", "filePath", "fileType", "testTable2", s"${databaseName}")
    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${msg.dataset_name}.db/${msg.table_name}")
    val loadInfoRaw = LoadInfoRaw(file_type = dummyFileType, schema = Some("fld1:String,fld2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("fld1"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val dummyFileTypeObjects = List(DummyFileType("dummy_id_001", 1), DummyFileType("dummy_id_001", 2), DummyFileType("dummy_id_002", 3))
    val dummyFileTypeDF = dummyFileTypeObjects.toDF
    assertThrows[Exception] {
      new SparkChunkedStorageService().write(null, dummyFileTypeDF, 1, msg)
    }
  }
}
package hsbc.emf.infrastructure.serde

import hsbc.emf.command.SparkCommandAllParameters
import org.json4s.CustomSerializer
import org.json4s.JsonAST._
import org.json4s.jackson.JsonMethods._

object SparkCommandAllParametersSerializer extends CustomSerializer[SparkCommandAllParameters](format => (
  {
    case JObject(List(("paramMap", JObject(paramJson)))) =>
      val params = paramJson map {
        element => {
          val valString = element._2 match {
            case JString(s) => s.toString
            case _ => compact(render(element._2))
          }
          element._1 -> valString
        }
      } toMap
      val parameters = SparkCommandAllParameters(params)
      parameters
  },
  {
    case x: SparkCommandAllParameters =>
      JObject(JField("paramMap", JString(x.paramMap.toString())))
  }
))
package hsbc.emf.command

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters

case class SparkCommandAllParameters(paramMap: Map[String, Any])

/** Utils to support extracting all parameters in the json string into a PlaceholderParameters object.
  * The main method to be used is extractAllParamsAsSelfReplacedPlaceholderParams(String).
  *
  * To cater the scenario that the parameters already contain both placeholders and the replacement values (e.g. a valid scenario
  * is for SparkRun parameters from dim_queue json containing labels parameter with value like "[$site]" and the site parameter
  * is also in the original parameters set), a self-replace is required. This means a PlaceholderParameterisation.insertParams()
  * operation is performed using the original set of parameters.
  *
  * We also expose the self-replacement result as a separate method, i.e. extractAllParamsAsSelfReplacedParamJson(String)
  * because some operations in SparkRun.apply and SparkDagBuilder.buildDag need it.
  *
  * Note that the complex json object will remain as string in PlaceholderParameters, but it is re-rendered in a compact
  * format (e.g. spaces removed). It is due to the implementation of SparkCommandAllParametersSerializer. So the json
  * string will have space differences if replacement happened for complex json object (e.g. array, map).
  */
object SparkCommandAllParamsExtractor {
  def extractAllParamsAsSelfReplacedPlaceholderParams(parametersJsonString: String)(implicit messageInfo: MessageInfo): PlaceholderParameters = {
    try {
      val selfReplacedParamsJson = extractAllParamsAsSelfReplacedParamJson(parametersJsonString) // self-replacement happens within this method call
      val selfReplacedAllParams = JsonReader.deserializeWithCheck[SparkCommandAllParameters](s"""{"paramMap": $selfReplacedParamsJson}""")
      PlaceholderParameters(selfReplacedAllParams.paramMap)
    }
    catch {
      case ex: Exception =>
        EmfLogger.error(s"SparkCommandAllParamsExtractor.extractAllParametersAsSelfReplacedPlaceholderParams(String) failed: ${ex.getMessage}")
        throw ex
    }
  }

  def extractAllParamsAsSelfReplacedParamJson(parametersJsonString: String)(implicit messageInfo: MessageInfo): String = {
    try {
      val allParamsOriginal = JsonReader.deserializeWithCheck[SparkCommandAllParameters](s"""{"paramMap": $parametersJsonString}""")
      val allParamsOriginalPlaceholderParams = PlaceholderParameters(allParamsOriginal.paramMap)
      PlaceholderParameterisation.insertParams(allParamsOriginalPlaceholderParams, parametersJsonString) // self-replacement happens on this line


    }
    catch {
      case ex: Exception =>
        EmfLogger.error(s"SparkCommandAllParamsExtractor.extractAllParametersAsSelfReplacedParamJson(String) failed: ${ex.getMessage}")
        throw ex
    }
  }


}package hsbc.emf.command

import hsbc.emf.infrastructure.logging.MessageContextTestData
import org.scalatest.FlatSpec

class SparkCommandAllParamsExtractorTest extends FlatSpec with MessageContextTestData{

  behavior of "extractAllParamsAsSelfReplacedParamJson"

  it should ", given parameters string without placeholder, return the origin parameter string" in {
    val inputParametersJson = """{"workflow": "main_workflow", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""
    assert(SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedParamJson(inputParametersJson) == inputParametersJson)
  }

  it should ", given parameters string with self-replaceable placeholder, return the self replaced parameter string" in {
    val inputParametersJson = """{"workflow": "main_workflow", "process_tasks_constraints": [], "enabled": ["[$site]"], "site": "HK"}"""
    val expectedOutputParametersJson = """{"workflow": "main_workflow", "process_tasks_constraints": [], "enabled": ["HK"], "site": "HK"}"""
    assert(SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedParamJson(inputParametersJson) == expectedOutputParametersJson)
  }

  it should ". given parameters string with parameter name same as placeholder name, return the origin parameter string" in {
    val inputParametersJson = """{"query": "select * from test_table", "table": "result_table", "target_dataset": "[$target_dataset]"}"""
    assert(SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedParamJson(inputParametersJson) == inputParametersJson)
  }

  behavior of "extractAllParamsAsSelfReplacedPlaceholderParams"

  it should ", given parameters string without placeholder, return the PlaceholderParams containing all parameters " +
    "with original values (complex json object rendered in compact format)" in {
    val inputParametersJson = """{"workflow": "main_workflow", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""
    val outputPlaceholderParams = SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedPlaceholderParams(inputParametersJson)
    assert(outputPlaceholderParams.paramMap.size == 2)
    assert(outputPlaceholderParams.format("workflow") == "main_workflow")
    assert(outputPlaceholderParams.format("process_tasks_constraints") == """[{"attribute":"location","value":"HK"}]""") //note compact format
  }

  it should ", given parameters string with self-replaceable placeholder, return PlaceholderParams containing self replaced values" in {
    val inputParametersJson = """{"workflow": "main_workflow", "process_tasks_constraints": [], "enabled": ["[$site]"], "site": "HK"}"""
    val outputPlaceholderParams = SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedPlaceholderParams(inputParametersJson)
    assert(outputPlaceholderParams.paramMap.size == 4)
    assert(outputPlaceholderParams.format("workflow") == "main_workflow")
    assert(outputPlaceholderParams.format("process_tasks_constraints") == "[]")
    assert(outputPlaceholderParams.format("enabled") == """["HK"]""")
    assert(outputPlaceholderParams.format("site") == "HK")
  }

  it should ", given parameters string with parameter name same as placeholder name, return the PlaceholderParams containing original values" in {
    val inputParametersJson = """{"query": "select * from test_table", "table": "result_table", "target_dataset": "[$target_dataset]"}"""
    val outputPlaceholderParams = SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedPlaceholderParams(inputParametersJson)
    assert(outputPlaceholderParams.paramMap.size == 3)
    assert(outputPlaceholderParams.format("query") == "select * from test_table")
    assert(outputPlaceholderParams.format("table") == "result_table")
    assert(outputPlaceholderParams.format("target_dataset") == """[$target_dataset]""")
  }
}package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.infrastructure.logging.EmfLogger._
import hsbc.emf.dao.ingestion.LoadInfoDAO
import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.sql.SqlExecutor

import org.apache.spark.sql.SparkSession
import hsbc.emf.service.createtable.SparkCreateTableService
import hsbc.emf.data.sparkcmdmsg.SparkCreateTableMessage
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler


class SparkCreateTable(val file_type: String,
                       val target_database: String,
                       val target_table: String,
                       val inject_metadata: Boolean,
                       val adjustable_override:Boolean = false)
                      (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {

    val sparkCreateTableMessage = SparkCreateTableMessage(file_type, target_database, target_table,inject_metadata, adjustable_override)
    val tableExistsCheck = spark.catalog.tableExists(s"$target_database.$target_table")

    if (messageValidate(sparkCreateTableMessage) && !tableExistsCheck) {
      Try {
        val sqlExecutor = new SqlExecutor()
        new SparkCreateTableService(new LoadInfoDAO(sqlExecutor)).createTableFromFileType(file_type, target_database, target_table,inject_metadata, adjustable_override)
        info(s"SparkCreateTable command executed & table created successfully: $target_database.$target_table")
      }
      match {
        case Success(_) => Complete
        case Failure(exception) =>
          ExceptionHandler.handle("SparkCreateTable command execution failed", exception)
          Failed
      }
    }
    else {
      EmfLogger.error(s"SparkCreateTable command failed with error: File_type is required to create new table")
      Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkCreateTableMessage]
    msg.table_name != null && msg.table_name.trim.nonEmpty &&
      msg.dataset_name != null && msg.dataset_name.trim.nonEmpty
    msg.file_type != null && file_type.trim.nonEmpty
  }
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkCreateTableMessage (file_type: String,
                                    dataset_name: String,
                                    table_name: String,
                                    inject_metadata: Boolean = false,
                                    adjustable_override: Boolean = false) extends ISparkCommandMessagepackage hsbc.emf.service.createtable

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.{IngestionHierarchy, Schema, SchemaItem}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.{EmfServiceException, SparkCreateTableServiceException}
import hsbc.emf.infrastructure.helper.{DataFrameValueHandler, SchemaUtility}
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.EmfLogger.info
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import org.apache.spark.sql.types._
import org.apache.spark.sql.{Row, SaveMode, SparkSession}

class SparkCreateTableService(loadInfoDAO: ILoadInfoDAO)
                             (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCreateTableService with MessageContext {

  @throws(classOf[EmfServiceException])
  override def createTableFromFileType(file_type: String,
                                       target_database: String,
                                       target_table: String,
                                       inject_metadata: Boolean,
                                       adjustable_override: Boolean): Unit = {

    try {
      val fileTypeInfo = loadInfoDAO.readByType(file_type)
      fileTypeInfo match {
        case Some(loadInfo) =>

          val schemaWithPartition = getNewSchema(loadInfo.schema, loadInfo.ingestHierarchy)
          var schemaStructType = SchemaUtility.convertSchemaToStructType(schemaWithPartition)
          /**
            * For GBQ-CREATE-TABLE-FROM-FILE-TYPE
            *
            * If inject_metadata(or add_metadata_columns) being false,
            * based on load_info to create table and we should not include
            * (__file_type,__created,__metadata,entity_uuid )column.
            *
            * If the ingest_metadata(or add_metadata_columns) is set as true,
            * that means the table need to has (__file_type,__created,__metadata)
            * with  entity_uuid(normal column).
            *
            * if any additional parition--> normal columns
            **/

          val dynamicFlag: Boolean = loadInfo.dynamicFlag.getOrElse(true)
          if ((inject_metadata) || (!dynamicFlag)) {
            schemaStructType = schemaStructType.add("__file_type", StringType)
              .add("__created", TimestampType)
              .add("__metadata", ArrayType(new StructType()
                .add("attribute", StringType)
                .add("value", StringType)
                .add("data_type", StringType)
                .add("domain", StringType)))
            info(s"inject_metadata is $inject_metadata, will create the table with fields __file_type/__created/__metadata")
          }
          var dataDF = spark.createDataFrame(spark.sparkContext.emptyRDD[Row], schemaStructType)
          if (loadInfo.isAdjustable.getOrElse(false)) {
            if (!adjustable_override) {
              dataDF = DataFrameValueHandler.appendRowUUID(dataDF)
            }
          }
          if ((!inject_metadata) && (dynamicFlag)) {
            dataDF = dataDF.drop("entity_uuid")
            info(s"inject_metadata is $inject_metadata, drop column entity_uuid as this field doen't be used.")
          }
          // FuncSpec[FCCC-8777], it mentions "The target database should ALWAYS be the ZZZ one, so it's temp table in ORC format in Azure"
          // FCCC-10704 Implementation: no change to it as it's intermediate table
          val writerService = new DataFrameWriterService(new OrcFileFormatConfig())
          writerService.saveDFAsTable(dataDF, target_table, Some(target_database), SaveMode.Append, List.empty, None, Some(true), createTableCommandFlow = true)

          info(s"SparkCreateTableService completed & table created successfully: $target_database.$target_table")

        case None =>
          val error_message = s"SparkCreateTableService failed with error: ${file_type} not found in loadInfo"
          throw new SparkCreateTableServiceException(error_message, None.orNull)
      }
    }
    catch {
      case ex: Exception =>
        EmfLogger.error(s"SparkCreateTableService failed to execute with error: ${ex.getMessage}")
        throw new SparkCreateTableServiceException("SparkCreateTableService failed to execute", ex)
    }
  }

  def getNewSchema(schema: Schema, ingestionHierarchy: IngestionHierarchy): Schema = {
    var schemaItems: List[SchemaItem] = schema.schema
    ingestionHierarchy.hierarchy.foreach {
      hierarchyItem =>
        if (!schemaItems.exists { item => item.name.toLowerCase() == hierarchyItem.toLowerCase() }) {
          schemaItems :+= SchemaItem(None, hierarchyItem, "String", None)
        }
    }
    if (!schemaItems.exists { item => item.name.toLowerCase() == "entity_uuid" }) {
      schemaItems :+= SchemaItem(None, "entity_uuid", "String", None)
    }
    Schema(schemaItems)
  }

}
package hsbc.emf.command

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.types._
import org.scalatest.FlatSpec


class SparkCreateTableTest extends FlatSpec with IntegrationTestSuiteBase {

  import spark.implicits._

  val testInputDb = "test_input_db"
  val testInputTable = "test_input_table"
  val testInputTable2 = "test_input_table2"
  val testInputTable3 = "test_input_table3"
  val testInputTableAdjustable = "test_input_table_adjustable"
  val testInputTableDecimal = "test_input_table_decimal"
  val testFileType = "test_type"
  val testFileType2 = "test_type2"
  val testFileTypeAdjustable = "test_type_adjustable"
  val testFileTypeIngestMetadata = "test_create_ingest_metadata"
  val testFileTypeIngestMetadataHierarchy = "test_create_ingest_metadata_hier"
  val testFileTypeDecimal = "test_type_decimal"
  val testFileTypeIngestMetadata1 = "test_create_ingest_metadata1"
  val testFileTypeIngestMetadata2 = "test_create_ingest_metadata2"
  val testFileTypeIngestMetadata3 = "test_create_ingest_metadata3"

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists $testInputDb")
    val sample = """[{"key": 10, "value": "ten", "test_value": "test"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testInputDb.$testInputTable")

    val loadInfoRawList = List(
      LoadInfoRaw(file_type = testFileType,
        schema = Some("key:Long,value:String"),
        extension = Some("parquet"),
        ingest_hierarchy = Some("test_value"),
        ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
        max_bad_records = Some("1")),
      LoadInfoRaw(file_type = testFileType2,
        schema = Some("key:Long,value:String, test_value:String"),
        extension = Some("parquet"),
        ingest_hierarchy = Some("test_value"),
        ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
        max_bad_records = Some("1")),
      LoadInfoRaw(file_type = testFileTypeDecimal,
        schema = Some("idField:Long, decimalField:decimal(38,9), stringField:String"),
        extension = Some("parquet"),
        ingest_hierarchy = Some("stringField"),
        ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
        max_bad_records = Some("1")),
      LoadInfoRaw(file_type = testFileTypeAdjustable,
        schema = Some("key:Long,value:String"),
        extension = Some("parquet"),
        ingest_hierarchy = Some("test_value"),
        ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
        max_bad_records = Some("1")),
      LoadInfoRaw(
        file_type = s"$testFileTypeIngestMetadata",
        schema = Some("my_date:DATE,weekday:STRING"),
        ingest_hierarchy = None,
        ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
        max_bad_records = Some("1")
      ),
      LoadInfoRaw(
        file_type = s"$testFileTypeIngestMetadataHierarchy",
        schema = Some("my_date:DATE,weekday:STRING,weekday_number:BIGINT"),
        ingest_hierarchy = Some("weekday_number"),
        ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
        max_bad_records = Some("1")
      ),
      LoadInfoRaw(
        file_type = s"$testFileTypeIngestMetadata1",
        schema = Some("my_date:DATE,weekday:STRING"),
        ingest_hierarchy = None,
        ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
        dynamic_flag = Some(false),
        max_bad_records = Some("1")
      ),
      LoadInfoRaw(
        file_type = s"$testFileTypeIngestMetadata2",
        schema = Some("my_date:DATE,weekday:STRING"),
        ingest_hierarchy = None,
        ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
        dynamic_flag = None,
        max_bad_records = Some("1")
      ),
      LoadInfoRaw(
        file_type = s"$testFileTypeIngestMetadata3",
        schema = Some("my_date:DATE,weekday:STRING"),
        ingest_hierarchy = None,
        ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
        dynamic_flag = Some(true),
        max_bad_records = Some("1")
      )
    )
    loadInfoRawList.toDF().write.mode("overwrite").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS $testInputDb CASCADE ")
    super.afterAll()
  }

  "run(), if the table already exists" should "throw the exception" in {
    val existingTableCheck = new SparkCreateTable(s"$testFileType", s"$testInputDb", s"$testInputTable",false)
    assert(existingTableCheck.run() == Failed)
  }

  "run(), if file type not provided" should "throw the exception" in {
    val fileTypeNotProvidedCheck = new SparkCreateTable(" ", s"$testInputDb", s"$testInputTable2",false)
    assert(fileTypeNotProvidedCheck.run() == Failed)
  }

  "run(), if all input parameters provided" should "create table & complete the process" in {
    val testSparkCreateTable = new SparkCreateTable(s"$testFileType", s"$testInputDb", s"$testInputTable2",false)
    assert(testSparkCreateTable.run() == Complete)
    val df2 = spark.read.table(s"$testInputDb.$testInputTable2")
    assert(df2.count == 0)
    val df = spark.read.table(s"$testInputDb.$testInputTable")
    assert(df.schema.sortBy(_.name) == df2.schema.sortBy(_.name))
    val testSparkCreateTable2 = new SparkCreateTable(s"$testFileType2", s"$testInputDb", s"$testInputTable3",false)
    assert(testSparkCreateTable2.run() == Complete)
  }

  "run(), if all input parameters provided - adjustable file_type" should "create table & complete the process" in {
    val testSparkCreateTable = new SparkCreateTable(s"$testFileTypeAdjustable", s"$testInputDb", s"$testInputTableAdjustable",false)
    assert(testSparkCreateTable.run() == Complete)
    val df = spark.read.table(s"$testInputDb.$testInputTableAdjustable")
    assert(df.count == 0)
    assert(df.schema.fieldIndex("__uuid") > 0)
  }

  "FCCC-10840: given a load_info.schema with decimal(38,9) field" should "table is created successfully" in {
    // 1. call the command to create the table
    val testSparkCreateTable = new SparkCreateTable(s"$testFileTypeDecimal", s"$testInputDb", s"$testInputTableDecimal",false)
    // 2. assertion: verify the command execution result
    assert(testSparkCreateTable.run() == Complete)
    val emptyTableDF = spark.read.table(s"$testInputDb.$testInputTableDecimal")
    // 3. assertion: verify if table is empty
    assert(emptyTableDF.count == 0)
    // 4. assertion: verify the created table matches field name and field type given in load_info.schema
    val schemaFields = emptyTableDF.schema.fields
    assert("idField".equals(schemaFields(0).name) && LongType.equals(schemaFields(0).dataType))
    assert("decimalField".equals(schemaFields(1).name) && DecimalType(38, 9).equals(schemaFields(1).dataType))
    assert("stringField".equals(schemaFields(2).name) && StringType.equals(schemaFields(2).dataType))
  }
  "If ingest_metadata is ture" should "create the table with entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata,targetDB,testFileTypeIngestMetadata, true).run()
    val resultDF=spark.table(testFileTypeIngestMetadata)
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
    assert(resultDF.schema.fieldIndex("__uuid")  >0)

  }
  "If ingest_metadata is false" should "create the table without entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.$testFileTypeIngestMetadata")
    new SparkCreateTable(testFileTypeIngestMetadata,testInputDb,testFileTypeIngestMetadata, false).run()
    val resultDF=spark.table(s"$testInputDb.$testFileTypeIngestMetadata")
    assert(resultDF.columns.length == 3 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday")  >0)
    assert(resultDF.schema.fieldIndex("__uuid") >0)

  }
  "If ingest_metadata is true and IngestionHierarchy has value " should "create the table with weekday_number/entity_uuid/__file_type/__created/__metadata and has partition_field as normal table " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadataHierarchy}")
    // schema = Some("my_date:DATE,weekday:STRING,weekday_number:BIGINT"),
    new SparkCreateTable(testFileTypeIngestMetadataHierarchy,testInputDb,testFileTypeIngestMetadataHierarchy, true).run()
    val resultDF=spark.table(s"$testInputDb.$testFileTypeIngestMetadataHierarchy")
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("weekday_number")  >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type") >0)
    assert(resultDF.schema.fieldIndex("__created") >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
  }
  "If ingest_metadata is false and IngestionHierarchy has value " should "create the table without entity_uuid/__file_type/__created/__metadata and has partition_field as normal table " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.$testFileTypeIngestMetadataHierarchy")
    // schema = Some("my_date:DATE,weekday:STRING,weekday_number:BIGINT"),
    new SparkCreateTable(testFileTypeIngestMetadataHierarchy,testInputDb,testFileTypeIngestMetadataHierarchy, false).run()
    val resultDF=spark.table(s"$testInputDb.$testFileTypeIngestMetadataHierarchy")
    assert(resultDF.columns.length == 3 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") == 1)
    assert(resultDF.schema.fieldIndex("weekday_number") == 2)
  }
  "If ingest_metadata is false and dynamic_flag is false " should "create the table with entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata1}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata1,targetDB,testFileTypeIngestMetadata1, false).run()
    val resultDF=spark.table(testFileTypeIngestMetadata1)
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
    assert(resultDF.schema.fieldIndex("__uuid")  >0)
  }
  "If ingest_metadata is false and dynamic_flag is true " should "create the table with entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata2}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata2,targetDB,testFileTypeIngestMetadata2, false).run()
    val resultDF=spark.table(testFileTypeIngestMetadata2)
    assert(resultDF.columns.length == 3 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday")  >0)
    assert(resultDF.schema.fieldIndex("__uuid") >0)
  }
  "If ingest_metadata is true and dynamic_flag is true " should "create the table with entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata3}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata3,targetDB,testFileTypeIngestMetadata3, true).run()
    val resultDF=spark.table(testFileTypeIngestMetadata3)
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
    assert(resultDF.schema.fieldIndex("__uuid")  >0)
  }
  "If ingest_metadata is true and dynamic_flag is false " should "create the table with entity_uuid/__file_type/__created/__metadata " in {
    val targetDB="default"
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata1}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata1,targetDB,testFileTypeIngestMetadata1, true).run()
    val resultDF=spark.table(testFileTypeIngestMetadata1)
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
    assert(resultDF.schema.fieldIndex("__uuid")  >0)
  }
  "If adjustable_override is true " should "create the table with out __uuid " in {
    val targetDB=testInputDb
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata1}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata1,targetDB,testFileTypeIngestMetadata1, true, true).run()
    val resultDF=spark.table(s"$testInputDb.$testFileTypeIngestMetadata1")
    assert(resultDF.columns.length == 6 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
  }
  "If adjustable_override is false " should "create the table with __uuid " in {
    val targetDB=testInputDb
    spark.sql(s" drop table if exists $testInputDb.${testFileTypeIngestMetadata1}")
    // schema = Some("my_date:DATE,weekday:STRING"),
    new SparkCreateTable(testFileTypeIngestMetadata1,targetDB,testFileTypeIngestMetadata1, true,false).run()
    val resultDF=spark.table(s"$testInputDb.$testFileTypeIngestMetadata1")
    assert(resultDF.columns.length == 7 )
    assert(resultDF.schema.fieldIndex("my_date") == 0)
    assert(resultDF.schema.fieldIndex("weekday") >0)
    assert(resultDF.schema.fieldIndex("entity_uuid") >0)
    assert(resultDF.schema.fieldIndex("__file_type")  >0)
    assert(resultDF.schema.fieldIndex("__created")  >0)
    assert(resultDF.schema.fieldIndex("__metadata")  >0)
    assert(resultDF.schema.fieldIndex("__uuid")  >0)
  }
}
package hsbc.emf.service.crm.calculators

import hsbc.emf.data.crm.{Approach, FOU}
import scala.collection.mutable.Map

object SparkCrmCalculationFunctions {

  def calculatePreviousExposure(expKey: String, exposureValues: Map[String, Double], expOriginalExposure: Double): Double = {
    if (exposureValues.contains(expKey))
      exposureValues.get(expKey).get
    else
      expOriginalExposure
  }

  def calculatePreviousMitigant(mitKey: String, mitigantValues: Map[String, Double], mitGrossAmount: Double): Double = {
    if (mitigantValues.contains(mitKey))
      mitigantValues.get(mitKey).get
    else
      mitGrossAmount
  }

  def exposureCovered(expOriginalExposure: Double, prevExposure: Double): Double = {
    expOriginalExposure - prevExposure
  }

  def calculateCoverageByExposureRatio(expOriginalExposure: Double, prevMitigant: Double, exposureCovered: Double): Double = {
    var cbyeratio = 1.0
    if (expOriginalExposure != 0.0)
      cbyeratio = (prevMitigant + exposureCovered) / expOriginalExposure
    cbyeratio
  }

  def calculateAvailable(relEfficiency: Double, prevMitigant: Double): Double = {
    relEfficiency * prevMitigant
  }

  def calculateEligibleFlag(approach: Approach, relcstar: Double, cbyeratio: Double): String = {
    if (approach == FOU && relcstar > cbyeratio)
      "N"
    else
      "Y"
  }

  def calculateAllocation(approach: Approach, relCstar: Double, cbyeratio: Double, prevExposure: Double, available: Double): Double = {
    if (approach == FOU && relCstar > cbyeratio)
      return 0
    else
      prevExposure.min(available)
  }

  def calculateLeftMitigant(relEfficiency: Double, prevMitigant: Double, allocation: Double): Double = {
    if (relEfficiency == 0)
      prevMitigant
    else
      prevMitigant - allocation / relEfficiency
  }

  def calculateLeftExposure(prevExposure: Double, allocation: Double): Double = {
    prevExposure - allocation
  }

  def calculateComment(allocation: Double, eligibleFlag: String, leftExposure: Double): Option[String] = {
    if (allocation != 0)
      None
    else if (eligibleFlag == 'N')
      Some("Collateral not eligible")
    else if (leftExposure == 0)
      Some("Exposure fully covered")
    else
      Some("Collateral fully allocated")
  }

  def calculateUnsecuredExposureCovered(expOriginalExposure: Double, exposureValues: Map[String, Double], expKey: String): Double = {
    expOriginalExposure - exposureValues.get(expKey).get
  }
}
package hsbc.emf.service.crm.calculators

import hsbc.emf.data.crm.{Approach, CrmInput, CrmOutput, Exposure}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.logging.EmfLogger
import org.apache.spark.sql.SparkSession

import scala.collection.mutable.{ListBuffer, Map}

class SparkCrmCalculator(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCrmCalculator {

  var order: Int = 0
  var exposureObjects = Map[String, Exposure]()
  var exposureValues = Map[String, Double]()
  var mitigantValues = Map[String, Double]()

  var crmSecuredOutputsList = new ListBuffer[CrmOutput]()

  def calculate(approach: Approach, crmInputsList: List[CrmInput]): List[CrmOutput] = {

    EmfLogger.info(" SparkCrmCalculator.calculate command calculating secured values")
    for (crmInput <- crmInputsList) {

      val crmOutput: CrmOutput = SparkCrmSecuredCalculation.run(approach, order, exposureObjects, exposureValues, mitigantValues, crmInput)
      crmSecuredOutputsList += crmOutput
      order += 1
    }
    EmfLogger.info(" SparkCrmCalculator.calculate command calculating unsecured values")
    val crmUnSecuredOutputsList = SparkCrmUnsecuredCalculation.run(approach, order, exposureObjects, exposureValues)
    crmSecuredOutputsList.toList ++ crmUnSecuredOutputsList
  }
}
package hsbc.emf.service.crm


import hsbc.emf.data.crm._
import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.infrastructure.io.readers.CsvFileReaderToDF
import hsbc.emf.infrastructure.services.mapper.CrmOutputToCrmOutputRawMapper
import hsbc.emf.service.crm.calculators.SparkCrmCalculator
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.types._
import org.apache.spark.sql.{DataFrame, Dataset, Encoders}

class SparkCrmCalculatorTest extends IntegrationTestSuiteBase {

  val config = CsvFileFormatConfig(delimiter = ",", skipRows = 0)
  val CrmOutputRawEncoder = Encoders.product[CrmOutputRaw]
  val inputSchema = StructType(List(
    StructField("uniqueAccountId", StringType, true),
    StructField("uniqueMitigantId", StringType, true),
    StructField("undrawnFlag", StringType, true),
    StructField("crmPriorityOrderSequenceNumber", StringType, true),
    StructField("creditMitigantValue", DoubleType, true),
    StructField("totalOriginalExposurePreCcf", DoubleType, true),
    StructField("effectiveCrmFactor", DoubleType, true),
    StructField("cstar", DoubleType, true)))

  val outputSchema = StructType(List(
    StructField("Uniq_Account_Id", StringType, true),
    StructField("Uniq_CRM_ID", StringType, true),
    StructField("Undrawn_Flag", StringType, true),
    StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
    StructField("Regulator", StringType, true),
    StructField("PRA_Reporting_Approach_From_CRM_Engine", StringType, true),
    StructField("Adjustment_Flag", StringType, true),
    StructField("Original_Exposure_Covered_USD", DoubleType, true),
    StructField("CbyE_Ratio", DoubleType, true),
    StructField("CRM_Eligible_For_Exposure_Flag", StringType, true),
    StructField("Effective_CRM_Amount_After_Efficiency", DoubleType, true),
    StructField("Effective_CRM_Amount_Allocated_USD", DoubleType, true),
    StructField("Effective_CRM_Amount_Available_USD", DoubleType, true),
    StructField("Original_Exposure_not_covered", DoubleType, true),
    StructField("Comment", StringType, true),
    StructField("Secured_Indicator", StringType, true),
    StructField("Allocation_Order", DoubleType, true)
  ))

  "given CRM Source data with ADV" should "return true" in {

    import spark.implicits._

    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_INPUT_ADV.csv", Some(inputSchema))

    var expectedOutputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_OUTPUT_EXPECTED_ADV.csv", Some(outputSchema))

    val crmInputList: List[CrmInput] = inputDF.as[CrmInput].collect().toList
    val crmOuputList: List[CrmOutput] = new SparkCrmCalculator().calculate(ADV, crmInputList)
    val crmOuputRawList: List[CrmOutputRaw] = CrmOutputToCrmOutputRawMapper.map(crmOuputList)
    val crmOutputs: Dataset[CrmOutputRaw] = spark.createDataset(crmOuputRawList)(CrmOutputRawEncoder)
    val resultDF: DataFrame = crmOutputs.toDF()
    assert(expectedOutputDF.count() == resultDF.count())

    expectedOutputDF = expectedOutputDF.na.fill(0)

    val colNames = Seq("Uniq_Account_Id", "Uniq_CRM_ID", "Undrawn_Flag", "CRM_Priority_Order_Sequence_Number", "Regulator",
      "PRA_Reporting_Approach_From_CRM_Engine", "Adjustment_Flag", "Original_Exposure_Covered_USD", "CbyE_Ratio", "CRM_Eligible_For_Exposure_Flag",
      "Effective_CRM_Amount_After_Efficiency", "Effective_CRM_Amount_Allocated_USD", "Effective_CRM_Amount_Available_USD",
      "Original_Exposure_not_covered", "Comment", "Secured_Indicator", "Allocation_Order")

    val sortedResultDF = resultDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    val sortedExpectedOutputDF = expectedOutputDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    assert(sortedResultDF.except(sortedExpectedOutputDF).isEmpty)
  }

  "given CRM Source data with FOU" should "return true" in {

    import spark.implicits._

    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_INPUT_FOU.csv", Some(inputSchema))

    var expectedOutputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_OUTPUT_EXPECTED_FOU.csv", Some(outputSchema))

    val crmInputList: List[CrmInput] = inputDF.as[CrmInput].collect().toList
    val crmOuputList: List[CrmOutput] = new SparkCrmCalculator().calculate(FOU, crmInputList)
    val crmOuputRawList: List[CrmOutputRaw] = CrmOutputToCrmOutputRawMapper.map(crmOuputList)
    val crmOutputs: Dataset[CrmOutputRaw] = spark.createDataset(crmOuputRawList)(CrmOutputRawEncoder)
    val resultDF: DataFrame = crmOutputs.toDF()
    assert(expectedOutputDF.count() == resultDF.count())

    expectedOutputDF = expectedOutputDF.na.fill(0)

    val colNames = Seq("Uniq_Account_Id", "Uniq_CRM_ID", "Undrawn_Flag", "CRM_Priority_Order_Sequence_Number", "Regulator",
      "PRA_Reporting_Approach_From_CRM_Engine", "Adjustment_Flag", "Original_Exposure_Covered_USD", "CbyE_Ratio", "CRM_Eligible_For_Exposure_Flag",
      "Effective_CRM_Amount_After_Efficiency", "Effective_CRM_Amount_Allocated_USD", "Effective_CRM_Amount_Available_USD",
      "Original_Exposure_not_covered", "Comment", "Secured_Indicator", "Allocation_Order")

    val sortedResultDF = resultDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    val sortedExpectedOutputDF = expectedOutputDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    assert(sortedResultDF.except(sortedExpectedOutputDF).isEmpty)
  }

  "given CRM Source data with STD" should "return true" in {

    import spark.implicits._

    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_INPUT_STD.csv", Some(inputSchema))

    var expectedOutputDF = spark.read.schema(outputSchema).csv("tests/hsbc/emf/testingFiles/" +
      "spark_crm_mockup_data/CRM_OUTPUT_EXPECTED_STD.csv")

    val crmInputList: List[CrmInput] = inputDF.as[CrmInput].collect().toList
    val crmOuputList: List[CrmOutput] = new SparkCrmCalculator().calculate(STD, crmInputList)
    val crmOuputRawList: List[CrmOutputRaw] = CrmOutputToCrmOutputRawMapper.map(crmOuputList)
    val crmOutputs: Dataset[CrmOutputRaw] = spark.createDataset(crmOuputRawList)(CrmOutputRawEncoder)
    var resultDF: DataFrame = crmOutputs.toDF()
    assert(expectedOutputDF.count() == resultDF.count())

    expectedOutputDF = expectedOutputDF.na.fill(0)

    val colNames = Seq("Uniq_Account_Id", "Uniq_CRM_ID", "Undrawn_Flag", "CRM_Priority_Order_Sequence_Number", "Regulator",
      "PRA_Reporting_Approach_From_CRM_Engine", "Adjustment_Flag", "Original_Exposure_Covered_USD", "CbyE_Ratio", "CRM_Eligible_For_Exposure_Flag",
      "Effective_CRM_Amount_After_Efficiency", "Effective_CRM_Amount_Allocated_USD", "Effective_CRM_Amount_Available_USD",
      "Original_Exposure_not_covered", "Comment", "Secured_Indicator", "Allocation_Order")

    val sortedResultDF = resultDF.select(colNames.head, colNames.tail: _*).orderBy("Effective_CRM_Amount_After_Efficiency")
    val sortedExpectedOutputDF = expectedOutputDF.select(colNames.head, colNames.tail: _*).orderBy("Effective_CRM_Amount_After_Efficiency")

    assert(sortedResultDF.except(sortedExpectedOutputDF).isEmpty)
  }
}
package hsbc.emf.service.crm.calculators

import hsbc.emf.data.crm._
import hsbc.emf.data.logging.MessageInfo

import scala.collection.mutable.Map

object SparkCrmSecuredCalculation {
  def run(approach: Approach, order: Int,
          exposureObjects: Map[String, Exposure],
          exposureValues: Map[String, Double],
          mitigantValues: Map[String, Double],
          crmInput: CrmInput)(implicit messageInfo: MessageInfo): CrmOutput = {

    val exposure = Exposure(crmInput.uniqueAccountId + "_" + crmInput.undrawnFlag, crmInput.uniqueAccountId,
      crmInput.undrawnFlag, crmInput.totalOriginalExposurePreCcf)
    val mitigant = Mitigant(crmInput.uniqueMitigantId, crmInput.uniqueMitigantId, crmInput.creditMitigantValue)
    val relation = Relation(crmInput.effectiveCrmFactor, crmInput.crmPriorityOrderSequenceNumber, crmInput.cstar)
    exposureObjects(exposure.key) = exposure

    val prevExposure = SparkCrmCalculationFunctions.calculatePreviousExposure(exposure.key, exposureValues,
      exposure.originalExposure)
    val prevMitigant = SparkCrmCalculationFunctions.calculatePreviousMitigant(mitigant.key, mitigantValues,
      mitigant.grossAmount)
    val exposureCovered = SparkCrmCalculationFunctions.exposureCovered(exposure.originalExposure, prevExposure)
    val coverageByExposureRatio = SparkCrmCalculationFunctions.calculateCoverageByExposureRatio(exposure.originalExposure, prevMitigant,
      exposureCovered)

    val available = SparkCrmCalculationFunctions.calculateAvailable(relation.efficiency, prevMitigant)
    val eligibleFlag = SparkCrmCalculationFunctions.calculateEligibleFlag(approach, relation.cstar, coverageByExposureRatio)

    val allocation = SparkCrmCalculationFunctions.calculateAllocation(approach, relation.cstar, coverageByExposureRatio,
      prevExposure, available)

    val leftMitigant = SparkCrmCalculationFunctions.calculateLeftMitigant(relation.efficiency, prevMitigant, allocation)
    val leftExposure = SparkCrmCalculationFunctions.calculateLeftExposure(prevExposure, allocation)

    mitigantValues(mitigant.key) = leftMitigant
    exposureValues(exposure.key) = leftExposure

    val comment = SparkCrmCalculationFunctions.calculateComment(allocation, eligibleFlag, leftExposure)
    new CrmOutput(exposure.id, Some(mitigant.id), exposure.undrawnFlag, Some(relation.order), None, approach.name
      ,None, exposureCovered, Some(coverageByExposureRatio), eligibleFlag, available, allocation, Some(leftMitigant),
      Some(leftExposure), comment, "Secured", order)
  }
}
package hsbc.emf.service.crm

import hsbc.emf.data.crm.CrmInput
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRwaCrmMessage
import hsbc.emf.infrastructure.exception.SparkCrmServiceException
import hsbc.emf.infrastructure.io.readers.CrmDataReader
import hsbc.emf.infrastructure.io.writers.CrmDataWriter
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.service.crm.calculators.SparkCrmCalculator
import org.apache.spark.sql.SparkSession

import scala.util.{Failure, Success, Try}

class SparkCrmService
(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCrmService {
  def calculate(message: SparkRwaCrmMessage): Unit = {
    Try {
      val crmInputList: List[CrmInput] = new CrmDataReader().getInput(message)
      EmfLogger.debug("SparkCrmService.calculate calling calculate method to get secured and unsecured crm rows")
      val crmOuputList = new SparkCrmCalculator().calculate(message.approach, crmInputList)
      new CrmDataWriter().writeOutput(message.target_dataset, message.target_table, crmOuputList)
    } match {
      case Success(_) =>
        EmfLogger.debug("SparkCrmService.calculate completed calculation for secured and unsecured crm rows")
      case Failure(exception) =>
        val customMessage = s"SparkCrmService.calculate fails to calculate secured and unsecure values with message. Reason : ${exception.getMessage}"
        EmfLogger.error(customMessage)
        throw new SparkCrmServiceException(customMessage, exception)
    }
  }
}package hsbc.emf.service.crm.calculators

import hsbc.emf.data.crm.{Approach, CrmOutput, Exposure}
import hsbc.emf.data.logging.MessageInfo

import scala.collection.mutable.{ListBuffer, Map}

object SparkCrmUnsecuredCalculation {
  def run(
           approach: Approach,
           order: Int,
           exposureObjects: Map[String, Exposure],
           exposureValues: Map[String, Double]
         )(implicit messageInfo: MessageInfo): List[CrmOutput] = {

    var orderUnsecured = order + 1
    var crmUnSecuredOutputsList = new ListBuffer[CrmOutput]()
    for (key <- exposureObjects.keySet) {
      val exposure: Exposure = exposureObjects(key)
      val exposureCovered = SparkCrmCalculationFunctions.calculateUnsecuredExposureCovered(exposure.originalExposure, exposureValues, exposure.key)
      val crmUnSecuredOutput: CrmOutput = new CrmOutput(exposure.id, None, exposure.undrawnFlag, None, None, approach.name, None, exposureCovered, None,
        "Y", exposureValues(exposure.key), exposureValues(exposure.key), None, None,
        Some("Unsecured portion"), "Unsecured", order)

      crmUnSecuredOutputsList += crmUnSecuredOutput
      orderUnsecured += 1
    }
    crmUnSecuredOutputsList.toList
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.LoadInfoDAO
import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkCurateMessage
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.curate.SparkCurateService
import hsbc.emf.service.ingestion.{SparkCatalougeService, SparkCuratedStorageService}

import org.apache.spark.sql.SparkSession

class SparkCurate(val sourceDatabaseName: Option[String],
                  val sourceTableName: String,
                  val fileType: String,
                  val metadata: List[MetadataEntry])
                 (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    val msg = SparkCurateMessage(sourceDatabaseName, sourceTableName, fileType, metadata)
    messageValidate(msg) match {
      case true =>
        val sqlExecutor = new SqlExecutor()
        val service = new SparkCurateService(new SparkCuratedStorageService(),
          new SparkCatalougeService(),
          new LoadInfoDAO(sqlExecutor),
          new HiveRepair())
        Try {
          service.curate(msg)
          EmfLogger.info("SparkCurate command executed successfully")
        } match {
          case Success(_) => Complete
          case Failure(exception) =>
            ExceptionHandler.handle("SparkCurate command execution failed", exception)
            Failed
        }
      case false =>
        EmfLogger.error("SparkCurate command validation failed. source_table_name/file_type should not be empty.")
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkCurateMessage]
    msg.source_table_name != null && msg.source_table_name.trim.nonEmpty &&
      msg.file_type != null && msg.file_type.trim.nonEmpty
  }
}package hsbc.emf.service.ingestion

import hsbc.emf.data.ingestion.{LoadInfo, MetadataEntry}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.{EmfConfig, FileCfsConfig}
import hsbc.emf.infrastructure.exception.EmfPartitionFieldNotFoundException
import hsbc.emf.infrastructure.helper.DataFrameValueHandler
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import org.apache.spark.sql.functions.lit
import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}

import scala.util.control._

class SparkCuratedStorageService()(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCuratedStorageService with MessageContext {

  import spark.implicits._

  def write(loadInfo: LoadInfo, dataDF: DataFrame, metadataDF: DataFrame, uuid: String, mode: SaveMode = SaveMode.Append): Unit = {
    var transformedSourceFileDF = appendPartition(dataDF, metadataDF, loadInfo.ingestHierarchy.hierarchy, uuid)
    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${loadInfo.fileType}.db/${EmfConfig.defaultTableName}")
    val fileCfsConfig = FileCfsConfig(loadInfo.ingestHierarchy.hierarchy, tableCfsLocation)
    val writerService = new DataFrameWriterService(loadInfo.curateFormatConfig)
    writerService.save(transformedSourceFileDF, fileCfsConfig, mode)
  }

  def insert(loadInfo: LoadInfo, dataDF: DataFrame, metadataDF: DataFrame, uuid: String, mode: SaveMode = SaveMode.Append): Unit = {
    val transformedSourceFileDF = appendPartition(dataDF, metadataDF, loadInfo.ingestHierarchy.hierarchy, uuid)
    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${loadInfo.fileType}.db/${EmfConfig.defaultTableName}")
    val writerService = new DataFrameWriterService(loadInfo.curateFormatConfig)

    // FCCC-10908: remove FCCC-10704 Implementation because of the refactory of ISparkCuratedStorageService
    writerService.saveDFIntoTable(transformedSourceFileDF, EmfConfig.defaultTableName, loadInfo.fileType, mode, loadInfo.ingestHierarchy.hierarchy)
  }

  @throws(classOf[EmfPartitionFieldNotFoundException])
  def appendPartition(originalDataDF: DataFrame, metadataDF: DataFrame, hierarchy: List[String], uuid: String): DataFrame = {
    var convertedDF = originalDataDF
    for (partitionFieldName: String <- hierarchy) {
      var foundInSource = false
      val loop = new Breaks
      loop.breakable {
        for (field <- originalDataDF.schema.fields) {
          if (field.name.equalsIgnoreCase(partitionFieldName)) {
            foundInSource = true
            EmfLogger.debug(s"SparkCuratedStorageService.appendPartition: partition field '${partitionFieldName}' exists in source")
            loop.break
          }
        }
      }
      var foundInMetadata = false
      if (!foundInSource) {
        if (partitionFieldName.equalsIgnoreCase(EmfConfig.defaultTablePartition)) {
          convertedDF = convertedDF.withColumn(partitionFieldName, lit(uuid))
          foundInMetadata = true
          EmfLogger.debug(s"SparkCuratedStorageService.appendPartition: partition field '${partitionFieldName}' is uuid, populated with the generated UUID '${uuid}'")
        } else {
          val metadataPartitionFieldDF = metadataDF.as[MetadataEntry].filter(entry => entry.attribute.equalsIgnoreCase(partitionFieldName))
          if (metadataPartitionFieldDF.count > 0) {
            convertedDF = convertedDF.withColumn(partitionFieldName, lit(metadataPartitionFieldDF.head.value))
            foundInMetadata = true
            EmfLogger.debug(s"SparkCuratedStorageService.appendPartition: partition field '${partitionFieldName}' exists in metadata")
          }
        }
      }
      if (!foundInSource && !foundInMetadata) {
        val errorMessage = s"SparkCuratedStorageService.appendPartition: partition field '${partitionFieldName}' does not exist neither in source nor metadata"
        EmfLogger.error(errorMessage)
        throw new EmfPartitionFieldNotFoundException(errorMessage)
      }
    }
    convertedDF
  }
}
package hsbc.emf.service.ingestion

import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.infrastructure.config.{EmfConfig, MetaDataTextFileFormatConfig}
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.io.readers.SparkFileReaderService
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.service.ingestion.data.DummyFileType
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.DataFrame
import org.scalamock.scalatest.MockFactory

class SparkCuratedStorageServiceTest extends IntegrationTestSuiteBase with MockFactory {

  val dummyFileType = "dummyFileType"
  val dummyFileTypeFailure = "dummyFileTypeFailure"

  override def beforeAll(): Unit = {
    super.beforeAll()
    val tableCfsLocation = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${dummyFileType}.db/${EmfConfig.defaultTableName}")
    spark.sql(s"create database if not exists ${dummyFileType}")
    spark.sql(s"create table if not exists ${dummyFileType}.${EmfConfig.defaultTableName} (fld2 Int) partitioned by (fld1 String, entity_uuid String) stored as parquet location '${tableCfsLocation}'")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists ${dummyFileType} cascade")
    super.afterAll()
  }

  import spark.implicits._

  "given valid params" should "throw no Exception" in {
    val uuid: String = generateEntityUUID()

    val loadInfoRaw = LoadInfoRaw(file_type = dummyFileType, schema = Some("fld1:String,fld2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("fld1"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val dummyFileTypeObjects = List(DummyFileType("dummy_id_001", 1), DummyFileType("dummy_id_001", 2), DummyFileType("dummy_id_002", 3))
    val dummyFileTypeDF = dummyFileTypeObjects.toDF
    val metaDataDF: DataFrame = SparkFileReaderService(new MetaDataTextFileFormatConfig).read(new MetaDataTextFileFormatConfig, "tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/success_case1_test_parquet001", None)
    new SparkCuratedStorageService().write(loadInfo, dummyFileTypeDF, metaDataDF, uuid)
    spark.sql(s"MSCK REPAIR TABLE ${dummyFileType}.${EmfConfig.defaultTableName}")
    val dummyFileTypeTableDF = spark.sql(s"select fld1, fld2 from ${dummyFileType}.${EmfConfig.defaultTableName}")

    assert(dummyFileTypeDF.except(dummyFileTypeTableDF).isEmpty)
  }

  "given invalid params" should "throw Exception" in {
    val uuid: String = generateEntityUUID()
    val loadInfoRaw = LoadInfoRaw(file_type = dummyFileTypeFailure, schema = Some("fld1:String,fld2:Int"), extension = Some("parquet"), ingest_hierarchy = Some("fld1"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val dummyFileTypeObjects = List(DummyFileType("dummy_id_001", 1), DummyFileType("dummy_id_001", 2), DummyFileType("dummy_id_002", 3))
    val dummyFileTypeDF = dummyFileTypeObjects.toDF
    try {
      val metaDataDF: DataFrame = SparkFileReaderService(new MetaDataTextFileFormatConfig).read(new MetaDataTextFileFormatConfig, "tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/success_case1_test_parquet001", None)
      new SparkCuratedStorageService().write(loadInfo, dummyFileTypeDF, metaDataDF, null)
      assert(false)
    } catch {
      case e: Throwable => assert(true)
    }
  }
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.ingestion.MetadataEntry


case class SparkCurateMessage(source_dataset_name: Option[String],
                              source_table_name: String,
                              file_type: String,
                              metadata: List[MetadataEntry]) extends ISparkCommandMessage
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage


case class SparkCurateMessageRaw(source_dataset_name: Option[String],
                                 source_table_name: String,
                                 file_type: String,
                                 metadata: Map[String, String]) extends ISparkCommandMessage
package hsbc.emf.service.curate

import java.sql.Timestamp
import java.time.{Instant, LocalDate, ZoneId}
import scala.collection.mutable.ListBuffer
import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion._
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkCurateMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfSchemaValidationException, SparkCurateServiceException}
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.helper.{DataFrameValueHandler, SchemaUtility}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.service.ingestion.{ISparkCatalougeService, ISparkCuratedStorageService}
import org.apache.spark.sql.{SaveMode, SparkSession}
import org.apache.spark.sql.functions.lit

class SparkCurateService(sparkCuratedStorageService: ISparkCuratedStorageService,
                         sparkCatalougeService: ISparkCatalougeService,
                         loadInfoDAO: ILoadInfoDAO,
                         hiveRepair: HiveRepair)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCurateService with MessageContext {

  private def getMetadataRaw(metadata: List[MetadataEntry], uuid: String, file_type: String): List[MetadataRaw] = {
    var metadataRaw = new ListBuffer[MetadataRaw]()
    val date = LocalDate.now()
    val reportedDateTimestamp = Timestamp.from(date.atStartOfDay(ZoneId.systemDefault()).toInstant())
    metadata.foreach {
      entry =>
        metadataRaw += MetadataRaw(uuid, file_type,
          Timestamp.from(Instant.now()),
          entry.attribute,
          entry.value,
          entry.data_type,
          entry.domain,
          Some(reportedDateTimestamp))
    }
    metadataRaw.toList
  }

  private def getTableName(msg: SparkCurateMessage): String = {
    val dbName: String = msg.source_dataset_name.getOrElse("")
    (dbName == null || dbName.trim.isEmpty) match {
      case true =>
        msg.source_table_name
      case false =>
        s"${dbName}.${msg.source_table_name}"
    }
  }

  def getCompareSchema(schema: Schema, ingestionHierarchy: IngestionHierarchy): Schema = {
    var schemaItems: List[SchemaItem] = schema.schema
    if (!schemaItems.exists { item => item.name.toLowerCase() == "entity_uuid" }) {
      schemaItems :+= SchemaItem(None, "entity_uuid", "String", None)
    }
    ingestionHierarchy.hierarchy.foreach {
      hierarchyItem =>
        if (!schemaItems.exists { item => item.name.toLowerCase() == hierarchyItem.toLowerCase() }) {
          schemaItems :+= SchemaItem(None, hierarchyItem, "String", None)
        }
    }
    Schema(schemaItems)
  }

  def curate(msg: SparkCurateMessage): Unit = {
    import spark.implicits._

    try {
      val uuid = generateEntityUUID()
      val loadInfo = loadInfoDAO.readByType(msg.file_type).get
      val dfInput = spark.table(getTableName(msg))
      // Update uuid with newly generated one
      var df = dfInput.withColumn("entity_uuid", lit(uuid))
      if (loadInfo.isAdjustable.getOrElse(false)) {
        df = DataFrameValueHandler.appendRowUUID(df)
      }
      if (!SchemaUtility.compareSchema(df.schema, getCompareSchema(loadInfo.schema, loadInfo.ingestHierarchy))) {
        throw new EmfSchemaValidationException("SparkCurateService.curate Schema validation Failed")
      }

      /**
       * Requirement: "The partition will be overwritten if it existed already"
       * Requirement Reference link: https://alm-confluence.systems.uk.hsbc/confluence/pages/viewpage.action?pageId=635184312
       * PS: it requires spark conf property "spark.sql.sources.partitionOverwriteMode" to be "dynamic"
       */
      // FCCC-10908: remove the hive repair because of the refactory of ISparkCuratedStorageService
      sparkCuratedStorageService.insert(loadInfo, df, msg.metadata.toDF, uuid, SaveMode.Overwrite)

      sparkCatalougeService.write(getMetadataRaw(msg.metadata, uuid, msg.file_type).toDF, uuid)

    } catch {
      case e: Exception =>
        val customMessage = s"SparkCurateService.curate fails with message ${msg}  : ${e.getMessage}"
        EmfLogger.error(customMessage)
        throw e
    }
  }
}
package hsbc.emf.service.curate

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion._
import hsbc.emf.data.sparkcmdmsg.SparkCurateMessage
import hsbc.emf.infrastructure.config.{CsvFileFormatConfig, TextFileFormatConfig}
import hsbc.emf.infrastructure.exception.{SparkCurateServiceException, EmfSchemaValidationException}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.service.ingestion.{ISparkCatalougeService, ISparkCuratedStorageService}
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.DataFrame
import org.scalamock.scalatest.MockFactory
import scala.util.matching.Regex


class SparkCurateServiceTest extends IntegrationTestSuiteBase with MockFactory {

  import spark.implicits._

  val mockLoadInfoDAO = mock[ILoadInfoDAO]
  val mockSparkCuratedStorageService = mock[ISparkCuratedStorageService]
  val mockSparkCatalougeService = mock[ISparkCatalougeService]
  val mockHiveRepair = mock[HiveRepair]
  val uuidRegEx = new Regex("[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}")

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists curate_test_db")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists curate_test_db cascade")
    super.afterAll()
  }

  "SparkCurateServiceTest: given mismatched schema" should "throw EmfSchemaValidationException" in {

    val sample = """[{"entity_uuid": "some_uuid_value","test": "t", "key": "10", "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable("curate_test_db.test_table_1")
    val schema = Schema(List(SchemaItem(Some("m"), "key", "Long", None), SchemaItem(Some("m"), "value", "String", None)))
    val loadInfo = new LoadInfo(fileType = "test_type",
      schema = schema,
      fileFormatConfig = TextFileFormatConfig(),
      curateFormatConfig = CsvFileFormatConfig(),
      ingestHierarchy = IngestionHierarchy(List("test")))
    (mockLoadInfoDAO.readByType _).expects("test_type").returning(Some(loadInfo)).once()

    val msg = new SparkCurateMessage(Some("curate_test_db"), "test_table_1", "test_type", List(MetadataEntry("a", "b", "c", "d")))
    val caught = intercept[EmfSchemaValidationException] {
      (new SparkCurateService(mockSparkCuratedStorageService, mockSparkCatalougeService, mockLoadInfoDAO, mockHiveRepair)).curate(msg)
    }
    assert(caught.getMessage.contains("SparkCurateService.curate Schema validation Failed"))
  }

  "SparkCurateServiceTest: given correct schema" should "not throw Exception" in {

    val sample = """[{"entity_uuid": "some_uuid_value","test": "t", "key": "10", "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable("curate_test_db.test_table_2")
    val schema = Schema(List(SchemaItem(Some("m"), "key", "String", None), SchemaItem(Some("m"), "value", "String", None)))
    val loadInfo = new LoadInfo(fileType = "test_type",
      schema = schema,
      fileFormatConfig = TextFileFormatConfig(),
      curateFormatConfig = CsvFileFormatConfig(),
      ingestHierarchy = IngestionHierarchy(List("test")))
    (mockLoadInfoDAO.readByType _).expects("test_type").returning(Some(loadInfo)).once()

    def assertDf(actualDf: DataFrame): Unit = {
      val uuid = actualDf.select("entity_uuid").as[String].first
      assert(uuidRegEx.findAllIn(uuid).length == 1)
      assert(actualDf.select("test", "key", "value").except(df.select("test", "key", "value")).count == 0)
    }

    def assertMetadata(metadataDf: DataFrame): Unit = {
      assert(metadataDf.count == 1)
      assert(metadataDf.filter(metadataDf("attribute") === "a").count == 1)
      assert(metadataDf.filter(metadataDf("value") === "b").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "d").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "c").count == 0)
    }

    (mockSparkCuratedStorageService.insert _).expects(loadInfo, argAssert(assertDf _), *, *, *).returning(()).once()
    (mockSparkCatalougeService.write _).expects(argAssert(assertMetadata _), *).returning(()).once()
    val msg = new SparkCurateMessage(Some("curate_test_db"), "test_table_2", "test_type", List(MetadataEntry("a", "b", "c", "d")))

    (mockHiveRepair.run _).expects("test_type", EmfConfig.defaultTableName).returning(true).never()
    (new SparkCurateService(mockSparkCuratedStorageService, mockSparkCatalougeService, mockLoadInfoDAO, mockHiveRepair)).curate(msg)

  }

  "SparkCurateServiceTest: given correct schema with different case" should "not throw exception" in {

    val sample = """[{"VALUE": "ten", "entity_uuid": "some_uuid_value","test": "t", "key": "10"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable("curate_test_db.test_table_5")
    val schema = Schema(List(SchemaItem(Some("m"), "key", "String", None), SchemaItem(Some("m"), "value", "String", None)))
    val loadInfo = new LoadInfo(fileType = "test_type",
      schema = schema,
      fileFormatConfig = TextFileFormatConfig(),
      curateFormatConfig = CsvFileFormatConfig(),
      ingestHierarchy = IngestionHierarchy(List("test")))
    (mockLoadInfoDAO.readByType _).expects("test_type").returning(Some(loadInfo)).once()

    def assertDf(actualDf: DataFrame): Unit = {
      val uuid = actualDf.select("entity_uuid").as[String].first
      assert(uuidRegEx.findAllIn(uuid).length == 1)
      assert(actualDf.select("test", "key", "value").except(df.select("test", "key", "value")).count == 0)
    }

    def assertMetadata(metadataDf: DataFrame): Unit = {
      assert(metadataDf.count == 1)
      assert(metadataDf.filter(metadataDf("attribute") === "a").count == 1)
      assert(metadataDf.filter(metadataDf("value") === "b").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "d").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "c").count == 0)
    }

    (mockSparkCuratedStorageService.insert _).expects(loadInfo, argAssert(assertDf _), *, *, *).returning(()).once()
    (mockSparkCatalougeService.write _).expects(argAssert(assertMetadata _), *).returning(()).once()
    val msg = SparkCurateMessage(Some("curate_test_db"), "test_table_5", "test_type", List(MetadataEntry("a", "b", "c", "d")))

    (mockHiveRepair.run _).expects("test_type", EmfConfig.defaultTableName).returning(true).never()
    new SparkCurateService(mockSparkCuratedStorageService, mockSparkCatalougeService, mockLoadInfoDAO, mockHiveRepair).curate(msg)
  }

  "SparkCurateServiceTest: given complex schema" should "not throw Exception" in {
    val sample = """[{"entity_uuid": "some_uuid_value","rule_id": "t", "rule_expression": "10", "rule_metadata": [{"attribute":"a", "value": "b"}], "component": [{"source_table":"table","component_key_expression":"","metric_name":"","alias":"","metric_expression":"","where_condition":"","join_clause":""}]}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable("curate_test_db.test_table_4")
    val schema = Schema(List(
        SchemaItem(Some("m"), "rule_id", "String", None),
        SchemaItem(Some("m"), "rule_expression", "String", None),
        SchemaItem(Some("REPEATED"), "rule_metadata","List",Option(List(
          SchemaItem(Some("m"), "attribute", "String", None),
          SchemaItem(Some("m"), "value", "String", None)
        ))),
        SchemaItem(Some("REPEATED"), "component","List",Option(List(
          SchemaItem(Some("m"), "source_table", "String", None),
          SchemaItem(Some("m"), "component_key_expression", "String", None),
          SchemaItem(Some("m"), "metric_name", "String", None),
          SchemaItem(Some("m"), "alias", "String", None),
          SchemaItem(Some("m"), "metric_expression", "String", None),
          SchemaItem(Some("m"), "where_condition", "String", None),
          SchemaItem(Some("m"), "join_clause", "String", None)
        )))
    ))

    val loadInfo = new LoadInfo(fileType = "test_type",
      schema = schema,
      fileFormatConfig = TextFileFormatConfig(),
      curateFormatConfig = CsvFileFormatConfig(),
      ingestHierarchy = IngestionHierarchy(List())
    )

    (mockLoadInfoDAO.readByType _).expects("test_type").returning(Some(loadInfo)).once()

    def assertDf(actualDf: DataFrame): Unit = {
      val uuid = actualDf.select("entity_uuid").as[String].first
      assert(uuidRegEx.findAllIn(uuid).length == 1)
      assert(actualDf.drop("entity_uuid").except(df.drop("entity_uuid")).count == 0)
    }

    def assertMetadata(metadataDf: DataFrame): Unit = {
      assert(metadataDf.count == 1)
      assert(metadataDf.filter(metadataDf("attribute") === "a").count == 1)
      assert(metadataDf.filter(metadataDf("value") === "b").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "d").count == 1)
      assert(metadataDf.filter(metadataDf("domain") === "c").count == 0)
    }

    (mockSparkCuratedStorageService.insert _).expects(loadInfo, argAssert(assertDf _), *, *, *).returning(()).once()
    (mockSparkCatalougeService.write _).expects(argAssert(assertMetadata _), *).returning(()).once()
    val msg = new SparkCurateMessage(Some("curate_test_db"), "test_table_4", "test_type", List(MetadataEntry("a", "b", "c", "d")))

    (mockHiveRepair.run _).expects("test_type", EmfConfig.defaultTableName).returning(true).never()
    (new SparkCurateService(mockSparkCuratedStorageService, mockSparkCatalougeService, mockLoadInfoDAO, mockHiveRepair)).curate(msg)

  }

}package hsbc.emf.command

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.helper.HelperUtility.generateDatabaseNameUUID
import hsbc.emf.data.ingestion.{MetadataEntry, LoadInfoRaw}
import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.{DataFrame, Row}
import org.apache.spark.sql.types.{StringType, StructField, StructType, DateType}
import java.util.Calendar
import java.sql.Date
import scala.util.matching.Regex


class SparkCurateTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  val testInputDb = "test_input_db"
  val testType = "test_type"
  val testTypeMissingUuid = "test_type_missing_uuid"
  val testTypeOverwrite = "test_type_overwrite"
  val testType1 = "test_type_1"
  val testTypeCache1 = "test_type_cache_1"
  val testTypeCache2 = "test_type_cache_2"
  val testTypeCacheAdjustable = "test_type_cache_adjustable"
  val uuidRegEx = new Regex("[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}")

  override def beforeAll(): Unit = {
    super.beforeAll()

    spark.sql(s"create database if not exists $testInputDb")
    var query = s"""create database if not exists $testType"""
    spark.sql(query)
    query =
      s"""create table if not exists $testType.${EmfConfig.defaultTableName} (entity_uuid String, key Long, value String,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    query = s"""create database if not exists $testTypeMissingUuid"""
    spark.sql(query)
    query =
      s"""create table if not exists $testTypeMissingUuid.${EmfConfig.defaultTableName} (entity_uuid String, key Long, value String,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    query = s"""create database if not exists $testTypeOverwrite"""
    spark.sql(query)
    query =
      s"""create table if not exists $testTypeOverwrite.${EmfConfig.defaultTableName} (entity_uuid String, key Long, value String,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    spark.sql(s"create database if not exists $testType1")

    query =
      s"""create table if not exists $testType1.${EmfConfig.defaultTableName} (entity_uuid String, key String, datefld date,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    query = s"""create database if not exists $testTypeCache1"""
    spark.sql(query)
    query =
      s"""create table if not exists $testTypeCache1.${EmfConfig.defaultTableName} (entity_uuid String, key Long, value String,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    query = s"""create database if not exists $testTypeCache2"""
    spark.sql(query)
    query =
      s"""create table if not exists $testTypeCache2.${EmfConfig.defaultTableName} (entity_uuid String, key Long, value String,test_value String)
        using parquet partitioned by (test_value, entity_uuid)"""
    spark.sql(query)

    query = s"""create database if not exists $testTypeCacheAdjustable"""
    spark.sql(query)
    query =
      s"""create table if not exists $testTypeCacheAdjustable.${EmfConfig.defaultTableName} (`entity_uuid` String, `key` Long, `value` String, `test_value` String, `__uuid` String)
        using parquet partitioned by (`test_value`, `entity_uuid`)"""
    spark.sql(query)

    spark.sql(s"create database if not exists ${EmfConfig.loadInfoDatabaseName}")
    spark.sql(s"create table if not exists ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} (file_type String, schema String, primary_key String, extension String, delimiter String, prefix String, skip_rows String, quote_character String, dataset_name String, dynamic_flag Boolean, max_bad_records String, schema_json String, file_description String, file_category String, labels String, write_disposition String, ingestion_workflow_name String, ingest_hierarchy String, expiry_days Int, archive_days Int, ingestion_parameters String, allow_quoted_newlines Boolean) partitioned by (entity_uuid String) stored as parquet")
    spark.sql(s"create database if not exists ${EmfConfig.catalogueDatabaseName}")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $testTypeOverwrite.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$testTypeOverwrite' group by m.entity_uuid, m.file_type
       """.stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $testTypeCache1.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$testTypeCache1' group by m.entity_uuid, m.file_type
       """.stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $testTypeCache2.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$testTypeCache2' group by m.entity_uuid, m.file_type
       """.stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $testTypeCacheAdjustable.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$testTypeCacheAdjustable' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists $testInputDb cascade")
    spark.sql(s"drop database if exists $testTypeMissingUuid cascade")
    spark.sql(s"drop database if exists $testType cascade")
    spark.sql(s"drop database if exists $testType1 cascade")
    spark.sql(s"drop database if exists $testTypeOverwrite cascade")
    spark.sql(s"drop database if exists $testTypeCache1 cascade")
    spark.sql(s"drop database if exists $testTypeCache2 cascade")
    spark.sql(s"drop database if exists ${EmfConfig.loadInfoDatabaseName} cascade")
    spark.sql(s"drop database if exists ${EmfConfig.catalogueDatabaseName} cascade")
    super.afterAll()
  }

  "SparkCurateTest: given invalid params to SparkCurate run" should "return Failed" in {
    assert(new SparkCurate(Some("a"), "", "b", List(MetadataEntry("a", "b", "c", "d"))).run() == Failed)
    assert(new SparkCurate(Some("a"), null, "b", List(MetadataEntry("a", "b", "c", "d"))).run() == Failed)
    assert(new SparkCurate(Some("a"), "b", "", List(MetadataEntry("a", "b", "c", "d"))).run() == Failed)
    assert(new SparkCurate(None, "b", null, List(MetadataEntry("a", "b", "c", "d"))).run() == Failed)
    assert(new SparkCurate(None, "", "", List(MetadataEntry("a", "b", "c", "d"))).run() == Failed)
  }

  "SparkCurateTest: given correct info to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableName = "test_table_1"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testType,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"entity_uuid": "some_uu_id_value", "test_value": "test", "key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testInputDb.$testTableName")
    assert((new SparkCurate(Some(testInputDb), testTableName, testType, List(MetadataEntry("file_type", "test_type", "String", "domain")))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testType.${EmfConfig.defaultTableName}").select("test_value", "key", "value")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.except(df.select("test_value", "key", "value")).count == 0)
  }

  "SparkCurateTest: given correct info to SparkCurate run without entity_uuid" should "return Complete" in {
    val testTableName = "test_table_missing_entity_uuid"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testTypeMissingUuid,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"test_value": "test", "key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testInputDb.$testTableName")
    assert(new SparkCurate(Some(testInputDb), testTableName, testTypeMissingUuid, List(MetadataEntry("file_type", testTypeMissingUuid, "String", "domain"))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testTypeMissingUuid.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.select("test_value", "key", "value").except(df.select("test_value", "key", "value")).count == 0)

    var uuid = testTypeTableDF.select("entity_uuid").as[String].first
    assert(uuidRegEx.findAllIn(uuid).length == 1)
  }

  "SparkCurateTest: given correct info with dateType to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableName = "test_table_date"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testType1,
      schema = Some("key:String,datefld:date"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))

    val dateValue = new Date(Calendar.getInstance.getTimeInMillis)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val schema = StructType(Array(StructField("entity_uuid", StringType, true), StructField("test_value", StringType, true), StructField("key", StringType, true), StructField("datefld", DateType)))
    val rowData = Seq(Row("some_uuid", "test", "test_date", dateValue))
    val df = spark.createDataFrame(spark.sparkContext.parallelize(rowData), schema)
    df.write.saveAsTable(s"$testInputDb.$testTableName")
    assert(new SparkCurate(Some(testInputDb), testTableName, testType1, List(MetadataEntry("file_type", testType1, "String", "domain"))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testType1.${EmfConfig.defaultTableName}").select("test_value", "key", "datefld")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.except(df.select("test_value", "key", "datefld")).count == 0)
    assert(testTypeTableDF.head.getAs[Date]("datefld").toString == dateValue.toString)
  }

  "SparkCurateTest: partition overwrite given correct info to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableNameInput1 = "test_table_overwrite_1"
    val testTableNameInput2 = "test_table_overwrite_2"
    val testTableNameInput3 = "test_table_overwrite_3"


    val loadInfoRawList = List(LoadInfoRaw(file_type = testTypeOverwrite,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"entity_uuid": "some_uu_id_value", "test_value": "test", "key": 1010, "value": "ten-ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testInputDb.$testTableNameInput1")
    assert(new SparkCurate(Some(testInputDb), testTableNameInput1, testTypeOverwrite, List(MetadataEntry("file_type", testTypeOverwrite, "String", "domain"))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testTypeOverwrite.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.select("test_value", "key", "value").except(df.select("test_value", "key", "value")).count == 0)

    var uuid = testTypeTableDF.select("entity_uuid").as[String].first
    assert(uuidRegEx.findAllIn(uuid).length == 1)
    var catalogueDAO = new CatalogueDAO(new SqlExecutor())
    var catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeOverwrite)

    val overWriteSample1 =
      """[{"entity_uuid": "some_uu_id_value", "test_value": "test", "key": 100, "value": "hundred"},
    {"entity_uuid": "new_uuid_value", "test_value": "test", "key": 20, "value": "twenty"}]"""
    val overWriteDf1 = spark.read.json(Seq(overWriteSample1).toDS)
    overWriteDf1.write.saveAsTable(s"$testInputDb.$testTableNameInput2")
    assert((new SparkCurate(Some(testInputDb), testTableNameInput2, testTypeOverwrite, List(MetadataEntry("file_type", testTypeOverwrite, "String", "domain")))).run() == Complete)
    val testTypeTableDF1: DataFrame = spark.table(s"$testTypeOverwrite.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF1.count == 3)
    assert(testTypeTableDF1.select("test_value", "key", "value").except(overWriteDf1.union(df).select("test_value", "key", "value")).count == 0)

    uuid = testTypeTableDF1.select("entity_uuid").as[String].first
    assert(uuidRegEx.findAllIn(uuid).length == 1)
    catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeOverwrite)

    val overWriteSample2 =
      """[{"entity_uuid": "some_uuid_value", "test_value": "test", "key": 100, "value": "hundred"},
    {"entity_uuid": "new_uuid_value_2", "test_value": "test", "key": 30, "value": "thirty"}]"""
    val overWriteDf2 = spark.read.json(Seq(overWriteSample2).toDS)
    overWriteDf2.write.saveAsTable(s"$testInputDb.$testTableNameInput3")
    assert(new SparkCurate(Some(testInputDb), testTableNameInput3, testTypeOverwrite, List(MetadataEntry("file_type", testTypeOverwrite, "String", "domain"))).run() == Complete)
    val testTypeTableDF2: DataFrame = spark.table(s"$testTypeOverwrite.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF2.count == 5)
    assert(testTypeTableDF2.select("test_value", "key", "value").except(testTypeTableDF1.union(overWriteDf2).select("test_value", "key", "value")).count == 0)

    uuid = testTypeTableDF2.select("entity_uuid").as[String].first
    assert(uuidRegEx.findAllIn(uuid).length == 1)
    catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeOverwrite)

  }

  "SparkCurateTest: given correct info and empty db to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableName = s"$testInputDb.test_table_2"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testTypeCache1,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))

    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"entity_uuid": "some_uuid_value" , "test_value": "test", "key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(testTableName)
    val cacheTable = generateDatabaseNameUUID()
    assert(new SparkSqlEval(s"select * from $testTableName", cacheTable, asView = true).run() == Complete)
    assert(new SparkCurate(None, cacheTable, testTypeCache1, List(MetadataEntry("file_type", testTypeCache1, "String", "domain"))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testTypeCache1.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.select("test_value", "key", "value").except(df.select("test_value", "key", "value")).count == 0)

    val catalogueDAO = new CatalogueDAO(new SqlExecutor())
    val uuid = testTypeTableDF.select("entity_uuid").as[String].first
    val catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeCache1)

  }

  "SparkCurateTest: given correct info ( adjustable ) and empty db to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableName = s"$testInputDb.test_table_adjustable"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testTypeCacheAdjustable,
      schema = Some("key:Long,value:String,__uuid: String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"true\"}"),
      max_bad_records = Some("1")))

    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"entity_uuid": "some_uuid_value" , "test_value": "test", "key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(testTableName)
    val cacheTable = generateDatabaseNameUUID()
    assert(new SparkSqlEval(s"select * from $testTableName", cacheTable, asView = true).run() == Complete)
    assert(new SparkCurate(None, cacheTable, testTypeCacheAdjustable, List(MetadataEntry("file_type", testTypeCacheAdjustable, "String", "domain"))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testTypeCacheAdjustable.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.select("test_value", "key", "value").except(df.select("test_value", "key", "value")).count == 0)
    assert(testTypeTableDF.select("__uuid").distinct().collectAsList().size() == 1)

    val catalogueDAO = new CatalogueDAO(new SqlExecutor())
    val uuid = testTypeTableDF.select("entity_uuid").as[String].first
    val catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeCacheAdjustable)

  }

  "SparkCurateTest: given correct info and empty db with un-ordered fields to SparkCurate run" should "return Complete" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val testTableName = s"${testInputDb}.test_table_5"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testTypeCache2,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test_value"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))

    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"key": 10, "entity_uuid": "some_uuid_value" , "test_value": "test", "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(testTableName)
    val cacheTable = generateDatabaseNameUUID()
    assert((new SparkSqlEval(s"select * from ${testTableName}", cacheTable, asView = true)).run() == Complete)
    assert((new SparkCurate(None, cacheTable, testTypeCache2, List(MetadataEntry("file_type", testTypeCache2, "String", "domain")))).run() == Complete)
    val testTypeTableDF: DataFrame = spark.table(s"$testTypeCache2.${EmfConfig.defaultTableName}")
    assert(testTypeTableDF.count == 1)
    assert(testTypeTableDF.select("test_value", "key", "value").except(df.select("test_value", "key", "value")).count == 0)

    val catalogueDAO = new CatalogueDAO(new SqlExecutor())
    val uuid = testTypeTableDF.select("entity_uuid").as[String].first
    val catalogueEntities = catalogueDAO.readById(uuid)
    assert(catalogueEntities(0).entity_uuid == uuid)
    assert(catalogueEntities(0).file_type == testTypeCache2)
  }

  "SparkCurateTest: given invalid file_type to SparkCurate run" should "return Failed" in {
    val testTableName = "test_table_3"
    val loadInfoRawList = List(LoadInfoRaw(file_type = testType,
      schema = Some("key:Long,value:String"),
      extension = Some("parquet"),
      ingest_hierarchy = Some("test"),
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    val sample = """[{"key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testInputDb.$testTableName")
    assert((new SparkCurate(Some(testInputDb), testTableName, "invalid", List(MetadataEntry("file_type", testType, "String", "domain")))).run() == Failed)
  }
}package hsbc.emf.service.orchestration

import java.util.Locale
import scala.util.{Failure, Success, Try}

import hsbc.emf.command._
import hsbc.emf.data.logging._
import hsbc.emf.data.orchestration.{ProcessTask, ProcessTaskLabelsParameter}
import hsbc.emf.data.sparkcmdmsg._
import hsbc.emf.infrastructure.exception.{EmfDagBuilderException, EmfUnknownCommandException}
import hsbc.emf.infrastructure.helper.{JsonReader, MetadataHelper}
import hsbc.emf.infrastructure.logging.audit.{Active, AuditLogger, MessageStateInfo, WorkflowSpawnInfo}
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.services.mapper.SparkResolveMessageMapper

import org.apache.spark.sql.SparkSession

class SparkDagBuilder(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkDagBuilder with MessageContext {

  override def buildDag(processTasksSplitByDependency: Seq[Seq[ProcessTask]], workflowPlaceholderParams: PlaceholderParameters,
                        enabled: Map[String, List[String]] = Map.empty, disabled: Map[String, List[String]] = Map.empty,
                        workflow: String, runUUID: String): Seq[Seq[ISparkCommand]] = {
    Try(
      processTasksSplitByDependency.par.map {
        processTasks =>
          processTasks.par.filter {
            processTask =>
              Try(shouldSpawn(processTask, workflowPlaceholderParams, enabled, disabled)) match {
                case Success(value) => value
                case Failure(exception) => throw new RuntimeException("SparkDagBuilder shouldSpawn failed", exception)
              }
          }.map {
            processTask =>
              Try(buildCommand(processTask, workflowPlaceholderParams, workflow, runUUID, enabled, disabled)) match {
                case Success(value) => value
                case Failure(exception) => throw new RuntimeException("SparkDagBuilder buildCommand failed", exception)
              }
          }.seq
      }.seq
    ) match {
      case Success(v) => v
      case Failure(exception) =>
        throw new EmfDagBuilderException("SparkDagBuilder buildDag failed", exception)
    }
  }

  def shouldSpawn(processTask: ProcessTask, workflowPlaceholderParams: PlaceholderParameters,
                  enabled: Map[String, List[String]], disabled: Map[String, List[String]]): Boolean = {
    val labelsParamEither = JsonReader.deserialize[ProcessTaskLabelsParameter](processTask.parameters)
    if (labelsParamEither.isLeft) EmfLogger.warn("Failed to deserialize labels parameter. Continue as no labels parameter.")
    val labelsParam = labelsParamEither.right.getOrElse(ProcessTaskLabelsParameter(None))

    if (labelsParam.labels.nonEmpty) { // the command has labels; need to check skip or not
      val labels: Map[String, List[String]] = labelsParam.labels.get
      labels.keys.foreach {
        labelKey =>
          if (enabled.nonEmpty && (!enabled.contains(labelKey) || enabled(labelKey).intersect(labels(labelKey)).isEmpty) ||
            (disabled.nonEmpty && (disabled.contains(labelKey) && disabled(labelKey).intersect(labels(labelKey)).nonEmpty))) {
            EmfLogger.debug(s"Skip command ${processTask.command} (order id: ${processTask.order_id}) " +
              s"based on command labels '$labels', enabled '$enabled' and disabled '$disabled'")
            return false
          }
      }
    }
    true
  }

  // scalastyle:off cyclomatic.complexity
  def buildCommand(processTask: ProcessTask, workflowPlaceholderParams: PlaceholderParameters, workflow: String, runUUID: String,
                   enabled: Map[String, List[String]], disabled: Map[String, List[String]]): ISparkCommand = {
    val taskParametersJsonWithWorkflowParamsReplaced =
      PlaceholderParameterisation.insertParams(workflowPlaceholderParams, processTask.parameters)
    val taskParametersJsonFullyReplaced =
      SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedParamJson(taskParametersJsonWithWorkflowParamsReplaced)

    val spawnMessageInfo = MessageInfo(runUUID, workflow, processTask.order_id, processTask.command, taskParametersJsonFullyReplaced,
      Option(processTask.parents).getOrElse(List.empty))

    // Create the command instance based on the process task
    val sparkCommand = processTask.command.toUpperCase(Locale.ROOT) match {
      case "GBQ-SQL-EVAL" | "SPARK-SQL-EVAL" =>
        val sparkSqlEvalMessage = JsonReader.deserializeWithCheck[SparkSqlEvalMessage](taskParametersJsonFullyReplaced)
        new SparkSqlEval(sparkSqlEvalMessage.query, sparkSqlEvalMessage.table,
          sparkSqlEvalMessage.write_disposition, sparkSqlEvalMessage.as_view, sparkSqlEvalMessage.dataset)(spark, spawnMessageInfo)
      case "GBQ-SQL-FROM-GCS" | "SPARK-SQL-FROM-FILE" =>
        val sparkSqlFromFileMessage = JsonReader.deserializeWithCheck[SparkSqlFromFileMessage](taskParametersJsonFullyReplaced)
        new SparkSqlFromFile(sparkSqlFromFileMessage.bucket, sparkSqlFromFileMessage.file_name,
          sparkSqlFromFileMessage.target_table, sparkSqlFromFileMessage.target_dataset,
          sparkSqlFromFileMessage.as_view, sparkSqlFromFileMessage.write_disposition)(spark, spawnMessageInfo)
      case "GBQ-MESSAGES-FROM-QUERY" | "SPARK-MESSAGES-FROM-QUERY" =>
        val sparkMessagesFromQueryMessage =
          JsonReader.deserializeWithCheck[SparkMessagesFromQueryMessage](taskParametersJsonFullyReplaced)
        new SparkMessagesFromQuery(sparkMessagesFromQueryMessage.query, sparkMessagesFromQueryMessage.write_disposition,
          sparkMessagesFromQueryMessage.as_view, sparkMessagesFromQueryMessage.target_dataset)(spark, spawnMessageInfo)
      case "ASSERT" | "SPARK-ASSERT" =>
        val sparkAssertMessage = JsonReader.deserializeWithCheck[SparkAssertMessage](taskParametersJsonFullyReplaced)
        new SparkAssert(sparkAssertMessage.assertion, sparkAssertMessage.message, sparkAssertMessage.log_level)(spark, spawnMessageInfo)
      case "GBQ-RESOLVE" | "SPARK-RESOLVE" =>
        val sparkResolveMessageRaw = JsonReader.deserializeWithCheck[SparkResolveMessageRaw](taskParametersJsonFullyReplaced)
        val sparkResolveMessage = SparkResolveMessageMapper.map(sparkResolveMessageRaw)
        new SparkResolve(sparkResolveMessage.criteria, sparkResolveMessage.table_name, sparkResolveMessage.where_clause,
          sparkResolveMessage.source_entity_type, sparkResolveMessage.retry_count, sparkResolveMessage.inter_retry_interval,
          sparkResolveMessage.as_view, sparkResolveMessage.dataset_name,sparkResolveMessage.inject_metadata)(spark,spawnMessageInfo)
      case "GBQ-RESOLVE-FROM-INPUT-REQUIREMENTS" | "SPARK-RESOLVE-FROM-INPUT-REQUIREMENTS" =>
        val sparkResolveFromInputRequirementsMessage =
          JsonReader.deserializeWithCheck[SparkResolveFromInputRequirementsMessage](taskParametersJsonFullyReplaced)
        new SparkResolveFromInputRequirements(sparkResolveFromInputRequirementsMessage.input_requirements_table_name,
          sparkResolveFromInputRequirementsMessage.dataset_name, sparkResolveFromInputRequirementsMessage.as_view,
          sparkResolveFromInputRequirementsMessage.inject_metadata)(spark, spawnMessageInfo)
      case "GCS-CURATE" | "SPARK-CURATE" =>
        val sparkCurateMessageRaw = JsonReader.deserializeWithCheck[SparkCurateMessageRaw](taskParametersJsonFullyReplaced)
        val convertedMetadata = MetadataHelper.convertMetadata(sparkCurateMessageRaw.metadata)
        val sparkCurateMessage = SparkCurateMessage(sparkCurateMessageRaw.source_dataset_name,
          sparkCurateMessageRaw.source_table_name, sparkCurateMessageRaw.file_type, convertedMetadata)
        new SparkCurate(sparkCurateMessage.source_dataset_name, sparkCurateMessage.source_table_name,
          sparkCurateMessage.file_type, sparkCurateMessage.metadata)(spark,spawnMessageInfo)
      case "GBQ-CREATE-TABLE-FROM-FILE-TYPE" | "SPARK-CREATE-TABLE" =>
        val sparkCreateTableMessage = JsonReader.deserializeWithCheck[SparkCreateTableMessage](taskParametersJsonFullyReplaced)
        new SparkCreateTable(sparkCreateTableMessage.file_type, sparkCreateTableMessage.dataset_name,
          sparkCreateTableMessage.table_name,sparkCreateTableMessage.inject_metadata)(spark, spawnMessageInfo)
      case "GBQ-LOAD-TABLE-FROM-GCS" | "SPARK-LOAD-TABLE-FROM-FILE" =>
        val sparkLoadTableFromFileMessage =
          JsonReader.deserializeWithCheck[SparkLoadTableFromFileMessage](taskParametersJsonFullyReplaced)
        new SparkLoadTableFromFile(sparkLoadTableFromFileMessage.bucket, sparkLoadTableFromFileMessage.file_path,
          sparkLoadTableFromFileMessage.file_type, sparkLoadTableFromFileMessage.dataset_name,
          sparkLoadTableFromFileMessage.table_name)(spark,spawnMessageInfo)
      case "GBQ-EXPORT-TO-GCS" | "SPARK-EXPORT" =>
        val sparkExportMessageRaw = JsonReader.deserializeWithCheck[SparkExportMessageRaw](taskParametersJsonFullyReplaced)
        val convertedMetadata = MetadataHelper.convertMetadata(sparkExportMessageRaw.metadata)
        val sparkExportMessage  = SparkExportMessage(sparkExportMessageRaw.source_dataset_name,
          sparkExportMessageRaw.source_table_name, sparkExportMessageRaw.export_format,
          sparkExportMessageRaw.field_delimiter, sparkExportMessageRaw.print_header,
          sparkExportMessageRaw.target_file_name, sparkExportMessageRaw.target_bucket_name, sparkExportMessageRaw.target_file_path,
          sparkExportMessageRaw.number_of_files, Some(convertedMetadata), sparkExportMessageRaw.meta_query, sparkExportMessageRaw.token_file_name)
        new SparkExport(sparkExportMessage.sourceDatasetName, sparkExportMessage.sourceTableName, sparkExportMessage.exportFormat,
          sparkExportMessage.fieldDelimiter, sparkExportMessage.printHeader, sparkExportMessage.targetFileName,
          sparkExportMessage.targetBucketName, sparkExportMessage.targetFilePath ,sparkExportMessage.numberOfFiles, sparkExportMessage.metadata,
          sparkExportMessage.metaQuery, sparkExportMessage.tokenFileName) (spark,spawnMessageInfo)
      case "SPARK-INGEST"  =>
        val sparkIngestMessage = JsonReader.deserializeWithCheck[SparkIngestMessage](taskParametersJsonFullyReplaced)
        new SparkIngest(sparkIngestMessage.bucket_cfs, sparkIngestMessage.file_path_input)(spark,spawnMessageInfo)
      case "GBQ-EXPORT-ALL-RESOLUTIONS" | "SPARK-EXPORT-ALL-RESOLUTIONS" =>
        val sparkExportAllResolutionsMessage =
          JsonReader.deserializeWithCheck[SparkExportAllResolutionsMessage](taskParametersJsonFullyReplaced)
        new SparkExportAllResolutions(sparkExportAllResolutionsMessage.criteria, sparkExportAllResolutionsMessage.target_bucket_name,
          sparkExportAllResolutionsMessage.target_file_name, sparkExportAllResolutionsMessage.export_format,
          sparkExportAllResolutionsMessage.field_delimiter, sparkExportAllResolutionsMessage.print_header,
          sparkExportAllResolutionsMessage.number_of_files)(spark, spawnMessageInfo)
      case "GBQ-CATALOGUE" | "SPARK-CATALOGUE" =>
        new SparkCatalogue()(spark,spawnMessageInfo)
      case "OE-RUN" | "SPARK-RUN" =>
        SparkRun(taskParametersJsonFullyReplaced, disabled, enabled, Some(runUUID))(spark, spawnMessageInfo)
      case "GBQ-RWA-CRM" | "SPARK-RWA-CRM" =>
        val sparkRwaCrmMessage = JsonReader.deserializeWithCheck[SparkRwaCrmMessage](taskParametersJsonFullyReplaced)
        new SparkRwaCrm(sparkRwaCrmMessage.source_dataset, sparkRwaCrmMessage.source_table,
        sparkRwaCrmMessage.target_dataset, sparkRwaCrmMessage.target_table,
        sparkRwaCrmMessage.approach, sparkRwaCrmMessage.crm_read_sql)(spark, spawnMessageInfo)
      case unknownCommand: String =>
        val exceptionMessage = s"Encounter unknown command '$unknownCommand' when mapping process task to Spark command"
        EmfLogger.error(exceptionMessage)
        throw new EmfUnknownCommandException(exceptionMessage)
    }

    //audit log - spawn messages
    AuditLogger().audit[WorkflowSpawnInfo](WorkflowSpawnInfo(messageInfo, spawnMessageInfo))

    //Message State Audit logging - set state to ACTIVE
    AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Active))

    // Set the PlaceholderParams into the instantiated command
    sparkCommand.addPlaceholderParams(workflowPlaceholderParams)
    val taskPlaceholderParamsFullyReplaced =
      SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedPlaceholderParams(taskParametersJsonFullyReplaced)
    sparkCommand.addPlaceholderParams(taskPlaceholderParamsFullyReplaced)
    sparkCommand._messageInfo = spawnMessageInfo
    sparkCommand
  }

}package hsbc.emf.service.orchestration

import java.io.{PrintWriter, StringWriter}

import hsbc.emf.command._
import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.data.sqleval.{WriteAppend, WriteTruncate}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.EmfDagBuilderException
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class SparkDagBuilderTest extends IntegrationTestSuiteBase with MockFactory {

  private def fixture = new {
    val runUUID = "test_run_uuid"
    val workflow = "test_workflow"
    val workflowParams = PlaceholderParameters(Map(EmfConfig.sparkRunGeneratedParamNameRunUuid->runUUID, "my_database" -> "XYZ", "site" -> "UK"))
  }

  "given a list of Process Tasks" should "return a list of Spark Commands" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS005", "SPARK-ASSERT", List("JS001"),
        """{"assertion" : "data", "message": "data","log_level":"error"}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands != null && commands.nonEmpty)
    assert(commands.head != null && commands.head.nonEmpty)
    assert(commands.head.head.isInstanceOf[SparkAssert])
  }

  "given a list of Process Tasks stored with GCP names" should "return a list of Spark Commands" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS005", "ASSERT", List("JS001"),
        """{"assertion" : "data", "message": "data","log_level":"error"}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands != null && commands.size == 1)
    assert(commands.head != null && commands.head.size == 1)
    assert(commands.head.head.isInstanceOf[SparkAssert])
  }

  "given an unknown Command in Process Tasks" should "throw EmfUnknownCommand exception" in {
    assertThrows[EmfDagBuilderException] {
      val processTaskList: Seq[Seq[ProcessTask]] = Seq(Seq(
        ProcessTask("JS005", "UNKNOWN_COMMAND", List("JS001"),
          """{"assertion" : "data", "message": "data","log_level":"error"}""", "")))
      new SparkDagBuilder().buildDag(processTaskList, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    }
  }

  "given a list of Process Tasks with placeholders in parameters" should
    "return a list of Spark Commands with their parameters have all placeholders filled" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("JS001", "SPARK-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'", "table": "result_table", "as_view":true}""", "")),
      Seq(ProcessTask("JS005", "SPARK-ASSERT", List("JS001"),
        """{"assertion" : "select col1 from [$my_database].table_efg where id = 1", "message": "data", "log_level": "error"}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    val sparkSqlEval = commands.head.head.asInstanceOf[SparkSqlEval]
    val sparkAssert = commands(1).head.asInstanceOf[SparkAssert]
    assert(sparkSqlEval.query == "select * from XYZ.table_abc where site = 'UK'")
    assert(sparkAssert.assertion == "select col1 from XYZ.table_efg where id = 1")
  }

  "given a list of Process Tasks with GCP Names, and with placeholders in parameters" should
    "return a list of Spark Commands with their parameters have all placeholders filled" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("JS001", "GBQ-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'", "table": "result_table", "as_view":true}""", "")),
      Seq(ProcessTask("JS005", "ASSERT", List("JS001"),
        """{"assertion" : "select col1 from [$my_database].table_efg where id = 1", "message": "data", "log_level": "error"}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow=fixture.workflow, runUUID = fixture.runUUID)
    val sparkSqlEval = commands.head.head.asInstanceOf[SparkSqlEval]
    val sparkAssert = commands(1).head.asInstanceOf[SparkAssert]
    assert(sparkSqlEval.query == "select * from XYZ.table_abc where site = 'UK'")
    assert(sparkAssert.assertion == "select col1 from XYZ.table_efg where id = 1")
  }

  "given a list of Process Tasks containing SPARK-SQL-FROM-FILE command" should
    "return a Spark Command list containing SparkSqlFromFile command with the provided placeholderParams" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS001", "SPARK-SQL-FROM-FILE", List.empty[String],
        """{"bucket": "some_bucket", "file_name": "some_filename", "target_table": "some_table", "as_view":true}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    val sparkSqlFromFile = commands.head.head.asInstanceOf[SparkSqlFromFile]

    val expectedCommandParamMap = Map("bucket" -> "some_bucket", "file_name" -> "some_filename", "target_table" -> "some_table", "as_view" -> "true")
    val expectedPlaceholderParams = PlaceholderParameters(fixture.workflowParams.paramMap ++ expectedCommandParamMap)
    assert(sparkSqlFromFile.placeholderParams == expectedPlaceholderParams)
  }

  "given a list of Process Tasks containing GBQ-SQL-FROM-GCS command" should
    "return a Spark Command list containing SparkSqlFromFile command with the provided placeholderParams" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS001", "GBQ-SQL-FROM-GCS", List.empty[String],
        """{"bucket": "some_bucket", "file_name": "some_filename", "target_table": "some_table", "as_view": true}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    val sparkSqlFromFile = commands.head.head.asInstanceOf[SparkSqlFromFile]

    val expectedCommandParamMap = Map("bucket" -> "some_bucket", "file_name" -> "some_filename", "target_table" -> "some_table", "as_view" -> "true")
    val expectedPlaceholderParams = PlaceholderParameters(fixture.workflowParams.paramMap ++ expectedCommandParamMap)
    assert(sparkSqlFromFile.placeholderParams == expectedPlaceholderParams)
  }

  "given a list of Process Tasks containing SPARK-MESSAGES-FROM-QUERY command" should
    "return a Spark Command list containing SparkMessagesFromQuery command with the provided placeholderParams" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS001", "SPARK-MESSAGES-FROM-QUERY", List.empty[String],
        """{"query": "some_query", "write_disposition": "write_truncate", "as_view":true}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    val sparkMessagesFromQuery = commands.head.head.asInstanceOf[SparkMessagesFromQuery]

    val expectedCommandParamMap = Map("query" -> "some_query", "write_disposition" -> "write_truncate", "as_view" -> "true")
    val expectedPlaceholderParams = PlaceholderParameters(fixture.workflowParams.paramMap ++ expectedCommandParamMap)
    assert(sparkMessagesFromQuery.placeholderParams == expectedPlaceholderParams)
    assert(sparkMessagesFromQuery.writeDisposition == WriteTruncate)
  }

  "given a list of Process Tasks containing GBQ-MESSAGES-FROM-QUERY command" should
    "return a Spark Command list containing SparkMessagesFromQuery command with the provided placeholderParams" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS001", "GBQ-MESSAGES-FROM-QUERY", List.empty[String],
        """{"query": "some_query", "write_disposition": "write_append", "as_view":true}""", "")))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    val sparkMessagesFromQuery = commands.head.head.asInstanceOf[SparkMessagesFromQuery]

    val expectedCommandParamMap = Map("query" -> "some_query", "write_disposition" -> "write_append", "as_view" -> "true")
    val expectedPlaceholderParams = PlaceholderParameters(fixture.workflowParams.paramMap ++ expectedCommandParamMap)
    assert(sparkMessagesFromQuery.placeholderParams == expectedPlaceholderParams)
    assert(sparkMessagesFromQuery.writeDisposition == WriteAppend)
  }

  "given labels not present in the parameters of a list of process tasks" should "return a list all Spark Commands without filtering" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("JS005", "SPARK-ASSERT", List("JS001"),
        """{"assertion" : "data", "message": "data","log_level":"error"}""", "")),
      Seq(ProcessTask("JS001", "SPARK-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'","table": "result_table", "as_view":true}""", "")))

    val enabled = Map("site" -> List("HK"), "freq" -> List("Monthly"))
    val commands1: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, enabled, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands1 != null)
    assert(commands1.flatten.size == 2)
    assert(commands1.head.head.isInstanceOf[SparkAssert])
    assert(commands1(1).head.isInstanceOf[SparkSqlEval])

    val disabled = Map("site" -> List("CA"), "freq" -> List("Monthly"))
    val commands2: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, disabled = disabled, workflow=fixture.workflow, runUUID = fixture.runUUID)
    assert(commands2 != null)
    assert(commands2.flatten.size == 2)
    assert(commands2.head.head.isInstanceOf[SparkAssert])
    assert(commands2(1).head.isInstanceOf[SparkSqlEval])
  }

  "given enabled map parameter and a list of Process Tasks with labels" should
    "return a list of Spark Commands which label values exist in the enabled map" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(
      Seq(ProcessTask("JS005", "SPARK-ASSERT", List("JS001"),
        """{"assertion" : "data", "message": "data","log_level":"error","labels":{"site":["HK","UK"],"freq":["Monthly","Daily"]}}""", "")),
      Seq(ProcessTask("JS001", "SPARK-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'","table": "result_table",""" +
          """"labels":{"site":["HK","UK"],"freq":["Daily"]}}""", "")))
    val enabled = Map("site" -> List("HK", "CA"), "freq" -> List("Monthly"))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, enabled, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands != null)
    assert(commands.flatten.size == 1)
    assert(commands.head.head.isInstanceOf[SparkAssert])
  }

  "given disabled map parameter and a list of Process Tasks with labels" should
    "return a list of Spark Commands which label values don't exist in the disabled map" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS005", "SPARK-ASSERT", List.empty[String],
        """{"assertion" : "data", "message": "data","log_level":"error","labels":{"site":["HK","UK"],"freq":["Daily"]}}""", ""),
      ProcessTask("JS001", "SPARK-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'",""" +
          """"table": "result_table","labels":{"site":["CA","UK"],"freq":["Monthly","Daily"]}}""", "")))
    val disabled = Map("site" -> List("CA"), "freq" -> List("Monthly"))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, disabled = disabled, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands != null)
    assert(commands.flatten.size == 1)
    assert(commands.head.head.isInstanceOf[SparkAssert])
  }

  "given both enabled and disabled map parameters and a list of Process Tasks with labels" should
    "return a list of Spark Commands which label values exist in the enabled map and don't exist in the disabled map" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS005", "SPARK-ASSERT", List.empty[String],
        """{"assertion" : "data", "message": "data","log_level":"error","labels":{"site":["HK","UK"],"freq":["Monthly","Daily"]}}""", ""),
      ProcessTask("JS001", "SPARK-SQL-EVAL", List.empty[String],
        """{"query": "select * from [$my_database].table_abc where site = '[$site]'", "table": "result_table",""" +
          """"labels":{"site":["CA","UK"],"freq":["Monthly","Daily"]}}""", ""),
      ProcessTask("JS006", "SPARK-ASSERT", List.empty[String],
        """{"assertion" : "data", "message": "data","log_level":"error","labels":{"site":["HK","CA"],"freq":["Monthly","Daily"]}}""", "")))
    val enabled = Map("site" -> List("CA"), "freq" -> List("Monthly"))
    val disabled = Map("site" -> List("UK"))
    val commands: Seq[Seq[ISparkCommand]] =
      new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, enabled, disabled, workflow = fixture.workflow, runUUID = fixture.runUUID)
    assert(commands != null)
    assert(commands.flatten.size == 1)
    assert(commands.head.head.isInstanceOf[SparkAssert])
  }

  "given invalid json string" should "throw error" in {
    val processTasks: Seq[Seq[ProcessTask]] = Seq(Seq(
      ProcessTask("JS005", "SPARK-ASSERT", List("JS001"),
        """{"assertion" : "data", "message": data,"log_level":"error"}""", "")))


    val caught = intercept[EmfDagBuilderException] {
      val commands: Seq[Seq[ISparkCommand]] =
        new SparkDagBuilder().buildDag(processTasks, fixture.workflowParams, workflow = fixture.workflow, runUUID = fixture.runUUID)
    }

    val sw = new StringWriter
    caught.printStackTrace(new PrintWriter(sw))
    assert(sw.toString.contains("hsbc.emf.infrastructure.exception.EmfJsonDeserializeException"))

  }

}package hsbc.emf.runner

import scala.util.{Failure, Success, Try}
import hsbc.emf.command.SparkTrigger
import hsbc.emf.constants._
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.udf.UdfRegistration
import org.apache.logging.log4j.LogManager
import org.apache.spark.SparkConf
import hsbc.emf.infrastructure.helper.HelperUtility.generateRunUUID

import org.apache.spark.sql.SparkSession

/**
  * Emf Runner main class to be called by spark-submit or livy.
  *
  */
object SparkEmfRunner {

  private val logger = LogManager.getLogger(SparkEmfRunner.getClass)

  def main(args: Array[String]): Unit = {
    var _spark: SparkSession = null
    try {
      // Handle parameters
      if (args.length != 2) {
        throw new IllegalArgumentException(s"Invalid number of arguments: ${args.length}; expecting 2")
      }
      val tokenFileUrl = args(0)
      val cloudTypeString = args(1)
      val cloudType = Try {
        CloudType(cloudTypeString)
      } match {
        case Success(value) => value
        case Failure(exception) => throw exception
      }
      System.setProperty("Log4jContextSelector", "org.apache.logging.log4j.core.async.AsyncLoggerContextSelector")

      logger.info(s"SparkEmfRunner is triggered with tokenFileUrl = '$tokenFileUrl' and cloudType = '$cloudType'")
      val (tokenFileBucket, tokenFilePath): (String, String) = cloudType match {
        case Azure => extractAzureBlobFileSystemPath(tokenFileUrl)
        case GCP => extractGcsPath(tokenFileUrl)
        case Local => ("", tokenFileUrl)
        case OnPrem => throw new UnsupportedOperationException("On premises cloud provider not yet implemented")
      }

      // Set the cloud type config to be referenced by cloud-specific operations (e.g. the logic to prepend protocol prefix to bucket).
      // It is a temp workaround and is expected to move to external config file once the functionality is implemented.
      EmfConfig.cloudType = cloudType

      // Start Spark Session
      _spark = SparkSession.builder()
        .master(EmfConfig.sparkConfMasterUrl)
        .appName(EmfConfig.sparkConfAppName)
        .config(new SparkConf().setAll(EmfConfig.sparkConfMap))
        .enableHiveSupport()
        .getOrCreate()
      implicit val spark: SparkSession = _spark

      registerAllUdfs(spark)

      // Start Spark EMF (Calls SparkTrigger)
      logger.info(s"SparkEmfRunner calls SparkTrigger with tokenFileBucket = '$tokenFileBucket'" +
        s" and tokenFilePath = '$tokenFilePath'")
      implicit val messageInfo = MessageInfo(generateRunUUID(), "dim-queue-load", "worflow-exec", "SPARK-TRIGGER", "")
      val execResult = new SparkTrigger(tokenFileBucket, tokenFilePath).run()
      if (execResult == Complete) {
        logger.info("SparkEmfRunner called Ingestion Extension and it succeeded")
      }
      else {
        val errorMessage = "SparkEmfRunner called Ingestion Extension and it failed"
        logger.error(s"$errorMessage")
        throw new IllegalStateException(errorMessage)
      }
    }
    catch {
      case exception: Exception =>
        logger.error(s"SparkEmfRunner failed with error: ${exception.getMessage}")
        // re-throw to pass the failure status back to Spark
        throw new IllegalStateException(s"SparkEmfRunner failed with error: ${exception.getMessage}", exception)
    }
    finally {
      LogManager.shutdown()
      if (!_spark.sparkContext.isStopped) {
        _spark.stop()
        _spark.close()
      }
    }
  }

  private[runner] def registerAllUdfs(spark: SparkSession): Unit = {
    logger.info("Invoking registerAllUdfs to register UDFS from SparkEmfRunner")
    UdfRegistration.registerAllUdfs(spark)
    logger.info("All Udfs have been registered Successfully from SparkEmfRunner")
  }

  // Package visibility for SparkEmfRunnerTest
  private[runner] def extractAzureBlobFileSystemPath(tokenFileUrl: String): (String, String) = {
    try {
      /* tokenFileUrl from Azure Function is in the form -
         https://${storageAccountName}.blob.core.windows.net/${containerName}/${dirPath}/x__metadata_chunk_token__ */
      val tokenFileUrlSplit = tokenFileUrl.split("/")

      // tokenFileUrlSplit(0) is "https:"
      // tokenFileUrlSplit(1) is ""
      // tokenFileUrlSplit(2) is "${storageAccountName}.blob.core.windows.net"
      // tokenFileUrlSplit(3) is "${containerName}
      // Target bucket format: "abfs://${containerName}@${storageAccountName}.dfs.core.windows.net/"
      val updatedStorageAccountFqdn = tokenFileUrlSplit(2).replace("blob.core.windows.net", "dfs.core.windows.net")
      val tokenFileBucket = s"${Azure.protocolPrefix}${tokenFileUrlSplit(3)}@$updatedStorageAccountFqdn/"

      // Dropping the first 4 elements from tokenFileUrlSplit till container name and also drop last element which is token file name,
      // to get only the ${dirPath} in which token file is present
      val numOfPartsToDrop = 4
      val tokenFilePath = tokenFileUrlSplit.drop(numOfPartsToDrop).dropRight(1).mkString("/")
      (tokenFileBucket, tokenFilePath)
    }
    catch {
      case exception: Exception =>
        val errorMessage = s"extractAzureBlobFileSystemPath with tokenFileUrl: '$tokenFileUrl' failed with error: ${exception.getMessage}"
        logger.error(s"$errorMessage")
        throw new IllegalArgumentException(errorMessage, exception)
    }
  }

  private[runner] def extractGcsPath(tokenFileUrl: String): (String, String) = {
    try {
      /* tokenFileUrl is in the form -
         gs://${bucketName}/${dirPath}/x__metadata_chunk_token__ */
      val tokenFileUrlSplit = tokenFileUrl.split("/")

      // tokenFileUrlSplit(0) is "gs:"
      // tokenFileUrlSplit(1) is ""
      // tokenFileUrlSplit(2) is "${bucketName}"
      // Target bucket format: "gs://${bucketName}/"
      val tokenFileBucket = s"${tokenFileUrlSplit(0)}//${tokenFileUrlSplit(2)}/"

      // Dropping the first 3 elements from tokenFileUrlSplit till bucket name and also drop last element which is token file name,
      // to get only the ${dirPath} in which token file is present
      val numOfPartsToDrop = 3
      val tokenFilePath = tokenFileUrlSplit.drop(numOfPartsToDrop).dropRight(1).mkString("/")
      (tokenFileBucket, tokenFilePath)
    }
    catch {
      case exception: Exception =>
        val errorMessage = s"extractGcsPath with tokenFileUrl: '$tokenFileUrl' failed with error: ${exception.getMessage}"
        logger.error(s"$errorMessage")
        throw new IllegalArgumentException(errorMessage, exception)
    }
  }
}package hsbc.emf.runner

import java.io.File
import java.util.UUID

import hsbc.emf.constants.{Azure, GCP, Local}
import hsbc.emf.infrastructure.config.EmfConfig
import org.apache.commons.io.FileUtils
import org.scalatest.{BeforeAndAfterAll, FlatSpec}

class SparkEmfRunnerTest extends FlatSpec with BeforeAndAfterAll {

  private var warehouseDir: String = _

  override def beforeAll(): Unit = {
    super.beforeAll()

    val randomUUID = UUID.randomUUID.toString
    val tmpDir = System.getProperty("java.io.tmpdir")
    warehouseDir = s"$tmpDir${File.separator}spark-warehouse${File.separator}$randomUUID"

    val localSparkConfMap = Map(
      "spark.testing.memory" -> "2147480000",
      "spark.sql.warehouse.dir" -> new File(warehouseDir).getAbsolutePath,
      "javax.jdo.option.ConnectionURL" -> s"jdbc:derby:memory:$randomUUID;create=true")

    EmfConfig.sparkConfMasterUrl = "local"
    EmfConfig.sparkConfMap = EmfConfig.sparkConfMap ++ localSparkConfMap
  }

  override def afterAll(): Unit = {
    EmfConfig.cloudType = Local // this system-wise config will be changed by SparkEmfRunner during test execution; thus reset it
    FileUtils.deleteDirectory(new File(warehouseDir).getAbsoluteFile)
  }

  "given an azureFunctionTokenFilePath, extractAzureBlobFileSystemPath method" should "return azure blob file system path" in {
    val expectedBucketCfsValue = "abfs://corecomp02land-dev-0001@hsbccorecompn1devbl02.dfs.core.windows.net/"
    val expectedFilePathInputValue = "ingestiontriggertest/abc"
    val azureFunctionTokenFilePath = "https://hsbccorecompn1devbl02.blob.core.windows.net/corecomp02land-dev-0001/" +
      s"ingestiontriggertest/abc/${EmfConfig.spark_readable_meta_chunk_token}"
    val (resultBucketCfs, resultFilePathInput) = SparkEmfRunner.extractAzureBlobFileSystemPath(azureFunctionTokenFilePath)
    assert(expectedBucketCfsValue == resultBucketCfs)
    assert(expectedFilePathInputValue == resultFilePathInput)
  }

  "given a gcpTokenFilePath, extractGcsPath" should "return gcs path" in {
    val expectedBucketCfsValue = "gs://corecomp6land-dev-0001/"
    val expectedFilePathInputValue = "spark_ingest_mockup_data/test_par001_set7"
    val gcpTokenFilePath = s"gs://corecomp6land-dev-0001/spark_ingest_mockup_data/test_par001_set7/${EmfConfig.spark_readable_meta_chunk_token}"
    val (resultBucketCfs, resultFilePathInput) = SparkEmfRunner.extractGcsPath(gcpTokenFilePath)
    assert(expectedBucketCfsValue == resultBucketCfs)
    assert(expectedFilePathInputValue == resultFilePathInput)
  }

  "given an azureTokenFilePath and cloudType as Azure" should
    "call SparkIngest and failed due to abfs:// path invalid in local and ci env" in {
    val azureFunctionTokenFilePath = "https://hsbccorecompn1devbl02.blob.core.windows.net/corecomp02land-dev-0001/" +
      s"ingestiontriggertest/abc/${EmfConfig.spark_readable_meta_chunk_token}__AAA"
    assertThrows[IllegalStateException] {
      SparkEmfRunner.main(Array(azureFunctionTokenFilePath, Azure.toString))
    }
  }

  "given a gcpTokenFilePath and cloudType as GCP" should
    "call SparkIngest and failed due to gs:// path invalid in local and ci env" in {
    val gcpTokenFilePath = s"gs://corecomp6land-dev-0001/spark_ingest_mockup_data/test_par001_set7/${EmfConfig.spark_readable_meta_chunk_token}"
    assertThrows[IllegalStateException] {
      SparkEmfRunner.main(Array(gcpTokenFilePath, GCP.toString))
    }
  }

  "SparkEmfRunner" should s"be given a SparkSession with ${EmfConfig.sparkConfSqlCrossJoinEnabledName} " +
    s"spark conf as ${EmfConfig.sparkConfSqlCrossJoinEnabledValue}" in {
    // EmfConfig.sparkConfMap will be used by SparkEmfRunner.main() to construct SparkSession.
    // As we have no way to access the SparkSession defined within SparkEmfRunner.main() to assert it (and the SparkSession
    // will also be destroyed at the end of main()), we can only assert the source EmfConfig.sparkConfigMap instead.
    assert(EmfConfig.sparkConfMap.getOrElse(EmfConfig.sparkConfSqlCrossJoinEnabledName, "") == EmfConfig.sparkConfSqlCrossJoinEnabledValue)
    // Lifted from the test above
    val gcpTokenFilePath = s"gs://corecomp6land-dev-0001/spark_ingest_mockup_data/test_par001_set7/${EmfConfig.spark_readable_meta_chunk_token}"
    assertThrows[IllegalStateException] {
      SparkEmfRunner.main(Array(gcpTokenFilePath, GCP.toString))
    }
  }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkExportMessage
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.export.SparkExportService
import org.apache.spark.sql.SparkSession

import scala.util.{Failure, Success, Try}

class SparkExport(val sourceDatasetName: Option[String],
                  val sourceTableName: String,
                  val exportFormat: String = "csv",
                  val fieldDelimiter: String = ",",
                  val printHeader: Boolean = true,
                  val targetFileName: Option[String],
                  val targetBucketName: Option[String],
                  val targetFilePath: Option[String],
                  val numberOfFiles: Int = 0,
                  val metadata: Option[List[MetadataEntry]] = Some(List.empty[MetadataEntry]),
                  val metaQuery: Option[String],
                  val tokenFileName: Option[String]
                 )
                 (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    val newTargetFileName = if (targetFileName.getOrElse("").trim.isEmpty) generateEntityUUID() else targetFileName.get
    val newTargetBucketName = if (targetBucketName.getOrElse("").trim.isEmpty) generateEntityUUID() else targetBucketName.get
    val sparkExportMessage = SparkExportMessage(
      sourceDatasetName, sourceTableName, exportFormat,
      fieldDelimiter, printHeader, Some(newTargetFileName), Some(newTargetBucketName), targetFilePath, numberOfFiles, metadata, metaQuery, tokenFileName)
    if (messageValidate(sparkExportMessage)) {
      Try {
        val sqlExecutor = new SqlExecutor()
        new SparkExportService(sqlExecutor, new CatalogueDAO(sqlExecutor)).export(sparkExportMessage)
        EmfLogger.info(s"SparkExport command executed successfully for table: $sourceTableName")
      } match {
        case Success(_) => Complete
        case Failure(exception) =>
          ExceptionHandler.handle("SparkExport command execution failed", exception)
          Failed
      }
    } else {
      EmfLogger.error(s"SparkExport command failed with error: Messages Validation failed. sourceTableName/targetFileName/targetBucketName should not be empty")
      Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkExportMessage]
    msg.sourceTableName != null && msg.sourceTableName.trim.nonEmpty
  }
}package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution.ResolutionCriteria
import hsbc.emf.data.sparkcmdmsg.SparkExportAllResolutionsMessage
import hsbc.emf.infrastructure.helper.ViewUtils
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.export.{SparkExportAllResolutionsService, SparkExportService}
import hsbc.emf.service.resolution.SparkResolveService

import org.apache.spark.sql.SparkSession

class SparkExportAllResolutions(val criteria: ResolutionCriteria,
                                val targetBucketName: String,
                                val targetFileName: String,
                                val exportFormat: String = "csv",
                                val fieldDelimiter: String = ",",
                                val printHeader: Boolean = true,
                                val numberOfFiles: Int = 0)
                               (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    val msg = SparkExportAllResolutionsMessage(criteria,
      targetBucketName,
      targetFileName,
      exportFormat,
      fieldDelimiter,
      printHeader,
      numberOfFiles)
    messageValidate(msg) match {
      case true =>
        Try {
          val sqlExecutor = new SqlExecutor()
          val catalogueDao = new CatalogueDAO(sqlExecutor)
          val sparkExportService = new SparkExportService(sqlExecutor, catalogueDao)
          val sparkResolveService = new SparkResolveService(sqlExecutor, catalogueDao)
          new SparkExportAllResolutionsService(sparkResolveService, sparkExportService, catalogueDao, new ViewUtils()).resolveAndExport(msg)
          EmfLogger.info("SparkExportAllResolutions command executed successfully")
        } match {
          case Success(_) =>
            Complete
          case Failure(exception) =>
            ExceptionHandler.handle("SparkExportAllResolutions command execution failed", exception)
            Failed
        }
      case false =>
        EmfLogger.error("SparkExportAllResolutions command execution failed. Message Validation Failed. file_type/target_bucket_name should not be empty")
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkExportAllResolutionsMessage]
    msg.criteria.file_type != null &&
      !msg.criteria.file_type.trim.isEmpty &&
      msg.target_bucket_name != null &&
      !msg.target_bucket_name.trim.isEmpty
  }
}
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.resolution.ResolutionCriteria


case class SparkExportAllResolutionsMessage(criteria: ResolutionCriteria,
                                            target_bucket_name: String,
                                            target_file_name: String,
                                            export_format: String = "csv",
                                            field_delimiter: String = ",",
                                            print_header: Boolean = true,
                                            number_of_files: Int = 0)  extends ISparkCommandMessagepackage hsbc.emf.service.export

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.{SparkExportAllResolutionsMessage, SparkExportMessage, SparkResolveMessage}
import hsbc.emf.infrastructure.exception.SparkExportServiceException
import hsbc.emf.infrastructure.helper.HelperUtility.generateDatabaseNameUUID
import hsbc.emf.infrastructure.helper.ViewUtils
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.service.resolution.ISparkResolveService

import org.apache.spark.sql.SparkSession


class SparkExportAllResolutionsService(sparkResolveService: ISparkResolveService,
                                       sparkExportService: ISparkExportService,
                                       catalogueDAO: ICatalogueDAO,
                                       viewUtils: ViewUtils)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo)
  extends ISparkExportAllResolutionsService with MessageContext {


  def resolveAndExport(message: SparkExportAllResolutionsMessage): Unit = {
    val tableName = generateDatabaseNameUUID()
    val sparkResolveMsg = SparkResolveMessage(criteria = message.criteria, table_name = tableName, as_view = true)
    sparkResolveMsg.latest_only = message.criteria.latest_only

    try {
      sparkResolveService.resolve(sparkResolveMsg)
      viewUtils.dropColumnsFromView(tableName, List("entity", "metadata"))
      val catalogueEntities: (List[CatalogueEntity], String) = sparkResolveService.constructCatalogue4Uuids(message.criteria, message.criteria.latest_only)
      val catalogueUuids = catalogueEntities._1.map(ce => ce.entity_uuid)
      val tempViewName = generateDatabaseNameUUID()
      val timeStamp = DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()).replace(":", "_")
      catalogueUuids.foreach {
        uuid =>
          val catalogueEntities: List[CatalogueEntity] = catalogueDAO.readById(uuid)
          if (catalogueEntities.size > 0) {
            catalogueEntities.foreach {
              catalogueEntity =>
                viewUtils.loadViewFromQuery(s"select * from ${tableName} where entity_uuid in ('${catalogueEntity.entity_uuid}')", tempViewName)
                val recordCount = viewUtils.viewRecordCount(tempViewName)
                var metadata: List[MetadataEntry] = catalogueEntity.metadata
                val dbName = metadata.filter(m => (m.attribute.toLowerCase() == "dataset_name"))
                if (dbName.isEmpty) {
                  throw new SparkExportServiceException(s"No dataset_name attribute found in metadata for ${uuid}", None.orNull)
                }
                metadata :+= MetadataEntry("record_count", recordCount.toString, "Long", "")
                val expMsg = SparkExportMessage(sourceDatasetName = None,
                                                sourceTableName = tempViewName,
                                                exportFormat = message.export_format,
                                                fieldDelimiter = message.field_delimiter,
                                                printHeader = message.print_header,
                                                targetFileName = Some(message.target_file_name),
                                                targetBucketName = Some(message.target_bucket_name),
                                                targetFilePath = None,
                                                numberOfFiles = message.number_of_files,
                                                metadata = Some(metadata.toSet.toList),
                                                metaQuery = None,
                                                tokenFileName = None
                )
                sparkExportService.export(expMsg)
                viewUtils.dropView(tempViewName)
            }
          } else {
            val errMsg = s"No catalogue entity found for $uuid"
            EmfLogger.error(errMsg)
            throw new SparkExportServiceException(errMsg, None.orNull)
          }
      }

    } catch {
      case e: Exception =>
        val customMessage = s"SparkExportAllResolutionsService.resolveAndExport failed with message ${message}  : ${e.getMessage}"
        EmfLogger.error(customMessage)
        throw e
    }
  }
}
package hsbc.emf.service.export

import java.sql.Timestamp

import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.resolution.ResolutionCriteria
import hsbc.emf.data.sparkcmdmsg.{SparkExportAllResolutionsMessage, SparkExportMessage, SparkResolveMessage}
import hsbc.emf.infrastructure.exception.SparkExportServiceException
import hsbc.emf.infrastructure.helper.ViewUtils
import hsbc.emf.infrastructure.logging.MessageContextTestData
import hsbc.emf.service.resolution.ISparkResolveService
import org.scalamock.scalatest.MockFactory
import org.scalatest.FlatSpec

import org.apache.spark.sql.SparkSession


class SparkExportAllResolutionsServiceTest extends FlatSpec with MockFactory with MessageContextTestData {
  private var _spark: SparkSession = _
  implicit lazy val spark = _spark

  val mockSparkResolveService = mock[ISparkResolveService]
  val mockSparkExportService = mock[ISparkExportService]
  val stubCatalogueDAO = stub[ICatalogueDAO]
  val mockViewUtils = mock[ViewUtils]


  "SparkExpAllResServiceTest: case valid data mock" should "not throw Exception" in {
    val fileType = "some_type"
    val criteria = ResolutionCriteria(file_type = fileType)
    val msg = SparkExportAllResolutionsMessage(criteria,
                                              "target_bucket_name",
                                              "target_file_name",
                                              "export_format",
                                              "field_delimiter",
                                              true,
                                              1)

    def assertMsg(m: SparkResolveMessage) : Unit = {
      assert(m.criteria.file_type == fileType)
    }

    (mockSparkResolveService.resolve _).expects(argAssert(assertMsg _)).returning(()).once()
    val catalogueUuids = (List(CatalogueEntity("uuid1", "file_type_1", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr1", "val1", "string", null))),
                              CatalogueEntity("uuid2", "file_type_2", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr2", "val2", "string", null)))), "cat")
    (mockSparkResolveService.constructCatalogue4Uuids _).expects(criteria, true).returning(catalogueUuids).once()

    val metadata =  List(MetadataEntry("file_type", "test_type", "String", "domain"),
                         MetadataEntry("file_type", "test_type", "String", "domain"),
                         MetadataEntry("dataset_name", "test_dataset", "String", "domain"))
    val catalogueEntityList: List[CatalogueEntity] = List(CatalogueEntity("uuid1", "file_type",
                                                            Timestamp.valueOf("2021-01-01 00:00:00"),
                                                            metadata),
                                                          CatalogueEntity("uuid2", "file_type2",
                                                             Timestamp.valueOf("2021-01-01 00:00:00"),
                                                             metadata))

    (stubCatalogueDAO.readById _).when("uuid1").returns(List(catalogueEntityList(0)))
    (stubCatalogueDAO.readById _).when("uuid2").returns(List(catalogueEntityList(1)))

    def assertExportMsg(m: SparkExportMessage ) : Unit = {
      assert(m.metadata.get.size == 3)
      assert(m.metadata.get(0).attribute == "file_type")
      assert(m.metadata.get(0).value == "test_type")
      assert(m.metadata.get(0).data_type == "String")
      assert(m.metadata.get(0).domain == "domain")

      assert(m.metadata.get(1).attribute == "dataset_name")
      assert(m.metadata.get(1).value == "test_dataset")
      assert(m.metadata.get(1).data_type == "String")
      assert(m.metadata.get(1).domain == "domain")
    }

    (mockSparkExportService.export _).expects(argAssert(assertExportMsg _)).returning(()).twice()
    (mockViewUtils.dropColumnsFromView _).expects(*, List("entity", "metadata")).returning(()).once()

    def assertQuery(query: String) : Unit = {
      assert(query.contains(catalogueUuids._1(0).entity_uuid) || query.contains(catalogueUuids._1(1).entity_uuid))
    }
    (mockViewUtils.loadViewFromQuery _).expects(argAssert(assertQuery _), *).returning(()).twice()
    (mockViewUtils.dropView _).expects(*).returning(()).twice()
    (mockViewUtils.viewRecordCount _).expects(*).returning(1).twice()

    val service = new SparkExportAllResolutionsService(mockSparkResolveService, mockSparkExportService, stubCatalogueDAO, mockViewUtils)
    service.resolveAndExport(msg)
  }

  "SparkExpAllResServiceTest: case None catalogueEntity" should "throw SparkExportServiceException" in {
    val fileType = "some_type"
    val criteria = ResolutionCriteria(file_type = fileType)
    val msg = SparkExportAllResolutionsMessage(criteria,
                                              "target_bucket_name",
                                              "target_file_name",
                                              "export_format",
                                              "field_delimiter",
                                              true,
                                              1)

    def assertMsg(m: SparkResolveMessage) : Unit = {
      assert(m.criteria.file_type == fileType)
    }

    (mockSparkResolveService.resolve _).expects(argAssert(assertMsg _)).returning(()).once()
    val catalogueUuids = (List(CatalogueEntity("uuid1", "file_type_1", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr1", "val1", "string", null)))), "cat")
    (mockSparkResolveService.constructCatalogue4Uuids _).expects(criteria, true).returning(catalogueUuids).once()

    val metadata =  List(MetadataEntry("file_type", "test_type", "String", "domain"),
                         MetadataEntry("file_type", "test_type", "String", "domain"))
    val catalogueEntityList: List[CatalogueEntity] = List(CatalogueEntity("uuid1", "file_type",
                                                            Timestamp.valueOf("2021-01-01 00:00:00"),
                                                            metadata),
                                                          CatalogueEntity("uuid2", "file_type2",
                                                             Timestamp.valueOf("2021-01-01 00:00:00"),
                                                             metadata))

    (stubCatalogueDAO.readById _).when("uuid1").returns(List())
    (mockViewUtils.dropColumnsFromView _).expects(*, List("entity", "metadata")).returning(()).once()
    val service = new SparkExportAllResolutionsService(mockSparkResolveService, mockSparkExportService, stubCatalogueDAO, mockViewUtils)
    val caught = intercept[SparkExportServiceException] {
      service.resolveAndExport(msg)
    }
    assert(caught.getMessage.contains("No catalogue entity found"))
  }

  "SparkExpAllResServiceTest: case read from catalogueDAO" should "not throw Exception" in {
    val fileType = "test1"
    val datasetName = "test_dataset"
    val metadata =  List(MetadataEntry("file_type", fileType, "String", "domain"),
                         MetadataEntry("dataset_name", datasetName , "String", "domain"))
    val catalogueEntityList: List[CatalogueEntity] = List(CatalogueEntity("T12", fileType,
                                                            Timestamp.valueOf("2021-01-01 00:00:00"),
                                                            metadata),
                                                          CatalogueEntity("T22", fileType,
                                                             Timestamp.valueOf("2021-01-01 00:00:00"),
                                                             metadata))

    (stubCatalogueDAO.readById _).when("T12").returns(List(catalogueEntityList(0)))
    (stubCatalogueDAO.readById _).when("T22").returns(List(catalogueEntityList(1)))

    val criteria = ResolutionCriteria(file_type = fileType)
    val msg = SparkExportAllResolutionsMessage(criteria,
                                              "target_bucket_name",
                                              "target_file_name",
                                              "export_format",
                                              "field_delimiter",
                                              true,
                                              1)
    def assertMsg(m: SparkResolveMessage) : Unit = {
      assert(m.criteria.file_type == fileType)
    }
    (mockSparkResolveService.resolve _).expects(argAssert(assertMsg _)).returning(()).once()
    val catalogueUuids = (List(CatalogueEntity("T12", "file_type_1", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr1", "val1", "string", null))),
      CatalogueEntity("T22", "file_type_2", Timestamp.valueOf("2021-01-01 00:00:00"), List(MetadataEntry("attr3", "val3", "string", null)))), "cat")
    (mockSparkResolveService.constructCatalogue4Uuids _).expects(criteria, true).returning(catalogueUuids).once()

    def assertExportMsg(m: SparkExportMessage ) : Unit = {
      assert(m.metadata.get.size == 3)
      assert(m.metadata.get(0).attribute == "file_type")
      assert(m.metadata.get(0).value == fileType)
      assert(m.metadata.get(0).data_type == "String")
      assert(m.metadata.get(0).domain == "domain")

      assert(m.metadata.get(2).attribute == "record_count")
      assert(m.metadata.get(2).value == "1")
      assert(m.metadata.get(2).data_type == "Long")
    }

    (mockSparkExportService.export _).expects(argAssert(assertExportMsg _)).returning(()).twice()

    def assertQuery(query: String) : Unit = {
      assert(query.contains(catalogueUuids._1(0).entity_uuid) || query.contains(catalogueUuids._1(1).entity_uuid))
    }
    (mockViewUtils.loadViewFromQuery _).expects(argAssert(assertQuery _), *).returning(()).twice()
    (mockViewUtils.dropView _).expects(*).returning(()).twice()
    (mockViewUtils.viewRecordCount _).expects(*).returning(1).twice()
    (mockViewUtils.dropColumnsFromView _).expects(*, List("entity", "metadata")).returning(()).once()
    val service = new SparkExportAllResolutionsService(mockSparkResolveService, mockSparkExportService, stubCatalogueDAO, mockViewUtils)
    service.resolveAndExport(msg)
  }
}
package hsbc.emf.command

import java.io.File

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.resolution.ResolutionCriteria
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.commons.io.FileUtils
import org.apache.spark.sql.SaveMode

// Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11063,there is conflict between SPARK-EXPORT-ALL-RESOLUTIONS and
//(SPARK-RESOLVE/SPARK-RESOLVE-FROM-INPUT-REQUIREMENTS/SPARK-CREATE-TABLE). Comment this unit tests to pass CI

//class SparkExportAllResolutionsTest extends IntegrationTestSuiteBase {
//import spark.implicits._
//val testDbFailedCase = "spark_exp_all_2"
//val testDbExpCase = "spark_exp_all_1"
//val testInputTable = EmfConfig.defaultAccessView
//val temporaryBucketName = "SparkExportAllResolutions"
//
//
//override def beforeAll(): Unit = {
//  super.beforeAll()
//  spark.sql(s"create database if not exists ${testDbExpCase}")
//  spark.sql(s"create database if not exists ${testDbFailedCase}")
//}
//
//override def afterAll(): Unit = {
//  FileUtils.deleteDirectory(new File(temporaryBucketName.split("/")(0)))
//  spark.sql(s"DROP DATABASE IF EXISTS ${testDbExpCase} CASCADE")
//  spark.sql(s"DROP DATABASE IF EXISTS ${testDbFailedCase} CASCADE")
//  super.afterAll()
//}
//
//def traverseTree(file: File): Iterable[File] = {
//  val children = new Iterable[File] {
//    def iterator: Iterator[File] = if (file.isDirectory) file.listFiles.iterator else Iterator.empty
//  }
//  Seq(file) ++: children.flatMap(traverseTree(_))
//}
//
//def getFiles(path: String, ext: String): List[String] = {
//  val dir = new File(path)
//  var files: List[String] = List()
//  for(entry <- traverseTree(dir)) {
//    if (entry.getName.endsWith(ext)) {
//      files :+= entry.getAbsolutePath
//    }
//  }
//  files
//}
//
//"SparkExportAllResolutionsTest: given invalid params to SparkExportAllResolutions run" should "return Failed" in {
//  assert ((new SparkExportAllResolutions(ResolutionCriteria(file_type = ""), "a", "b", "c", "d", true, 1)).run() == Failed)
//  assert ((new SparkExportAllResolutions(ResolutionCriteria(file_type = null), "a", "b", "c", "d", true, 1)).run() == Failed)
//  assert ((new SparkExportAllResolutions(ResolutionCriteria(file_type = "a"), "", "b", "c", "d", true, 1)).run() == Failed)
//  assert ((new SparkExportAllResolutions(ResolutionCriteria(file_type = "b"), null, "b", "c", "d", true, 1)).run() == Failed)
//}
//
//"SparkExportAllResolutionsTest: case export data" should "return Complete" in {
//  val fileType = s"$testDbExpCase"
//
//  val catalogueData = spark.read
//    .format("csv")
//    .option("header", "true")
//    .option("delimiter", ",")
//    .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
//    .option("inferSchema", "true")
//    .option("nullValue", "null")
//    .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue6.csv")
//
//  catalogueData.write.mode(SaveMode.Overwrite)
//    .format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
//    .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
//
//  val t12DbTable = s"$testDbExpCase.T12"
//
//  val sample = s"""[{"entity_uuid": "${t12DbTable}","key": "10", "value": "ten"},{"entity_uuid": "${t12DbTable}","key": "20", "value": "twenty"}]"""
//  val df = spark.read.json(Seq(sample).toDS)
//  df.write.saveAsTable(s"$testDbExpCase.$testInputTable")
//
//  val criteria = ResolutionCriteria(file_type = fileType)
//  val metadata =  List(MetadataEntry("file_type", fileType, "String", ""))
//
//  val expAllCmd = new SparkExportAllResolutions(criteria = criteria,
//    targetBucketName = temporaryBucketName,
//    targetFileName = "sys_radar_sdi_cashflow_v01_00",
//    exportFormat = "csv",
//    fieldDelimiter = ",",
//    printHeader = true,
//    numberOfFiles = 1)
//  assert(expAllCmd.run == Complete)
//
//  val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00"
//  val filePaths: List[String] = getFiles(exportLocation, ".csv")
//  val filesAsDf = spark.read.format("csv")
//    .options(Map("header" -> "true", "delimiter" -> ","))
//    .load(filePaths:_*)
//  assert(filesAsDf.count == 2)
//  assert(filesAsDf.except(df).count == 0)
//}
//
//"SparkExportAllResolutionsTest: export unknown entity_uuid" should "return Complete with zero records" in {
//  val fileType = s"$testDbFailedCase"
//
//  val catalogueData = spark.read
//    .format("csv")
//    .option("header", "true")
//    .option("delimiter", ",")
//    .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
//    .option("inferSchema", "true")
//    .option("nullValue", "null")
//    .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue7.csv")
//
//  catalogueData.write.mode(SaveMode.Overwrite)
//    .format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
//    .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
//
//  val sample = s"""[{"entity_uuid": "xyz","key": "10", "value": "ten"},{"entity_uuid": "xyz","key": "20", "value": "twenty"}]"""
//  val df = spark.read.json(Seq(sample).toDS)
//  df.write.saveAsTable(s"$testDbFailedCase.$testInputTable")
//
//
//  val criteria = ResolutionCriteria(file_type = fileType)
//  val metadata =  List(MetadataEntry("file_type", fileType, "String", ""))
//
//  val expAllCmd = new SparkExportAllResolutions(criteria = criteria,
//    targetBucketName = temporaryBucketName,
//    targetFileName = "sys_radar_sdi_cashflow_v01_00/csv",
//    exportFormat = "csv",
//    fieldDelimiter = ",",
//    printHeader = true,
//    numberOfFiles = 1)
//  assert(expAllCmd.run == Complete)
//  val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/csv"
//  val filePaths: List[String] = getFiles(exportLocation, ".csv")
//  val filesAsDf = spark.read.format("csv")
//    .options(Map("header" -> "true", "delimiter" -> ","))
//    .load(filePaths:_*)
//  assert(filesAsDf.count == 0)
//}
//}
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.ingestion.MetadataEntry

case class SparkExportMessage(sourceDatasetName: Option[String],
                              sourceTableName: String,
                              exportFormat: String = "csv",
                              fieldDelimiter: String = ",",
                              printHeader: Boolean = true,
                              targetFileName: Option[String],
                              targetBucketName: Option[String],
                              targetFilePath: Option[String],
                              numberOfFiles: Int = 0,
                              metadata: Option[List[MetadataEntry]] = Some(List.empty[MetadataEntry]),
                              metaQuery: Option[String],
                              tokenFileName: Option[String]
                             )
  extends ISparkCommandMessage
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkExportMessageRaw(source_dataset_name: Option[String],
                                 source_table_name: String,
                                 export_format: String = "csv",
                                 field_delimiter: String = ",",
                                 print_header: Boolean = true,
                                 target_file_name: Option[String],
                                 target_bucket_name: Option[String],
                                 target_file_path: Option[String],
                                 number_of_files: Int = 0,
                                 metadata: Map[String, String] = Map.empty[String, String],
                                 meta_query: Option[String],
                                 token_file_name: Option[String])
  extends ISparkCommandMessage
package hsbc.emf.service.export

import java.time.LocalDateTime

import hsbc.emf.dao.ingestion.{ICatalogueDAO, LoadInfoDAO}
import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkExportMessage
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.{MissingLoadInfo, SparkExportServiceException}
import hsbc.emf.infrastructure.helper.{CloudTypeUtils, FileUtility, MetadataHelper}
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.sql.ISqlExecutor
import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.functions.col

//scalastyle:off cyclomatic.complexity
//scalastyle:off caselocale

class SparkExportService(sqlExecutor: ISqlExecutor, catalogueDAO: ICatalogueDAO)
                        (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkExportService with MessageContext {

  override def export(message: SparkExportMessage): Unit = {
    import spark.implicits._
    try {
      // 1) Check Catalog for source_database_name and sourceTableName exists?
      if (checkTableInCatalogue(message.sourceDatasetName, message.sourceTableName)) {
        val dbTableName = message.sourceDatasetName match {
          case Some(dbName) => dbName + "." + message.sourceTableName
          case None => message.sourceTableName
        }
        // 2) Read source table into DataFrame
        var tableDF = sqlExecutor.execute(s"select * from $dbTableName")
        if (tableDF.columns.contains(EmfConfig.runtime_uuid_column)) {
          tableDF = tableDF.drop(EmfConfig.runtime_uuid_column)
        }

        // 3) Create path for files
        val separator = "/"
        val fileLocation = message.targetFilePath match {
          case Some(value) => {
            val path = value.replace("/*","")
            CloudTypeUtils.prependFsProtocol(message.targetBucketName.get, EmfConfig.cloudType) + separator + path
          }
          case None => {
            val fileName = message.sourceTableName
            val localTime = LocalDateTime.now().toString.replace(":", "_")
            var uniquePath = ""
            if (message.metadata.isDefined) {
              val dbName = message.metadata.get.filter(m => m.attribute.toLowerCase() == "dataset_name")
              uniquePath =
                if (dbName.nonEmpty) {
                  dbName.head.value
                }
                else {
                  generateEntityUUID()
                }
            } else if (message.sourceDatasetName.isDefined) {
              uniquePath = message.sourceDatasetName.get
            }
            else {
              uniquePath = generateEntityUUID()
            }
            // fileLocation value will be in the format A/Timestamp/UniqueUUID/B , where A=targetFilename and B=sourceTableName
            //and the name of the export files will start from sourceTableName
            CloudTypeUtils.prependFsProtocol(message.targetBucketName.get, EmfConfig.cloudType) + separator +
              message.targetFileName.get + separator + localTime + separator + uniquePath + separator + fileName
          }
        }

        // 4) Save the table DF to fileLocation
        val fileFormatConfig = message.exportFormat.toLowerCase match {
          case "avro" => AvroFileFormatConfig()
          case "json" => JsonFileFormatConfig()
          case "orc" => OrcFileFormatConfig()
          case "parquet" => ParquetFileFormatConfig()
          case "csv" => {

            // fccc-12125, as discussed with service line
            // It is a normal case that load info may not exist. so we can't do it in the current way, we need to backout the change in the coming release

            /*//fccc-11897,fccc-11954, export quote character setting should align with file_type setting.
            val exportFileType = message.metadata.get.filter(m => m.attribute.toLowerCase() == "file_type")
            if (exportFileType.isEmpty) EmfLogger.warn("SparkExportService cannot find file_type in metadata")
            val exportLoadInfoEntry = new LoadInfoDAO(sqlExecutor).readByType(exportFileType.head.value)
            val catalogueLoadInfo = exportLoadInfoEntry match {
              case Some(_) => exportLoadInfoEntry.get
              case None => throw new MissingLoadInfo(s" export file type '$exportFileType' does not exists!!! ")
            }

            val quoteCharacter = catalogueLoadInfo.fileFormatConfig match {
              case csvConfig: CsvFileFormatConfig => csvConfig.quoteCharacter
              case _ => ""
            }
            CsvFileFormatConfig(delimiter = message.fieldDelimiter, printHeader = message.printHeader, quoteCharacter = quoteCharacter )
            */


            CsvFileFormatConfig(delimiter = message.fieldDelimiter, printHeader = message.printHeader)
          }
          case _ => val customMessage = s"SparkExportService.export fails to export: invalid exportFormat:" +
            s"${message.exportFormat}"
            EmfLogger.error(customMessage)
            throw new SparkExportServiceException(customMessage, None.orNull)
        }
        val numberOfFiles = if (message.numberOfFiles > 0) Some(message.numberOfFiles) else None
        val fileCfsConfig = FileCfsConfig(List[String](), fileLocation, numberOfFiles)
        new DataFrameWriterService(fileFormatConfig).save(tableDF, fileCfsConfig)

        // 5) Rename all part* files to fileName
        FileUtility.renameFiles(fileLocation, message.exportFormat.toLowerCase, message.sourceTableName, isMetadataFile = false)

        // 6) Write __metadata_chunk_token__
        var metaQueryList: List[MetadataEntry] = List.empty[MetadataEntry]
        if (message.metaQuery.getOrElse("").trim.length > 0) {
          val metaDF = sqlExecutor.execute(message.metaQuery.get)
          if (metaDF.count() > 0) {
            if (metaDF.count() != metaDF.select(metaDF.columns.slice(0, 1).map(m => col(m)): _*).distinct().count()) {
              val customMessage = s"SparkExportService.export fails to export: invalid metaQuery - duplicated attribute field return. metaQuery: " + s"${message.metaQuery}"
              EmfLogger.error(customMessage)
              throw new SparkExportServiceException(customMessage, None.orNull)
            }
            if (metaDF.schema.fields.length < 2) {
              val customMessage = s"SparkExportService.export fails to export: invalid metaQuery - insufficient columns return. metaQuery: " + s"${message.metaQuery}"
              EmfLogger.error(customMessage)
              throw new SparkExportServiceException(customMessage, None.orNull)
            }
            metaQueryList = MetadataHelper.convertMetadata(metaDF.select(metaDF.columns.slice(0, 2).map(m => col(m)): _*).as[(String, String)].collect.toMap)
          }
        }

        val metadataList = message.metadata.getOrElse(List.empty[MetadataEntry])
        if (metadataList.nonEmpty || metaQueryList.nonEmpty) {
          // FCCC-10844: Bug Fix for 10828: New attributes add into Catalogue -SPARK-EXPORT
          val runtimeMetadataList = MetadataHelper.convertMetadata(Map("export_run_uuid" -> messageInfo.runUUID))
          catalogueDAO.writeMetadataFile(metadataList ::: metaQueryList ::: runtimeMetadataList, fileLocation, message.tokenFileName)
        }
        else
          EmfLogger.info(s"SparkExportService.export: No metadata file is created as metadataList" +
            s" is empty = ${message.metadata} and metaQuery is empty = ${message.metaQuery}")

      }
      else {
        EmfLogger.error(s"SparkExportService.export fails to export: source database " +
          s"${message.sourceDatasetName} and table ${message.sourceTableName} not found in catalog ")
        throw new SparkExportServiceException(s"SparkExportService.export fails to export: source database " +
          s"${message.sourceDatasetName} and table ${message.sourceTableName} not found in catalog ", None.orNull)
      }

    }
    catch {
      case e: Exception =>
        EmfLogger.error(s"SparkExportService.export fails to export with message $message  : ${e.getMessage}")
        throw new SparkExportServiceException(s"SparkExportService.export fails to export with message $message  :" +
          s"${e.getMessage}", e.getCause)
    }
  }

  private def checkTableInCatalogue(datasetName: Option[String], tableName: String): Boolean = {
    datasetName match {
      case Some(dbName) => spark.catalog.tableExists(dbName, tableName)
      case None => spark.catalog.tableExists(tableName)
    }
  }

}
package hsbc.emf.service.export

import java.io.File

import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.ingestion.MetadataEntry
import hsbc.emf.data.sparkcmdmsg.SparkExportMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.SparkExportServiceException
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.commons.io.FileUtils
import org.scalamock.scalatest.MockFactory
import org.apache.spark.sql.{DataFrame, SaveMode}
import org.apache.spark.sql.types._
import org.apache.spark.sql.functions.lit

class SparkExportServiceTest extends IntegrationTestSuiteBase with MockFactory {
  val testInputDataset = "test_input_dataset"
  val testInputTable = "RADAR_SDI_CASHFLOW_GB_FINAL"
  val temporaryBucketName = "SparkExport"
  val metadata = MetadataEntry("file_type", "fotc_carm_f_fac_snapshot_v08_00", "STRING", "")
  val autoExportMetadataCount = 1
  private val mockSqlExecutor = mock[SqlExecutor]
  val simpleSchema = StructType(Array(
    StructField("stringFld", StringType, true),
    StructField("binaryFld", BooleanType, false),
    StructField("intFld", IntegerType, true),
    StructField("floatFld", DoubleType, true),
    StructField("decimalFld", DecimalType(38, 18), true),
    StructField("dateFld", DateType, true),
    StructField("dateTimeFld", TimestampType, true)
  ))

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database  if not exists $testInputDataset")
    dataDF.write.mode(SaveMode.Overwrite).saveAsTable(s"$testInputDataset.$testInputTable")
  }

  override def afterAll(): Unit = {
    FileUtils.deleteDirectory(new File(temporaryBucketName.split("/")(0)))
    spark.sql(s"DROP DATABASE IF EXISTS $testInputDataset CASCADE")
    super.afterAll()
  }

  def traverseTree(file: File): Iterable[File] = {
    val children = new Iterable[File] {
      def iterator: Iterator[File] = if (file.isDirectory) file.listFiles.iterator else Iterator.empty
    }
    Seq(file) ++: children.flatMap(traverseTree(_))
  }

  def getFiles(path: String, ext: String): List[String] = {
    val dir = new File(path)
    var files: List[String] = List()
    for (entry <- traverseTree(dir)) {
      if (entry.getName.endsWith(ext)) {
        files :+= entry.getAbsolutePath
      }
    }
    files
  }

  def dataDF: DataFrame = {
    spark.read.format("csv")
      .options(Map("header" -> "false", "delimiter" -> "|"))
      .schema(simpleSchema)
      .load("tests/hsbc/emf/testingFiles/service/export/file.csv")
  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
//  "Success case 1: given a valid sparkExportMessage with csv exportFormat" should "export csv file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "csv", "|",
//      printHeader = true, Some("sys_radar_sdi_cashflow_v01_00/csv1"), Some(temporaryBucketName), 3, Some(List(metadata)), None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/csv1"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/csv1/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".csv")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//    val filesAsDf = spark.read.options(Map("header" -> "true", "delimiter" -> "|")).format("csv")
//      .schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("csv")).length == 3)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 1.1: given a valid sparkExportMessage with csv exportFormat" should "export csv file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "csv", ",",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/csv2"), Some(temporaryBucketName), 3, Some(List(metadata)), None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/csv2"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/csv2/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".csv")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//    val filesAsDf = spark.read.options(Map("header" -> "false", "delimiter" -> ",")).format("csv")
//      .schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("csv")).length == 3)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 2: given a valid sparkExportMessage with json exportFormat" should "export json file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "json", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/json"), Some(temporaryBucketName), 2, Some(List(metadata)), None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/json/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/json"
//    val filePaths: List[String] = getFiles(exportLocation, ".json")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("json").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("json")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 3: given a valid sparkExportMessage with avro exportFormat" should "export avro file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "avro", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/avro"), Some(temporaryBucketName), 2, Some(List(metadata)), None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/avro"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/avro/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".avro")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("avro").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("avro")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 4: given a valid sparkExportMessage with parquet exportFormat" should "export parquet file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet1"), Some(temporaryBucketName), 2, Some(List(metadata)), None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet1"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet1/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 5: given a valid sparkExportMessage with no metadata" should "no metadata token file is generated" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet2"), Some(temporaryBucketName), 2, metaQuery = None)
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet2"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 0)
//  }
//
//  "Success case 6: given a valid sparkExportMessage with metadata and metaQuery sql string" should "export metadata token file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    val metaQuery = s"select 'file_type', 'fotc_carm_f_fac_snapshot_v08_01' union select 'file_type1', 'fotc_carm_f_fac_snapshot_v08_02'"
//    import spark.implicits._
//    val metaDF = Seq(("file_type", "fotc_carm_f_fac_snapshot_v08_01"), ("file_type1", "fotc_carm_f_fac_snapshot_v08_02")).toDF("keyColumn", "valueColumn")
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//    (mockSqlExecutor.execute _).expects(metaQuery).returning(metaDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet3"), Some(temporaryBucketName), 2, Some(List(metadata)), metaQuery = Some(metaQuery))
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet3"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet3/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + metaDF.count() + autoExportMetadataCount)
//  }
//
//  "Success case 6.1: given a valid sparkExportMessage with no metadata but metaQuery sql string" should "export metadata token file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    val metaQuery = s"select 'file_type', 'fotc_carm_f_fac_snapshot_v08_01'"
//
//    import spark.implicits._
//    val metaDF = Seq(("file_type", "fotc_carm_f_fac_snapshot_v08_01")).toDF("keyColumn", "valueColumn")
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//    (mockSqlExecutor.execute _).expects(metaQuery).returning(metaDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet4"), Some(temporaryBucketName), 2, None, metaQuery = Some(metaQuery))
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet4"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet4/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + autoExportMetadataCount)
//  }
//
//  "Success case 6.2: given a valid sparkExportMessage with no metadata but metaQuery empty sql string" should "no metadata token file is generated" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet5"), Some(temporaryBucketName), 2, metaQuery = Some(" "))
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet5"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 0)
//
//  }
//
//  "Success case 6.3: given a valid sparkExportMessage with integer data type in metaQuery sql string" should "export metadata token file successfully" in {
//    val query = s"select * from $testInputDataset.$testInputTable"
//    val metaQuery = s"select 'file_type', 0"
//    import spark.implicits._
//    val metaDF = Seq(("file_type", 0)).toDF("keyColumn", "valueColumn")
//    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
//    (mockSqlExecutor.execute _).expects(metaQuery).returning(metaDF).once()
//
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet6"), Some(temporaryBucketName), 2, Some(List(metadata)), metaQuery = Some(metaQuery))
//
//    val sparkExportService = new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//      .export(sparkExportMessage)
//
//    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet6"
//    val loadLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00/parquet6/*/*/RADAR_SDI_CASHFLOW_GB_FINAL/"
//    val filePaths: List[String] = getFiles(exportLocation, ".parquet")
//    val tokenFilePath: List[String] = getFiles(exportLocation, "")
//
//    val filesAsDf = spark.read.format("parquet").schema(simpleSchema).load(filePaths: _*)
//
//    assert(dataDF.except(filesAsDf).isEmpty)
//    assert(filePaths.filter(filePath => filePath.contains("RADAR_SDI_CASHFLOW_GB_FINAL") && filePath.endsWith("parquet")).length == 2)
//    assert(tokenFilePath.filter(filePath => filePath.endsWith(EmfConfig.real_meta_chunk_token)).length == 1)
//    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
//    //    assert(new MetaDataTextFileReaderToDF().read(MetaDataTextFileFormatConfig(), loadLocation, None).count() ==
//    //      List(metadata).length + metaDF.count() + autoExportMetadataCount)
//  }

  "Failure case 1 - give an invalid SparkExportMessage - table not found" should "throw exception" in {
    val sparkExportMessage = SparkExportMessage(Some(""), testInputTable, "", "",
      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet"), Some(temporaryBucketName), None, 2, Some(List(metadata)), None, tokenFileName = None)
    val caught = intercept[SparkExportServiceException] {
      new SparkExportService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
        .export(sparkExportMessage)
    }
    assert(caught.getMessage.contains(s"SparkExportService.export fails to export: source database" +
      s" Some() and table RADAR_SDI_CASHFLOW_GB_FINAL not found in catalog "))
  }


  "Failure case 2 - give an invalid SparkExportMessage - invalid exportFormat" should "throw exception" in {
    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "", "",
      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet"), Some(temporaryBucketName), None, 2, Some(List(metadata)), None, tokenFileName = None)
    val caught = intercept[SparkExportServiceException] {
      new SparkExportService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
        .export(sparkExportMessage)
    }
    assert(caught.getMessage.contains(s"SparkExportService.export fails to export: invalid exportFormat"))
  }

  "Failure case 3 - give an invalid SparkExportMessage - invalid metaQuery string" should "throw exception" in {
    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet"), Some(temporaryBucketName), None, 2, Some(List(metadata)), Some("sele1ct xxx"), tokenFileName = None)
    val caught = intercept[SparkExportServiceException] {
      new SparkExportService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
        .export(sparkExportMessage)
    }
    assert(caught != null)
  }
  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
//
//  "Failure case 4 - give an invalid SparkExportMessage - invalid metaQuery string - insufficient columns return" should "throw exception" in {
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet"), Some(temporaryBucketName), 2, Some(List(metadata)), Some("select 'file_type'"))
//    val caught = intercept[SparkExportServiceException] {
//      new SparkExportService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
//        .export(sparkExportMessage)
//    }
//    assert(caught.getMessage.contains(s"SparkExportService.export fails to export: invalid metaQuery"))
//  }
//
//  "Failure case 5 - give an invalid SparkExportMessage - invalid metaQuery string - duplicated attribute field return" should "throw exception" in {
//    val metaQuery = s"select 'file_type', '1' union (select 'file_type', '2')"
//    val sparkExportMessage = SparkExportMessage(Some(testInputDataset), testInputTable, "parquet", "",
//      printHeader = false, Some("sys_radar_sdi_cashflow_v01_00/parquet"), Some(temporaryBucketName), 2, Some(List(metadata)), metaQuery = Some(metaQuery))
//    val caught = intercept[SparkExportServiceException] {
//      new SparkExportService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
//        .export(sparkExportMessage)
//    }
//    assert(caught.getMessage.contains(s"SparkExportService.export fails to export: invalid metaQuery"))
//  }


//      "Success case 7: export a csv with delimiter and quote character in string field" should "export csv file successfully" in {
//        // test in local mode, remember to disable checkTableInCatalogue in SparkExportSercice
//        import spark.implicits._
//        val fileType = "test_csv_with_quote"
//        val testDataset = fileType
//        val sample =
//          s"""{
//             |"file_type":"${fileType}",
//             |"schema":"",
//             |"primary_key":"",
//             |"extension":"csv",
//             |"delimiter":",",
//             |"prefix":"",
//             |"skip_rows":"0",
//             |"dataset_name":"",
//             |"dynamic_flag":false,
//             |"max_bad_records":"0",
//             |"file_description":"",
//             |"file_category":"",
//             |"labels":[""],
//             |"write_disposition":"",
//             |"ingestion_workflow_name":"",
//             |"ingest_hierarchy":"",
//             | "ingestion_parameters":"",
//             | "allow_quoted_newlines":false, "entity_uuid":""
//             |}""".stripMargin
//        var loadInfoDF = spark.read.json(Seq(sample).toDS())
//        loadInfoDF = loadInfoDF
//          .withColumn("quote_character",lit("\""))
//          .withColumn("expiry_days",lit(1))
//          .withColumn("archive_days",lit(1))
//          .withColumn("schema_json",lit(
//            """[
//              |{"mode":"REQUIRED","name":"s1","type":"STRING"},
//              |{"mode":"REQUIRED","name":"s2","type":"STRING"}]""".stripMargin))
//
//
//        loadInfoDF.show(false)
//        val query = s"select * from $testDataset.data"
//        val testDF = spark.read.json(Seq("""{"s1":"\"\"abc\"\"","s2":"\"\"a,b,c\"\""}"""
//            .stripMargin).toDS())
//        // testDF.show()
//        (mockSqlExecutor.execute _).expects(query).returning(testDF).once()
//        val loadInfoQuery = s"""SELECT
//                                 | file_type, schema, primary_key, extension, delimiter,
//                                 | prefix, skip_rows, quote_character, dataset_name,
//                                 | dynamic_flag, max_bad_records, schema_json, file_description,
//                                 | file_category, labels, write_disposition, ingestion_workflow_name,
//                                 | ingest_hierarchy, expiry_days, archive_days, ingestion_parameters,
//                                 | allow_quoted_newlines, entity_uuid
//                                 | FROM ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultAccessView}""".stripMargin
//        (mockSqlExecutor.execute _).expects(loadInfoQuery).returning(loadInfoDF).once()
//        val loadInfoQuery2 = s"""select * from load_info_cache where upper(file_type)=upper('${fileType}')""".stripMargin
//        (mockSqlExecutor.execute _).expects(loadInfoQuery2).returning(loadInfoDF).once()
//
//        val sparkExportMessage = SparkExportMessage(Some(fileType), "data", "csv", ",", false, Some(s"${fileType}/csv2"), Some(temporaryBucketName), None,1, Some(List(MetadataEntry("file_type", fileType, "STRING", ""))),None,None)
//        new SparkExportService(mockSqlExecutor, new CatalogueDAO(mockSqlExecutor))
//          .export(sparkExportMessage)
//
//        val exportLocation = temporaryBucketName + s"/${fileType}/csv2"
//        val loadLocation = temporaryBucketName + s"/${fileType}/csv2/*/*/data/"
//        val filePaths: List[String] = getFiles(exportLocation, ".csv")
//        val schema = StructType(List(
//          StructField("s1", StringType),
//          StructField("s2", StringType)))
//        val filesAsDf = spark.read.options(Map("header" -> "false", "delimiter" -> ",")).format("csv")
//          .schema(schema).load(filePaths: _*)
//        testDF.show()
//
//        filesAsDf.show()
//        assert(testDF.except(filesAsDf).isEmpty)
//
//      }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.{LoadInfoRaw, MetadataEntry}
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.commons.io.FileUtils
import org.apache.spark.sql.SaveMode
import java.io.File

class SparkExportTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  val testInputDataset = "test_input_dataset"
  val testInputTable = "RADAR_SDI_CASHFLOW_GB_FINAL"
  val temporaryBucketName = "SparkExport"
  val optionalTokenName = "x__metadata_chunk_token__"

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists $testInputDataset")
    Seq(("row1a", "row1b", "row1c"), ("row2a", "row2b", "row2c")).toDF("colA", "colB", "colC")
      .write.mode(SaveMode.Overwrite).saveAsTable(s"$testInputDataset.$testInputTable")

    val loadInfoRawList = List(
      LoadInfoRaw(file_type = s"fotc_carm_f_fac_snapshot_v08_00", quote_character = Some(""),
      schema = Some("key:string"), delimiter = Some(","), skip_rows = Some("0"),
      extension = Some("csv"),
      ingest_hierarchy = Some(""),
      ingestion_parameters = Some("{}"),
      max_bad_records = Some("1"))
      ,
      LoadInfoRaw(file_type = s"sys_radar_sdi_cashflow_v01_00", quote_character = Some(""),
        schema = Some("key:string"), delimiter = Some(","), skip_rows = Some("0"),
        extension = Some("csv"),
        ingest_hierarchy = Some(""),
        ingestion_parameters = Some("{}"),
        max_bad_records = Some("1"))
      ,
      LoadInfoRaw(file_type = s"test_type", quote_character = Some(""),
        schema = Some("key:string"), delimiter = Some(","), skip_rows = Some("0"),
        extension = Some("csv"),
        ingest_hierarchy = Some(""),
        ingestion_parameters = Some("{}"),
        max_bad_records = Some("1")))
    import spark.implicits._
    loadInfoRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"load_info.access_view")


  }

  override def afterAll(): Unit = {
    FileUtils.deleteDirectory(new File(temporaryBucketName.split("/")(0)))
    spark.sql(s"drop database if exists $testInputDataset cascade")
    spark.sql(s"drop database if exists load_info cascade")
    super.afterAll()
  }

  "SparkExportTest: given invalid params to SparkExport run" should "return Failed" in {

    assert(new SparkExport(Some("a"), "", "b", ",", true,
      Some("c"), Some("d"), None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), null, "b", ",", true,
      Some("c"), Some("d"), None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      Some(""), Some("d"), None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      None, Some("d"), None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      Some("c"), Some(""), None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      Some("c"), None, None, 1, Some(List.empty[MetadataEntry]), None, None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      Some("c"), None, None, 1, Some(List.empty[MetadataEntry]), Some("s"), None).run() == Failed)

    assert(new SparkExport(Some("a"), "ab", "b", ",", true,
      Some("c"), None, None, 1, Some(List.empty[MetadataEntry]), Some("select abcd from abcd"), None).run() == Failed)
  }

  "SparkExportTest: given correct info to SparkExport run" should "return Complete" in {

    val metadata = MetadataEntry("file_type", "fotc_carm_f_fac_snapshot_v08_00", "STRING", "")
    assert(new SparkExport(Some(testInputDataset), testInputTable, "csv",
      "|", printHeader = true, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "json",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "avro",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "parquet",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "parquet",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, None, None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "parquet",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), Some(""), None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "parquet",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, None, Some("select 'file_type', 'fotc_carm_f_fac_snapshot_v08_01'"), None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "parquet",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), Some("select 'file_type', 'fotc_carm_f_fac_snapshot_v08_01'"), None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "orc",
      "", printHeader = false, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(Some(testInputDataset), testInputTable, "orc",
      "", printHeader = false, Some(""),
      Some(temporaryBucketName), None, 2, Some(List(metadata)), None, None).run() == Complete)

    assert(new SparkExport(sourceDatasetName = Some(testInputDataset), sourceTableName = testInputTable, exportFormat = "orc",
      fieldDelimiter = "", printHeader = false, targetBucketName = Some(temporaryBucketName), targetFilePath = None, targetFileName = None, numberOfFiles = 2, metadata = Some(List(metadata)), metaQuery = None, tokenFileName = None).run() == Complete)

    assert(new SparkExport(sourceDatasetName = Some(testInputDataset), sourceTableName = testInputTable, exportFormat = "orc",
      fieldDelimiter = "", printHeader = false, targetBucketName = None, targetFilePath = None, targetFileName = None, numberOfFiles = 2, metadata = Some(List(metadata)), metaQuery = None, tokenFileName = None).run() == Complete)

  }

  "SparkExportTest: given target_file_path parameter store files in given path" should "return Complete" in {
    val metadata = List(MetadataEntry("file_type", "test_type", "String", ""), MetadataEntry("exec_type", "test_exec_type", "String", ""))
    val status = new SparkExport(sourceDatasetName = Some(testInputDataset), sourceTableName = testInputTable, exportFormat = "csv",
      fieldDelimiter = ",", printHeader = false, targetBucketName = Some(temporaryBucketName), targetFilePath = Some("target/static_export_path/*"), targetFileName = None, metadata = Some(metadata), metaQuery = None, tokenFileName = None).run()
    assert(status == Complete)
    val outDf = spark.read.csv("SparkExport/target/static_export_path")
    val inputDf = spark.table(s"$testInputDataset.$testInputTable")
    assert(inputDf.except(outDf).isEmpty)
  }

  "SparkExportTest: given optional parameter token_file_name in parameter list" should "return Complete" in {
    val metadata = MetadataEntry("file_type", "fotc_carm_f_fac_snapshot_v08_00", "STRING", "token")
    assert(new SparkExport(Some(testInputDataset), testInputTable, "json",
      "|", printHeader = true, Some("sys_radar_sdi_cashflow_v01_00"),
      Some(temporaryBucketName), targetFilePath = Some("target/static_export_path/*"), 2, Some(List(metadata)), None, Some(optionalTokenName)).run() == Complete)

    val tokenPath = "SparkExport/target/static_export_path/x__metadata_chunk_token__"

    val tokenDF = spark.read.format("json").load(s"$tokenPath").as[MetadataEntry].collectAsList()

    assert(tokenDF.contains(metadata))



  }

}package hsbc.emf.infrastructure.io.readers

import hsbc.emf.infrastructure.config.{EmfConfig, FileFormatConfig}
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.infrastructure.spark.SparkSessionWrapper

import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.types.StructType

abstract class SparkFileReader[T <: FileFormatConfig](implicit val spark: SparkSession) extends IFileReader[T, DataFrame] with SparkSessionWrapper {

  @throws(classOf[EmfIoException] )
  def read(fileFormatConfig: T, fileLocation: String, schema: Option[StructType], modeFailfast: Boolean = false): DataFrame = {
    try {
      schema match {
        case None => spark.read.format(fileFormatConfig.format).load(s"$fileLocation/*.${fileFormatConfig.format}")
        case _ =>
          val optionsMap = if (modeFailfast) Map("mode" -> "FAILFAST") else Map("columnNameOfCorruptRecord" -> EmfConfig.columnNameOfCorruptRecord, "mode" -> "PERMISSIVE")
          spark.read.format(fileFormatConfig.format).options(optionsMap).schema(schema.get)
            .load(s"$fileLocation/*.${fileFormatConfig.format}")

      }
    } catch {
      case e: Throwable => throw new EmfIoException(e.getMessage, e.getCause)
    }
  }
}


package hsbc.emf.infrastructure.io.readers

import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.infrastructure.config.{AvroFileFormatConfig, CsvFileFormatConfig, FileFormatConfig, MetaDataTextFileFormatConfig}
import org.apache.spark.sql.types.StructType
import org.apache.spark.sql.{DataFrame, SparkSession}

/* Experimental */
object SparkFileReaderService {

  def apply[T <: FileFormatConfig](fileFormat: T)(implicit spark: SparkSession, messageInfo: MessageInfo): SparkFileReader[T] = fileFormat match {

    case csvConfig: CsvFileFormatConfig => new SparkFileReader[T] {
      val csvReader = new CsvFileReaderToDF()

      override def read(fileFormatConfig: T, fileLocation: String, schema: Option[StructType], modeFailfast:Boolean = false): DataFrame = csvReader.read(csvConfig, fileLocation, schema, modeFailfast)
    }
    case metaDataTextFileFormatConfig: MetaDataTextFileFormatConfig => new SparkFileReader[T] {
      val metaDataTextFileReader = new MetaDataTextFileReaderToDF()

      override def read(fileFormatConfig: T, fileLocation: String, schema: Option[StructType], modeFailfast: Boolean = false): DataFrame = metaDataTextFileReader.read(metaDataTextFileFormatConfig, fileLocation, schema, modeFailfast)
    }
    case avroConfig: AvroFileFormatConfig => new SparkFileReader[T] {
      val avroReader = new AvroFileReadertoDF()

      override def read(fileFormatConfig: T, fileLocation: String, schema: Option[StructType], modeFailfast:Boolean = false): DataFrame = avroReader.read(avroConfig, fileLocation, schema, modeFailfast)
    }

    case _ => new SparkFileReader[T] {}

  }

}
package hsbc.emf.infrastructure.io.readers

import hsbc.emf.infrastructure.config.{JsonFileFormatConfig, ParquetFileFormatConfig}
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkFileReaderServiceTest extends IntegrationTestSuiteBase {


  "given a valid json file path" should "read the file" in {
    val actualDF = spark.read.json("tests/hsbc/emf/testingFiles/*.json")
    val config = JsonFileFormatConfig()
    val dataFrameJson = SparkFileReaderService(config).read(config, "tests/hsbc/emf/testingFiles", None)
    assert(dataFrameJson != null)
    assert(actualDF.except(dataFrameJson).isEmpty)
  }

  "given a valid parquet file path" should "read the file" in {

    val actualDF = spark.read.format("parquet").load("tests/hsbc/emf/testingFiles/data.parquet/*.parquet")
    val config = ParquetFileFormatConfig()
    val dataFrameParquet = SparkFileReaderService(config).read(config, "tests/hsbc/emf/testingFiles", None)
    assert(dataFrameParquet != null)
    assert(actualDF.except(dataFrameParquet).isEmpty)

  }

}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.LoadInfoDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkIngestMessage
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.ingestion.{SparkCatalougeService, SparkCuratedStorageService, SparkIngestService}

import org.apache.spark.sql.SparkSession

class SparkIngest(val bucketCfs: String, val filePathInput: String)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    Try {
      val sparkIngestMessage = SparkIngestMessage(bucketCfs, filePathInput)
      new SparkIngestService(new LoadInfoDAO(new SqlExecutor()), new HiveRepair(), new SparkCuratedStorageService(), new SparkCatalougeService()).ingest(sparkIngestMessage)
      EmfLogger.info(s"SparkIngest command executed successfully for file(s) landed: $bucketCfs/$filePathInput")
    } match {
      case Success(_) => Complete
      case Failure(exception) => {
        ExceptionHandler.handle("SparkIngest command execution failed", exception)
        Failed
      }
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkIngestMessage(bucket_cfs: String, file_path_input: String) extends ISparkCommandMessagepackage hsbc.emf.service.ingestion

import scala.util.{Failure, Success, Try}
import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.{LoadInfo, MetadataEntry}
import hsbc.emf.data.logging._
import hsbc.emf.data.sparkcmdmsg.SparkIngestMessage
import hsbc.emf.infrastructure.config._
import hsbc.emf.infrastructure.exception.{EmfLoadInfoException, SparkIngestServiceException}
import hsbc.emf.infrastructure.helper._
import hsbc.emf.infrastructure.helper.HelperUtility.generateEntityUUID
import hsbc.emf.infrastructure.helper.SchemaUtility.mapStructType
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.io.readers.SparkFileReaderService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import org.apache.spark.sql.functions.{expr, lit}
import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}
import org.apache.spark.sql.types.{StringType, StructField, StructType}

class SparkIngestService(loadInfoDAO: ILoadInfoDAO, hiveRepair: HiveRepair, sparkCuratedStorageService: SparkCuratedStorageService, sparkCatalougeService: ISparkCatalougeService)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkIngestService with MessageContext {

  def ingest(message: SparkIngestMessage): Unit = {
    import spark.implicits._
    try {
      val uuid: String = generateEntityUUID()

      // 1) Read file name(s) and location
      val fileLocation = s"${CloudTypeUtils.prependFsProtocol(message.bucket_cfs, EmfConfig.cloudType)}/${message.file_path_input}"
      val config = MetaDataTextFileFormatConfig()
      val metaDataDF: DataFrame = SparkFileReaderService(config).read(config, fileLocation, None)
      var fileType: String = ""

      if (metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").count() > 0) {
        fileType = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").head.value
      } else {
        val customMessage = s"SparkIngestService.ingest there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token} at ${fileLocation}"
        EmfLogger.error(customMessage)
        throw new EmfLoadInfoException(customMessage)
      }

      // 2) LOAD_INFO entry exist?
      val loadInfo: LoadInfo = Try {
        loadInfoDAO.readByType(fileType).get // if it's not exists will throw the exception
      } match {
        case Success(value) => value
        case Failure(exception) => {
          ExceptionHandler.handle(s"No LoadInfo found for file_type '${fileType}' ", exception)
          throw exception
        }
      }

      // 3) Validate schema against LOAD_INFO
      // 4) Schema match?
      // 5) Record Count tag included?
      // 6) Perform select count check in Dataframe
      // 7) Record Count match？

      val recordCountDf = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "record_count")
      val recordCount: Long = if (recordCountDf.count > 0) recordCountDf.head.value.toLong else 0

      // When source file is csv(s), it's needed to read the file(s) with schema, otherwise, it fails the validaiton always. As for others (avro, parquet, json, orc), please make use of existing schema with file to do validation
      val loadInfoSchemaStructType = StructType(loadInfo.schema.schema.map(
        schemaItem => mapStructType(schemaItem.mode, schemaItem.name, schemaItem.`type`, schemaItem.fields,
          false)))
      var soureFileDF = loadInfo.fileFormatConfig match {
        case csvConfig: CsvFileFormatConfig =>
          SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, Some(loadInfoSchemaStructType), false)
        case jsonConfig: JsonFileFormatConfig =>
          if (fileType != null & fileType == EmfConfig.dimQueueFileType) {
            var transformedSourceFileDF = SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None, false)
            // align the schema for the ingested dim_queue dataframe
            val targetOrderTable = spark.table(s"${fileType}.${EmfConfig.defaultTableName}")
            for (missingColumn <- targetOrderTable.columns.toSet.diff(transformedSourceFileDF.columns.toSet)) {
              if (missingColumn != EmfConfig.defaultTablePartition) {
                transformedSourceFileDF = transformedSourceFileDF.withColumn(missingColumn, expr("null"))
              }
            }
            transformedSourceFileDF
          }
          else {
            if (SchemaUtility.checkSchemaContainTimestampOrDate(loadInfo.schema.schema)) {
              val schemaModified = getSchemaModified(loadInfo)
              val rawSourceFileDF = SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, Some(schemaModified), false)
              val repairDf = DataFrameUtils.cleanCorruptRow(rawSourceFileDF)
              DataFrameValueHandler.cleanAndCastTimeStampAndDate(loadInfo.schema.schema, repairDf)

              } else {
               DataFrameUtils.coalesceColumnsLoadDataFrameWithSchema(
                SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None, true),
                loadInfoSchemaStructType)
            }
          }
        case avroConfig: AvroFileFormatConfig =>
          SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None, false)

        case otherConfig => SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None, true)
      }

      val rowCountCol = "row_count"
      val rowCountDF = soureFileDF.withColumn(rowCountCol,lit("1")).select(rowCountCol)
      if (recordCount != rowCountDF.count) {
        EmfLogger.warn(s"SparkIngestService recordCount validation fails because " +
          s"${EmfConfig.spark_readable_meta_chunk_token} has recordCount as ${recordCount} while ${rowCountDF.count} for source files")
      }

      // 8) Load into Curated Storage & convert based on ingestion_parameters
      // FCCC-10908: remove the hive repair because of the refactor of ISparkCuratedStorageService


      if (loadInfo.isAdjustable.getOrElse(false)) {
        soureFileDF = DataFrameValueHandler.appendRowUUID(soureFileDF)
      }

      // curateFormatConfig is default to ParquetFileFormatConfig
      loadInfo.changeCurateFormatConfig(SchemaUtility.getTheCurateFormatBySchema(soureFileDF, loadInfo.curateFormatConfig))

      sparkCuratedStorageService.insert(loadInfo, soureFileDF, metaDataDF, uuid, SaveMode.Append)

      // 9) Write FCCC Metadata Catalogue entries
      // FCCC-10842: Bug Fix for 10828: New attributes add into Catalogue -SPARK-INGEST
      val extraMetadataMap = Map(
        "bucket" -> message.bucket_cfs,
        // FCCC-10932: Bug Fix for 10920: file_name to be full path including protocol, bucket and actual filename
        "file_name" -> metaDataDF.inputFiles(0),
        "run_uuid" -> messageInfo.runUUID,
        //fccc-11857
        "entity_uuid" -> uuid
      )

      val extraMetadataDF = MetadataHelper.convertMetadata(extraMetadataMap).toDF()
      sparkCatalougeService.write(metaDataDF.union(extraMetadataDF), uuid)

    } catch {
      case e: Exception =>
        val customMessage = s"SparkIngestService.ingest fails to perform ingestion with message ${message}  : ${e.getMessage}"
        EmfLogger.error(customMessage)
        throw new SparkIngestServiceException(customMessage, e.getCause)
    }
  }

  private def getSchemaModified(loadInfo: LoadInfo): StructType = {
    val structFieldList = loadInfo.schema.schema.map(schemaItem =>
      mapStructType(
        schemaItem.mode,
        schemaItem.name,
        schemaItem.`type`,
        schemaItem.fields,
        true)
    )
    addCorruptStructField(StructType(structFieldList))
  }

  private def addCorruptStructField(schema: StructType): StructType = {
    StructType(schema.+:( StructField( EmfConfig.columnNameOfCorruptRecord, StringType)))
  }

}
package hsbc.emf.service.ingestion

import scala.util.matching.Regex

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.sparkcmdmsg.SparkIngestMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, SparkIngestServiceException}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

import org.apache.spark.sql.SaveMode


class SparkIngestServiceTest extends IntegrationTestSuiteBase with MockFactory {
  val mockLoadInfoDAO = mock[ILoadInfoDAO]
  val mockSqlExecutor = mock[SqlExecutor]
  val mockSparkCatalougeService = mock[ISparkCatalougeService]
  var hiveRepair: HiveRepair = null
  var sparkIngestService4Validation: SparkIngestService = null
  var dimSchemaJsonString = ""
  val curateFileType = "curate_result"
  val uuidRegEx = new Regex("[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}")

  val defaultTableName = EmfConfig.defaultTableName
  val bucketCfs = "tests/hsbc/emf"
  val successCase1TestParquet001 = "success_case1_test_parquet001"
  val successCase1_1TestParquet001 = "success_case1_1_test_parquet001"
  val successCase1_2TestParquet001 = "success_case1_2_test_parquet001"
  val successCase2TestParquet001WithMismatchCount = "success_case2_test_parquet001_with_mismatch_count"
  val successCase3TestCsv001 = "success_case3_test_csv001"
  val successCase4TestCsv001 = "success_case4_test_csv001"
  val successCase5TestCsv001 = "success_case5_test_csv001"
  val successCase6TestAvro001 = "success_case6_test_avro001"
  val successCase6TestdimQueue001 = "dim_queue001"
  val successCase7TestdimQueue001 = "dim_queue002"
  val successCase8TestJson001 = "success_case8_test_json001"
  val successCase9TestParquet001 = "success_case9_test_parquet001"
  val successCase10TestOrc001 = "success_case10_test_orc001"
  val successCase11TestAvro001 = "success_case11_test_avro001"
  val successCase12TestDimQueue = "success_case12_test_dim_queue"
  val successCase13TestArrayColumn = "success_case13_test_array"
  val successCase13TestDateColumn = "success_case13_test_date"
  val successCase13TestStructColumn = "success_case13_test_struct"
  val successCase14TestDataInQuotes001 = "success_case14_test_data_in_quotes001"
  val successCase14TestDataInQuotes002 = "success_case14_test_data_in_quotes002"
  val successCase14TestDataInQuotes003Coalesce = "success_case14_test_data_in_quotes003_coalesce"
  val successCase14TestDataInQuotes004 = "success_case14_test_data_in_quotes004_csv"
  val failureCase1Test = "failure_case1_test"
  val failureCase2Test = "failure_case2_test"
  val failureCase3Test = "failure_case3_test"
  val failureCase4Test = "failure_case4_test"
  val failureCase7Test = "failure_case7_test"

  val testTopic = ""

  import spark.implicits._


  override def beforeAll(): Unit = {
    super.beforeAll()
    hiveRepair = new HiveRepair()
    sparkIngestService4Validation = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    spark.sql(s"create database if not exists ${EmfConfig.catalogueDatabaseName}")

    // case 1 prepartion: create db and table for file type 'success_case1_test_parquet001'
    spark.sql(s"create database if not exists ${successCase1TestParquet001}")
    spark.sql(s"create table if not exists ${successCase1TestParquet001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) stored as parquet")

    // case 1.1 prepartion: create db and table for file type 'success_case1_1_test_parquet001'
    spark.sql(s"create database if not exists ${successCase1_1TestParquet001}")
    spark.sql(s"create table if not exists ${successCase1_1TestParquet001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) stored as orc")

    // case 1.2 prepartion: create db and table for file type 'success_case1_2_test_parquet001'
    spark.sql(s"create database if not exists ${successCase1_2TestParquet001}")
    spark.sql(s"create table if not exists ${successCase1_2TestParquet001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp, `__uuid` String) partitioned by (entity_uuid String) stored as orc")

    // case 2 prepartion: create db and table for file type 'success_case2_test_parquet001_with_mismatch_count'
    spark.sql(s"create database if not exists ${successCase2TestParquet001WithMismatchCount}")
    spark.sql(s"create table if not exists ${successCase2TestParquet001WithMismatchCount}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) stored as parquet")

    // case 3 prepartion: create db and table for file type 'success_case3_test_csv'
    spark.sql(s"create database if not exists ${successCase3TestCsv001}")
    spark.sql(s"create table if not exists ${successCase3TestCsv001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) ROW FORMAT DELIMITED FIELDS TERMINATED BY '|' stored as textfile")

    // case 4 preparation: create db and table for file type 'success_case4_test_csv'
    spark.sql(s"create database if not exists ${successCase4TestCsv001}")
    spark.sql(s"create table if not exists ${successCase4TestCsv001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) ROW FORMAT DELIMITED FIELDS TERMINATED BY '|' stored as textfile")

    // case 5 preparation: create db and table for file type 'success_case5_test_csv'
    spark.sql(s"create database if not exists ${successCase5TestCsv001}")
    spark.sql(s"create table if not exists ${successCase5TestCsv001}.${defaultTableName} (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (reporting_date date, entity_uuid String) ROW FORMAT DELIMITED FIELDS TERMINATED BY '|' stored as textfile")

    spark.sql(s"create database if not exists ${successCase6TestAvro001}")
    spark.sql(s"create table if not exists ${successCase6TestAvro001}.${defaultTableName}(`cfs_scd_fle_rec_tcd` STRING, `cfs_legal_enty_cde` STRING, `cfs_sched_id` STRING, `cfs_sched_type_cde` STRING, `cfs_prod_srcsys_cd` STRING, `cfs_arr_id_char1` STRING, `cfs_sched_start_dt` DATE, `cfs_sched_end_dt` DATE, `cfs_insl_frq_nm_unit` BIGINT, `cfs_instl_pymt_uom` STRING, `cfs_instl_amt` DOUBLE, `cfs_insl_amt_ccy_cd` STRING, `cfs_csh_flow_dt_tcd` STRING, `cfs_cshflw_dt_ofs_nm` BIGINT, `cfs_int_accr_dy_ct` STRING, `cfs_int_type_cde` STRING, `cfs_int_cmpd_frq_cd` STRING, `cfs_pymt_dlay_cde` STRING, `cfs_npmt_dlay_dt` DATE, `bank_book_cflw_scd_leg_id` STRING, `bnk_bk_cflw_scd_leg_rc_id` STRING, `cfs_acct_dl_id_arr_src_sys_cde` STRING, `cfs_acct_deal_id_arr_lcl_num` STRING, `cfs_acct_deal_id_arr_suff_num` STRING, `cfs_arr_id` STRING) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")

    spark.sql(s"CREATE DATABASE IF NOT EXISTS testingdb")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.process_tasks}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testingdb.source_table")

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/orchestration/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    dimSchemaJsonString =
      """[ { "mode": "NULLABLE", "name": "msg_id", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "run_uuid", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "workflow", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "order_id", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "command", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "priority", "type": "INTEGER" },
        |{ "mode": "NULLABLE", "name": "parameters", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "created", "type": "TIMESTAMP" },
        |{ "mode": "NULLABLE", "name": "run_date", "type": "TIMESTAMP" },
        |{ "mode": "REPEATED", "name": "parents", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "description", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "topic", "type": "STRING" } ]""".stripMargin

    //Case 7
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${curateFileType}")
    val query =
      s"""create table if not exists ${curateFileType}.${EmfConfig.defaultTableName} (col_a String)
    partitioned by (entity_uuid String) stored as parquet"""
    spark.sql(query)

    // case 8 preparation: create db and table for file type 'success_case8_test_json'
    spark.sql(s"create database if not exists ${successCase8TestJson001}")
    spark.sql(s"create table if not exists ${successCase8TestJson001}.${defaultTableName} (`timestamp1` TIMESTAMP,`date1` DATE,`component` ARRAY<STRUCT<`timestamp3`: TIMESTAMP,`date3`: DATE,`alias`: STRING, `component_key_expression`: STRING, `join_clause`: STRING, `metric_expression`: STRING, `metric_name`: STRING, `source_table`: STRING, `where_condition`: STRING>>, `rule_expression` STRING, `rule_id` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `${EmfConfig.defaultTablePartition}` String) using json partitioned by (`${EmfConfig.defaultTablePartition}`)")

    // case 9 preparation: create db and table for file type 'success_case9_test_parquet'
    spark.sql(s"create database if not exists ${successCase9TestParquet001}")
    spark.sql(s"create table if not exists ${successCase9TestParquet001}.${defaultTableName} (`rule_id` STRING, `timestamp1` TIMESTAMP, `date1` DATE, `rule_expression` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `component` ARRAY<STRUCT<`source_table`: STRING, `component_key_expression`: STRING, `metric_name`: STRING, `alias`: STRING, `metric_expression`: STRING, `where_condition`: STRING, `timestamp3`: TIMESTAMP, `date3`: DATE, `join_clause`: STRING>>) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as parquet")

    // case 10 preparation: create db and table for file type 'success_case10_test_orc'
    spark.sql(s"create database if not exists ${successCase10TestOrc001}")
    spark.sql(s"create table if not exists ${successCase10TestOrc001}.${defaultTableName} (`rule_id` STRING, `timestamp1` TIMESTAMP, `date1` DATE, `rule_expression` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `component` ARRAY<STRUCT<`source_table`: STRING, `component_key_expression`: STRING, `metric_name`: STRING, `alias`: STRING, `metric_expression`: STRING, `where_condition`: STRING, `timestamp3`: TIMESTAMP, `date3`: DATE, `join_clause`: STRING>>) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 11 preparation: create db and table for file type 'success_case11_test_avro'
    spark.sql(s"create database if not exists ${successCase11TestAvro001}")
    spark.sql(s"create table if not exists ${successCase11TestAvro001}.${defaultTableName} (`rule_id` STRING, `timestamp1` TIMESTAMP, `date1` DATE, `rule_expression` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `component` ARRAY<STRUCT<`source_table`: STRING, `component_key_expression`: STRING, `metric_name`: STRING, `alias`: STRING, `metric_expression`: STRING, `where_condition`: STRING, `timestamp3`: TIMESTAMP, `date3`: DATE, `join_clause`: STRING>>) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as avro")

    // case 12 preparation: create db and table for file type 'success_case12_test_dim_queue'
    spark.sql(s"create database if not exists ${EmfConfig.dimQueueFileType}")
    spark.sql(s"create table if not exists ${EmfConfig.dimQueueFileType}.${defaultTableName} (msg_id String, run_uuid String, workflow String, order_id String, command String, priority String, parameters String, created Timestamp, run_date Timestamp, parents String, description String, topic String) using json")

    // case 13 preparation: create db and table for file type 'successCase13TestArrayColumn'
    spark.sql(s"create database if not exists ${successCase13TestArrayColumn}")
    spark.sql(s"create table if not exists ${successCase13TestArrayColumn}.${defaultTableName} (`component` ARRAY<STRUCT<`timestamp3`: TIMESTAMP,`date3`: DATE,`alias`: STRING, `component_key_expression`: STRING, `join_clause`: STRING, `metric_expression`: STRING, `metric_name`: STRING, `source_table`: STRING, `where_condition`: STRING>>, `rule_id` STRING, `${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 13 preparation: create db and table for file type 'successCase13TestStructColumn'
    spark.sql(s"create database if not exists ${successCase13TestStructColumn}")
    spark.sql(s"create table if not exists ${successCase13TestStructColumn}.${defaultTableName} (`component` STRUCT<`timestamp3`: TIMESTAMP,`date3`: DATE,`alias`: STRING, `component_key_expression`: STRING, `join_clause`: STRING, `metric_expression`: STRING, `metric_name`: STRING, `source_table`: STRING, `where_condition`: STRING>, `rule_id` STRING, `${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 13 preparation: create db and table for file type 'successCase13TestDateColumn'
    spark.sql(s"create database if not exists ${successCase13TestDateColumn}")
    spark.sql(s"create table if not exists ${successCase13TestDateColumn}.${defaultTableName} (`date3` DATE, `rule_id` STRING, `${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 14 preparation: create db and table for file type 'successCase14TestDataInQuotes001'
    spark.sql(s"create database if not exists ${successCase14TestDataInQuotes001}")
    spark.sql(s"CREATE TABLE IF NOT EXISTS ${successCase14TestDataInQuotes001}.${defaultTableName} " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches BIGINT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")

    spark.sql(s"create database if not exists ${successCase14TestDataInQuotes002}")
    spark.sql(s"CREATE TABLE IF NOT EXISTS ${successCase14TestDataInQuotes002}.${defaultTableName} " +
      "(string_type STRING, date_type date, " +
      "datatime_type TIMESTAMP, binary_type boolean, numeric_type Decimal(33,9),float_type double," +
      "long_type long, int_type integer, " +
      "array_type1 ARRAY<STRUCT<attribute: STRING, num: long, child_array_type: ARRAY<long>>>, " +
      "array_type2 ARRAY<long>, " +
      "struct_type STRUCT<attribute: STRING, num: long> " +
      ") stored as parquet")

    spark.sql(s"create database if not exists ${successCase14TestDataInQuotes003Coalesce}")
    spark.sql(s"CREATE TABLE IF NOT EXISTS ${successCase14TestDataInQuotes003Coalesce}.${defaultTableName} " +
      "(string_type STRING, " +
      "binary_type boolean, numeric_type Decimal(33,9),float_type double," +
      "long_type long, int_type integer, " +
      "array_type1 ARRAY<STRUCT<attribute: STRING, num: long, child_array_type: ARRAY<long>>>, " +
      "array_type2 ARRAY<long>, " +
      "struct_type STRUCT<attribute: STRING, num: long> " +
      ") stored as parquet")

    spark.sql(s"create database if not exists ${successCase14TestDataInQuotes004}")
    spark.sql(s"CREATE TABLE IF NOT EXISTS ${successCase14TestDataInQuotes004}.${defaultTableName} " +
      "(string_type STRING, binary_type boolean, numeric_type Decimal(33,9),float_type double," +
      "long_type long, int_type integer" +
      ") stored as parquet")

  }

  override def afterAll(): Unit = {
    //    spark.sql(s"drop database if exists ${EmfConfig.catalogueDatabaseName} cascade")
    spark.sql(s"drop database if exists ${successCase1TestParquet001} cascade")
    spark.sql(s"drop database if exists ${successCase1_1TestParquet001} cascade")
    spark.sql(s"drop database if exists ${successCase1_2TestParquet001} cascade")
    spark.sql(s"drop database if exists ${successCase2TestParquet001WithMismatchCount} cascade")
    spark.sql(s"drop database if exists ${successCase3TestCsv001} cascade")
    spark.sql(s"drop database if exists ${successCase4TestCsv001} cascade")
    spark.sql(s"drop database if exists ${successCase5TestCsv001} cascade")
    spark.sql(s"drop database if exists ${successCase8TestJson001} cascade")
    spark.sql(s"drop database if exists ${successCase9TestParquet001} cascade")
    spark.sql(s"drop database if exists ${successCase10TestOrc001} cascade")
    spark.sql(s"drop database if exists ${successCase11TestAvro001} cascade")
    spark.sql(s"drop database if exists ${successCase6TestAvro001} cascade")
    spark.sql(s"drop database if exists ${successCase13TestArrayColumn} cascade")
    spark.sql(s"drop database if exists ${successCase13TestStructColumn} cascade")
    spark.sql(s"drop database if exists ${successCase13TestDateColumn} cascade")
    spark.sql(s"drop database if exists ${successCase14TestDataInQuotes001} cascade")
    spark.sql(s"drop database if exists ${successCase14TestDataInQuotes002} cascade")
    spark.sql(s"drop database if exists ${successCase14TestDataInQuotes003Coalesce} cascade")
    spark.sql(s"drop database if exists ${successCase14TestDataInQuotes004} cascade")

    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.process_tasks} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS testingdb CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${curateFileType} CASCADE")
    super.afterAll()
  }

  "Success case 1: given a valid SparkIngestMessage - Source is Parquet, Target is Parquet" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase1TestParquet001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(12L))

    // 5. check system generated metadata
    assert((metadataTableDF.filter(metadataTableDF("attribute")=== "file_type").select("value").collect()(0).get(0))
      .equals(fileType))
    assert((metadataTableDF.filter(metadataTableDF("attribute")=== "bucket").select("value").collect()(0).get(0))
      .equals(bucketCfs))
    assert((metadataTableDF.filter(metadataTableDF("attribute")=== "run_uuid").select("value").count())
      .equals(1L))
    assert((metadataTableDF.filter(metadataTableDF("attribute")=== "file_name").select("value").collect()(0).getAs[String](0))
      .contains(filePathInput))
    assert((metadataTableDF.filter(metadataTableDF("attribute")=== "entity_uuid").select("value").collect()(0).get(0))
      .equals(
        metadataTableDF.first().getAs("entity_uuid")))

  }

  "Success case 1.1: given a valid SparkIngestMessage - Source is Parquet, Target is Orc" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase1_1TestParquet001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(13L))
  }

  "Success case 1.2: given a valid SparkIngestMessage - Source is Parquet (Adjustable), Target is Orc" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase1_2TestParquet001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"},
        |{"mode":"NULLABLE","name":"__uuid","type":"String"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"true"
         |,"curate_format":"orc"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(2L))
    assert(tableDF.select("__uuid").count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(13L))
  }

  "Success case 2: given a valid SparkIngestMessage - Source is Parquet, Target is Parquet & without record_count in token" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase2TestParquet001WithMismatchCount
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(38,18)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(12L))
  }

  "Success case 3: given a valid SparkIngestMessage - Source is Csv, Target is Csv" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase3TestCsv001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "csv"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"csv"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1"),
      delimiter = Some("|"),
      skip_rows = Some("0"),
      quote_character = Some("")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(1L))

    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(13L))
  }

  "Success case 4: given a valid SparkIngestMessage - Source is Csv, Target is Csv but with empty ingestion hierarchy" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase4TestCsv001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "csv"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"csv"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = fileType,
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = Some(""),
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1"),
      delimiter = Some("|"),
      skip_rows = Some("0"),
      quote_character = Some(""))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(1L))

    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(13L))
  }

  "Success case 5: given a valid SparkIngestMessage - Source is Csv, Target is Csv but with empty ingestion hierarchy and metadata partition field" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase5TestCsv001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "csv"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"csv"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = fileType,
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = Some("reporting_date"),
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1"),
      delimiter = Some("|"),
      skip_rows = Some("0"),
      quote_character = Some(""))
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing
    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(1L))

    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(13L))
  }

  "Failure case 1 - give an invalid SparkIngestMessage - invalid location" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${failureCase1Test}"
    val caught = intercept[SparkIngestServiceException] {
      new SparkIngestService(
        mockLoadInfoDAO,
        hiveRepair,
        new SparkCuratedStorageService(),
        new SparkCatalougeService()
      ).ingest(new SparkIngestMessage(bucketCfs, filePathInput))
    }
    assert(caught.isInstanceOf[SparkIngestServiceException])
    assert(caught.getMessage.contains(s"Path does not exist"))
  }

  "Failure case 2 - no file_type in present in token" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${failureCase2Test}"
    val caught = intercept[SparkIngestServiceException] {
      new SparkIngestService(
        mockLoadInfoDAO,
        hiveRepair,
        new SparkCuratedStorageService(),
        new SparkCatalougeService()
      ).ingest(new SparkIngestMessage(bucketCfs, filePathInput))
    }
    assert(caught.isInstanceOf[SparkIngestServiceException])
    assert(caught.getMessage.contains(s"there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token}"))
  }

  "Failure case 3 - no file_type exists in load_info.data table" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${failureCase3Test}"
    // 1. set the mockup object expectation
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${failureCase3Test}",
      schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"dummyFld\",\"type\":\"String\"}]"),
      extension = Some("parquet"),
      ingest_hierarchy = None,
      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    (mockLoadInfoDAO.readByType _).expects(failureCase3Test).throwing(new EmfLoadInfoDaoException(s"SparkIngestService.ingest there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} for '${failureCase3Test}'", new Throwable()))
    val caught = intercept[SparkIngestServiceException] {
      new SparkIngestService(
        mockLoadInfoDAO,
        hiveRepair,
        new SparkCuratedStorageService(),
        new SparkCatalougeService()
      ).ingest(new SparkIngestMessage(bucketCfs, filePathInput))
    }
    assert(caught.isInstanceOf[SparkIngestServiceException])
    assert(caught.getMessage.contains(s"there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}"))
  }

  //  "Failure case 4: give an invalid LoadInfo with mismatched schema" should "throw exception" in {
  //    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
  //    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${failureCase4Test}"
  //    val loadInfoRaw = LoadInfoRaw(
  //      file_type = s"${failureCase4Test}",
  //      schema_json = Some(
  //        """[
  //          |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
  //          |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(38,18)"},
  //          |{"mode":"NULLABLE","name":"intFld","type":"Long"},
  //          |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
  //          |{"mode":"NULLABLE","name":"dateFld","type":"Long"}
  //          |]""".stripMargin),
  //      extension = Some("parquet"),
  //      ingest_hierarchy = None,
  //      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
  //      max_bad_records = Some("1")
  //    )
  //    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
  //
  //    // 2. set the mockup object expectation
  //    (mockLoadInfoDAO.readByType _).expects(failureCase4Test).returning(Some(loadInfo)).once()
  //
  //    // 3. call the ingestion framework
  //    val caught = intercept[SparkIngestServiceException] {
  //      new SparkIngestService(
  //        mockLoadInfoDAO,
  //        hiveRepair,
  //        new SparkCuratedStorageService(),
  //        new SparkCatalougeService()
  //      ).ingest(new SparkIngestMessage(bucketCfs, filePathInput))
  //    }
  //    assert(caught.getMessage.contains(s"SparkIngestService.ingest fails to perform ingestion"))
  //  }


  "Success case 8: given a valid SparkIngestMessage with complex types -  Target is Json" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase8TestJson001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  //  "Success case 9: given a valid SparkIngestMessage with complex types  -  Target is Parquet" should "ingest successfully" in {
  //    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
  //    val fileType = successCase9TestParquet001
  //    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
  //    val sourceFormat = "parquet"
  //    val schemaJsonString =
  //      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
  //        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
  //        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
  //        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
  //        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
  //        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
  //        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
  //        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
  //        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
  //        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
  //        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
  //    val ingestionParametersString =
  //      s"""{
  //         |"is_adjustable":"false"
  //      }""".stripMargin
  //    val loadInfoRaw = LoadInfoRaw(
  //      file_type = s"${fileType}",
  //      schema_json = Some(schemaJsonString),
  //      extension = Some(sourceFormat),
  //      ingest_hierarchy = None,
  //      ingestion_parameters = Some(ingestionParametersString),
  //      max_bad_records = Some("1")
  //    )
  //    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
  //
  //    // 2. set the mockup object expectation
  //    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()
  //
  //    // 3. prepare a source file for the table ingestion testing
  //
  //    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
  //    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))
  //
  //    // 4. check record count for source table and catalogue table
  //    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
  //    assert(tableDF.count() == 2)
  //    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
  //    assert(metadataTableDF.count() == 4)
  //  }


  "Success case 10: given a valid SparkIngestMessage with complex types  -  Target is Orc" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase10TestOrc001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "orc"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  "Success case 11: given a valid SparkIngestMessage with complex types  -  Target is Avro" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase11TestAvro001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "avro"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"avro"
         |,"use_avro_logical_types": "true"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  "given a test case for fixing FCCC10812- Source is Avro, Target is Orc" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase6TestAvro001
    val filePathInput = s"testingFiles/spark_ingest_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString = """[{"mode": "NULLABLE", "name": "CFS_SCD_FLE_REC_TCD", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_LEGAL_ENTY_CDE", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_SCHED_ID", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_SCHED_TYPE_CDE", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_PROD_SRCSYS_CD", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_ARR_ID_CHAR1", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_SCHED_START_DT", "type": "DATE"}, {"mode": "NULLABLE", "name": "CFS_SCHED_END_DT", "type": "DATE"}, {"mode": "NULLABLE", "name": "CFS_INSL_FRQ_NM_UNIT", "type": "BIGINT"}, {"mode": "NULLABLE", "name": "CFS_INSTL_PYMT_UOM", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_INSTL_AMT", "type": "DOUBLE"}, {"mode": "NULLABLE", "name": "CFS_INSL_AMT_CCY_CD", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_CSH_FLOW_DT_TCD", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_CSHFLW_DT_OFS_NM", "type": "BIGINT"}, {"mode": "NULLABLE", "name": "CFS_INT_ACCR_DY_CT", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_INT_TYPE_CDE", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_INT_CMPD_FRQ_CD", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_PYMT_DLAY_CDE", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_NPMT_DLAY_DT", "type": "DATE"}, {"mode": "NULLABLE", "name": "BANK_BOOK_CFLW_SCD_LEG_ID", "type": "STRING"}, {"mode": "NULLABLE", "name": "BNK_BK_CFLW_SCD_LEG_RC_ID", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_ACCT_DL_ID_ARR_SRC_SYS_CDE", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_ACCT_DEAL_ID_ARR_LCL_NUM", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_ACCT_DEAL_ID_ARR_SUFF_NUM", "type": "STRING"}, {"mode": "NULLABLE", "name": "CFS_ARR_ID", "type": "STRING"}]"""
    val ingestionParametersString =
      s"""{"is_adjustable": "false", "use_avro_logical_types": true, "curate_format": "orc"}"""
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("0"),
      skip_rows = Some("1"),
      quote_character = Some("\""),
      delimiter = Some("|")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(!tableDF.isEmpty)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
  }

  "Success case 12: given a valid SparkIngestMessage with dim_queue as file_type" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = EmfConfig.dimQueueFileType
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${successCase12TestDimQueue}"
    val sourceFormat = "json"

    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count() == 1)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)

    // 5. check if missing columns are correctly set to "null" while existing columns are not wrongly set to "null"
    assert(tableDF.select("created").collect()(0).isNullAt(0))
    assert(tableDF.select("run_date").collect()(0).isNullAt(0))

    assert(tableDF.select("msg_id").collect()(0)(0) == "rules_engine_20210420_01")
  }

  "Success case 13.1: given a valid SparkIngestMessage with array type - Target should be identified as ORC" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase13TestArrayColumn
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")

    //
    //val path = spark.conf.get("spark.sql.warehouse.dir").concat(s"/${loadInfo.fileType}.db/${EmfConfig.defaultTableName}")
    //val tableDF1 = spark.read.orc(path)
    //tableDF1.show()
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  "Success case 13.2: given a valid SparkIngestMessage with struct type - Target should be identified as ORC" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase13TestStructColumn
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "NULLABLE"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")

    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  "Success case 13.3: given a valid SparkIngestMessage with date type - Target should be identified as ORC" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase13TestDateColumn
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date3", "mode": "NULLABLE"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")

    assert(tableDF.count() == 3)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count() == 5)
  }

  "Success case 14.1: ingest corrupt data" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase14TestDataInQuotes001
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"mode": "REQUIRED", "name": "file_type", "type": "STRING"},
        |{"mode": "REQUIRED", "name": "table_name", "type": "STRING"},
        |{"mode": "NULLABLE", "name": "created_to", "type": "TIMESTAMP"},
        |{"mode": "NULLABLE", "name": "created_from", "type": "TIMESTAMP"},
        |{"mode": "REQUIRED", "name": "latest_only", "type": "BOOLEAN"},
        |{"mode": "REQUIRED", "name": "min_matches", "type": "BIGINT"},
        |{"mode": "REPEATED", "name": "constraints", "type": "RECORD", "fields": [
        |   {"mode": "REQUIRED", "name": "attribute", "type": "STRING"},
        |   {"mode": "REQUIRED", "name": "operator", "type": "STRING"},
        |   {"mode": "REQUIRED", "name": "value", "type": "STRING"}
        |   ]},
        |{"mode": "NULLABLE", "name": "source_entity_type", "type": "STRING"},
        |{"mode": "REPEATED", "name": "where_clause", "type": "RECORD", "fields": [
        |   {"mode": "REQUIRED", "name": "attribute", "type": "STRING"},
        |   {"mode": "REQUIRED", "name": "operator", "type": "STRING"},
        |   {"mode": "REQUIRED", "name": "value", "type": "STRING"}]}]
        |
      """.stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format": "json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(7L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(7L))
  }

  "Success case 14.2: ingest corrupt complex data" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase14TestDataInQuotes002
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"mode": "REQUIRED", "name": "string_type", "type": "STRING"},
        |{"mode": "NULLABLE", "name": "date_type", "type": "DATE"},
        |{"mode": "NULLABLE", "name": "datatime_type", "type": "TIMESTAMP"},
        |{"mode": "REQUIRED", "name": "binary_type", "type": "BOOLEAN"},
        |{"mode": "REQUIRED", "name": "numeric_type", "type": "DECIMAL(33,9)"},
        |{"mode": "NULLABLE","name":  "float_type","type":"Double"},
        |{"mode": "NULLABLE","name":  "long_type","type":"Long"},
        |{"mode": "NULLABLE","name":  "int_type","type":"Integer"},
        |{"mode":"REPEATED","name":"array_type1","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"num","type":"LONG"},
        |   {"mode":"REPEATED","name":"child_array_type","type":"LONG"}
        |   ]},
        |{"mode":"REPEATED","name":"array_type2","type":"Long"},
        |{"mode":"REQUIRED","name":"struct_type","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"num","type":"LONG"}
        |   ]}
        |]
        |
        """.stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format": "json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")

    assert(tableDF.count().equals(1L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(7L))
  }

  "Success case 14.3: ingest corrupt complex coalesce " should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ArrayType./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase14TestDataInQuotes003Coalesce
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"mode": "REQUIRED", "name": "string_type", "type": "STRING"},
        |{"mode": "REQUIRED", "name": "binary_type", "type": "BOOLEAN"},
        |{"mode": "REQUIRED", "name": "numeric_type", "type": "DECIMAL(33,9)"},
        |{"mode": "NULLABLE","name":  "float_type","type":"Double"},
        |{"mode": "NULLABLE","name":  "long_type","type":"Long"},
        |{"mode": "NULLABLE","name":  "int_type","type":"Integer"},
        |{"mode":"REPEATED","name":"array_type1","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"num","type":"LONG"},
        |   {"mode":"REPEATED","name":"child_array_type","type":"LONG"}
        |   ]},
        |{"mode":"REPEATED","name":"array_type2","type":"Long"},
        |{"mode":"REQUIRED","name":"struct_type","type":"RECORD","fields":
        |   [{"mode":"REQUIRED","name":"attribute","type":"STRING"},
        |   {"mode":"REQUIRED","name":"num","type":"LONG"}
        |   ]}
        |]
        |
        """.stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format": "json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")

    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(7L))
  }


  "Success case 14.4: ingest corrupt csv data" should "ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/x__metadata_chunk_token__
    val fileType = successCase14TestDataInQuotes004
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "csv"
    val schemaJsonString =
      """[{"mode": "REQUIRED", "name": "string_type", "type": "STRING"},
        |{"mode": "REQUIRED", "name": "binary_type", "type": "BOOLEAN"},
        |{"mode": "REQUIRED", "name": "numeric_type", "type": "DECIMAL(33,9)"},
        |{"mode": "NULLABLE","name":  "float_type","type":"Double"},
        |{"mode": "NULLABLE","name":  "long_type","type":"Long"},
        |{"mode": "NULLABLE","name":  "int_type","type":"Integer"}
        |]
        |
        """.stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format": "json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1"),
      delimiter = Some("|"),
      skip_rows = Some("0"),
      quote_character = Some("\"")  // important
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from ${fileType}.${defaultTableName}")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='${fileType}'")
    assert(metadataTableDF.count().equals(7L))
  }


}package hsbc.emf.service.ingestion

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.sparkcmdmsg.SparkIngestMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode
import org.apache.spark.sql.types._
import org.scalamock.scalatest.MockFactory


class SparkIngestServiceTestPart2 extends IntegrationTestSuiteBase with MockFactory {
  val mockLoadInfoDAO = mock[ILoadInfoDAO]
  val mockSqlExecutor = mock[SqlExecutor]
  val mockSparkCatalougeService = mock[ISparkCatalougeService]
  var hiveRepair: HiveRepair = null
  var sparkIngestService4Validation: SparkIngestService = null
  val curateFileType = "curate_result"

  val defaultTableName = EmfConfig.defaultTableName
  val bucketCfs = "tests/hsbc/emf"
  val successCase15TestAvro001 = "success_case15_test_avro001"
  val successCase16TestAvro001 = "success_case16_test_avro001"
  val successCase17TestAvro001 = "success_case17_test_avro001"
  val successCase18TestAvro001 = "success_case18_test_avro001"

  val testTopic = ""

  override def beforeAll(): Unit = {
    super.beforeAll()
    hiveRepair = new HiveRepair()
    sparkIngestService4Validation = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    spark.sql(s"create database if not exists ${EmfConfig.catalogueDatabaseName}")

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/orchestration/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    // case 15 preparation: create db and table for file type 'success_case15_test_avro001'
    spark.sql(s"create database if not exists ${successCase15TestAvro001}")
    spark.sql(s"create table if not exists ${successCase15TestAvro001}.${defaultTableName}(`ARR_ID_CHAIN` LONG, `RANK_ACCT_NUM` integer, `SNAP_DT` integer, `SNAP_DT_TS` LONG, `ACCT_NUM` STRING) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 16 preparation: create db and table for file type 'success_case16_test_avro001'
    spark.sql(s"create database if not exists ${successCase16TestAvro001}")
    spark.sql(s"create table if not exists ${successCase16TestAvro001}.${defaultTableName}(`ARR_ID_CHAIN` LONG, `RANK_ACCT_NUM` integer, `SNAP_DT` DATE, `SNAP_DT_TS` TIMESTAMP, `ACCT_NUM` STRING) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 17 preparation: create db and table for file type 'success_case16_test_avro001'
    spark.sql(s"create database if not exists ${successCase17TestAvro001}")
    spark.sql(s"create table if not exists ${successCase17TestAvro001}.${defaultTableName}(`ARR_ID_CHAIN` LONG, `RANK_ACCT_NUM` integer, `SNAP_DT` integer, `SNAP_DT_TS` LONG, `ACCT_NUM` STRING) partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")

    // case 18 preparation: create db and table for file type 'success_case16_test_avro001'
    spark.sql(s"create database if not exists ${successCase18TestAvro001}")
    spark.sql(s"create table if not exists ${successCase18TestAvro001}.${defaultTableName} (`ACCT_NUM` string, `REP_MONTH` integer, `REC_TS` long, `ORG_CDE` STRING, `LOGO_CDE` string, `PD_SEG_CDE` integer, `PIT_EST` byte, `PILLR1_EST` byte, `PD_VAL` string, `LGD_SEG_CDE` string, `DISCNT_LGD` byte, `DWNTRN_LGD` byte, `LGD_VAL` byte, `EAD_SEG_CDE` string, `POOL_VALUE_EAD` byte, `CCF_EAD_DWNTRN_VAL` byte, `FINAL_POOL_VALUE_EAD` byte, `EAD_DWNTRN` byte, `EXPECTED_LOSS_AMT` byte, `ECONOMIC_LOSS_AMT` byte, `AVG_ACTUAL_LGD` byte)  partitioned by (`${EmfConfig.defaultTablePartition}` String) stored as orc")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists ${EmfConfig.catalogueDatabaseName} cascade")
    spark.sql(s"drop database if exists ${successCase15TestAvro001} cascade")
    spark.sql(s"drop database if exists ${successCase16TestAvro001} cascade")
    spark.sql(s"drop database if exists ${successCase17TestAvro001} cascade")
    spark.sql(s"DROP DATABASE IF EXISTS ${curateFileType} CASCADE")
    super.afterAll()
  }

  "given Source is Avro, No Use Logical Type in ingestion parametes, Type as Int/Long, Logical type as DATE/TIMESTAMP_MICROS and  Target is Orc" should "converted to Integer/Long and ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per x__metadata_chunk_token__
    val fileType = successCase15TestAvro001
    val filePathInput = s"testingFiles/spark_ingest_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString = """[{"mode": "NULLABLE", "name": "ARR_ID_CHAIN", "type": "LONG"}, {"mode": "NULLABLE", "name": "RANK_ACCT_NUM", "type": "integer"}, {"mode": "NULLABLE", "name": "SNAP_DT", "type": "integer"}, {"mode": "NULLABLE", "name": "SNAP_DT_TS", "type": "long"}, {"mode": "NULLABLE", "name": "ACCT_NUM", "type": "STRING"}]"""
    val ingestionParametersString =
      s"""{"is_adjustable": "false", "curate_format": "orc"}"""
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("0"),
      skip_rows = Some("1"),
      quote_character = Some("\""),
      delimiter = Some("|")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. assert datatype
    val tableDF = spark.sql(s"select SNAP_DT, SNAP_DT_TS from ${fileType}.${defaultTableName}")
    assert(!tableDF.isEmpty)
    assert(tableDF.schema("SNAP_DT").dataType.equals(IntegerType))
    assert(tableDF.schema("SNAP_DT_TS").dataType.equals(LongType))
  }

  "given Source is Avro, Use Logical Type is true, Type as Int/Long, Logical type as DATE/TIMESTAMP_MICROS and  Target is Orc" should "converted to date/timestamp and ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per x__metadata_chunk_token__
    val fileType = successCase16TestAvro001
    val filePathInput = s"testingFiles/spark_ingest_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString = """[{"mode": "NULLABLE", "name": "ARR_ID_CHAIN", "type": "LONG"}, {"mode": "NULLABLE", "name": "RANK_ACCT_NUM", "type": "integer"}, {"mode": "NULLABLE", "name": "SNAP_DT", "type": "DATE"}, {"mode": "NULLABLE", "name": "SNAP_DT_TS", "type": "TIMESTAMP"}, {"mode": "NULLABLE", "name": "ACCT_NUM", "type": "STRING"}]"""
    val ingestionParametersString =
      s"""{"is_adjustable": "false", "use_avro_logical_types": "true", "curate_format": "orc"}"""
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("0"),
      skip_rows = Some("1"),
      quote_character = Some("\""),
      delimiter = Some("|")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. assert datatype
    val tableDF = spark.sql(s"select SNAP_DT, SNAP_DT_TS from ${fileType}.${defaultTableName}")
    assert(!tableDF.isEmpty)
    assert(tableDF.schema("SNAP_DT").dataType.equals(DateType))
    assert(tableDF.schema("SNAP_DT_TS").dataType.equals(TimestampType))
  }

  "given Source is Avro, Use Logical Type is false, Type as Int/Long, Logical type as DATE/TIMESTAMP_MICROS and  Target is Orc" should "converted to Integer/Long and ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per x__metadata_chunk_token__
    val fileType = successCase17TestAvro001
    val filePathInput = s"testingFiles/spark_ingest_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString = """[{"mode": "NULLABLE", "name": "ARR_ID_CHAIN", "type": "LONG"}, {"mode": "NULLABLE", "name": "RANK_ACCT_NUM", "type": "integer"}, {"mode": "NULLABLE", "name": "SNAP_DT", "type": "integer"}, {"mode": "NULLABLE", "name": "SNAP_DT_TS", "type": "long"}, {"mode": "NULLABLE", "name": "ACCT_NUM", "type": "STRING"}]"""
    val ingestionParametersString =
      s"""{"is_adjustable": "false",  "use_avro_logical_types": "false", "curate_format": "orc"}"""
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("0"),
      skip_rows = Some("1"),
      quote_character = Some("\""),
      delimiter = Some("|")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. assert datatype
    val tableDF = spark.sql(s"select SNAP_DT, SNAP_DT_TS  from ${fileType}.${defaultTableName}")
    assert(!tableDF.isEmpty)
    assert(tableDF.schema("SNAP_DT").dataType.equals(IntegerType))
    assert(tableDF.schema("SNAP_DT_TS").dataType.equals(LongType))
  }

  "given Source is Avro, Use Logical Type is false, Type as bytes, Logical type as decimal and  Target is Orc" should "converted to bytes and ingest successfully" in {
    // 1. prepare dedicated LoadInfo object as per x__metadata_chunk_token__
    val fileType = successCase18TestAvro001
    val filePathInput = s"testingFiles/spark_ingest_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString =
      """[{"mode":"NULLABLE","name":"ACCT_NUM","type":"STRING"},{"mode":"NULLABLE","name":"REP_MONTH","type":"INT64"},
        |{"mode":"NULLABLE","name":"REC_TS","type":"INT64"},{"mode":"NULLABLE","name":"ORG_CDE","type":"STRING"},
        |{"mode":"NULLABLE","name":"LOGO_CDE","type":"STRING"},{"mode":"NULLABLE","name":"PD_SEG_CDE","type":"STRING"},
        |{"mode":"NULLABLE","name":"PIT_EST","type":"NUMERIC"},{"mode":"NULLABLE","name":"PILLR1_EST","type":"NUMERIC"},
        |{"mode":"NULLABLE","name":"PD_VAL","type":"STRING"},{"mode":"NULLABLE","name":"LGD_SEG_CDE","type":"STRING"},
        |{"mode":"NULLABLE","name":"DISCNT_LGD","type":"NUMERIC"},{"mode":"NULLABLE","name":"DWNTRN_LGD","type":"NUMERIC"},
        |{"mode":"NULLABLE","name":"LGD_VAL","type":"NUMERIC"},{"mode":"NULLABLE","name":"EAD_SEG_CDE","type":"STRING"},
        |{"mode":"NULLABLE","name":"POOL_VALUE_EAD","type":"NUMERIC"},{"mode":"NULLABLE","name":"CCF_EAD_DWNTRN_VAL","type":"NUMERIC"},
        |{"mode":"NULLABLE","name":"FINAL_POOL_VALUE_EAD","type":"NUMERIC"},{"mode":"NULLABLE","name":"EAD_DWNTRN","type":"NUMERIC"},
        |{"mode":"NULLABLE","name":"EXPECTED_LOSS_AMT","type":"NUMERIC"},{"mode":"NULLABLE","name":"ECONOMIC_LOSS_AMT","type":"NUMERIC"},
        |{"mode":"NULLABLE","name":"AVG_ACTUAL_LGD","type":"NUMERIC"}]""".stripMargin


    val ingestionParametersString =
      s"""{"is_adjustable": "false",  "use_avro_logical_types": "false", "curate_format": "orc"}"""
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("0"),
      skip_rows = Some("1"),
      quote_character = Some("\""),
      delimiter = Some("|")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. prepare a source file for the table ingestion testing

    val sparkIngestService = new SparkIngestService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(new SparkIngestMessage(bucketCfs, filePathInput))

    // 4. assert datatype
    val tableDF = spark.sql(s"select PIT_EST, PILLR1_EST  from ${fileType}.${defaultTableName}")
    assert(!tableDF.isEmpty)
    assert(tableDF.schema("PIT_EST").dataType.equals(ByteType))
    assert(tableDF.schema("PILLR1_EST").dataType.equals(ByteType))
  }
}package hsbc.emf.command

import java.io.File

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.{LoadInfoRaw, IngestionHierarchy}
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.infrastructure.config.EmfConfig
import org.apache.commons.io.FileUtils


class SparkIngestTest extends IntegrationTestSuiteBase {
  import spark.implicits._

  val successCase12TestJson001 = "success_case12_test_json001"
  val defaultTableName = EmfConfig.defaultTableName

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists $successCase12TestJson001")
    spark.sql(s"create table if not exists ${successCase12TestJson001}.${defaultTableName} (entity_uuid string, time DATE, _uuid STRING, id LONG) using parquet partitioned by (entity_uuid)")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists $successCase12TestJson001 cascade")
    super.afterAll()
  }

  "SparkIngestTest: given schema case mismatch in json" should "ingest successfully" in {

    val defaultTableName = EmfConfig.defaultTableName
    val bucketCfs = "tests/hsbc/emf"
    val fileType = "success_case12_test_json001"
    val filePathInput = s"/testingFiles/spark_ingest_mockup_data/${fileType}"
    val sourceFormat = "json"

    val ingestionParametersString =
      s"""{
       |"is_adjustable":"false"
       |,"curate_format":"parquet"
      }""".stripMargin

    val schemaJsonString =
      """[{"type": "STRING", "name": "_UUID", "mode": "NULLABLE"},
      | {"type": "STRING", "name": "Entity_uuid", "mode": "NULLABLE"},
      | {"type": "LONG", "name": "iD", "mode": "NULLABLE"},
      | {"type": "DATE", "name": "timE", "mode": "NULLABLE"}]""".stripMargin


    val loadInfoRaw = LoadInfoRaw(
    file_type = s"${fileType}",
    schema_json = Some(schemaJsonString),
    extension = Some(sourceFormat),
    ingest_hierarchy = None,
    ingestion_parameters = Some(ingestionParametersString),
    max_bad_records = Some("1"))

    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    val execResult = new SparkIngest(bucketCfs, filePathInput).run()
    assert(execResult == Complete)
    val dataDF =  spark.table(s"$fileType.$defaultTableName").select("_uuid", "entity_uuid", "id", "time")
    val actualDF = spark.read.json(s"$bucketCfs/$filePathInput/data.json")
    assert(dataDF.count == actualDF.count)
    assert(dataDF.except(actualDF).count == 0)
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.LoadInfoDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.loadtablefromfile.{SparkChunkedStorageService, SparkLoadTableFromFileService}

import org.apache.spark.sql.SparkSession

class SparkLoadTableFromFile(val bucketCfs: String,
                             val filePathInput: String,
                             val fileType: String,
                             val databaseName: String,
                             val tableName: String)
                            (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    val sparkLoadTableFromFileMessage = SparkLoadTableFromFileMessage(bucketCfs, filePathInput, fileType, tableName, databaseName)
    if (messageValidate(sparkLoadTableFromFileMessage)) {
      Try {
        new SparkLoadTableFromFileService(new LoadInfoDAO(new SqlExecutor()), new SparkChunkedStorageService()).loadTableFromFile(sparkLoadTableFromFileMessage)
        EmfLogger.info(s"SparkLoadTableFromFile command executed successfully for file(s) landed: $bucketCfs/$filePathInput")
      } match {
        case Success(_) => Complete
        case Failure(exception) => {
          ExceptionHandler.handle("SparkLoadTableFromFile command execution failed", exception)
          Failed
        }
      }
    } else {
      EmfLogger.error(s"SparkLoadTableFromFile command failed with error: Messages Validation failed. catalogue.data table load is restricted")
      Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkLoadTableFromFileMessage]
    msg.dataset_name != "catalogue" && msg.table_name != "data"
  }
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkLoadTableFromFileMessage (bucket: String, file_path: String,file_type:String,
                                          table_name: String,dataset_name:String ) extends ISparkCommandMessagepackage hsbc.emf.service.loadtablefromfile

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.{LoadInfo, MetadataEntry, Schema}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import hsbc.emf.infrastructure.config.{CsvFileFormatConfig, EmfConfig, MetaDataTextFileFormatConfig}
import hsbc.emf.infrastructure.exception._
import hsbc.emf.infrastructure.helper.{CloudTypeUtils, SchemaUtility}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.io.readers.SparkFileReaderService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}

import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.types.StructType

class SparkLoadTableFromFileService(loadInfoDAO: ILoadInfoDAO, sparkChunkedStorageService: ISparkChunkedStorageService
                                   )(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkLoadTableFromFileService with MessageContext {

  def loadTableFromFile(message: SparkLoadTableFromFileMessage): Unit = {
    import spark.implicits._
    try {
      // 1) check for the token file and get filetype
      val fileLocation = s"${CloudTypeUtils.prependFsProtocol(message.bucket, EmfConfig.cloudType)}/${message.file_path}"
      val fileCount: Long = spark.sparkContext.binaryFiles(fileLocation).count
      var fileType: String = message.file_type
      var recordCount: Long = 0
      var partitionCount: Long = 0
      var metaDataDF: DataFrame = null
      val config = MetaDataTextFileFormatConfig()
      try {
        metaDataDF = SparkFileReaderService(config).read(config, fileLocation, None)
      } catch {
        case e: Exception =>
          val customMessage = s"SparkLoadTableFromFileService.loadTableFromFile don't have meta token on the path,proceeding without token ${message}  : ${e.getMessage}"
          EmfLogger.warn(customMessage)
      }
      if (metaDataDF != null && metaDataDF.count > 0) {

        //get file type
        if (metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").count() > 0) {
          fileType = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").head.value
        } else {
          val customMessage = s"SparkLoadTableFromFileService.loadTableFromFile there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token} at ${fileLocation}"
          EmfLogger.error(customMessage)
          throw new EmfLoadInfoException(customMessage)
        }
        //get record count
        val recordCountDf = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "record_count")
        if (recordCountDf.count > 0) {
          recordCount = recordCountDf.head.value.toLong
        }

        //get partition count
        val partitionCountDf = metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "partition_count")
        if (partitionCountDf.count > 0) {
          partitionCount = partitionCountDf.head.value.toLong
        }
      }

      // 2) Read file name(s) and location
      var loadInfo: LoadInfo = null
      try {
        loadInfo = loadInfoDAO.readByType(fileType).get // if it's not exists will throw the exception
      } catch {
        case e: EmfLoadInfoDaoException =>
          val customMessage = s"SparkLoadTableFromFileService.loadTableFromFile there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} for '${fileType}' "
          EmfLogger.error(s"${customMessage}")
          throw e
      }

      // 3) Validate schema against LOAD_INFO
      // 4) Schema match?
      // 5) Record Count tag included?
      // 6) Perform select count check in Dataframe
      // 7) Record Count match？
      // 8) Partition Count match？

      // When source file is csv(s), it's needed to read the file(s) with schema, otherwise, it fails the validaiton always. As for others (avro, parquet, json, orc), please make use of existing schema with file to do validation
      val soureFileDF = loadInfo.fileFormatConfig match {
        case csvConfig: CsvFileFormatConfig => SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, Some(SchemaUtility.convertSchemaToStructType(loadInfo.schema)))
        case otherConfig => SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None)
      }

      if (metaDataDF != null && metaDataDF.count > 0) {
        if (!this.validate(soureFileDF.schema, loadInfo.schema, recordCount, soureFileDF.count, partitionCount, fileCount)) {
          throw new EmfSchemaValidationException("SparkLoadTableFromFileService.loadTableFromFile Schema validation Failed")
        }
      }
      // 9) Load into Storage
      sparkChunkedStorageService.write(loadInfo, soureFileDF, partitionCount, message)

      // 9) MSCK Repair(update Hive Metadata Catalogue)`
      new HiveRepair().run(s"${message.dataset_name}", s"${message.table_name}")
    } catch {
      case e: Exception =>
        val customMessage = s"SparkLoadTableFromFileService.loadTableFromFile fails to perform loadTableFromFile with message ${message}  : ${e.getMessage}"
        EmfLogger.error(customMessage)
        throw new SparkLoadTableFromFileServiceException(customMessage, e.getCause)
    }
  }

  def compareRecordCount(recordCountFromMetadata: Long, dfRecordCount: Long): Boolean = {
    recordCountFromMetadata == dfRecordCount
  }

  def comparePartitionCount(partitionCountFromMetadata: Long, fileCount: Long): Boolean = {
    partitionCountFromMetadata == (fileCount - 1)
  }

  def validate(dfSchema: StructType, loadInfoSchema: Schema, recordCountFromMetadata: Long, dfRecordCount: Long, partitionCountFromMetadata: Long, fileCount: Long): Boolean = {
    val compareSchemaResult: Boolean = SchemaUtility.compareSchema(dfSchema, loadInfoSchema)
    val compareRecordCountResult: Boolean = compareRecordCount(recordCountFromMetadata, dfRecordCount)
    val comparePartitionCountResult: Boolean = comparePartitionCount(partitionCountFromMetadata, fileCount)
    if (!compareSchemaResult) {
      EmfLogger.error("SparkLoadTableFromFileService.validate schema mismatch error")
    }
    if (!compareRecordCountResult) {
      EmfLogger.warn(s"SparkLoadTableFromFileService.validate record_count validation fails because ${EmfConfig.spark_readable_meta_chunk_token} has record_count as ${recordCountFromMetadata} while ${dfRecordCount} for source files")
    }
    if (!comparePartitionCountResult) {
      EmfLogger.warn(s"SparkLoadTableFromFileService.validate partition_count validation fails because ${EmfConfig.spark_readable_meta_chunk_token} has partition_count as ${partitionCountFromMetadata} while ${fileCount - 1} for source files")
    }
    compareSchemaResult
  }
}
package hsbc.emf.service.loadtablefromfile

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.sparkcmdmsg.SparkLoadTableFromFileMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, SparkLoadTableFromFileServiceException}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class SparkLoadTableFromFileServiceTest extends IntegrationTestSuiteBase with MockFactory {
  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
//  val successCase1TestParquet001 = "success_case1_test_parquet001"
//  val successCase2TestParquet001 = "success_case2_load_test_parquet001"
//  val successCase3TestCsv001 = "success_case3_load_test_csv001"
//  val successCaseRecordPartitionMismatch = "success_case_record_partition_mismatch"
//  val failureCase1Test = "failure_case1_test"
//  val failureCase2Test = "failure_case2_test"
//  val failureCase3Test = "failure_case3_test"
//  val failureCase4Test = "failure_case4_test"
//  val databaseName = "exampleDB"
//  val mockLoadInfoDAO = mock[ILoadInfoDAO]
//  val mockSqlExecutor = mock[SqlExecutor]
//  var hiveRepair: HiveRepair = null
//
//
//  override def beforeAll(): Unit = {
//    super.beforeAll()
//    hiveRepair = new HiveRepair()
//  }
//
//  override def afterAll(): Unit = {
//    spark.sql(s"drop database if exists ${databaseName} cascade")
//    super.afterAll()
//  }
//
//  "Success case 1: given a valid SparkLoadTableFromFileMessage with token file " should "Store successfully" in {
//    val loadInfoRaw = LoadInfoRaw(file_type = s"${successCase1TestParquet001}", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(38,18)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//
//    (mockLoadInfoDAO.readByType _).expects(s"${successCase1TestParquet001}").returning(Some(loadInfo)).once()
//
//    val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/success_case1_test_parquet001", "file_type", "testTable1", s"${databaseName}")
//    val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//    sparkLoadTableFromFileService.loadTableFromFile(msg)
//
//    val tableDF = spark.sql(s"select * from ${msg.dataset_name}.${msg.table_name}")
//    assert(tableDF.count == 2)
//  }
//
//  "Success case 2: given a valid SparkLoadTableFromFileMessage with out token file  " should "Store successfully" in {
//    val loadInfoRaw = LoadInfoRaw(file_type = "file_type", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//
//    (mockLoadInfoDAO.readByType _).expects("file_type").returning(Some(loadInfo)).once()
//
//    val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/success_case2_load_test_parquet001", "file_type", "testTable2", s"${databaseName}")
//    val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//    sparkLoadTableFromFileService.loadTableFromFile(msg)
//
//    val tableDF = spark.sql(s"select * from ${msg.dataset_name}.${msg.table_name}")
//    assert(tableDF.count == 2)
//  }
//
//  "Success case 3: given a valid SparkLoadTableFromFileMessage - Csv Format" should "ingest successfully" in {
//    val loadInfoRaw = LoadInfoRaw(file_type = s"${successCase3TestCsv001}", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("csv"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"), delimiter = Some("|"), skip_rows = Some("0"), quote_character = Some("'"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//
//    (mockLoadInfoDAO.readByType _).expects(successCase3TestCsv001).returning(Some(loadInfo)).once()
//
//    val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${successCase3TestCsv001}", "file_type", "testTable3", s"${databaseName}")
//    val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//    sparkLoadTableFromFileService.loadTableFromFile(msg)
//    val tableDF = spark.sql(s"select * from ${msg.dataset_name}.${msg.table_name}")
//    assert(tableDF.count == 1)
//  }
//
//  "Success case 4: given a valid SparkLoadTableFromFileMessage - partition and record mismatch" should "ingest successfully" in {
//    val loadInfoRaw = LoadInfoRaw(file_type = s"${successCaseRecordPartitionMismatch}",
//      schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"),
//      extension = Some("csv"), ingest_hierarchy = None,
//      ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"), delimiter = Some("|"), skip_rows = Some("0"), quote_character = Some("'"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//
//    (mockLoadInfoDAO.readByType _).expects(successCaseRecordPartitionMismatch).returning(Some(loadInfo)).once()
//
//    val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf",
//      s"/testingFiles/spark_ingest_mockup_data/${successCaseRecordPartitionMismatch}",
//      "file_type", "testTableRecordPartitionMismatch", s"${databaseName}")
//    val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//    sparkLoadTableFromFileService.loadTableFromFile(msg)
//    val tableDF = spark.table(s"${msg.dataset_name}.${msg.table_name}")
//    assert(tableDF.count == 2)
//  }
//
//  "Failure case 1 - give an invalid SparkIngestMessage - invalid location" should "throw exception" in {
//    val caught = intercept[SparkLoadTableFromFileServiceException] {
//      val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${failureCase1Test}", "file_type", "testTable4", s"${databaseName}")
//      val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//      sparkLoadTableFromFileService.loadTableFromFile(msg)
//    }
//    assert(caught.getMessage.contains(s"Input path does not exist"))
//  }
//
//  "Failure case 2 - no file_type in present in token" should "throw exception" in {
//    val caught = intercept[SparkLoadTableFromFileServiceException] {
//      val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${failureCase2Test}", "file_type", "testTable5", s"${databaseName}")
//      val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//      sparkLoadTableFromFileService.loadTableFromFile(msg)
//    }
//    assert(caught.getMessage.contains(s"there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token}"))
//  }
//
//  "Failure case 3 - no file_type exists in load_info.data table" should "throw exception" in {
//    // 1. set the mockup object expectation
//    val loadInfoRaw = LoadInfoRaw(file_type = s"${failureCase3Test}", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"dummyFld\",\"type\":\"String\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//    (mockLoadInfoDAO.readByType _).expects(failureCase3Test).throwing(new EmfLoadInfoDaoException(s"SparkIngestService.ingest there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} for '${failureCase3Test}'", new Throwable()))
//    val caught = intercept[SparkLoadTableFromFileServiceException] {
//      val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${failureCase3Test}", "file_type", "testTable6", s"${databaseName}")
//      val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//      sparkLoadTableFromFileService.loadTableFromFile(msg)
//    }
//    assert(caught.getMessage.contains(s"there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}"))
//  }
//
//  "Failure case 4: give an invalid LoadInfo with mismatched schema" should "throw exception" in {
//    val loadInfoRaw = LoadInfoRaw(file_type = s"${failureCase4Test}", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(38,18)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1"))
//    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
//    (mockLoadInfoDAO.readByType _).expects(failureCase4Test).returning(Some(loadInfo)).once()
//    val caught = intercept[SparkLoadTableFromFileServiceException] {
//      val msg = new SparkLoadTableFromFileMessage("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${failureCase4Test}", "file_type", "testTable7", s"${databaseName}")
//      val sparkLoadTableFromFileService = new SparkLoadTableFromFileService(mockLoadInfoDAO, new SparkChunkedStorageService())
//      sparkLoadTableFromFileService.loadTableFromFile(msg)
//    }
//    assert(caught.getMessage.contains(s"SparkLoadTableFromFileService.loadTableFromFile Schema validation Failed"))
//  }
}package hsbc.emf.command

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.infrastructure.config.EmfConfig

class SparkLoadTableFromFileTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  val successCase1TestParquet001 = "success_case2_load_test_parquet001"
  val failureCase1Test = "failure_case1_test"


  override def beforeAll(): Unit = {
    super.beforeAll()
  }

  override def afterAll(): Unit = {
    super.afterAll()
  }

  "given a valid message in command" should "return Complete" in {

    val loadInfoRawList = List(LoadInfoRaw(file_type = "file_type", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode("overwrite").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}") //EmfConfig.defaultTableName

    val dummyFileTypeDF = spark.read.format("parquet").load(s"tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/${successCase1TestParquet001}")

    assert(new SparkLoadTableFromFile("tests/hsbc/emf", s"/testingFiles/spark_ingest_mockup_data/${successCase1TestParquet001}", "file_type", "exampleDB", "testTable1").run() == Complete)

    val dummyFileTypeTableDF = spark.sql(s"select * from exampleDB.testTable1")
    assert(dummyFileTypeDF.except(dummyFileTypeTableDF).isEmpty)
  }

  "given an invalid message in command" should "return Failed" in {

    val loadInfoRawList = List(LoadInfoRaw(file_type = s"${failureCase1Test}", schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"},{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"},{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"},{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"},{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"},{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"), extension = Some("parquet"), ingest_hierarchy = None, ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1")))

    loadInfoRawList.toDF().write.mode("overwrite").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}") //EmfConfig.defaultTableName
    assert(new SparkLoadTableFromFile("tests/hsbc/emf", s"testingFiles/spark_ingest_mockup_data/${failureCase1Test}", "file_type", "exampleDB", "testTable2").run() == Failed)
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}
import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkMessagesFromQueryMessage
import hsbc.emf.data.sqleval.{WriteAppend, WriteDisposition, WriteTruncate}
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.sqleval.SparkSqlEvalService
import org.apache.spark.sql.SparkSession

class SparkMessagesFromQuery(val query: String,
                             val writeDisposition: WriteDisposition = WriteAppend,
                             val asView: Boolean = false,
                             val targetDataset: Option[String] = None)
                            (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    var sparkMsgFromQueryResult: ExecutionResult = Complete
    Try {
      val sparkMessagesFromQueryMsg = SparkMessagesFromQueryMessage(query, writeDisposition, asView, targetDataset)

      val listOfSparkSqlEvalMsgObjects = new SparkSqlEvalService(new SqlExecutor())
        .evalQueryToGetMessageDetails(sparkMessagesFromQueryMsg)
     
      if (listOfSparkSqlEvalMsgObjects.isEmpty) {
        EmfLogger.warn("The list of sql eval message is empty, skip the SqlEval process and completed the SparkMessagesFromQuery")
      }
      else {
        val listOfSparkSqlEvalMsgObjectsTableNames =
          listOfSparkSqlEvalMsgObjects.map(_.table)
        val transformedCollection =
          if (listOfSparkSqlEvalMsgObjectsTableNames.distinct.size != listOfSparkSqlEvalMsgObjectsTableNames.size) {
            listOfSparkSqlEvalMsgObjects
          } else {
            listOfSparkSqlEvalMsgObjects.par
          }
        transformedCollection.map {
          sparkSqlEvalMsgObject => {
            val sqlEvalResult = new SparkSqlEval(
              PlaceholderParameterisation.insertParams(placeholderParams, sparkSqlEvalMsgObject.query),
              sparkSqlEvalMsgObject.table,
              sparkSqlEvalMsgObject.write_disposition,
              sparkSqlEvalMsgObject.as_view,
              sparkSqlEvalMsgObject.dataset).run()
            if (sqlEvalResult == Failed) {
            sparkMsgFromQueryResult = Failed
            }
          }
        }
      }
      if (sparkMsgFromQueryResult == Failed) {
        EmfLogger.error(s"SparkMessagesFromQuery command failed to execute")
      }
      else {
        EmfLogger.info("SparkMessagesFromQuery command executed successfully")
      }
      sparkMsgFromQueryResult
    } match {
      case Success(executionResult) => executionResult
      case Failure(exception) => {
        ExceptionHandler.handle("SparkMessagesFromQuery command execution failed", exception)
        Failed
      }
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.sqleval.{WriteAppend, WriteDisposition}

case class SparkMessagesFromQueryMessage(var query: String,
                                         val write_disposition: WriteDisposition = WriteAppend,
                                         val as_view: Boolean = false,
                                         val target_dataset: Option[String] = None) extends ISparkCommandMessagepackage hsbc.emf.command

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.sqleval.{WriteAppend, WriteTruncate}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.Row
import org.apache.spark.sql.types.{StringType, StructField, StructType}

class SparkMessagesFromQueryTest extends IntegrationTestSuiteBase {

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists exampleDB")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists exampleDB cascade")
    super.afterAll()
  }

  "non existing table query in command" should "return Failed" in {
    val execResult: ExecutionResult = new SparkMessagesFromQuery("select * from non_existing_table", asView = true).run()
    assert(execResult == Failed)
  }

  "spark messages from query with valid queries,3 columns and a,b as first two columns names" should "return Complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_1", "NY"),
      ("select * from test_table", "test_table_2", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", asView = true).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted = sqlExec.execute("select * from test_table_1")
    val content = dfExecuted.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)


    val dfExecuted1 = sqlExec.execute("select * from test_table_2")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
  }

  "spark messages from query with valid queries,2 columns and y,x as first 2 column names " should "return Complete" in {
    import spark.implicits._
    val sample = """{"key" : "b", "value": 2}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testing_table")

    val sampleData = Seq(("select key,value from testing_table", "final_table_1"),
      ("select * from testing_table", "final_table_2"))
    val df1 = sampleData.toDF("y", "x")
    df1.write.mode("overwrite").saveAsTable("finalize_table")

    val execResult = new (SparkMessagesFromQuery)("select * from finalize_table", asView = true).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted = sqlExec.execute("select * from final_table_1")
    val content = dfExecuted.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("b") == 2)

    val dfExecuted1 = sqlExec.execute("select * from final_table_2")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("b") == 2)
  }

  "spark messages from query with output of query containing 2 columns but empty " should "return complete" in {
    val schema = StructType(List(StructField("a", StringType), StructField("b", StringType)))
    val emptyDF = spark.createDataFrame(spark.sparkContext.emptyRDD[Row], schema)
    emptyDF.write.mode("overwrite").saveAsTable("testing_table")
    val execResult = new (SparkMessagesFromQuery)("select * from testing_table", asView = true).run()
    assert(execResult.equals(Complete))
  }

  "spark messages from query with both valid and invalid queries and sql,target_table as first 2 column names " should "return Failed" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select * from test_table", "test_table_1"), // valid
      ("select * from wrong_table", "test_table_2"), // invalid
      ("select * from test_table", "test_table_3"), // valid
      ("select * from test_table345", "test_table_4"), // invalid
      ("select * from test_table111", "test_table_5"), // invalid
      ("select * from wrong_table121", "test_table_6"), // invalid
      ("select * from test_table", "test_table_9"), // valid
      ("select * from test_table131", "test_table_7"), // invalid
      ("select * from test_table141", "test_table_8")) // invalid
    val df1 = sampleData.toDF("sql", "target_table")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table",  asView = true).run()
    assert(execResult.equals(Failed))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select * from test_table_1")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)

    val dfExecuted3 = sqlExec.execute("select * from test_table_3")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)

    val dfExecuted9 = sqlExec.execute("select * from test_table_9")
    val content9 = dfExecuted9.as[(String, BigInt)].collect.toMap
    assert(content9.size == 1)
    assert(content9("a") == 1)

  }

  "spark message from query with write_truncate, " should "return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sample1 = """{"key" : "aaa", "value": 111}"""
    spark.read.json(Seq(sample1).toDS()).write.mode("overwrite").saveAsTable("test_table_tr1")

    val sample2 = """{"key" : "bbb", "value": 222}"""
    spark.read.json(Seq(sample2).toDS()).write.mode("overwrite").saveAsTable("test_table_tr2")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr1", "NY"),
      ("select * from test_table", "test_table_tr2", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteTruncate, asView = true).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted = sqlExec.execute("select * from test_table_tr1")
    val content = dfExecuted.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)

    val dfExecuted1 = sqlExec.execute("select * from test_table_tr2")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
  }

  "spark message from query with write_truncate without view, " should "return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sample1 = """{"key" : "aaa", "value": 111}"""
    spark.read.json(Seq(sample1).toDS()).write.saveAsTable("exampleDB.test_table_tr1")

    val sample2 = """{"key" : "bbb", "value": 222}"""
    spark.read.json(Seq(sample2).toDS()).write.saveAsTable("exampleDB.test_table_tr2")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr1", "NY"),
      ("select * from test_table", "test_table_tr2", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteTruncate, asView = false,  Some("exampleDB")).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted = sqlExec.execute("select * from exampleDB.test_table_tr1")
    val content = dfExecuted.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)

    val dfExecuted1 = sqlExec.execute("select * from exampleDB.test_table_tr2")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
  }

  "spark messages from query with write_append without view and distinct tablenames, " should "run in parallel and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr1", "NY"),
      ("select * from test_table", "test_table_tr2", "NY"),
      ("select key,value from test_table", "test_table_tr3", "NY"),
      ("select * from test_table", "test_table_tr4", "NY"),
      ("select key,value from test_table", "test_table_tr5", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteAppend, asView = false,  Some("exampleDB")).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select key,value from exampleDB.test_table_tr1")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
    val dfExecuted2 = sqlExec.execute("select key,value from exampleDB.test_table_tr2")
    val content2 = dfExecuted2.as[(String, BigInt)].collect.toMap
    assert(content2.size == 1)
    assert(content2("a") == 1)
    val dfExecuted3 = sqlExec.execute("select key,value from exampleDB.test_table_tr3")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select key,value from exampleDB.test_table_tr4")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select key,value from exampleDB.test_table_tr5")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_append with view and distinct tablenames, " should "run in parallel and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr1", "NY"),
      ("select * from test_table", "test_table_tr2", "NY"),
      ("select key,value from test_table", "test_table_tr3", "NY"),
      ("select * from test_table", "test_table_tr4", "NY"),
      ("select key,value from test_table", "test_table_tr5", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteAppend, asView = true,  None).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select * from test_table_tr1")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
    val dfExecuted2 = sqlExec.execute("select * from test_table_tr2")
    val content2 = dfExecuted2.as[(String, BigInt)].collect.toMap
    assert(content2.size == 1)
    assert(content2("a") == 1)
    val dfExecuted3 = sqlExec.execute("select * from test_table_tr3")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select * from test_table_tr4")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select * from test_table_tr5")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_truncate without view and distinct tablenames, " should "run in parallel and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr6", "NY"),
      ("select * from test_table", "test_table_tr7", "NY"),
      ("select key,value from test_table", "test_table_tr8", "NY"),
      ("select * from test_table", "test_table_tr9", "NY"),
      ("select key,value from test_table", "test_table_tr10", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteTruncate, asView = false,  Some("exampleDB")).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select key,value from exampleDB.test_table_tr6")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
    val dfExecuted2 = sqlExec.execute("select key,value from exampleDB.test_table_tr7")
    val content2 = dfExecuted2.as[(String, BigInt)].collect.toMap
    assert(content2.size == 1)
    assert(content2("a") == 1)
    val dfExecuted3 = sqlExec.execute("select key,value from exampleDB.test_table_tr8")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select key,value from exampleDB.test_table_tr9")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select key,value from exampleDB.test_table_tr10")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_truncate with view and distinct tablenames, " should "run in parallel and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr6", "NY"),
      ("select * from test_table", "test_table_tr7", "NY"),
      ("select key,value from test_table", "test_table_tr8", "NY"),
      ("select * from test_table", "test_table_tr9", "NY"),
      ("select key,value from test_table", "test_table_tr10", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteTruncate, asView = true,  None).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select * from test_table_tr6")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
    val dfExecuted2 = sqlExec.execute("select * from test_table_tr7")
    val content2 = dfExecuted2.as[(String, BigInt)].collect.toMap
    assert(content2.size == 1)
    assert(content2("a") == 1)
    val dfExecuted3 = sqlExec.execute("select * from test_table_tr8")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select * from test_table_tr9")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select * from test_table_tr10")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_append without view and duplicate tablenames, " should "run in sequentially and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr11", "NY"),
      ("select * from test_table", "test_table_tr11", "NY"),
      ("select key,value from test_table", "test_table_tr31", "NY"),
      ("select * from test_table", "test_table_tr41", "NY"),
      ("select key,value from test_table", "test_table_tr51", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteAppend, asView = false,  Some("exampleDB")).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select key,value from exampleDB.test_table_tr11")
    assert(dfExecuted1.count() == 2)
    val dfExecuted3 = sqlExec.execute("select key,value from exampleDB.test_table_tr31")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select key,value from exampleDB.test_table_tr41")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select key,value from exampleDB.test_table_tr51")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_truncate without view and duplicate tablenames, " should "run sequentially and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr12", "NY"),
      ("select * from test_table", "test_table_tr12", "NY"),
      ("select key,value from test_table", "test_table_tr32", "NY"),
      ("select * from test_table", "test_table_tr42", "NY"),
      ("select key,value from test_table", "test_table_tr52", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteTruncate, asView = false,  Some("exampleDB")).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select key,value from exampleDB.test_table_tr12")
    val content1 = dfExecuted1.as[(String, BigInt)].collect.toMap
    assert(content1.size == 1)
    assert(content1("a") == 1)
    val dfExecuted3 = sqlExec.execute("select key,value from exampleDB.test_table_tr32")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select key,value from exampleDB.test_table_tr42")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select key,value from exampleDB.test_table_tr52")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark messages from query with write_append with view and duplicate tablenames, " should "run sequentially and return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from test_table", "test_table_tr13", "NY"),
      ("select * from test_table", "test_table_tr13", "NY"),
      ("select key,value from test_table", "test_table_tr33", "NY"),
      ("select * from test_table", "test_table_tr43", "NY"),
      ("select key,value from test_table", "test_table_tr53", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteAppend, asView = true, None).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted1 = sqlExec.execute("select * from test_table_tr13")
    assert(dfExecuted1.count() == 2)
    val dfExecuted3 = sqlExec.execute("select * from test_table_tr33")
    val content3 = dfExecuted3.as[(String, BigInt)].collect.toMap
    assert(content3.size == 1)
    assert(content3("a") == 1)
    val dfExecuted4 = sqlExec.execute("select * from test_table_tr43")
    val content4 = dfExecuted4.as[(String, BigInt)].collect.toMap
    assert(content4.size == 1)
    assert(content4("a") == 1)
    val dfExecuted5 = sqlExec.execute("select * from test_table_tr53")
    val content5 = dfExecuted5.as[(String, BigInt)].collect.toMap
    assert(content5.size == 1)
    assert(content5("a") == 1)
  }

  "spark message from query with write_append, " should "return complete" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sample1 = """{"key" : "aaa", "value": 111}"""
    val dfSample1 = spark.read.json(Seq(sample1).toDS())
    dfSample1.write.mode("overwrite").saveAsTable("test_table_ap1")

    val sample2 = """{"key" : "bbb", "value": 222}"""
    val dfSample2 = spark.read.json(Seq(sample2).toDS())
    dfSample2.write.mode("overwrite").saveAsTable("test_table_ap2")

    val sampleData = Seq(("select key,value from test_table", "test_table_ap1", "NY"),
      ("select * from test_table", "test_table_ap2", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", WriteAppend, asView = true).run()
    assert(execResult.equals(Complete))

    val sqlExec = new SqlExecutor()
    val dfExecuted = sqlExec.execute("select * from test_table_ap1")
    assert(dfExecuted.count == 2)
    assert(dfExecuted.except(df.union(dfSample1)).count == 0)

    val dfExecuted1 = sqlExec.execute("select * from test_table_ap2")
    assert(dfExecuted1.count == 2)
    assert(dfExecuted1.except(df.union(dfSample2)).count == 0)
  }

  "spark messages from query with invalid queries and valid number of columns" should "return Failed" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq(("select key,value from incorrect_table", "final_table_1"),
      ("select * from wrong_table", "final_table_2"))

    val df1 = sampleData.toDF("y", "x")
    df1.write.mode("overwrite").saveAsTable("final_table")

    val execResult = new (SparkMessagesFromQuery)("select * from final_table", asView = true).run()
    assert(execResult.equals(Failed))

  }

  "spark messages from query with valid queries but 1 column" should "return Failed" in {
    import spark.implicits._
    val sample = """{"key" : "b", "value": 2}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testing_table")

    val sampleData = Seq("select key,value from testing_table", "select * from testing_table")
    val df1 = sampleData.toDF("y")
    df1.write.mode("overwrite").saveAsTable("finalize_table")

    val execResult = new (SparkMessagesFromQuery)("select * from finalize_table", asView = true).run()
    assert(execResult.equals(Failed))

  }
}
package hsbc.emf.service.orchestration

import scala.util.{Failure, Success, Try}

import hsbc.emf.command.ISparkCommand
import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.{CatalogueDAO, ICatalogueDAO}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.orchestration.ProcessTask
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.sql.ISqlExecutor
import org.apache.spark.sql.SparkSession

class SparkOrchestrateService(sqlExecutor: ISqlExecutor)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo)
  extends ISparkOrchestrateService with MessageContext {

  def executeWorkFlow(sparkRunMessage: SparkRunMessage, workflowPlaceholderParams: PlaceholderParameters): ExecutionResult = {
    Try {
      EmfLogger.info(s"Workflow [${sparkRunMessage.workflow}] execution starts. run_uuid = ${sparkRunMessage.run_uuid.get}")
      val catalogueDAO: ICatalogueDAO = new CatalogueDAO(sqlExecutor)

      val execEnvInitializedParams = new WorkflowExecEnvInitializer(sqlExecutor, catalogueDAO).generateRunUuidAndZzzDb(sparkRunMessage, workflowPlaceholderParams)
      val externalParametersMap = ExternalParametersReader.read
      // parameters priority - (low to high) : external file parameters -> workflow initialized parameters -> workflow provided parameters
      val combinedPlaceholderParameters = PlaceholderParameters(externalParametersMap ++ execEnvInitializedParams.paramMap ++ workflowPlaceholderParams.paramMap)

      val resolvedProcessTasks: Seq[ProcessTask] = new ProcessTasksResolver().resolveProcessTasks(sparkRunMessage)
      val cleanedProcessTasks: Seq[ProcessTask] = ProcessTasksParametersHandler.removeQuotesForConstraints(resolvedProcessTasks)
      val processTasksSplitByDependency: Seq[Seq[ProcessTask]] = new ProcessTasksSorter().sortProcessTasks(cleanedProcessTasks)

      val workflowCommandsSplitByDependency: Seq[Seq[ISparkCommand]] = new SparkDagBuilder().buildDag(processTasksSplitByDependency,
        combinedPlaceholderParameters, sparkRunMessage.enabled, sparkRunMessage.disabled, sparkRunMessage.workflow, sparkRunMessage.run_uuid.get)

      val dagExecutionResult = new DagExecutor(sparkRunMessage, combinedPlaceholderParameters).executeDag(workflowCommandsSplitByDependency)
      if (dagExecutionResult == Complete) {
        EmfLogger.info(s"Workflow [${sparkRunMessage.workflow}] execution completed successfully. run_uuid = ${combinedPlaceholderParameters.format("run_uuid")}")
      } else {
        EmfLogger.info(s"Workflow [${sparkRunMessage.workflow}] execution failed. run_uuid = ${combinedPlaceholderParameters.format("run_uuid")}")
      }
      EmfLogger.debug(s"SparkOrchestrateService executeWorkFlow ends. workflow = ${sparkRunMessage.workflow}, run_uuid = ${sparkRunMessage.run_uuid.get}")
      dagExecutionResult
    } match {
      case Success(executionResult) => executionResult
      case Failure(exception) =>
        ExceptionHandler.handle(s"SparkOrchestrateService executeWorkFlow failed for Workflow [${sparkRunMessage.workflow}]", exception)
        Failed
    }
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution.{DATA, ISourceEntityType, ResolutionConstraint, ResolutionCriteria}
import hsbc.emf.data.sparkcmdmsg.SparkResolveMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.resolution.SparkResolveService

import org.apache.spark.sql.SparkSession

class SparkResolve(val criteria: ResolutionCriteria,
                   val tableName: String,
                   val whereClause: List[ResolutionConstraint] = List.empty,
                   val sourceEntityType: ISourceEntityType = DATA,
                   val retryCount: Int = 0,
                   val interRetryInterval: Int = 0,
                   val asView: Boolean = false,
                   val datasetName: Option[String] = None,
                   val injectMetadata: Boolean = false)
                  (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {
  def run(): ExecutionResult = {
    Try {
      val dsName: Option[String] = checkAndUpdateDataset()
      val sparkResolveMessage = SparkResolveMessage(criteria, tableName, whereClause, sourceEntityType, retryCount,
        interRetryInterval, asView, dsName, injectMetadata)
      EmfLogger.debug(s"SparkResolve command sparkResolveMessage: $sparkResolveMessage")

      // call service to get DF from ResolutionService
      val sqlExecutor = new SqlExecutor()
      new SparkResolveService(sqlExecutor, new CatalogueDAO(sqlExecutor)).resolve(sparkResolveMessage)
      EmfLogger.info("SparkResolve command executed successfully")
    } match {
      case Success(_) => Complete
      case Failure(exception) =>
        ExceptionHandler.handle("SparkResolve command execution failed", exception)
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    true
  }

  private def checkAndUpdateDataset(): Option[String] = {
    if (!asView && datasetName.isEmpty) {
      try {
        Some(placeholderParams.format(s"${EmfConfig.sparkRunGeneratedParamNameTargetDataset}"))
      }
      catch {
        case ex: Exception =>
          EmfLogger.error(s"SparkResolve command error: Failed to lookup target_dataset from " +
            s"placeholderParams for the case that asView is false and dataset is omitted ")
          throw ex
      }
    }
    else datasetName
  }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode
import org.apache.spark.sql.types._
import org.apache.spark.sql.functions._

class SparkResolveAdjustmentResolutionTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  private val file_type = "Person"
  private val resConstraint = List(ResolutionConstraint("md5", "10", Equal))
  private val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.catalogueDatabaseName}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    spark.sql(s"create database IF not EXISTS adjustment_cell")
    spark.sql(s"create database IF not EXISTS ADJUSTMENT_APPROVED")

     val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue_adjust_resolution.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)

    val personData = spark.read
      .format("json")
      .load("tests/hsbc/emf/testingFiles/service/resolution/test_college_sample_with_typed_data_adjustable.json")

    personData.toDF().write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"$file_type.data")

    spark.sql(s"create view if not exists $file_type.access_view as select * from $file_type.data")
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql("DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql("DROP DATABASE IF EXISTS adjustment_apprroved CASCADE")
    spark.sql("DROP DATABASE IF EXISTS adjustment_cell CASCADE")
    super.afterAll()
  }

  "given a message with  ADJUSTED_UNAPPROVED and add" should "save the data frame as view" in {

    spark.read
      .format("json")
      .option("inferSchema", "true")
      .load("tests/hsbc/emf/testingFiles/service/resolution/test_college_sample_with_typed_data_adjustable_cell_amend.json")
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.source_data")
    spark.sql("select * from adjustment_cell.source_data")
      .withColumn("__created", lit("1900-01-01 00:00:00").cast(StringType))
      .withColumn("__file_type", lit("adjustment_cell").cast(StringType))
      .withColumn("adjusted_table_file_type", lit("Person").cast(StringType))
      .withColumn("adjusted_table_uuid", lit("T1").cast(StringType))
      .withColumn("__metadata", lit(null).cast(ArrayType(new StructType()
        .add("attribute", StringType)
        .add("value", StringType)
        .add("data_type", StringType)
        .add("domain", StringType))))
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.access_view")

    val execResult = new SparkResolve(criteria = resolutionCriteria, "ResultTable1",
      whereClause = List.empty, ADJUSTED_UNAPPROVED, asView = true, injectMetadata = false).run()

    assert(execResult match {
      case Complete => true
      case Failed => false
    })

    assert(spark.sql("select * from ResultTable1").toDF().count() > 0)
    val resDF = spark.sql("select * from ResultTable1")
    val uuidList = resDF.select("__uuid").map(_.getString(0)).collect.toList

    assert(uuidList.contains("adjustment_add_001"))
    assert(uuidList.contains("adjustment_add_002"))
    assert(uuidList.contains("adjustment_add_003"))
  }

  "given a message with  ADJUSTED_UNAPPROVED and amend" should "save the data frame as view" in {

    spark.read
      .format("json")
      .option("inferSchema", "true")
      .load("tests/hsbc/emf/testingFiles/service/resolution/test_college_sample_with_typed_data_adjustable_cell_amend_exist.json")
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.source_data")

    spark.sql("select * from adjustment_cell.source_data")
      .withColumn("__created", lit("1900-01-01 00:00:00").cast(StringType))
      .withColumn("__file_type", lit("adjustment_cell").cast(StringType))
      .withColumn("adjusted_table_file_type", lit("Person").cast(StringType))
      .withColumn("adjusted_table_uuid", lit("T1").cast(StringType))
      .withColumn("__metadata", lit(null).cast(ArrayType(new StructType()
        .add("attribute", StringType)
        .add("value", StringType)
        .add("data_type", StringType)
        .add("domain", StringType))))
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.access_view")

    val execResult = new SparkResolve(criteria = resolutionCriteria, "ResultTable2",
      whereClause = List.empty, ADJUSTED_UNAPPROVED, asView = true).run()

    assert(execResult match {
      case Complete => true
      case Failed => false
    })
    assert(spark.sql("select * from ResultTable2").toDF().count() > 0)
    val resDF = spark.sql("select * from ResultTable2 where __uuid == \"032f6de9-2079-40ca-9f11-8ba999c84880\"")

    val enrollnoList = resDF.select("enrollno").map(_.getString(0)).collect.toList

    assert(enrollnoList.contains("A101"))
    assert(enrollnoList.contains("A101 amended"))
  }

  "given a message with  ADJUSTED_APPROVED" should "save the data frame as view" in {

    spark.read
      .format("json")
      .option("inferSchema", "true")
      .load("tests/hsbc/emf/testingFiles/service/resolution/test_college_sample_with_typed_data_adjustable_cell_add.json")
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.source_data")

    spark.sql("select * from adjustment_cell.source_data")
      .withColumn("__created", lit("1900-01-01 00:00:00").cast(StringType))
      .withColumn("__file_type", lit("adjustment_cell").cast(StringType))
      .withColumn("adjusted_table_file_type", lit("Person").cast(StringType))
      .withColumn("adjusted_table_uuid", lit("T1").cast(StringType))
      .withColumn("__metadata", lit(null).cast(ArrayType(new StructType()
        .add("attribute", StringType)
        .add("value", StringType)
        .add("data_type", StringType)
        .add("domain", StringType))))
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_cell.access_view")

    val adjustmentApproved = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/test_college_sample_with_typed_data_adjustable_approved.csv")
      .write.mode(SaveMode.Overwrite)
      .format("hive")
      .saveAsTable(s"adjustment_approved.access_view_source")
    var adjustmentApprovedData = spark.sql("select * from adjustment_approved.access_view_source")
      .withColumn("adjusted_table_file_type", lit("Person").cast(StringType))
      .withColumn("adjusted_table_uuid", lit("T1").cast(StringType))
      .write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable("adjustment_approved.data")

   val execResult = new SparkResolve(criteria = resolutionCriteria, tableName = "ResultTable3",
     whereClause = List.empty, ADJUSTED_APPROVED, asView = true).run()

    assert(execResult match {
      case Complete => true
      case Failed => false
    })
    assert(spark.sql("select * from ResultTable3").toDF().count() > 0)

    val resDF = spark.sql("select * from ResultTable3")
    val uuidList = resDF.select("__uuid").map(_.getString(0)).collect.toList

    assert(uuidList.contains("adjustment_add_001"))
    assert(uuidList.contains("adjustment_add_002"))
  }
}

package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkResolveFromInputRequirementsMessage
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.resolution.SparkResolveService

import org.apache.spark.sql.SparkSession

class SparkResolveFromInputRequirements(val inputRequirementsTableName: String,
                                        dataset_name: Option[String] = None,
                                        as_view: Boolean = false,
                                        inject_metadata: Boolean = false
                                       )
                                       (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    val sparkResolveMessage = SparkResolveFromInputRequirementsMessage(inputRequirementsTableName,
      dataset_name, as_view, inject_metadata)
    Try {
      val sqlExecutor = new SqlExecutor()
      new SparkResolveService(sqlExecutor, new CatalogueDAO(sqlExecutor))
        .resolveFromTable(sparkResolveMessage, placeholderParams)
      EmfLogger.info("SparkResolveFromInputRequirements command executed successfully")
    } match {
      case Success(_) => Complete
      case Failure(exception) =>
        ExceptionHandler.handle("SparkResolveFromInputRequirements command execution failed", exception)
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkResolveFromInputRequirementsMessage(input_requirements_table_name : String,
                                                    dataset_name: Option[String] = None,
                                                    as_view: Boolean = false,
                                                    inject_metadata: Boolean = false) extends ISparkCommandMessage
package hsbc.emf.command

import java.sql.Timestamp

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

import org.apache.spark.sql.AnalysisException
import org.apache.spark.sql.SaveMode

case class metaData(attribute: String,value: String,data_type: String,domain: String)

class SparkResolveFromInputRequirementsTest extends IntegrationTestSuiteBase  {

  private val input_req_table = "input_req_table"
  private val input_req_table_with_metadata = "input_req_table_with_metadata"
  private val input_req_table_without_some_columns = "input_req_table_without_some_columns"

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.catalogueDatabaseName}")
    spark.sql("CREATE DATABASE IF NOT EXISTS db")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
 /*   spark.sql(s"CREATE TABLE IF NOT EXISTS $input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches INT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>, dataset_name STRING, retry_count INT, inter_retry_interval INT, " +
      "as_view BOOLEAN) stored as parquet") */
    spark.sql(s"CREATE TABLE IF NOT EXISTS $input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches BIGINT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")

    spark.sql(s"CREATE TABLE IF NOT EXISTS $input_req_table_with_metadata " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches BIGINT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")

    spark.sql(s"CREATE TABLE IF NOT EXISTS $input_req_table_without_some_columns " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "latest_only BOOLEAN, min_matches BIGINT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")

    import spark.implicits._

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue2.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    val tableName = s"""Person.${EmfConfig.defaultAccessView}"""
    Seq(("T1", "row1", Timestamp.valueOf("2021-03-01 00:00:00.1"), "Person",List(metaData("att","val","string","")).toArray), ("T2", "row2", Timestamp.valueOf("2021-03-01 00:00:00.1"), "Person",List(metaData("att","val","string","")).toArray)).toDF("entity_uuid", "colB", "__created","__file_type","__metadata").write.mode(SaveMode.Overwrite)
      .format("hive").saveAsTable(tableName)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS db CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql("DROP VIEW IF EXISTS resolve_view_table")
    spark.sql("DROP TABLE IF EXISTS resolve_temp_table")
    spark.sql(s"DROP TABLE IF EXISTS $input_req_table")
    spark.sql(s"DROP TABLE IF EXISTS $input_req_table_with_metadata")
    spark.sql(s"DROP TABLE IF EXISTS $input_req_table_without_some_columns")

    super.afterAll()
  }


  "invalid tablename in command" should "return Failed" in {
    val execResult: ExecutionResult = new SparkResolveFromInputRequirements("").run()
    assert(execResult == Failed)
  }

  "valid tablename in command" should "return Complete" in {

    import spark.implicits._

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", null), ResolutionConstraintRaw("md5", "10", null)))
    val whereClause = Option(List(ResolutionConstraintRaw("colB", "row1", null)))
/*
    val inputRequirementRaw1 = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause,
      dataset_name = null,
      retry_count = null,
      inter_retry_interval = null,
      as_view = true)

    val inputRequirementRaw2 = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_temp_table",
      constraints = resolutionConstraint,
      created_to = null,
      created_from = null,
      latest_only = true,
      min_matches = null,
      source_entity_type = "Data",
      where_clause = null,
      dataset_name = null,
      retry_count = null,
      inter_retry_interval = null,
      as_view = false)

    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw1, inputRequirementRaw2)) */

    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    spark.sql(s"TRUNCATE TABLE $input_req_table")
    inputRequirementDS.toDF.write.format("hive").insertInto(input_req_table)
    val inp = spark.sql(s"select * from $input_req_table").as[InputRequirementRaw]

    val execResult: ExecutionResult = new SparkResolveFromInputRequirements(input_req_table, None, true).run()

    assert(execResult == Complete)
    assert(spark.sql("select * from resolve_view_table").except(Seq(( "row1")).toDF).isEmpty)
  /*  assert(spark.sql("select * from resolve_temp_table").except(Seq(("T1", "row1")).toDF).isEmpty) */
  }


  "Handle the missing column - [created_from, created_to]" should "return Complete" in {

    import spark.implicits._

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", null), ResolutionConstraintRaw("md5", "10", null)))
    val whereClause = Option(List(ResolutionConstraintRaw("colB", "row1", null)))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = None,
      created_from = None,
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    spark.sql(s"TRUNCATE TABLE $input_req_table_without_some_columns")

    // prepare the table with missing columns
    val inputRequirementDSTest = inputRequirementDS.drop("created_to", "created_from")
    inputRequirementDSTest.write.format("hive").insertInto(input_req_table_without_some_columns)

    val caught = intercept[AnalysisException] {
      // FCCC-10593 Handle the case of columns not provided in input requirement table
      val inp = spark.sql(s"select * from $input_req_table_without_some_columns").as[InputRequirementRaw]
    }

    val execResult: ExecutionResult = new SparkResolveFromInputRequirements(input_req_table_without_some_columns, None, true).run()

    assert(execResult == Complete)
    assert(spark.sql("select * from resolve_view_table").except(Seq(("row1")).toDF).isEmpty)
  }


  "valid table name in command with inject_metadata = true" should "return Complete" in {

    import spark.implicits._
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", null), ResolutionConstraintRaw("md5", "10", null)))
    val whereClause = Option(List(ResolutionConstraintRaw("colB", "row1", null)))
    val targetTable = "resolve_view_table_with_meta"
    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = targetTable,
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    inputRequirementDS.toDF.write.format("hive").insertInto(input_req_table_with_metadata)
    val inp = spark.sql(s"select * from $input_req_table_with_metadata").as[InputRequirementRaw]

    val execResult: ExecutionResult = new SparkResolveFromInputRequirements(input_req_table_with_metadata, None, true, true).run()
    assert(execResult == Complete)
    assert(spark.sql(s"select * from $targetTable").except(Seq(("T1", "row1",Timestamp.valueOf("2021-03-01 00:00:00.1"), "Person",List(metaData("att","val","string","")).toArray)).toDF).isEmpty)

    // unionDataframeAsView should 1+1 -> 2
    new SparkResolveFromInputRequirements(input_req_table_with_metadata, None, true, true).run()
    assert(spark.sql(s"select * from $targetTable").count() ==2)

  }

/*
  "given a matching criteria in input requirements table " should "save the resolved dataframe as db.resolve_temp_table2 in resolveFromTable" in {

    import spark.implicits._

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", null), ResolutionConstraintRaw("md5", "10", null)))
    val whereClause = Option(List(ResolutionConstraintRaw("colB", "row1", null)))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_temp_table2",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause,
      dataset_name = Some("db"),
      retry_count = null,
      inter_retry_interval = null,
      as_view = false)

    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    spark.sql(s"TRUNCATE TABLE $input_req_table")
    inputRequirementDS.toDF.write.format("hive").insertInto(input_req_table)

    val execResult: ExecutionResult = new SparkResolveFromInputRequirements(input_req_table).run()

    assert(execResult == Complete)

    val curr_db = spark.catalog.currentDatabase
    spark.catalog.setCurrentDatabase("db")
    assert(spark.sql("show tables").where(s"database = 'db'" +
      s" and tableName = 'resolve_temp_table2' and isTemporary = false").count == 1)
    assert(spark.sql("select * from db.resolve_temp_table2").except(Seq(("T1", "row1")).toDF).isEmpty)
    spark.catalog.setCurrentDatabase(curr_db)

  }
*/
  "given resolve two tables " should "return a single table" in {

    import spark.implicits._

    val table_name = "GBM_ALM_SDI_CASHFLOW_V01_08"
    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue-union.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("file_freq", "DAILY", "="),
      ResolutionConstraintRaw("provider_country_code", "CH", "="), ResolutionConstraintRaw("group_sys_id", "GBM", "="), ResolutionConstraintRaw("group_sub_sys_id", "DFLT", "="),
      ResolutionConstraintRaw("reporting_date", "2021-03-31", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = "GBM_ALM_SDI_CASHFLOW_V01_08",
      constraints = resolutionConstraint,
      created_from = Some(Timestamp.valueOf("1900-01-01 00:00:00.0")),
      created_to = Some(Timestamp.valueOf("2100-01-01 00:00:00.0")),
      latest_only = false,
      min_matches = Some(0),
      source_entity_type = "data",
      where_clause = Option(List.empty)
    )

    val inputRequirementRaw1 = InputRequirementRaw(
      file_type = "Person",
      table_name = "GBM_ALM_SDI_CASHFLOW_V01_08",
      constraints = resolutionConstraint,
      created_from = Some(Timestamp.valueOf("1900-01-01 00:00:00.0")),
      created_to = Some(Timestamp.valueOf("2100-01-01 00:00:00.0")),
      latest_only = false,
      min_matches = Some(0),
      source_entity_type = "data",
      where_clause = Option(List.empty)
    )

    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw, inputRequirementRaw1))
    spark.sql(s"TRUNCATE TABLE $input_req_table")
    inputRequirementDS.toDF.write.format("hive").insertInto(input_req_table)


    val execResult: ExecutionResult = new SparkResolveFromInputRequirements(input_req_table,Some("target_dataset"),true).run()

    assert(execResult == Complete)
    assert(spark.sql("select * from GBM_ALM_SDI_CASHFLOW_V01_08").count() ==2)
    assert(spark.sql("select * from GBM_ALM_SDI_CASHFLOW_V01_08").except(Seq(("row1"),("row1")).toDF).isEmpty)
  }
}
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.resolution.{ DATA, ISourceEntityType, ResolutionConstraint, ResolutionCriteria}

case class SparkResolveMessage(criteria: ResolutionCriteria,
                               table_name: String,
                               where_clause: List[ResolutionConstraint] = List.empty,
                               source_entity_type: ISourceEntityType = DATA,
                               retry_count: Int = 0,
                               inter_retry_interval: Int = 0,
                               as_view: Boolean = false,
                               dataset_name: Option[String] = None,
                               inject_metadata: Boolean = false
                              ) extends ISparkCommandMessage
{
   var latest_only = true
}package hsbc.emf.infrastructure.services.mapper

import java.sql.Timestamp

import hsbc.emf.data.resolution._
import hsbc.emf.data.sparkcmdmsg.{SparkResolveMessage, SparkResolveMessageRaw}
import hsbc.emf.infrastructure.exception.SparkResolveMessageMapperException

object SparkResolveMessageMapper extends IMapper[SparkResolveMessageRaw, SparkResolveMessage] {
  @throws(classOf[SparkResolveMessageMapperException])
  override def map(sparkResolveRaw: SparkResolveMessageRaw): SparkResolveMessage = {
    try {
      val table_name: String = sparkResolveRaw.table_name
      val where_clause: List[ResolutionConstraint] = ResolutionConstraintMapper.map(sparkResolveRaw.where_clause)
      val source_entity_type = mapSourceEntityType(sparkResolveRaw.source_entity_type)
      val retry_count: Int = sparkResolveRaw.retry_count
      val inter_retry_interval: Int = sparkResolveRaw.inter_retry_interval
      val as_view = sparkResolveRaw.as_view
      val dataset_name = sparkResolveRaw.dataset_name
      val inject_metadata = sparkResolveRaw.inject_metadata

      val constraints: List[ResolutionConstraint] = ResolutionConstraintMapper.map(sparkResolveRaw.criteria.constraints)

      val resCriteria: ResolutionCriteria = ResolutionCriteria(
        file_type = sparkResolveRaw.criteria.file_type,
        constraints = constraints,
        created_from = mapCreatedFrom(sparkResolveRaw.criteria.created_from),
        created_to = mapCreatedTo(sparkResolveRaw.criteria.created_to),
        retry_count = sparkResolveRaw.criteria.retry_count,
        inter_retry_interval = sparkResolveRaw.criteria.inter_retry_interval,
        as_view = sparkResolveRaw.as_view,
        latest_only = sparkResolveRaw.latest_only,
        min_matches = sparkResolveRaw.criteria.min_matches)

      new SparkResolveMessage(resCriteria, table_name, where_clause, source_entity_type, retry_count, inter_retry_interval, as_view, dataset_name, inject_metadata)

    }
    catch {
      case e: Exception =>
        val customMessage = "SparkResolveMessageMapper.map - fails with other reason: " + e.getMessage
        throw new SparkResolveMessageMapperException(customMessage, e)
    }
  }




  private def mapCreatedFrom(createdFrom: Option[String]): Option[Timestamp] = {
    Some(createdFrom match {
      case Some(timestamp) => Timestamp.valueOf(timestamp)
      case None => Timestamp.valueOf("1900-01-01 00:00:00")
    })
  }

  private def mapCreatedTo(createdTo: Option[String]): Option[Timestamp] = {
    Some(createdTo match {
      case Some(timestamp) => Timestamp.valueOf(timestamp)
      case None => Timestamp.valueOf("2100-01-01 00:00:00")
    })
  }

  @throws(classOf[SparkResolveMessageMapperException])
  private def mapSourceEntityType(sourceEntityType: String): ISourceEntityType = {
    sourceEntityType match {
      case "ADJUSTED_UNAPPROVED" => ADJUSTED_UNAPPROVED
      case "ADJUSTED_APPROVED" => ADJUSTED_APPROVED
      case _ => DATA
    }
  }

}
package hsbc.emf.infrastructure.services.mapper

import java.sql.Timestamp

import hsbc.emf.data.resolution.{ADJUSTED_APPROVED, GreaterThan, Like, NotIn}
import hsbc.emf.data.sparkcmdmsg.{SparkResolveMessage, SparkResolveMessageRaw}
import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkResolveMessageMapperTest extends IntegrationTestSuiteBase {

  "given json with all fields" should "return message object" in {

    val params =
      """{"criteria":{"file_type" : "person","constraints":[{"attribute":"attribute1","value":"value1","operator":"LIKE"}],
        |"created_from":"2021-01-01 12:22:00.0","created_to":"2021-01-01 12:25:00.0","retry_count" :2,
        |"inter_retry_interval":2,"latest_only": false,"min_matches":22},"table_name":"testTable",
        |"where_clause":[{"attribute":"attribute1","value":"value1","operator":"NOT IN"},{"attribute":"attribute2","value":"value2","operator":">"}],
        |"source_entity_type":"ADJUSTED_APPROVED","retry_count" :2,"inter_retry_interval":2,"as_view":false,"dataset_name":"testDataSet"}""".stripMargin

    val sparkResolveMessageRawMsg = JsonReader.deserialize[SparkResolveMessageRaw](params).right.get
    assert(sparkResolveMessageRawMsg.isInstanceOf[SparkResolveMessageRaw])

    val msg: SparkResolveMessage = SparkResolveMessageMapper.map(sparkResolveMessageRawMsg)
    assert(msg.isInstanceOf[SparkResolveMessage])

    //criteria optional parameters, values passed in json and default values are not set
    assert(msg.criteria.constraints(0).attribute.equals("attribute1"))
    assert(msg.criteria.constraints(0).value.equals("value1"))
    assert(msg.criteria.constraints(0).operator.equals(Like))
    assert(msg.criteria.created_from.equals(Some(Timestamp.valueOf("2021-01-01 12:22:00.0"))))
    assert(msg.criteria.created_to.equals(Some(Timestamp.valueOf("2021-01-01 12:25:00.0"))))
    assert(msg.criteria.retry_count.equals(2))
    assert(msg.criteria.inter_retry_interval.equals(2))
    assert(msg.criteria.as_view.equals(false))
    assert(msg.criteria.latest_only.equals(true))
    assert(msg.criteria.min_matches.equals(22L))

    //SparkResolveMessage optional parameters, values passed in json and default values are not set
    assert(msg.where_clause(0).attribute.equals("attribute1"))
    assert(msg.where_clause(0).value.equals("value1"))
    assert(msg.where_clause(0).operator.equals(NotIn))
    assert(msg.where_clause(1).attribute.equals("attribute2"))
    assert(msg.where_clause(1).value.equals("value2"))
    assert(msg.where_clause(1).operator.equals(GreaterThan))
    assert(msg.source_entity_type.equals(ADJUSTED_APPROVED))
    assert(msg.retry_count.equals(2))
    assert(msg.inter_retry_interval.equals(2))
    assert(msg.as_view.equals(false))
    assert(msg.dataset_name.contains("testDataSet"))
  }
}
package hsbc.emf.data.sparkcmdmsg


import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.resolution._

final case class SparkResolveMessageRaw(criteria: ResolutionCriteriaRaw,
                               table_name: String,
                               where_clause: List[ResolutionConstraintRaw] = List.empty ,
                               source_entity_type: String = "DATA",
                               retry_count: Int = 0,
                               inter_retry_interval: Int = 0,
                               as_view: Boolean = false,
                               dataset_name: Option[String] = None,
                               inject_metadata: Boolean = false
                              ) extends ISparkCommandMessage
{
  var latest_only = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.infrastructure.services.mapper.SparkResolveMessageMapper
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkResolveMessageRawTest extends IntegrationTestSuiteBase {

  "given json with required fields" should "return message object" in {

    val params = """{"criteria":{"file_type" : "person"},"table_name":"testTable","source_entity_type":"DATA"}"""

    val msg = JsonReader.deserialize[SparkResolveMessageRaw](params).right.get
    assert(msg.isInstanceOf[SparkResolveMessageRaw])

    //criteria optional parameters, values not passed in json and default values are set
    assert(msg.criteria.constraints.equals(List.empty))
    assert(msg.criteria.created_from.contains("1900-01-01 00:00:00"))
    assert(msg.criteria.created_to.contains("2100-01-01 00:00:00"))
    assert(msg.criteria.retry_count.equals(0))
    assert(msg.criteria.inter_retry_interval.equals(0))
    assert(msg.criteria.as_view.equals(false))
    assert(msg.criteria.latest_only.equals(true))
    assert(msg.criteria.min_matches.equals(0L))

    //SparkResolveMessage optional parameters, values not passed in json and default values are set
    assert(msg.where_clause.equals(List.empty))
    assert(msg.source_entity_type === "DATA")
    assert(msg.retry_count.equals(0))
    assert(msg.inter_retry_interval.equals(0))
    assert(msg.as_view.equals(false))
    assert(msg.dataset_name.equals(None))
  }

  "given json with all fields" should "return message object" in {

    val params =
      """{"criteria":{"file_type" : "person","constraints":[{"attribute":"attribute1","value":"value1","operator":"LIKE"}],
        |"created_from":"2021-01-01 12:22:00.0","created_to":"2021-01-01 12:25:00.0","retry_count" :2,
        |"inter_retry_interval":2,"latest_only": false,"min_matches":22},"table_name":"testTable",
        |"where_clause":[{"attribute":"attribute1","value":"value1","operator":"NOT IN"},{"attribute":"attribute2","value":"value2","operator":">"}],
        |"source_entity_type":"ADJUSTED_UNAPPROVED","retry_count" :2,"inter_retry_interval":2,"as_view":false,"dataset_name":"testDataSet"}""".stripMargin

    val msg = JsonReader.deserialize[SparkResolveMessageRaw](params).right.get
    assert(msg.isInstanceOf[SparkResolveMessageRaw])

    val mess1: SparkResolveMessage = SparkResolveMessageMapper.map(msg)

    //criteria optional parameters, values passed in json and default values are not set
    assert(msg.criteria.constraints(0).attribute.equals("attribute1"))
    assert(msg.criteria.constraints(0).value.equals("value1"))
    assert(msg.criteria.constraints(0).operator.equals("LIKE"))
    assert(msg.criteria.created_from.contains("2021-01-01 12:22:00.0"))
    assert(msg.criteria.created_to.contains("2021-01-01 12:25:00.0"))
    assert(msg.criteria.retry_count.equals(2))
    assert(msg.criteria.inter_retry_interval.equals(2))
    assert(msg.criteria.as_view.equals(false))
    assert(msg.criteria.latest_only.equals(false))
    assert(msg.criteria.min_matches.equals(22L))

    //SparkResolveMessage optional parameters, values passed in json and default values are not set
    assert(msg.where_clause(0).attribute.equals("attribute1"))
    assert(msg.where_clause(0).value.equals("value1"))
    assert(msg.where_clause(0).operator.equals("NOT IN"))
    assert(msg.where_clause(1).attribute.equals("attribute2"))
    assert(msg.where_clause(1).value.equals("value2"))
    assert(msg.where_clause(1).operator.equals(">"))
    assert(msg.source_entity_type.equals("ADJUSTED_UNAPPROVED"))
    assert(msg.retry_count.equals(2))
    assert(msg.inter_retry_interval.equals(2))
    assert(msg.as_view.equals(false))
    assert(msg.dataset_name.contains("testDataSet"))
  }

  "given json with as_view=true fields" should "return message object" in {

    val params =
      """{"criteria":{"file_type" : "person","constraints":[{"attribute":"attribute1","value":"value1","operator":"LIKE"}],
        |"created_from":"2021-01-01 12:22:00.0","created_to":"2021-01-01 12:25:00.0","retry_count" :2,
        |"inter_retry_interval":2,"latest_only": false,"min_matches":22},"table_name":"testTable",
        |"where_clause":[{"attribute":"attribute1","value":"value1","operator":"NOT IN"},{"attribute":"attribute2","value":"value2","operator":">"}],
        |"source_entity_type":"ADJUSTED_UNAPPROVED","retry_count" :2,"inter_retry_interval":2,"as_view":true,"dataset_name":"testDataSet"}""".stripMargin

    val msg = JsonReader.deserialize[SparkResolveMessageRaw](params).right.get
    assert(msg.isInstanceOf[SparkResolveMessageRaw])

    val mess1: SparkResolveMessage = SparkResolveMessageMapper.map(msg)
    //criteria optional parameters, values passed in json and default values are not set
    assert(msg.criteria.constraints(0).attribute.equals("attribute1"))
    assert(msg.criteria.constraints(0).value.equals("value1"))
    assert(msg.criteria.constraints(0).operator.equals("LIKE"))
    assert(msg.criteria.created_from.contains("2021-01-01 12:22:00.0"))
    assert(msg.criteria.created_to.contains("2021-01-01 12:25:00.0"))
    assert(msg.criteria.retry_count.equals(2))
    assert(msg.criteria.inter_retry_interval.equals(2))
    assert(msg.criteria.as_view.equals(false))
    assert(msg.criteria.latest_only.equals(false))
    assert(msg.criteria.min_matches.equals(22L))

    //SparkResolveMessage optional parameters, values passed in json and default values are not set
    assert(msg.where_clause(0).attribute.equals("attribute1"))
    assert(msg.where_clause(0).value.equals("value1"))
    assert(msg.where_clause(0).operator.equals("NOT IN"))
    assert(msg.where_clause(1).attribute.equals("attribute2"))
    assert(msg.where_clause(1).value.equals("value2"))
    assert(msg.where_clause(1).operator.equals(">"))
    assert(msg.source_entity_type.equals("ADJUSTED_UNAPPROVED"))
    assert(msg.retry_count.equals(2))
    assert(msg.inter_retry_interval.equals(2))
    assert(msg.as_view.equals(true))
    assert(msg.dataset_name.contains("testDataSet"))
  }
}package hsbc.emf.service.resolution

import scala.util.{Failure, Success, Try}
import hsbc.emf.command.PlaceholderParameterisation
import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.ingestion.CatalogueEntity
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution._
import hsbc.emf.data.sparkcmdmsg.{SparkResolveFromInputRequirementsMessage, SparkResolveMessage}
import hsbc.emf.infrastructure.config.{EmfConfig, FileFormatConfig, OrcFileFormatConfig}
import hsbc.emf.infrastructure.exception.{InvalidSourceEntity, ResolveError}
import hsbc.emf.infrastructure.helper.{HelperUtility, HiveUtils}
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.{AuditLogger, ResolutionInfo}
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.services.mapper.InputReqRawToInputReqMapper
import hsbc.emf.infrastructure.sql.ISqlExecutor
import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}
import org.apache.spark.sql.expressions.Window
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._

class SparkResolveService(sqlExector: ISqlExecutor, catalogueDAO: ICatalogueDAO)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo)

  extends ISparkResolveService with MessageContext {

  override def resolve(resolveMessage: SparkResolveMessage): Unit = {

   Try {
      EmfLogger.debug("SparkResolveService.resolve file_type: " +
        resolveMessage.criteria.file_type)

      if (resolveMessage.criteria.file_type == null || resolveMessage.criteria.file_type.trim.isEmpty) {
        EmfLogger.error(s"SparkResolveService null or empty file_type in criteria:")
        throw new ResolveError(s"file_type cannot be null or empty")
      }

      if (resolveMessage.table_name == null || resolveMessage.table_name.trim.isEmpty) {
        EmfLogger.error(s"SparkResolveService null or empty table_name in criteria:")
        throw new ResolveError(s"table_name cannot be null or empty")
      }
      val resolutionTarget = ResolutionTarget(resolveMessage.table_name, resolveMessage.source_entity_type, resolveMessage.where_clause)
      val (resultList, errorMessage) = constructCatalogue4Uuids(resolveMessage.criteria, resolveMessage.latest_only)
      // Audit Logging : ResolutionInfo
      val resolutionInfo = ResolutionInfo(messageInfo, resolveMessage.criteria, resultList, resultList.size, resolutionTarget)
      AuditLogger().audit[ResolutionInfo](resolutionInfo)

      if (resultList.nonEmpty & errorMessage.isEmpty) {
        val entityUuidList = resultList.map(res => res.entity_uuid)
        EmfLogger.debug(s"SparkResolveService resolved list of entities: $entityUuidList")
        val resolvedDF = this.constructDataDF(resolveMessage.criteria.file_type, entityUuidList,
          ResolutionTarget(resolveMessage.table_name, resolveMessage.source_entity_type, resolveMessage.where_clause, None, resolveMessage.inject_metadata))
        if (resolveMessage.as_view) {
          if (HiveUtils.checkTableInCatalogue(resolveMessage.table_name)) {
            unionDataframeAsView(resolveMessage.table_name, resolvedDF)
          }
          else saveDataFrameAsView(resolveMessage.table_name, resolvedDF)
        }

        /**
          * Requirement:
          * "As limitation on Azure hive, SPARK-CREATE_TABLE will create table as ORC only."
          */
        else appendDataFrameToTable(resolveMessage.dataset_name, resolveMessage.table_name, resolvedDF, OrcFileFormatConfig())
      }
      else {
        /* FCCC-10945 as the min_matches = 0,
        if no entity_uuid return to resolve data,
        then should skip the resolve(no view will be created) and should not throw exception to stop program.
        */
        if (resultList.isEmpty && resolveMessage.criteria.min_matches == 0) {
          EmfLogger.warn(s"min_matches is 0 and no entity uuid list return." +
            s"Resolution for file type [${resolveMessage.criteria.file_type}] will be skipped.")
          EmfLogger.warn(s"$errorMessage for criteria: ${resolveMessage.criteria}")
        } else {
          EmfLogger.error(s"$errorMessage for criteria: ${resolveMessage.criteria}")
          throw new ResolveError(s"Cannot resolve the user inputs")
        }
      }
    } match {
      case Success(_) =>
      case Failure(exception) => exception match {
        case rsEx: ResolveError =>
          EmfLogger.error(s"SparkResolveService.resolve ResolveError : ${rsEx.getMessage}")
          throw rsEx
        case _ =>
          EmfLogger.error(s"SparkResolveService.resolve failed with error : ${exception.getMessage}")
          throw new RuntimeException("SparkResolveService.resolve failed", exception)
      }
    }
  }

  /** Fetches Catalogue uuids base on the input Resolution Criteria
    *
    * @param criteria   a ResolutionCriteria Object
    * @param latestOnly a boolean if yes only fetches latest records
    * @return tuple(List of uuids, String tag) returns a tuple of List of uuids as string and a tag.
    */
  def constructCatalogue4Uuids(criteria: ResolutionCriteria, latestOnly: Boolean): (List[CatalogueEntity], String) = {

    val catalogList = Try(this.catalogueDAO.readByFileType(criteria.file_type)) match {
      case Success(value) => value
      case Failure(exception) => throw new RuntimeException(
        s"SparkResolveService.constructCatalogue4Uuids failed to fetch Catalog List for file_type {$criteria.file_type}", exception)
    }

    if (catalogList.nonEmpty) {
      val resultList = catalogList
        .map(entity =>
          Try(Match.run(entity, criteria)) match {
            case Success(value) => value
            case Failure(exception) => throw new RuntimeException("Match.run has failed", exception)
          }
        )
        .filter(matchedResult => matchedResult._2)
      if (criteria.min_matches > 0 & resultList.length < criteria.min_matches) (resultList.map(_._1),
        s"as number of resolved entities ${resultList.length} failed to meet the min_matches criteria of ${criteria.min_matches}")
      else {
        if (latestOnly) (resultList.sortWith((a, b) => b._1.created.before(a._1.created)).map(_._1) take 1, "")
        else (resultList.map(_._1), "")
      }
    }
    else (List.empty[CatalogueEntity], s"Cannot resolve entities as catalog returned for the file_type: ${criteria.file_type} is empty")
  }

  private def constructDataDF(fileType: String, listUUIDS: List[String], resolutionTarget: ResolutionTarget): DataFrame = {
    Try {
      val filterEntityExpression =
        s"""(${listUUIDS.map(x => s""""$x"""").reduce(_ concat "," concat _)})"""

      EmfLogger.debug(s"SparkResolveService Data filter expression: $filterEntityExpression")

      val tableSuffix = resolutionTarget.source_entity_type match {
        case DATA => EmfConfig.defaultAccessView
        case ADJUSTED_UNAPPROVED | ADJUSTED_APPROVED => generateAdjustmentViews(listUUIDS.head, fileType, s"${resolutionTarget.source_entity_type}")
        case _ => EmfLogger.error(s"SparkResolveService Invalid Source entity Type: ${resolutionTarget.source_entity_type}")
          throw new InvalidSourceEntity(s"Invalid source entity type:- ${resolutionTarget.source_entity_type}")
      }

      val srcTblName = fileType + "." + tableSuffix

      val dataDF = resolutionTarget.source_entity_type match {
        case ADJUSTED_UNAPPROVED | ADJUSTED_APPROVED =>
          this.sqlExector.execute(s"select * from $tableSuffix")
        case _ =>
          this.sqlExector.execute(s"select * from $srcTblName where entity_uuid in $filterEntityExpression")
      }

      val dfColumnTypes = dataDF.dtypes

      val resultDf = if (resolutionTarget.where_clause != null & resolutionTarget.where_clause.nonEmpty) {
        var dataDFFiltered = dataDF
        resolutionTarget.where_clause
          .map(FilterExpression.makeFilterString(_, dfColumnTypes))
          .foreach(eachvalue => {
            dataDFFiltered = dataDFFiltered.filter(eachvalue)
          })
        dataDFFiltered
      }
      else {
        dataDF
      }

      /**
        * If inject_metadata being false,
        * need to drop (entitiy_uuid, __file_type,__created,__metadata) after read data from soruce_table.access_view
        * If inject_metadata being true,
        * save the dataframe and with  fields (__file_type,__created,__metadata) with  entity_uuid(normal column).
        * */
      if (resolutionTarget.inject_metadata) {
        if (resultDf.columns.toSet.intersect(Set("__file_type", "__metadata", "__created")).size !=3) {
          EmfLogger.error(s"SparkResolveService constructDataDF failed with error. " +
            s"Reason: There are not enough columns as required for inject_metadata. " +
            s"file_type: $fileType, listUUIDS: $listUUIDS, srcTblName: $srcTblName, " +
            s"resolutionTarget: $resolutionTarget")
          throw new ResolveError("SparkResolveService constructDataDF failed")
        }
        resultDf
      } else {
        resultDf.drop("__file_type", "__metadata", "__created", "entity_uuid")
      }
    } match {
      case Success(v) => v
      case Failure(exception) =>
        EmfLogger.error(s"SparkResolveService constructDataDF failed with error. Reason: ${exception.getMessage}")
        throw new ResolveError("SparkResolveService constructDataDF failed", exception)
    }
  }

  override def resolveFromTable(sparkResolveFromInputRequirementsMessage: SparkResolveFromInputRequirementsMessage,
                                placeholderParams: PlaceholderParameters = PlaceholderParameters(Map.empty[String, Any])): Unit = {
    Try {
      EmfLogger.debug(s"SparkResolveFromInputRequirements service sparkResolveFromInputRequirementsMessage:" +
        s"$sparkResolveFromInputRequirementsMessage")
      EmfLogger.debug(s"SparkResolveFromInputRequirements service placeholderParams: $placeholderParams")
      // Replace input req table name with target_dataset if no dataset name given
      import spark.implicits._
      val inputRequirementsTableName =
        if (sparkResolveFromInputRequirementsMessage.input_requirements_table_name.contains(".")) {
          sparkResolveFromInputRequirementsMessage.input_requirements_table_name
        }
        else {
          val inpReqDataset = placeholderParams.format.getOrElse(s"${EmfConfig.sparkRunGeneratedParamNameTargetDataset}", "")
          if (inpReqDataset.trim.nonEmpty) {
            placeholderParams.format(s"${EmfConfig.sparkRunGeneratedParamNameTargetDataset}") + "." +
              sparkResolveFromInputRequirementsMessage.input_requirements_table_name
          }
          else {
            sparkResolveFromInputRequirementsMessage.input_requirements_table_name
          }
        }
      // Read input req table rows into InputRequirementRaw
      EmfLogger.debug(s"SparkResolveFromInputRequirements service inputRequirementsTableName: $inputRequirementsTableName")
      var inputRequirementRawDSSource = this.sqlExector
        .execute(s"select * from $inputRequirementsTableName")

      val rawColumnsSet = Set("file_type", "table_name", "constraints", "created_to", "created_from",
        "latest_only", "min_matches", "source_entity_type", "where_clause")
      for (col <- rawColumnsSet.diff(inputRequirementRawDSSource.columns.toSet)) {
        inputRequirementRawDSSource = inputRequirementRawDSSource.withColumn(col, expr("null"))
      }
      val inputRequirementRawDS = inputRequirementRawDSSource.as[InputRequirementRaw]

      // Substitute placeholder parameters for each row in inp req table and map each row InputRequirementRaw -> InputRequirement
      val inputRequirementList = inputRequirementRawDS.collect().toList
        .map(row => placeholderParametersSubstitution(row, placeholderParams))
        .map(InputReqRawToInputReqMapper.map)
      EmfLogger.debug(s"SparkResolveFromInputRequirements service inputRequirementList: $inputRequirementList")

      // For each row of inp req table construct SparkResolveMessage and call resolve service
      val transformedCollection =
        if (sparkResolveFromInputRequirementsMessage.as_view) {
          inputRequirementList
            .map(inputRequirement => constructSparkResolveMessage(inputRequirement,
              sparkResolveFromInputRequirementsMessage,
              placeholderParams))
        }
        else {
          val parallelCollection = inputRequirementList
            .map(inputRequirement => constructSparkResolveMessage(inputRequirement,
              sparkResolveFromInputRequirementsMessage,
              placeholderParams)).par
          // The following code is a hint to developers how to control the level of concurrency for future reference.
          // val forkJoinPool = new java.util.concurrent.ForkJoinPool(10)
          // parallelCollection.tasksupport = new ForkJoinTaskSupport(forkJoinPool)
          parallelCollection
        }
      transformedCollection.foreach(resolveMessage => resolve(resolveMessage))
    } match {
      case Success(_) =>
      case Failure(exception) =>
        EmfLogger.error(s"SparkResolve Service resolveFromTable failed. Reason : ${exception.getMessage}")
        throw new ResolveError("SparkResolve Service resolveFromTable failed", exception)
    }
  }

  private def constructSparkResolveMessage(inputRequirement: InputRequirement,
                                           sparkResolveFromInputRequirementsMessage: SparkResolveFromInputRequirementsMessage,
                                           placeholderParams: PlaceholderParameters): SparkResolveMessage = {
    val targetDataset =
      if (!sparkResolveFromInputRequirementsMessage.as_view &&
        sparkResolveFromInputRequirementsMessage.dataset_name.isEmpty) {
        Try {
          Some(placeholderParams.format(s"${EmfConfig.sparkRunGeneratedParamNameTargetDataset}"))
        }
        match {
          case Success(value) => value
          case Failure(exception) =>
            val errorMessage = s"SparkResolveFromInputRequirements constructSparkResolveMessage error: Failed to lookup target_dataset from " +
              s"placeholderParams: $placeholderParams for the case that asView is false and dataset_name is omitted "
            EmfLogger.error(s"errorMessage. Reason : {${exception.getMessage}}")
            throw new ResolveError(errorMessage, exception)
        }
      }
      else sparkResolveFromInputRequirementsMessage.dataset_name


    val sparkResolveMessage = SparkResolveMessage(inputRequirement.criteria,
      inputRequirement.target.table_name,
      inputRequirement.target.where_clause,
      inputRequirement.target.source_entity_type,
      inputRequirement.criteria.retry_count,
      inputRequirement.criteria.inter_retry_interval,
      sparkResolveFromInputRequirementsMessage.as_view,
      targetDataset,
      sparkResolveFromInputRequirementsMessage.inject_metadata
    )
    sparkResolveMessage.latest_only = inputRequirement.criteria.latest_only
    EmfLogger.debug(s"SparkResolveFromInputRequirements service constructSparkResolveMessage " +
      s"sparkResolveMessage: $sparkResolveMessage")
    sparkResolveMessage
  }

  private def placeholderParametersSubstitution(inputRequirementRaw: InputRequirementRaw,
                                                placeholderParameters: PlaceholderParameters): InputRequirementRaw = {
    inputRequirementRaw
      .copy(file_type = PlaceholderParameterisation.insertParams(placeholderParameters, inputRequirementRaw.file_type),
        table_name = PlaceholderParameterisation.insertParams(placeholderParameters, inputRequirementRaw.table_name),
        constraints = substituteConstraints(inputRequirementRaw.constraints, placeholderParameters),
        source_entity_type = PlaceholderParameterisation.insertParams(placeholderParameters,
          inputRequirementRaw.source_entity_type),
        where_clause = substituteConstraints(inputRequirementRaw.where_clause, placeholderParameters)
      )
  }

  private def substituteConstraints(constraints: Option[List[ResolutionConstraintRaw]],
                                    placeholderParameters: PlaceholderParameters): Option[List[ResolutionConstraintRaw]] = {
    constraints match {
      case Some(constraintsList) =>
        val substitutedConstraintsList =
          constraintsList.map(constraintItem =>
            ResolutionConstraintRaw(
              PlaceholderParameterisation.insertParams(placeholderParameters, constraintItem.attribute),
              PlaceholderParameterisation.insertParams(placeholderParameters, constraintItem.value),
              PlaceholderParameterisation.insertParams(placeholderParameters, constraintItem.operator)
            )
          )
        Some(substitutedConstraintsList)
      case None => None
    }
  }

  private def saveDataFrameAsView(viewName: String, resolvedDataFrame: DataFrame): Unit = {

    Try {
      resolvedDataFrame.createOrReplaceTempView(viewName)
      spark.catalog.cacheTable(viewName)
      EmfLogger.debug(s"SparkResolveService saveDataframeAsView dataframe saved as view: $viewName ")
    } match {
      case Success(_) =>
      case Failure(exception) =>
        EmfLogger.error(s"SparkResolveService saveDataframeAsView error while saving resolved dataframe as view: $viewName. Reason : ${exception.getMessage}")
        throw new ResolveError(s"Error in saveDataframeAsView", exception)
    }

  }

  private def unionDataframeAsView(viewName: String, resolvedDataFrame: DataFrame): Unit = {
    Try {
      val existingViewDF = spark.table(s"$viewName")
      saveDataFrameAsView(viewName, existingViewDF.union(resolvedDataFrame))
      EmfLogger.debug(s"SparkResolveService dataframe unioned and saved as view: $viewName ")
    } match {
      case Success(_) =>
      case Failure(exception) =>
        EmfLogger.error(
          s"SparkResolveService unionDataframeAsView error while union and saving resolved dataframe as view: $viewName. Reason: ${exception.getMessage}")
        throw new ResolveError(s"Error in unionDataframeAsView", exception)
    }
  }

  private def appendDataFrameToTable(datasetName: Option[String], tableName: String, resolvedDataFrame: DataFrame,
                                     fileFormatConfig: FileFormatConfig): Unit = {
    Try {
      // FCCC-11638: To fix the issue 404/412 error in GCP/Azure, change to use external table
      // FCCC-12084: Implement same parallel write change as FCCC-11875 (SQL Eval) to add extra partitioned column x__uuid to resulting DataFrame
      val dfWriter = new DataFrameWriterService(fileFormatConfig)
      val fullTableName = s"${datasetName.getOrElse("default")}.$tableName"

      if (spark.catalog.tableExists(fullTableName)) {
        if (spark.table(fullTableName).columns.contains(EmfConfig.runtime_uuid_column)) {
          val updatedDF  = resolvedDataFrame.withColumn(EmfConfig.runtime_uuid_column, lit(HelperUtility.generateRunUUID()))
          dfWriter.saveDFAsTable(updatedDF , tableName, datasetName, SaveMode.Append, List(EmfConfig.runtime_uuid_column), None, Some(true))
        } else {
          if (resolvedDataFrame.columns.contains(EmfConfig.runtime_uuid_column)) {
            val updatedDF  = resolvedDataFrame.drop(EmfConfig.runtime_uuid_column)
            dfWriter.saveDFAsTable(updatedDF , tableName, datasetName, SaveMode.Append, List.empty[String], None, Some(true))
          } else {
            dfWriter.saveDFAsTable(resolvedDataFrame, tableName, datasetName, SaveMode.Append, List.empty[String], None, Some(true))
          }
        }
      } else {
        val updatedDF  = resolvedDataFrame.withColumn(EmfConfig.runtime_uuid_column, lit(HelperUtility.generateRunUUID()))
        dfWriter.saveDFAsTable(updatedDF, tableName, datasetName, SaveMode.Append, List(EmfConfig.runtime_uuid_column), None, Some(true))
      }
      EmfLogger.debug(s"SparkResolveService resolved DataFrame appended to table: $fullTableName")
    } match {
      case Success(_) =>
      case Failure(exception) => EmfLogger.error("SparkResolveService appendDataFrameToTable error while appending resolved DataFrame to table:" +
        s" ${datasetName.getOrElse("default")}.$tableName. Reason : ${exception.getMessage}")
        throw new ResolveError(s"Error in appendDataFrameToTable", exception)
    }
  }

  def generateAdjustmentViews(entityUuid: String, fileType: String, sourceEntityType: String): String = {
    import spark.implicits._
    Try {
      // generate unique id for temp view names
      val uid = java.util.UUID.randomUUID.toString.replaceAll("-", "")
      val FILETYPE = fileType.toUpperCase
      val cellTable = reformatMetadataColumn(this.sqlExector.execute(
        s"select * from adjustment_cell.access_view where adjusted_table_uuid='$entityUuid'"))
      val baseTable = reformatMetadataColumn(this.sqlExector.execute(
        s"select * from $fileType.access_view where entity_uuid ='$entityUuid'"))
      // fetch column list and data types of respective columns
      val dtype = baseTable.drop(
        "__file_type", "__created", "__metadata", "entity_uuid", "__uuid")
        .schema.fields.map(f => f.dataType).mkString(" , ").replaceAll("Type", "").split(" , ")
      val colnames = baseTable.drop(
        "__file_type", "__created", "__metadata", "entity_uuid", "__uuid").schema.names.map(_.toLowerCase())
      // create an array of dynamic columnName,datatype for further processing
      val colDtype = colnames.zip(dtype).map { case (v1, v2) => (v1, v2) }

      // process records from cell table and explode nested arrays
      val cellDf1 = cellTable.select(cellTable("*"), explode($"row_set"))
        .select("entity_uuid", "adjustment_category", "adjustment_uuid", "description"
          , "remediation_type", "retrieval_timestamp", "row_set", "rule_id"
          , "col.change_type", "col.__uuid","col.cells", "__file_type", "__created", "__metadata")
      val cellDf2 = cellDf1.select(cellDf1("*"), explode($"cells")).select("*", "col.attribute", "col.old", "col.value", "change_type", "__uuid")
      // check if the output_view_type is ADJUSTED_UNAPPROVED or ADJUSTED_APPROVED for further processing

      if (sourceEntityType == "ADJUSTED_UNAPPROVED") {
        generateUnapprovedAdjustmentViews(cellDf2, colDtype, baseTable, uid, FILETYPE, entityUuid, colnames)
      }
      else {
        generateApprovedAdjustmentViews(cellDf2, colDtype, baseTable, uid, FILETYPE, entityUuid, colnames)
      }
    } match {
      case Success(value) => value
      case Failure(exception) =>
        EmfLogger.error(s"SparkResolveService generateAdjustmentViews failed with error. Reason: ${exception.getMessage} ")
        throw new ResolveError("SparkResolveService generateAdjustmentViews failed", exception)
    }
  }

  private def generateUnapprovedAdjustmentViews(cellDf2: DataFrame, colDtype: Array[Tuple2[String, String]], baseTable: DataFrame,
                                                uid: String, FILETYPE: String, entityUuid: String, colNames: Array[String]): String = {
    import spark.implicits._
    Try{
      // pivot the data creating one row per cell base add adjustment
      val ENTITYUUID = entityUuid.replaceAll("-", "_")
      val cellUnapproved = cellDf2.groupBy("__uuid", "retrieval_timestamp", "change_type", "entity_uuid", "__file_type", "__created", "__metadata" )
        .agg(collect_list(struct(lit(FILETYPE)
          .as("adjustment_table_name"), $"entity_uuid", $"adjustment_uuid", lit("CELL")
          .as("adjustment_type"), $"change_type", $"retrieval_timestamp", $"adjustment_category",
          $"remediation_type", $"rule_id", $"attribute", $"old", $"value", $"description"))
          .as("adjustment_info"))
        .withColumn("adjustment_type", lit("CELL"))
        .select("adjustment_type", "adjustment_info", "__uuid", "retrieval_timestamp", "change_type", "entity_uuid",
          "__file_type", "__created", "__metadata")
        .withColumn("retrieval_timestamp", cellDf2("retrieval_timestamp").cast("timestamp"))
      val cellExplodeUnapproved = cellUnapproved.select(cellUnapproved("*"), $"adjustment_info", explode($"adjustment_info"))
        .select("*", "col.attribute", "col.old", "col.value").drop("col").toDF()
      val colArrayUnapproved = Array("adjustment_type", "adjustment_info", "__uuid", "retrieval_timestamp", "change_type") ++ colNames ++
        Array("entity_uuid", "__file_type", "__created", "__metadata")
      val pivotedUnapporved = cellExplodeUnapproved.groupBy(
        "adjustment_type", "adjustment_info", "__uuid", "retrieval_timestamp", "change_type", "entity_uuid", "__file_type",
        "__created", "__metadata")
        .pivot(lower($"attribute"), colNames).agg(max("value"))
        .selectExpr(colArrayUnapproved: _*)
      val resultUnapproved = colDtype.foldLeft(pivotedUnapporved)((accDF, c) => accDF.withColumn(c._1, accDF(c._1).cast(c._2)))
        .withColumnRenamed("__uuid", "__uuid1")

      val baseDf2 = baseTable.select(
        lit("BASE").as("adjustment_type"),
        array(struct(
          lit("NULL").as("adjustment_table_name"), lit("NULL").as("entity_uuid"),
          lit("NULL").as("adjustment_uuid"), lit("NULL").as("adjustment_type"),
          lit("NULL").as("change_type"), lit("NULL").cast("timestamp").as("retrieval_timestamp"),
          lit("NULL").as("adjustment_category"), lit("NULL").as("remediation_type"),
          lit("NULL").as("rule_id"), lit("NULL").as("attribute"),
          lit("NULL").as("old"), lit("NULL").as("value"),
          lit("NULL").as("description"))
        ).as("adjustment_info"),
        baseTable("__uuid").as("__uuid1"), lit("1900-01-01").as("retrieval_timestamp").cast("timestamp"),
        lit("BASE").as("change_type"), baseTable("*")).drop("__uuid")
      // union cell based and base data records
      val unioned = baseDf2.union(resultUnapproved.select(baseDf2.columns.head, baseDf2.columns.tail: _*)).withColumnRenamed("__uuid1", "__uuid")
      // Calculating the "to date" for each base data adjusted records
      val windowspec = Window.partitionBy("__uuid").orderBy("retrieval_timestamp")
      val windowspec1 = Window.partitionBy("__uuid")
      val del_date = unioned.withColumn("lead", lead("retrieval_timestamp", 1, "2099-12-31")
        .over(windowspec)).withColumnRenamed("lead", "to_date")
        .withColumn("delete_date", min(
          when(lower(col("change_type")) === "delete", col("retrieval_timestamp"))
            .otherwise("null")).over(windowspec1))
        .withColumnRenamed("retrieval_timestamp", "from_date").select("*")

      // If a row is related to 'Delete' changes, disregard all subsequent Update/Delete changes

      val mergedUnapproved = del_date.filter(lower(del_date("change_type")) =!= "delete")
        .filter((del_date("delete_date") =!= "null") && (del_date("to_date") <= del_date("delete_date")) || (del_date("delete_date") === "null"))
      mergedUnapproved.createOrReplaceTempView("merged_unapproved_" + uid)
      val lastValCal = for {m1 <- colNames} yield
        "LAST_VALUE(`b`.`" + m1 + "` , true) OVER (PARTITION BY  `a`.`__uuid`, `a`.`from_date` ORDER BY `b`.`from_date`) as " + m1 + ""
      val lastval = lastValCal.mkString(",")
      val dfFinalUnapporved = spark.sql(
        s"""SELECT  `a`.`__uuid`, `a`.`from_date`, `a`.`to_date`, `a`.`adjustment_info`,
           | `b`.`from_date` AS child_from_date, $lastval, `a`.`entity_uuid`, `a`.`__file_type`,
           | `a`.`__created`, `a`.`__metadata`
           | FROM merged_unapproved_$uid a
           | LEFT JOIN merged_unapproved_$uid b
           |  ON `a`.`__uuid` = `b`.`__uuid` AND `b`.`from_date` <= `a`.`from_date`""".stripMargin)
      val outputUnapproved = dfFinalUnapporved.filter(col("from_date") === col("child_from_date")).drop("child_from_date")
      outputUnapproved.createOrReplaceTempView("ADJUSTED_UNAPPROVED_" + FILETYPE + "_" + ENTITYUUID)

      "ADJUSTED_UNAPPROVED_" + FILETYPE + "_" + ENTITYUUID
    } match {
      case Success(value) => value
      case Failure(exception) => EmfLogger.error(
        s"SparkResolveService create adjusted unapproved DF. Reason : ${exception.getMessage}")
        throw new ResolveError(s"Error in generateUnapprovedAdjustmentViews", exception)
    }
  }

  private def generateApprovedAdjustmentViews(cellDf2: DataFrame, colDtype: Array[Tuple2[String, String]], baseTable: DataFrame,
                                              uid: String, FILETYPE: String, entityUuid: String, colNames: Array[String]): String = {
    import spark.implicits._

    Try {
      // fetch approved data
      val ENTITYUUID = entityUuid.replaceAll("-", "_")
      val dfapprovalSource = reformatMetadataColumn(
          this.sqlExector.execute(s"""
           |SELECT `a`.`entity_uuid`, `a`.`adjustment_uuid`, `a`.`approval_type`
           |FROM adjustment_approved.data a WHERE `a`.`adjusted_table_uuid`='$entityUuid'""".stripMargin))
      val dfapprovalCatalogue = reformatMetadataColumn(
          this.sqlExector.execute(s"""
           |SELECT `m`.`entity_uuid`,
           |  MAX(CASE WHEN UPPER(`m`.`attribute`)='APPROVED_BY'
           |    THEN `m`.`value` ELSE NULL END) AS approved_by,
           |  MAX(CASE WHEN UPPER(`m`.`attribute`)='APPROVED_TIMESTAMP'
           |    THEN to_timestamp(from_unixtime(unix_timestamp(`m`.`value` ))) ELSE NULL END)
           |	AS approved_timestamp
           |FROM catalogue.data m
           |WHERE (UPPER(`m`.`attribute`)='APPROVED_BY' OR UPPER(`m`.`attribute`)='APPROVED_TIMESTAMP')
           |	and m.file_type='adjustment_approved' GROUP BY `m`.`entity_uuid`""".stripMargin)
        ).withColumnRenamed("entity_uuid", "entity_uuid_1")
      val dfapproval = dfapprovalSource.as("approval")
        .join(dfapprovalCatalogue.as("catalogue"), $"approval.entity_uuid" === $"catalogue.entity_uuid_1", "inner")
        .drop("entity_uuid_1")

      // fetch source data from approved ,cell ,and base table
      val cellApproved = cellDf2.as("CELL").join(dfapproval.as("APR"),
        $"CELL.adjustment_uuid" === $"APR.adjustment_uuid", "inner")
        .groupBy($"APR.adjustment_uuid", $"CELL.__uuid", $"CELL.retrieval_timestamp", $"CELL.change_type",
          $"APR.approved_timestamp", $"APR.approval_type", $"APR.entity_uuid",
          $"CELL.__file_type", $"CELL.__created", $"CELL.__metadata")
        .agg(collect_list(struct(
          lit(FILETYPE).as("adjustment_table_name"), $"CELL.entity_uuid", $"CELL.adjustment_uuid",
          lit("CELL").as("adjustment_type"),
          $"CELL.change_type", $"CELL.retrieval_timestamp", $"CELL.adjustment_category",
          $"CELL.remediation_type", $"CELL.rule_id", $"CELL.attribute", $"CELL.old",
          $"CELL.value", $"CELL.description", $"APR.approved_timestamp", $"APR.approved_by")).as("adjustment_info"))
        .withColumn("adjustment_type", lit("CELL"))
        .withColumnRenamed("approved_timestamp", "from_date")
        .withColumn("retrieval_timestamp", col("retrieval_timestamp").cast("timestamp"))

        val cellExplodeApproved = cellApproved.select(cellApproved("*"), explode($"adjustment_info"))
        .select("*", "col.attribute", "col.old", "col.value")
        .withColumnRenamed("approved_timestamp", "from_date").drop("col").toDF()
      val colArrayApproved = Array("adjustment_type", "adjustment_uuid", "adjustment_info",
        "__uuid", "retrieval_timestamp", "change_type", "from_date", "approval_type") ++ colNames ++
        Array("entity_uuid", "__file_type", "__created", "__metadata")
      val pivotedApproved = cellExplodeApproved.groupBy("adjustment_type", "adjustment_uuid",
        "adjustment_info", "__uuid", "retrieval_timestamp", "change_type", "from_date", "approval_type",
        "entity_uuid", "__file_type", "__created", "__metadata" ).pivot(lower($"attribute"), colNames)
        .agg(max("value")).selectExpr(colArrayApproved: _*)
      val resultApproved = colDtype.foldLeft(pivotedApproved)((accDF, c) => accDF.withColumn(c._1, accDF(c._1).cast(c._2))).withColumnRenamed("__uuid", "__uuid1")
      val baseDf2 = baseTable.select(
        lit("BASE").as("adjustment_type"), lit("NULL").as("adjustment_uuid"),
        array(struct(lit("NULL").as("adjustment_table_name"), lit("NULL").as("entity_uuid"),
          lit("NULL").as("adjustment_uuid"), lit("NULL").as("adjustment_type"),
          lit("NULL").as("change_type"), lit("NULL").cast("timestamp").as("retrieval_timestamp"),
          lit("NULL").as("adjustment_category"), lit("NULL").as("remediation_type"),
          lit("NULL").as("rule_id"), lit("NULL").as("attribute"),
          lit("NULL").as("old"), lit("NULL").as("value"),
          lit("NULL").as("description"),
          lit("NULL").cast("timestamp").as("approved_timestamp"),
          lit("NULL").as("approved_by"))).as("adjustment_info"),
        baseTable("__uuid").as("__uuid1"),
        lit("1900-01-01").as("retrieval_timestamp").cast("timestamp"),
        lit("BASE").as("change_type"),
        lit("1900-01-01 00:00:00.000000").as("from_date").cast("timestamp"),
        lit("NULL").as("approval_type"), baseTable("*"))
        .drop("__uuid")

      // union cell based and base data records along with

      val unioned = baseDf2.union(resultApproved.select(baseDf2.columns.head, baseDf2.columns.tail: _*)).withColumnRenamed("__uuid1", "__uuid")
      // calculate to_date and update dynamic columns

      val windowspec = Window.partitionBy($"A.__uuid").orderBy($"A.from_date", $"A.retrieval_timestamp", $"B.adjustment_uuid")
      val windowspec1 = Window.partitionBy($"A.__uuid")
      val windowspec2 = Window.partitionBy($"__uuid").orderBy($"from_date", $"retrieval_timestamp")

      // filters out all delete records for a given approval date

      val mergedApproved = unioned.as("A").join(unioned.as("B"),
        $"A.__uuid" === $"B.__uuid", "leftouter")
        .withColumn("approval_deletion_date",
          max(when(lower($"B.approval_type") === "delete", $"B.from_date"))
            .over(windowspec))
        .withColumn("deleted_approval_date",
          max(when(lower($"B.change_type") === "delete", $"B.from_date")).over(windowspec1))
        .filter($"B.from_date" <= $"A.from_date")
        .select(col("A.__uuid").as("__uuid_a"), col("A.from_date").as("from_date_A"),
          col("B.from_date").as("child_from_date"), col("approval_deletion_date"),
          col("deleted_approval_date"), col("B.*"))
        .drop("from_date", "__uuid").withColumnRenamed("from_date_A", "from_date")
        .withColumnRenamed("__uuid_a", "__uuid")
        .withColumn("to_date",
          lead("from_date", 1, "2099-12-31").over(windowspec2))
        .filter($"approval_deletion_date".isNull || col("child_from_date") > col("approval_deletion_date"))
      mergedApproved.createOrReplaceTempView("merged_approved_" + uid)

      val lastValCal = for {m1 <- colNames}
        yield "LAST_VALUE(`" + m1 + "` , true) OVER (PARTITION BY  `__uuid`, `from_date` ORDER BY `retrieval_timestamp`) as " +
          m1 + ""
      val lastval = lastValCal.mkString(",")
      val df_final_approved = spark.sql(
        s""" SELECT `__uuid` , `from_date` , `to_date`, `adjustment_info`, $lastval, `entity_uuid`, `__file_type`,
           |`__created`, `__metadata`
           |FROM merged_approved_$uid
           |WHERE `deleted_approval_date` IS NULL OR `deleted_approval_date` > `from_date`""".stripMargin)
      val outputApproved = df_final_approved.filter(col("from_date") =!= col("to_date"))
      outputApproved.createOrReplaceTempView("ADJUSTED_APPROVED_" + FILETYPE + "_" + ENTITYUUID)
      "ADJUSTED_APPROVED_" + FILETYPE + "_" + ENTITYUUID
    } match {
      case Success(value) => value
      case Failure(exception) =>
        EmfLogger.error(s"SparkResolveService create adjusted approved DF. Reason : ${exception.getMessage}")
        throw new ResolveError(s"Error in generateApprovedAdjustmentViews", exception)
    }
  }

  /**
    * if data frame is resolved from json string,
    * the keys inside the struct will be parsed by alphabetical order.
    * we need to make sure the schema look as expected before union.
    * @return
    */
  private def reformatMetadataColumn(df: DataFrame): DataFrame = {
    if (df.columns.contains("__metadata")) {
      df.withColumn("__metadata", arrays_zip(
        col("__metadata.attribute").as("attribute"),
        col("__metadata.value").as("value"),
        col("__metadata.data_type").as("data_type"),
        col("__metadata.domain").as("domain")
      )).withColumn("__metadata", col("__metadata").cast(ArrayType(new StructType()
        .add("attribute", StringType)
        .add("value", StringType)
        .add("data_type", StringType)
        .add("domain", StringType))))
    } else {
      df
    }
  }
}
package hsbc.emf.service.resolution

import java.sql.{Date, Timestamp}
import java.util.TimeZone

import hsbc.emf.dao.ingestion.CatalogueDAO
import hsbc.emf.data.ingestion.{CatalogueEntity, MetadataEntry}
import hsbc.emf.data.resolution._
import hsbc.emf.data.sparkcmdmsg.{SparkResolveFromInputRequirementsMessage, SparkResolveMessage}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.ResolveError
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode
import org.scalamock.scalatest.MockFactory

case class curatedData(entity_uuid: String, location: String, active: Boolean,
                       md5: Int, doubleCol: Double, bigDecCol: BigDecimal,
                       run_date: Date, created: Timestamp)
case class curatedDataInjectMetadataFalse(location: String, active: Boolean,
                                          md5: Int, doubleCol: Double, bigDecCol: BigDecimal,
                                          run_date: Date, created: Timestamp)
case class metaData(attribute: String, value: String, data_type: String, domain: String)
case class curatedDataWithMetaData(entity_uuid: String, location: String, active: Boolean,
                                   md5: Int, doubleCol: Double, bigDecCol: BigDecimal,
                                   run_date: Date, created: Timestamp, __created: Timestamp, __file_type: String,
                                   __metadata: Array[metaData])
case class ingestData( location: String, active: Boolean,
                       md5: Int, doubleCol: Double, bigDecCol: BigDecimal,
                       run_date: Date, created: Timestamp, __uuid: String)
case class ingestDataWithMetaData(entity_uuid: String, location: String, active: Boolean,
                                  md5: Int, doubleCol: Double, bigDecCol: BigDecimal,
                                  run_date: Date, created: Timestamp, __uuid: String,
                                  __created: Timestamp, __file_type: String,
                                  __metadata: Array[metaData])

class SparkResolveServiceTest extends IntegrationTestSuiteBase
  with MockFactory {
  private val defaultTimeZone = TimeZone.getDefault()
  private val file_type = "Person"
  private val entityList = List(
    CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-02 00:00:00"),
      List(MetadataEntry("location", "UK", "String", "")))
    , CatalogueEntity("T2", "Person", Timestamp.valueOf("2021-03-03 00:00:00"),
      List(MetadataEntry("location", "US", "String", ""))))
  private val mockCatalogDAO = mock[CatalogueDAO]
  private val mockSqlExecutor = mock[SqlExecutor]
  private val input_req_table = "input_req_table"
  val targetTableName = "test"
  val targetTableNameWithData = "test_data"
  private val selectAllTestSQL = s"select * from $targetTableName"
  private val selectAllTestWithDataSQL = s"select * from $targetTableNameWithData"

  val ADJ_CELL_QUERY = "select * from adjustment_cell.access_view where adjusted_table_uuid='T1'"
  val ADJ_BASE_DATA_QUERY = "select * from Person.access_view where entity_uuid ='T1'"
  val ADJ_APPROVAL_QUERY = """
                             |SELECT `a`.`entity_uuid`, `a`.`adjustment_uuid`, `a`.`approval_type`
                             |FROM adjustment_approved.data a WHERE `a`.`adjusted_table_uuid`='T1'""".stripMargin
  val ADJ_APPROVED_AGG_METADATA_QUERY = """
                             |SELECT `m`.`entity_uuid`,
                             |  MAX(CASE WHEN UPPER(`m`.`attribute`)='APPROVED_BY'
                             |    THEN `m`.`value` ELSE NULL END) AS approved_by,
                             |  MAX(CASE WHEN UPPER(`m`.`attribute`)='APPROVED_TIMESTAMP'
                             |    THEN to_timestamp(from_unixtime(unix_timestamp(`m`.`value` ))) ELSE NULL END)
                             |	AS approved_timestamp
                             |FROM catalogue.data m
                             |WHERE (UPPER(`m`.`attribute`)='APPROVED_BY' OR UPPER(`m`.`attribute`)='APPROVED_TIMESTAMP')
                             |	and m.file_type='adjustment_approved' GROUP BY `m`.`entity_uuid`""".stripMargin

  val ADJ_APPROVAL_JSON="""
                  |{"entity_uuid":"80j8k8hj-2l56-7542-j109-p560a4hlyts6",
                   |"adjustment_uuid":"adjustment_add_001",
                   |"approval_type":"add",
                   |"__file_type":"adjustment_cell",
                   |"__created":"2021-06-29T05: 22:47.638",
                   |"__metadata": [
                   |{"attribute": "adjusted_table_uuid", "value": "T1","data_type": "string", "domain": ""},
                   |{"attribute": "file_type", "value": "adjustment_approved", "data_type": "string", "domain": ""},
                   |{"attribute": "adjusted_table_file_type", "value": "Person", "data_type": "string", "domain": ""},
                   |{"attribute": "approved_timestamp", "value": "2021-06-29 06:10:00.000 UTC", "data_type": "string", "domain": ""},
                   |{"attribute": "adjusted_by", "value": "IN-TEST-ADJUSTMENTS-INPUTTER_SAMPLE", "data_type": "string", "domain": ""}
                   |]}""".stripMargin
  val ADJ_CELL_JSON =
                """{"remediation_type":"MANUAL","adjustment_category":"Manual Adjustment","retrieval_timestamp":"2020-04-03T01:55:17.000Z","rule_id":"ffff","adjustment_uuid":"adjustment_amend_001","description":"amend adjustment 1",
                  |"row_set":[{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"entity_uuid","old":"1234","value":"01234"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"location","old":"HK","value":"UK"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"active","old":"true","value":"false"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"md5","old":"5","value":"11"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"doubleCol","old":"10.5","value":"1.11"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"bigDecCol","old":"100.25","value":"111.11"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"run_date","old":"2021-02-01","value":"2021-02-02"}]},
                  |{"__uuid":"T1","change_type":"amend","cells":[{"attribute":"created","old":"2021-03-02 00:00:00","value":"2021-03-02 00:00:01"}]}],
                  |"adjusted_table_file_type":"Person","adjusted_table_uuid":"T1",
                  |"entity_uuid":"T1","__file_type":"adjustment_cell","__created":"2021-06-29T05:22:47.638Z",
                  |"__metadata":[{"attribute":"adjusted_table_uuid","value":"T1","data_type":"string","domain":""},
                  |{"attribute":"file_type","value":"adjustment_cell","data_type":"string","domain":""},
                  |{"attribute":"adjusted_table_file_type","value":"Person","data_type":"string","domain":""},
                  |{"attribute":"adjusted_by","value":"IN-TEST-ADJUSTMENTS-INPUTTER_SAMPLE","data_type":"string","domain":""}
                  |]}""".stripMargin
  val ADJ_RESULT_UNAPPROVED_QUERY = "select * from ADJUSTED_UNAPPROVED_PERSON_T1"
  val ADJ_RESULT_APPROVED_QUERY   = s"select * from ADJUSTED_APPROVED_PERSON_T1"

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS $file_type")
    spark.sql(s"CREATE TABLE IF NOT EXISTS $input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches INT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")

    TimeZone.setDefault(TimeZone.getTimeZone("UTC"))

  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP TABLE IF EXISTS $input_req_table")
    spark.sql(s"DROP DATABASE IF EXISTS $file_type CASCADE")
    TimeZone.setDefault(defaultTimeZone)
    super.afterAll()
  }

  override def beforeEach(): Unit = {
    spark.catalog.dropTempView(targetTableName)
  }

  "given a matching criteria" should "save the data data frame as view" in {

    import spark.implicits._
    val dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()

    val expectedDF = Seq(curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1"))).toDF()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(dataDF).once()

    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName,
      where_clause = whereClause, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 1)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "resolve to an existing table with inject_metadata = true " should "successfully" in {

    import spark.implicits._
    val dataDF = Seq(curatedDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1"), Timestamp.valueOf("2021-03-01 00:00:00.1"),"Person", __metadata = List(metaData("att","val","string","")).toArray),
      curatedDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00"), Timestamp.valueOf("2021-03-02 00:00:00"),"Person", __metadata = List(metaData("att","val","string","")).toArray),
      curatedDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"), Timestamp.valueOf("2021-01-01 00:00:00"),"Person", __metadata = List(metaData("att","val","string","")).toArray)).toDF()

    val expectedDF = Seq(curatedDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1"), Timestamp.valueOf("2021-03-01 00:00:00.1"),"Person", __metadata = List(metaData("att","val","string","")).toArray)).toDF()

    val targetTable = Seq(curatedDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-07-01"), Timestamp.valueOf("2021-07-01 00:00:00.1"), Timestamp.valueOf("2021-07-01 00:00:00.1"), "Person", __metadata = List(metaData("att","val","string","")).toArray)).toDF()
    targetTable.write.format("hive").saveAsTable(targetTableNameWithData)

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(dataDF).once()

    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableNameWithData,
      where_clause = whereClause, as_view = false, inject_metadata = true)

    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestWithDataSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableNameWithData' and isTemporary = false").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 2)
    // there is an existing record before. after resolving, there is another append to the table, so totally 2 records in tbale
    assert(actualDF.except(expectedDF).count == 1)
  }

  "given a matching criteria with resolved entities >= min_matches" should "save the data data frame as view" in {

    import spark.implicits._
    val dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-02"),
        Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"),
        Timestamp.valueOf("2021-01-01 00:00:00"))).toDF()

    val expectedDF = Seq(curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-01 00:00:00.1"))).toDF()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(dataDF).once()

    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint, min_matches = 1)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName,
      where_clause = whereClause, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 1)
    assert(actualDF.except(expectedDF).isEmpty)
  }
  "given a matching criteria with resolved entities = min_matches(3)" should "save the data frame as view" in {

    import spark.implicits._
    // return 3 matched entities
    val entityListTest = List(
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-01 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-02 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-03 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))))
    // return 4 rows after resolve
    val dataDF = Seq(
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.2")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.3")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00.4")),
      // created is smaller than 2021-03-01T00:00:00, will not save to view
      curatedData("T2", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2020-01-01 00:00:00"))).toDF()

    val expectedDF = Seq(
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.2")),
      curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.3")),
      curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00.4"))).toDF()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityListTest).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(
      ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint, min_matches = 3)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName,
      where_clause = whereClause, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 4)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a matching criteria with resolved entities > min_matches(3)" should "save the data frame as view" in {

    import spark.implicits._
    // return 4 matched entities
    val entityListTest = List(
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-01 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-02 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-03 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-04 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))))

    val dataDF = Seq(
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.2"))).toDF()

    val expectedDF = Seq(
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-01 00:00:00.1")),
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-01-01"), Timestamp.valueOf("2021-03-02 00:00:00.2"))).toDF()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityListTest).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(
      ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint, min_matches = 3)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName,
      where_clause = whereClause, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 2)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a matching criteria with resolved entities < min_matches(3)" should "return ResolveError" in {
    // return 1 matched entities
    val entityListTest = List(
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-01 00:00:00"), List(MetadataEntry("location", "UK", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-01 00:00:00"), List(MetadataEntry("location", "CN", "String", ""))),
      CatalogueEntity("T1", "Person", Timestamp.valueOf("2021-03-01 00:00:00"), List(MetadataEntry("location", "CN", "String", ""))))

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityListTest).once()
    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint, min_matches = 3)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    val caught = intercept[ResolveError] {
      new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a matching criteria with resolved entities < min_matches" should "return ResolveError" in {

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val resolutionCriteria = ResolutionCriteria(file_type, min_matches = 3)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    val caught = intercept[ResolveError] {
      new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    }
    assert(!caught.getMessage.isEmpty)
  }

  "given a matching criteria with latest_only true" should "save a latest data dataframe as view" in {

    import spark.implicits._
    val expectedDF = Seq(curatedDataInjectMetadataFalse( "US", active = true, 20, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T2")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(expectedDF).once()

    val resConstraint = List(ResolutionConstraint("location", "null", IsNot))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 1)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a matching criteria with latest_only false" should "save all rows of data dataframe as view" in {

    import spark.implicits._
    val expectedDF = Seq(curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("US", active = true, 20, 10.5, 100.25, Date.valueOf("2021-02-01"),
        Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1","T2")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(expectedDF).once()

    val resConstraint = List(ResolutionConstraint("location", "null", IsNot))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    msg.latest_only = false
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 2)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a matching criteria" should "save a data dataframe which is empty as view" in {

    import spark.implicits._
    val expectedDF = spark.emptyDataset[curatedDataInjectMetadataFalse].toDF()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T2")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(expectedDF).once()

    val resConstraint = List(ResolutionConstraint("location", "US", Equal))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    val actualDF = spark.sql(selectAllTestSQL)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    assert(actualDF != null)
    assert(actualDF.count() == 0)
    assert(actualDF.except(expectedDF).isEmpty)

  }

  "given a matching criteria and the view is existing" should "append 2 row of data dataframe to view" in {
    spark.catalog.dropTempView("test")
    import spark.implicits._
    val existingDF = Seq(
      curatedDataInjectMetadataFalse( "CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00"))).toDF

    val dataDF = Seq(
      curatedData("T2", "US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T2", "US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val expectedDF = Seq(
      curatedDataInjectMetadataFalse("US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00"))).toDF
    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T2")"""
    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    val resConstraint = List(ResolutionConstraint("location", "null", IsNot))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 1)
    val actualDF = spark.table(targetTableName)
    assert(beforeCount == 2)
    assert(actualDF.count() == 4)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a matching criteria and as view is false" should "append 2 row of data dataframe to table" in {
    val tableName = "test_save_as_table"
    import spark.implicits._
    val existingDF = Seq(
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00"))).toDF
    val dataDF = Seq(
      curatedData("T2", "US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedData("T2", "US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val expectedDF = Seq(
      curatedDataInjectMetadataFalse("US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("US", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-02-02"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 20, 10.5f, 100.25, Date.valueOf("2021-03-30"), Timestamp.valueOf("2021-03-30 00:00:00"))).toDF
    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T2")"""
    (mockSqlExecutor.execute _).expects(query).returning(dataDF).once()
    existingDF.write.format("hive").saveAsTable(tableName)
    val beforeCount = spark.table(tableName).count()
    val resConstraint = List(ResolutionConstraint("location", "null", IsNot))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, tableName, List.empty, DATA, 0, 0, false, Some("default"))
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    assert(spark.sql("show tables").where(s"tableName = '$tableName' and isTemporary = false").count == 1)
    val actualDF = spark.sql(s"select * from default.$tableName")
    assert(beforeCount == 2)
    assert(actualDF.count() == 4)
    assert(actualDF.except(expectedDF).isEmpty)
  }

  "given a non-matching criteria" should "return ResolveError" in {
    import spark.implicits._
    val expectedDF = spark.emptyDataset[curatedDataInjectMetadataFalse].toDF()
    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    (mockSqlExecutor.execute _).expects(*).returning(expectedDF).never

    val resConstraint = List(ResolutionConstraint("location", "USA", Equal))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 0)
  }


  "given a matching criteria in input requirements table " should "save the resolved dataframe as view in resolveFromTable" in {

    import spark.implicits._

    val expectedDF = Seq(curatedDataInjectMetadataFalse( "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )

    val inputRequirementRawDF = Seq(inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true)

    (mockSqlExecutor.execute _).expects(s"select * from ${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()
    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).once()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(expectedDF).once()

    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolveFromTable(sparkResolveFromInputRequirementsMessage)
    assert(spark.sql("show tables").where(s"tableName = 'view_table' and isTemporary = true").count == 1)
    assert(spark.sql("select * from view_table").except(expectedDF).isEmpty)
    spark.sql("drop table view_table")
  }

  "given a matching criteria in input requirements table " should "append to view in resolveFromTable" in {

    import spark.implicits._

    val expectedDF = Seq(curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
        Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )

    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true)

    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(dataDF).anyNumberOfTimes()

    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)

    assert(spark.sql("select * from resolve_view_table").except(expectedDF).isEmpty)
    /*   assert(spark.sql("select * from resolve_temp_table").except(expectedDF).isEmpty) */
    spark.sql("drop view if exists resolve_view_table")
    /*   spark.sql("drop table if exists resolve_temp_table") */

  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given a matching criteria in input requirements table " should "execute resolve in parallel and " +
  //    "append to table target_db.resolveFromTable" in {
  //
  //    import spark.implicits._
  //
  //    val dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
  //      Timestamp.valueOf("2021-03-02 00:00:00"))).toDF
  //
  //    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
  //    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
  //      ResolutionConstraintRaw("active", "true", "=")))
  //
  //    val inputRequirementRaw = InputRequirementRaw(
  //      file_type = file_type,
  //      table_name = "resolve_view_table2",
  //      constraints = resolutionConstraint,
  //      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
  //      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
  //      latest_only = true,
  //      min_matches = Some(1),
  //      source_entity_type = "data",
  //      where_clause = whereClause
  //    )
  //    spark.sql(s"CREATE DATABASE IF NOT EXISTS target_db")
  //    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw,
  //      inputRequirementRaw, inputRequirementRaw).toDF
  //    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
  //      Some("target_db"), false)
  //
  //    (mockSqlExecutor.execute _).expects(s"select * from " +
  //      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
  //      .returning(inputRequirementRawDF).once()
  //
  //    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()
  //    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
  //    (mockSqlExecutor.execute _).expects(query)
  //      .returning(dataDF).anyNumberOfTimes()
  //
  //    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
  //      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
  //
  //    assert(spark.sql(s"select * from target_db.resolve_view_table2").count() == 24)
  //    spark.sql(s"DROP DATABASE IF EXISTS target_db CASCADE")
  //
  //  }

  "given a matching criteria in input requirements table append to an existing view" should "append to existing view in resolveFromTable" in {

    import spark.implicits._
    val existingDF = Seq(
      curatedDataInjectMetadataFalse("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"))).toDF
    val expectedDF = Seq(
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00")),
      curatedDataInjectMetadataFalse("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"))).toDF

    val dataDF = Seq(curatedData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"),
      Timestamp.valueOf("2021-03-02 00:00:00"))).toDF
    val targetTableName = "resolve_view_table"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )

    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true)

    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()
    val query = s"""select * from Person.${EmfConfig.defaultAccessView} where entity_uuid in ("T1")"""
    (mockSqlExecutor.execute _).expects(query)
      .returning(dataDF).anyNumberOfTimes()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
    val afterCount = spark.table(targetTableName).count()
    assert(beforeCount == 2)
    assert(afterCount == 4)
    assert(spark.sql(s"select * from $targetTableName").except(expectedDF).isEmpty)
    /*   assert(spark.sql("select * from resolve_temp_table").except(expectedDF).isEmpty) */
    spark.sql(s"drop view if exists $targetTableName")
    /*   spark.sql("drop table if exists resolve_temp_table") */

  }

  "given a matching criteria in input requirements table " should "encode InputRequirement and " +
    "append to view resolved dataframe in resolveFromTable" in {

    import spark.implicits._

    spark.sql(s"create database IF NOT EXISTS ${EmfConfig.catalogueDatabaseName}")
    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue2.csv")

    catalogueData.write.mode(SaveMode.Overwrite)
      .format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")


    spark.sql("create database if not exists Person")
    val tableName = s"""Person.${EmfConfig.defaultAccessView}"""
    Seq(("T1", "row1"), ("T2", "row2")).toDF("entity_uuid", "colB").write.mode(SaveMode.Overwrite)
      .format("hive").saveAsTable(tableName)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", null)))
    val whereClause = Option(List(ResolutionConstraintRaw("colB", "row2", null)))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = "Person",
      table_name = "resolve_view_table",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "data",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    inputRequirementDS.toDF.write.format("hive").insertInto(input_req_table)
    val inp = spark.sql(s"select * from default.$input_req_table").as[InputRequirementRaw]

    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage(s"default.$input_req_table",
      None, true)

    new SparkResolveService(new SqlExecutor(), new CatalogueDAO(new SqlExecutor()))
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)

    assert(inp.except(inputRequirementDS).isEmpty)
    assert(spark.sql("select * from resolve_view_table").except(Seq("row2").toDF).isEmpty)
    /*  assert(spark.sql("select * from resolve_temp_table").except(Seq(("T1","row1")).toDF).isEmpty) */

    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql("drop view if exists resolve_view_table")
    /*  spark.sql("drop table if exists resolve_temp_table") */
  }

  "given a matching criteria with source_entity_type is ADJUSTED_UNAPPROVED in input requirements table append to an existing view" should "append to existing view resolve_view_table_adj_unappr" in {

    import spark.implicits._
    val existingDF = Seq(
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6"),
      ingestData( "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7")).toDF
    val expectedDF = Seq(
      ingestData("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1"),
      ingestData("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1"),
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6"),
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7")).toDF
    import spark.implicits._
    val adjCellDF = spark.read.json(Seq(this.ADJ_CELL_JSON).toDS)

    val baseTableQueryDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray)).toDF
    val targetTableName = "resolve_view_table_adj_unappr"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table_adj_unappr",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "ADJUSTED_UNAPPROVED",
      where_clause = whereClause
    )
    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true)
    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()

    // mock the expected DF of cell Table
    (mockSqlExecutor.execute _).expects(this.ADJ_CELL_QUERY)
      .returning(adjCellDF).anyNumberOfTimes()
    // mock the expected DF of base Table
    (mockSqlExecutor.execute _).expects(this.ADJ_BASE_DATA_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    //mock the expected DF of ADJUSTED_UNAPPROVED_PERSON_T1
    (mockSqlExecutor.execute _).expects(this.ADJ_RESULT_UNAPPROVED_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
    assert(spark.table("ADJUSTED_UNAPPROVED_PERSON_T1").count()>0)
    val resultDF = spark.table(targetTableName)
    val afterCount = resultDF.count()
    assert(!resultDF.columns.contains("__created"))
    assert(!resultDF.columns.contains("__file_type"))
    assert(!resultDF.columns.contains("__metadata"))
    assert(beforeCount == 2)
    assert(afterCount == 4)
    assert(spark.sql(s"select * from $targetTableName").except(expectedDF).isEmpty)
    spark.sql(s"drop view if exists $targetTableName")
    spark.sql(s"drop view if exists ADJUSTED_UNAPPROVED_PERSON_T1")

  }

  "given a matching criteria with source_entity_type is ADJUSTED_APPROVED in input requirements table append to an existing view" should "append to existing view resolve_view_table_adj_appr" in {

    import spark.implicits._
    val existingDF = Seq(
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6"),
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7")).toDF
    val expectedDF = Seq(
      ingestData("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1"),
      ingestData("UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1"),
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6"),
      ingestData("CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7")).toDF
    import spark.implicits._
    val adjCellDF = spark.read.json(Seq(this.ADJ_CELL_JSON).toDS)
    val adjAppDF = spark.read.json(Seq(this.ADJ_APPROVAL_JSON).toDS)
    val baseTableQueryDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25,
        Date.valueOf("2021-02-01"),
        Timestamp.valueOf("2021-03-02 00:00:00"),"T1",
        Timestamp.valueOf("2021-01-01 00:00:00"),
        file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray)).toDF
    val adjApprovedAggMetadataJson = "{\"entity_uuid\":\"80j8k8hj-2l56-7542-j109-p560a4hlyts6\",\"approved_by\":\"God itself\",\"approved_timestamp\":\"2021-06-29 06:10:00.000 UTC\"}"
    val adjApprovedAggMetadataDF = spark.read.json(Seq(adjApprovedAggMetadataJson).toDS)
    val targetTableName = "resolve_view_table_adj_appr"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))
    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table_adj_appr",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "ADJUSTED_APPROVED",
      where_clause = whereClause
    )
    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true)
    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()

    // mock the expected DF of cell Table
    (mockSqlExecutor.execute _).expects(this.ADJ_CELL_QUERY)
      .returning(adjCellDF).anyNumberOfTimes()
    // mock the expected DF of base Table
    (mockSqlExecutor.execute _).expects(this.ADJ_BASE_DATA_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    // mock the expected DF of adjustment_approved Table
    (mockSqlExecutor.execute _).expects(this.ADJ_APPROVAL_QUERY)
      .returning(adjAppDF).anyNumberOfTimes()
    // mock the expected DF of approval metadata agg Table
    (mockSqlExecutor.execute _).expects(this.ADJ_APPROVED_AGG_METADATA_QUERY)
      .returning(adjApprovedAggMetadataDF).anyNumberOfTimes()
    //mock the expected DF of ADJUSTED_APPROVED_PERSON_T1
    (mockSqlExecutor.execute _).expects(this.ADJ_RESULT_APPROVED_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
    assert(spark.table("ADJUSTED_APPROVED_PERSON_T1").count()>0)
    val resultDF = spark.table(targetTableName)
    val afterCount = resultDF.count()
    assert(!resultDF.columns.contains("__created"))
    assert(!resultDF.columns.contains("__file_type"))
    assert(!resultDF.columns.contains("__metadata"))
    assert(beforeCount == 2)
    assert(afterCount == 4)
    assert(spark.sql(s"select * from $targetTableName").except(expectedDF).isEmpty)
    spark.sql(s"drop view if exists $targetTableName")
    spark.sql(s"drop view if exists ADJUSTED_APPROVED_PERSON_T1")

  }


  "given a matching criteria with source_entity_type is ADJUSTED_UNAPPROVED in input requirements table append to an existing view, and inject_metadata=true" should "append to existing view resolve_view_table_adj_unappr" in {

    import spark.implicits._
    val existingDF = Seq(
      ingestDataWithMetaData("T6", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6", Timestamp.valueOf("2021-01-06 00:00:00"), file_type, __metadata = List(metaData("att", "val_T6", "string","")).toArray),
      ingestDataWithMetaData("T7", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7", Timestamp.valueOf("2021-01-07 00:00:00"), file_type, __metadata = List(metaData("att", "val_T7", "string","")).toArray)).toDF
    val expectedDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray),
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray),
      ingestDataWithMetaData("T6", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6", Timestamp.valueOf("2021-01-06 00:00:00"), file_type, __metadata = List(metaData("att", "val_T6", "string","")).toArray),
      ingestDataWithMetaData("T7", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7", Timestamp.valueOf("2021-01-07 00:00:00"), file_type, __metadata = List(metaData("att", "val_T7", "string","")).toArray)).toDF

    import spark.implicits._
    val adjCellDF = spark.read.json(Seq(this.ADJ_CELL_JSON).toDS)

    val baseTableQueryDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray)).toDF
    val targetTableName = "resolve_view_table_adj_unappr"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))

    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table_adj_unappr",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "ADJUSTED_UNAPPROVED",
      where_clause = whereClause
    )
    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true, inject_metadata = true)
    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()

    // mock the expected DF of cell Table
    (mockSqlExecutor.execute _).expects(this.ADJ_CELL_QUERY)
      .returning(adjCellDF).anyNumberOfTimes()
    // mock the expected DF of base Table
    (mockSqlExecutor.execute _).expects(this.ADJ_BASE_DATA_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    //mock the expected DF of ADJUSTED_UNAPPROVED_PERSON_T1
    (mockSqlExecutor.execute _).expects(this.ADJ_RESULT_UNAPPROVED_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
    assert(spark.table("ADJUSTED_UNAPPROVED_PERSON_T1").count()>0)
    val resultDF = spark.table(targetTableName)
    assert(resultDF.columns.contains("__created"))
    assert(resultDF.columns.contains("__file_type"))
    assert(resultDF.columns.contains("__metadata"))
    val afterCount = resultDF.count()
    assert(beforeCount == 2)
    assert(afterCount == 4)
    assert(spark.sql(s"select * from $targetTableName").except(expectedDF).isEmpty)
    spark.sql(s"drop view if exists $targetTableName")
    spark.sql(s"drop view if exists ADJUSTED_UNAPPROVED_PERSON_T1")

  }

  "given a matching criteria with source_entity_type is ADJUSTED_APPROVED in input requirements table append to an existing view, also inject_metadata=true" should "append to existing view resolve_view_table_adj_appr" in {

    import spark.implicits._
    val existingDF = Seq(
      ingestDataWithMetaData("T6", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6", Timestamp.valueOf("2021-01-06 00:00:00"), file_type, __metadata = List(metaData("att", "val_T6", "string","")).toArray),
      ingestDataWithMetaData("T7", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7", Timestamp.valueOf("2021-01-07 00:00:00"), file_type, __metadata = List(metaData("att", "val_T7", "string","")).toArray)).toDF
    val expectedDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray),
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray),
      ingestDataWithMetaData("T6", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T6", Timestamp.valueOf("2021-01-06 00:00:00"), file_type, __metadata = List(metaData("att", "val_T6", "string","")).toArray),
      ingestDataWithMetaData("T7", "CN", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T7", Timestamp.valueOf("2021-01-07 00:00:00"), file_type, __metadata = List(metaData("att", "val_T7", "string","")).toArray)).toDF

    import spark.implicits._
    val adjCellDF = spark.read.json(Seq(this.ADJ_CELL_JSON).toDS)
    val adjAppDF = spark.read.json(Seq(this.ADJ_APPROVAL_JSON).toDS)
    val baseTableQueryDF = Seq(
      ingestDataWithMetaData("T1", "UK", active = true, 5, 10.5, 100.25, Date.valueOf("2021-02-01"), Timestamp.valueOf("2021-03-02 00:00:00"),"T1", Timestamp.valueOf("2021-01-01 00:00:00"), file_type, __metadata = List(metaData("att", "val_T1", "string","")).toArray)).toDF
    val adjApprovedAggMetadataJson = "{\"entity_uuid\":\"80j8k8hj-2l56-7542-j109-p560a4hlyts6\",\"approved_by\":\"God itself\",\"approved_timestamp\":\"2021-06-29 06:10:00.000 UTC\"}"
    val adjApprovedAggMetadataDF = spark.read.json(Seq(adjApprovedAggMetadataJson).toDS)
    val targetTableName = "resolve_view_table_adj_appr"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("location", "UK", "=")))
    val whereClause = Option(List(ResolutionConstraintRaw("md5", "5", "="),
      ResolutionConstraintRaw("active", "true", "=")))
    val inputRequirementRaw = InputRequirementRaw(
      file_type = file_type,
      table_name = "resolve_view_table_adj_appr",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-03-03 00:00:00")),
      created_from = Some(Timestamp.valueOf("2021-03-01 00:00:00")),
      latest_only = true,
      min_matches = Some(1),
      source_entity_type = "ADJUSTED_APPROVED",
      where_clause = whereClause
    )
    val inputRequirementRawDF = Seq(inputRequirementRaw, inputRequirementRaw).toDF
    val sparkResolveFromInputRequirementsMessage = SparkResolveFromInputRequirementsMessage("input_requirement_table",
      None, true, inject_metadata = true)
    (mockSqlExecutor.execute _).expects(s"select * from " +
      s"${sparkResolveFromInputRequirementsMessage.input_requirements_table_name}")
      .returning(inputRequirementRawDF).once()

    (mockCatalogDAO.readByFileType _).expects(file_type).returning(entityList).anyNumberOfTimes()

    // mock the expected DF of cell Table
    (mockSqlExecutor.execute _).expects(this.ADJ_CELL_QUERY)
      .returning(adjCellDF).anyNumberOfTimes()
    // mock the expected DF of base Table
    (mockSqlExecutor.execute _).expects(this.ADJ_BASE_DATA_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    // mock the expected DF of adjustment_approved Table
    (mockSqlExecutor.execute _).expects(this.ADJ_APPROVAL_QUERY)
      .returning(adjAppDF).anyNumberOfTimes()
    // mock the expected DF of approval metadata agg Table
    (mockSqlExecutor.execute _).expects(this.ADJ_APPROVED_AGG_METADATA_QUERY)
      .returning(adjApprovedAggMetadataDF).anyNumberOfTimes()
    //mock the expected DF of ADJUSTED_APPROVED_PERSON_T1
    (mockSqlExecutor.execute _).expects(this.ADJ_RESULT_APPROVED_QUERY)
      .returning(baseTableQueryDF).anyNumberOfTimes()
    existingDF.createOrReplaceTempView(targetTableName)
    val beforeCount = spark.table(targetTableName).count()
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO)
      .resolveFromTable(sparkResolveFromInputRequirementsMessage)
    assert(spark.table("ADJUSTED_APPROVED_PERSON_T1").count()>0)
    val resultDF = spark.table(targetTableName)
    assert(resultDF.columns.contains("__created"))
    assert(resultDF.columns.contains("__file_type"))
    assert(resultDF.columns.contains("__metadata"))
    val afterCount = resultDF.count()
    assert(beforeCount == 2)
    assert(afterCount == 4)
    assert(spark.sql(s"select * from $targetTableName").except(expectedDF).isEmpty)
    spark.sql(s"drop view if exists $targetTableName")
    spark.sql(s"drop view if exists ADJUSTED_APPROVED_PERSON_T1")

  }

  "given a matching criteria with resolved entities =0  min_matches=0" should "skip the reslove" in {

    val emptyentityList=List()
    (mockCatalogDAO.readByFileType _).expects(file_type).returning(emptyentityList).once()
    val resConstraint = List(ResolutionConstraint("location", "UK", Equal))
    val whereClause = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "5", Equal),
      ResolutionConstraint("run_date", "[2021-02-01,2021-01-01]", In),
      ResolutionConstraint("created", "2021-03-01T00:00:00", GreaterThan))
    val resolutionCriteria = ResolutionCriteria(file_type, resConstraint, min_matches = 0)
    val msg = SparkResolveMessage(criteria = resolutionCriteria, table_name = targetTableName,
      where_clause = whereClause, as_view = true)
    new SparkResolveService(mockSqlExecutor, mockCatalogDAO).resolve(msg)
    // targetTableName should not be created. so the count should be 0
    assert(spark.sql("show tables").where(s"tableName = '$targetTableName' and isTemporary = true").count == 0)
  }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

import org.apache.spark.sql.SaveMode

class SparkResolveTest extends IntegrationTestSuiteBase {

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.catalogueDatabaseName}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.catalogueDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql("DROP TABLE IF EXISTS resolve_table")
    super.afterAll()
  }

  "invalid message in command" should "return Failed" in {
    val execResult: ExecutionResult = new SparkResolve(criteria = ResolutionCriteria(""),
      tableName ="dummy1", asView = true).run()
    assert(execResult == Failed)
  }


  "given a valid message in command" should "return Complete" in {

    import spark.implicits._

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue2.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    val tableName = s"""Person.${EmfConfig.defaultAccessView}"""
    Seq(("T1", "row1"), ("T1", "row2")).toDF("entity_uuid", "colB").write.mode(SaveMode.Overwrite)
      .format("hive").saveAsTable(tableName)

    val resConstraint = List(ResolutionConstraint("location", "UK", Equal),
      ResolutionConstraint("md5", "10", Equal))
    val whereClause = List(ResolutionConstraint("colB", "[row2]", In))
    val resolutionCriteria = ResolutionCriteria("Person", resConstraint)

    val sparkResolve = new SparkResolve(criteria = resolutionCriteria,
      tableName = "resolve_table", whereClause = whereClause, asView = true )
    val execResult: ExecutionResult = sparkResolve.run()

    assert(execResult match {
      case Complete => true
      case Failed => false
    })
    assert(spark.sql("select * from resolve_table").except(Seq(("row2")).toDF).isEmpty)
  }

}



package hsbc.emf.command

import java.sql.Timestamp

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.resolution.ResolutionConstraint
import hsbc.emf.data.sparkcmdmsg.{SparkRunMessage, SparkRunMessageRaw}
import hsbc.emf.infrastructure.helper.{HelperUtility, JsonReader}
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.services.mapper.SparkRunMessageMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.orchestration.SparkOrchestrateService

import org.apache.spark.sql.SparkSession

class SparkRun(val workflow: String,
               val processTasksConstraints: List[ResolutionConstraint],
               val processTasksCreatedTo: Timestamp = new Timestamp(System.currentTimeMillis),
               val sparkVersion: Option[String] = None,
               val disabled: Map[String, List[String]] = Map.empty,
               val enabled: Map[String, List[String]] = Map.empty,
               val runUuid: Option[String] = None)
              (implicit val spark: SparkSession, implicit override val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    Try {
      val sparkRunMessage = SparkRunMessage(workflow, processTasksConstraints, processTasksCreatedTo, sparkVersion, disabled, enabled, runUuid)
      EmfLogger.info("Starting SparkRun command execution")
      if (!messageValidate(sparkRunMessage)) {
        Failed
      }
      else {
        val execResult = new SparkOrchestrateService(new SqlExecutor()).executeWorkFlow(sparkRunMessage, placeholderParams)
        if (execResult == Complete) {
          EmfLogger.info("SparkRun command executed successfully")
        }
        else {
          EmfLogger.error("SparkRun command execution failed")
        }
        execResult
      }
    } match {
      case Success(executionResult) => executionResult
      case Failure(exception) =>
        ExceptionHandler.handle("SparkRun command execution failed", exception)
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val sparkRunMessage = message.asInstanceOf[SparkRunMessage]
    if (sparkRunMessage.workflow.trim.isEmpty) {
      EmfLogger.error(s"SparkRunMessage contains empty workflow")
      false
    } else true
  }
}

/** Companion object to provide apply() implementations. One version take same parameters as the class constructor.
  * Another version take a parameters json string, to facilitate SparkRun command creation from the process_tasks
  * parameters or dim_queue parameters.
  */
object SparkRun {
  def apply(workflow: String,
            processTasksConstraints: List[ResolutionConstraint],
            processTasksCreatedTo: Timestamp,
            sparkVersion: Option[String],
            disabled: Map[String, List[String]],
            enabled: Map[String, List[String]],
            runUuid: Option[String])
           (implicit spark: SparkSession, messageInfo: MessageInfo): SparkRun =
    new SparkRun(workflow,
                 processTasksConstraints,
                 processTasksCreatedTo,
                 sparkVersion,
                 disabled,
                 enabled,
                 Some(runUuid.getOrElse(HelperUtility.generateRunUUID())))

  def apply(parametersJsonString: String,
            parentDisabled: Map[String, List[String]] = Map.empty,
            parentEnabled: Map[String, List[String]] = Map.empty,
            parentRunUuid: Option[String] = None)
           (implicit spark: SparkSession, messageInfo: MessageInfo): SparkRun = {
    try {
      val selfReplacedParametersJson = SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedParamJson(parametersJsonString)
      val selfReplacedAllParams = SparkCommandAllParamsExtractor.extractAllParamsAsSelfReplacedPlaceholderParams(parametersJsonString)
      val sparkRunMessage = SparkRunMessageMapper.map(JsonReader.deserializeWithCheck[SparkRunMessageRaw](selfReplacedParametersJson))
      // Generate Run UUID if it is not provided
      val runUUID = sparkRunMessage.run_uuid.getOrElse(HelperUtility.generateRunUUID())

      val sparkRun =
        new SparkRun(
          sparkRunMessage.workflow,
          sparkRunMessage.process_tasks_constraints,
          sparkRunMessage.process_tasks_created_to,
          sparkRunMessage.spark_version,
          if (sparkRunMessage.disabled.nonEmpty) sparkRunMessage.disabled else parentDisabled,
          if (sparkRunMessage.enabled.nonEmpty) sparkRunMessage.enabled else parentEnabled,
          if (parentRunUuid.isDefined) parentRunUuid else Some(runUUID))
      sparkRun.placeholderParams = selfReplacedAllParams
      sparkRun._messageInfo = messageInfo
      sparkRun
    }
    catch {
      case ex: Exception =>
        EmfLogger.error(s"SparkRun.apply(String) failed with error: ${ex.getMessage}")
        throw ex
    }
  }
}
package hsbc.emf.command

import java.io.File

import scala.reflect.io.Directory
import hsbc.emf.constants.Complete
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.orchestration.ProcessTaskData
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode
import org.apache.commons.io.FileUtils

class SparkRunExportTest extends IntegrationTestSuiteBase {
  val testTopic = ""
  val resolvedProcessTaskEntityUuid = "E06"
  val testDbExpCase = "spark_exp_all_1"
  val exportLocation = "SparkExportAllResolutions/sys_radar_sdi_cashflow_v01_00"

  import spark.implicits._

  override def beforeAll(): Unit = {
    super.beforeAll()

    spark.sql(s"create database if not exists $testDbExpCase")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS testingdb")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.process_tasks}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testingdb.source_table")

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/orchestration/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    val catalogueData1 = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/resolution/catalogue6.csv")

    catalogueData1.write.mode(SaveMode.Append)
      .format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")

    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS ${EmfConfig.process_tasks}.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '${EmfConfig.process_tasks}' group by m.entity_uuid, m.file_type
       """.stripMargin)

    val loadInfoRawList = List(
      LoadInfoRaw(file_type = s"fotc_carm_f_fac_snapshot_v08_00", quote_character = Some(""),
        schema = Some("key:string"), delimiter = Some(","), skip_rows = Some("0"),
        extension = Some("csv"),
        ingest_hierarchy = Some(""),
        ingestion_parameters = Some("{}"),
        max_bad_records = Some("1"))     )
    loadInfoRawList.toDF().write.mode(SaveMode.Append).saveAsTable(s"load_info.data")

  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.process_tasks} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS testingdb CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $testDbExpCase CASCADE")
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
    spark.sql(s"drop database if exists load_info cascade")
    new Directory(new File(exportLocation)).deleteRecursively()
    FileUtils.deleteDirectory(new File("SparkExport".split("/")(0)))
    super.afterAll()
  }

  def traverseTree(file: File): Iterable[File] = {
    val children = new Iterable[File] {
      def iterator: Iterator[File] = if (file.isDirectory) file.listFiles.iterator else Iterator.empty
    }
    Seq(file) ++: children.flatMap(traverseTree)
  }

  def getFiles(path: String, ext: String): List[String] = {
    val dir = new File(path)
    var files: List[String] = List()
    for (entry <- traverseTree(dir)) {
      if (entry.getName.endsWith(ext)) {
        files :+= entry.getAbsolutePath
      }
    }
    files
  }

  "given a workflow for SparkExport " should "return Complete" in {

    val testInputDataset = "test_input_dataset"
    val testInputTable = "test_input_table"
    val temporaryBucketName = "SparkExport"

    spark.sql(s"create database if not exists $testInputDataset")
    Seq(("row1a", "row1b", "row1c"), ("row2a", "row2b", "row2c")).toDF("colA", "colB", "colC")
      .write.mode(SaveMode.Overwrite).saveAsTable(s"$testInputDataset.$testInputTable")

    val sparkExportParameters = "{\"source_dataset_name\":\"test_input_dataset\"," +
      "\"source_table_name\":\"test_input_table\",\"export_format\":\"csv\",\"field_delimiter\": \"=\"," +
      " \"print_header\": \"true\",\"target_file_name\":\"sys_radar_sdi_cashflow_v01_00\"," +
      "\"target_bucket_name\":\"SparkExport\",\"number_of_files\":2," +
      "\"metadata\":{\"file_type\":\"fotc_carm_f_fac_snapshot_v08_00\",\"run_no\":\"1000\",\"md5\":\"5.6\"," +
      "\"meta_query\":\"select 'file_type','fotc_carm_f_fac_snapshot_v08_01'\"," +
      "\"flag\":\"true\",\"run_date\":\"2021-05-01\",\"timestamp\":\"2021-05-01T00:00:00.123\"}}"

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-EXPORT", List.empty, sparkExportParameters, testTopic, resolvedProcessTaskEntityUuid))

    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

    val sparkRunResult = SparkRun(parametersJson).run()
    assert(sparkRunResult == Complete)

    val exportLocation = temporaryBucketName + "/sys_radar_sdi_cashflow_v01_00"
    val filePaths: List[String] = getFiles(exportLocation, ".csv")
    val filesAsDf = spark.read.format("csv")
      .options(Map("header" -> "true", "delimiter" -> "="))
      .load(filePaths: _*)

    val sourceDF = spark.sql(s"select * from $testInputDataset.$testInputTable")

    assert(sourceDF.except(filesAsDf).isEmpty)
  }
  // comment SPARK-EXPORT-ALL-RESOLUTIONS as service line is not using this cmd
  /*
  "given a workflow for SparkExportAllResolutions" should "return Complete" in {
    val testInputTable = EmfConfig.defaultAccessView
    val t12DbTable = s"$testDbExpCase.T12"

    val sample = s"""[{"entity_uuid": "$t12DbTable","key": "10", "value": "ten"},{"entity_uuid": "$t12DbTable","key": "20", "value": "twenty"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.write.saveAsTable(s"$testDbExpCase.$testInputTable")

    val sparkExportAllResolutionsParameters =
      """ {"criteria": {"file_type": "spark_exp_all_1"},""" +
        s""" "target_bucket_name":  "SparkExportAllResolutions", """ +
        s""" "target_file_name": "sys_radar_sdi_cashflow_v01_00", """ +
        s""" "export_format": "csv", "field_delimiter": ",", "print_header": true, "number_of_files": 1} """

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-EXPORT-ALL-RESOLUTIONS", List.empty, sparkExportAllResolutionsParameters, testTopic, resolvedProcessTaskEntityUuid))

    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

    val sparkRun = SparkRun(parametersJson)
    val sparkRunResult = sparkRun.run()

    assert(sparkRunResult == Complete)

    val filePaths: List[String] = getFiles(exportLocation, ".csv")
    val filesAsDf = spark.read.format("csv")
      .options(Map("header" -> "true", "delimiter" -> ","))
      .load(filePaths: _*)
    assert(filesAsDf.count == 2)
    assert(filesAsDf.except(df).count == 0)
  }
  */
  /*
   "given a workflow for SparkExportAllResolutions with Operator" should "return Complete" in {
     val testInputTable = EmfConfig.defaultAccessView
     val t12DbTable = s"$testDbExpCase.T12"

     val sample = s"""[{"entity_uuid": "$t12DbTable","key": "10", "value": "ten"},{"entity_uuid": "$t12DbTable","key": "20", "value": "twenty"}]"""
     val df = spark.read.json(Seq(sample).toDS)
     df.write.mode(SaveMode.Overwrite).saveAsTable(s"$testDbExpCase.$testInputTable")

     val sparkExportAllResolutionsParameters =
       """ {"criteria": {"file_type": "spark_exp_all_1","constraints":[{"attribute":"file_type","value":"test1","operator":"="}]},""" +
         s""" "target_bucket_name":  "SparkExportAllResolutions", """ +
         s""" "target_file_name": "sys_radar_sdi_cashflow_v01_00/csv", """ +
         s""" "export_format": "csv", "field_delimiter": ",", "print_header": true, "number_of_files": 1} """

     val processTasksSourceData: Seq[ProcessTaskData] =
       Seq(ProcessTaskData("T01", "SPARK-EXPORT-ALL-RESOLUTIONS", List.empty, sparkExportAllResolutionsParameters, testTopic, resolvedProcessTaskEntityUuid))

     processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
       .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

     createProcessTaskView()

     val parametersJson =
       s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

     val sparkRun = SparkRun(parametersJson)
     val sparkRunResult = sparkRun.run()

     assert(sparkRunResult == Complete)

     val filePaths: List[String] = getFiles("SparkExportAllResolutions/sys_radar_sdi_cashflow_v01_00/csv", ".csv")
     val filesAsDf = spark.read.format("csv")
       .options(Map("header" -> "true", "delimiter" -> ","))
       .load(filePaths: _*)
     assert(filesAsDf.count == 2)
     assert(filesAsDf.except(df).count == 0)
   }*/
}package hsbc.emf.data.sparkcmdmsg

import java.sql.Timestamp

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.resolution.ResolutionConstraint

case class  SparkRunMessage(workflow: String,
                            process_tasks_constraints: List[ResolutionConstraint],
                            process_tasks_created_to: Timestamp = new Timestamp(System.currentTimeMillis),
                            spark_version: Option[String] = None,
                            disabled: Map[String, List[String]] = Map.empty,
                            enabled: Map[String, List[String]] = Map.empty,
                            run_uuid: Option[String] = None)
  extends ISparkCommandMessagepackage hsbc.emf.infrastructure.services.mapper

import java.sql.Timestamp

import hsbc.emf.data.resolution.ResolutionConstraint
import hsbc.emf.data.sparkcmdmsg.{SparkRunMessage, SparkRunMessageRaw}
import hsbc.emf.infrastructure.exception.SparkRunMessageMapperException

object SparkRunMessageMapper extends IMapper[SparkRunMessageRaw, SparkRunMessage] {
  @throws(classOf[SparkRunMessageMapperException])
  override def map(sparkRunMessageRaw: SparkRunMessageRaw): SparkRunMessage = {
    try {
      val workflow: String = sparkRunMessageRaw.workflow
      val constraints: List[ResolutionConstraint] = ResolutionConstraintMapper.map(sparkRunMessageRaw.process_tasks_constraints)
      val process_tasks_created_to: Timestamp = sparkRunMessageRaw.process_tasks_created_to
      val spark_version: Option[String] = sparkRunMessageRaw.spark_version
      val disabled: Map[String, List[String]] = sparkRunMessageRaw.disabled
      val enabled: Map[String, List[String]] = sparkRunMessageRaw.enabled
      val run_uuid: Option[String] = sparkRunMessageRaw.run_uuid

      new SparkRunMessage(workflow, constraints, process_tasks_created_to, spark_version, disabled, enabled, run_uuid)
    }
    catch {
      case e: Exception =>
        val customMessage = "SparkRunMessageMapper.map fails with other reason: " + e.getMessage
        throw new SparkRunMessageMapperException(customMessage, e)
    }
  }
}
package hsbc.emf.infrastructure.services.mapper

import hsbc.emf.data.resolution.LessThan
import hsbc.emf.data.sparkcmdmsg.{SparkRunMessage, SparkRunMessageRaw}
import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkRunMessageMapperTest extends IntegrationTestSuiteBase {

  "given json with all fields" should "return message object" in {
    val params =
      """{"workflow":"some_workflow","process_tasks_constraints":[{"attribute":"attribute","value":"value","operator":"<"}],
        |"process_tasks_created_to":"2021-01-01 12:22:00.0","spark_version":"2.4.5",
        |"disabled":{"list1":["item1","item2"],"list2":["item1","item2"]},
        |"enabled":{"list1":["item1","item2"],"list2":["item1","item2"]},
        |"run_uuid":"testrun"}""".stripMargin

    val msg = JsonReader.deserialize[SparkRunMessageRaw](params).right.get
    assert(msg.isInstanceOf[SparkRunMessageRaw])

    val sparkRunMessage: SparkRunMessage = SparkRunMessageMapper.map(msg)

    assert(sparkRunMessage.isInstanceOf[SparkRunMessage])

    assert(sparkRunMessage.workflow.equals("some_workflow"))
    assert(sparkRunMessage.process_tasks_constraints(0).attribute.equals("attribute"))
    assert(sparkRunMessage.process_tasks_constraints(0).value.equals("value"))
    assert(sparkRunMessage.process_tasks_constraints(0).operator.equals(LessThan))
    assert(sparkRunMessage.spark_version.equals(Some("2.4.5")))
    assert(sparkRunMessage.disabled.valuesIterator.contains(List("item1","item2")))
    assert(sparkRunMessage.disabled.keySet.contains("list1"))
    assert(sparkRunMessage.disabled.keySet.contains("list2"))
    assert(sparkRunMessage.enabled.valuesIterator.contains(List("item1","item2")))
    assert(sparkRunMessage.enabled.keySet.contains("list1"))
    assert(sparkRunMessage.enabled.keySet.contains("list2"))
    assert(sparkRunMessage.run_uuid.contains("testrun"))
  }
}
package hsbc.emf.data.sparkcmdmsg


import java.sql.Timestamp

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.resolution.ResolutionConstraintRaw

case class SparkRunMessageRaw(
                               workflow: String,
                               process_tasks_constraints: List[ResolutionConstraintRaw],
                               process_tasks_created_to: Timestamp = new Timestamp(System.currentTimeMillis),
                               spark_version: Option[String] = None,
                               disabled: Map[String, List[String]] = Map.empty,
                               enabled: Map[String, List[String]] = Map.empty,
                               run_uuid: Option[String] = None
                             ) extends ISparkCommandMessagepackage hsbc.emf.data.sparkcmdmsg

import hsbc.emf.infrastructure.helper.JsonReader
import hsbc.emf.infrastructure.services.mapper.SparkRunMessageMapper
import hsbc.emf.sparkutils.IntegrationTestSuiteBase


class SparkRunMessageRawTest extends IntegrationTestSuiteBase {

  "given json with required fields" should "return message object" in {

    val params = """{"workflow":"some_workflow","process_tasks_constraints":[{"attribute":"attribute","value":"value"}]}"""
    val msg = JsonReader.deserialize[SparkRunMessageRaw](params).right.get
    assert(msg.isInstanceOf[SparkRunMessageRaw])

    //Optional parameters, values not passed in json and default values are set
    assert(msg.process_tasks_created_to != null)
    assert(msg.spark_version.equals(None))
    assert(msg.disabled.equals(Map.empty))
    assert(msg.enabled.equals(Map.empty))
    assert(msg.run_uuid.equals(None))
  }

  "given json with all fields" should "return message object" in {

    val params =
      """{"workflow":"some_workflow","process_tasks_constraints":[{"attribute":"attribute","value":"value","operator":"<"}],
        |"process_tasks_created_to":"2021-01-01 12:22:00.0","spark_version":"2.4.5",
        |"disabled":{"list1":["item1","item2"],"list2":["item1","item2"]},
        |"enabled":{"list1":["item1","item2"],"list2":["item1","item2"]},
        |"run_uuid":"testrun"}""".stripMargin

    val msg = JsonReader.deserialize[SparkRunMessageRaw](params).right.get

    assert(msg.isInstanceOf[SparkRunMessageRaw])

    assert(msg.workflow.equals("some_workflow"))
    assert(msg.process_tasks_constraints(0).attribute.equals("attribute"))
    assert(msg.process_tasks_constraints(0).value.equals("value"))
    assert(msg.process_tasks_constraints(0).operator.equals("<"))
    assert(msg.spark_version.equals(Some("2.4.5")))
    assert(msg.disabled.valuesIterator.contains(List("item1", "item2")))
    assert(msg.disabled.keySet.contains("list1"))
    assert(msg.disabled.keySet.contains("list2"))
    assert(msg.enabled.valuesIterator.contains(List("item1", "item2")))
    assert(msg.enabled.keySet.contains("list1"))
    assert(msg.enabled.keySet.contains("list2"))
    assert(msg.run_uuid.contains("testrun"))
  }
}
package hsbc.emf.command

import java.io.File
import java.sql.Timestamp

import scala.util.matching.Regex
import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.orchestration.ProcessTaskData
import hsbc.emf.data.resolution.{InputRequirementRaw, ResolutionConstraint, ResolutionConstraintRaw}
import hsbc.emf.infrastructure.config.{CsvFileFormatConfig, EmfConfig}
import hsbc.emf.infrastructure.io.readers.CsvFileReaderToDF
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.sparkutils.{IntegrationTestSuiteBase, TableUtils}
import org.apache.commons.io.FileUtils
import org.apache.spark.sql.{DataFrame, SaveMode}
import org.apache.spark.sql.types._

class SparkRunTest extends IntegrationTestSuiteBase {
  val emptyProcessTaskConstraints = List.empty[ResolutionConstraint]
  val temporaryBucketName = "SparkRun"
  val testTopic = ""
  val curateFileType = "curate_result"
  val uuidRegEx = new Regex("[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}")
  val resolutionSourceTableAccessViewName = s"Person.${EmfConfig.defaultAccessView}"

  import spark.implicits._

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS testingdb")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.process_tasks}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${curateFileType}")
    val query =
      s"""create table if not exists ${curateFileType}.${EmfConfig.defaultTableName} (col_a String)
        partitioned by (entity_uuid String) stored as parquet"""
    spark.sql(query)

    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testingdb.source_table")

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/orchestration/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    val resolvedTableSourceData = Seq(("row1_data", "E21", "Person", Timestamp.valueOf("2021-03-01 00:00:00.1"), List(metaData("att", "val", "string", "")).toArray), ("row2_data", "E21", "Person", Timestamp.valueOf("2021-03-01 00:00:00.1"), List(metaData("att", "val", "string", "")).toArray))
    resolvedTableSourceData.toDF("col_a", "entity_uuid", "__file_type", "__created", "__metadata").write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(resolutionSourceTableAccessViewName)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS ${EmfConfig.process_tasks}.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '${EmfConfig.process_tasks}' group by m.entity_uuid, m.file_type
       """.stripMargin)

  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.process_tasks} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS testingdb CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${curateFileType} CASCADE")
    FileUtils.deleteDirectory(new File(temporaryBucketName.split("/")(0)))
    super.afterAll()
  }

  "given empty workflow" should "return Failed" in {
    assert(new SparkRun("", emptyProcessTaskConstraints).run() == Failed)
  }

  "given parameters for PlaceholderParameters, SparkRun" should "store it for calling to SparkOrchestrateService" in {
    val placeholderParams = PlaceholderParameters(Map("my_database" -> "XYZ", "site" -> "UK"))
    val sparkRun = new SparkRun("some_workflow", emptyProcessTaskConstraints)
    sparkRun.placeholderParams = placeholderParams
    assert(sparkRun.placeholderParams == placeholderParams)
  }

  "given extra parameters, SparkRun.apply(String)" should "construct a SparkRun with placeholderParams containing all parameters" in {
    val parametersJson =
      """{"workflow": "some_workflow", "process_tasks_constraints": [{"attribute": "attribute1", "value": "value1"}], "my_database": "XYZ"}"""
    val sparkRun = SparkRun(parametersJson)
    assert(sparkRun.workflow == "some_workflow")
    assert(sparkRun.processTasksConstraints.head.attribute == "attribute1")
    assert(sparkRun.processTasksConstraints.head.value == "value1")
    assert(sparkRun.placeholderParams.paramMap.size == 3)
    assert(sparkRun.placeholderParams.format("my_database") == "XYZ")
  }

  "given a basic workflow" should "return Complete" in {
    val orginalDataDF: DataFrame = spark.sql(s"select * from testingdb.source_table")
    val testParameters = s"""{"query": "select * from testingdb.source_table", "table": "E01_result_table", "as_view":true }"""
    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(ProcessTaskData("T01", "SPARK-SQL-EVAL", List.empty, testParameters,
      testTopic, "E01"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "CA_ALM_R6", "process_tasks_constraints": [{"attribute": "location", "value": "UK"}]}"""
    val sparkRun = SparkRun(parametersJson).run()
    val resultDF = spark.sql("select * from E01_result_table")

    assert(orginalDataDF.except(resultDF).isEmpty)
    assert(sparkRun == Complete)
  }

  "given a workflow for multiple SparkSqlEval" should "return Complete and have correct data in result views" in {
    val orginalDataDF: DataFrame = spark.sql(s"select * from testingdb.source_table")
    val testParameters = """{"query": "select * from testingdb.source_table", "table": "E02_result_table", "as_view":true}"""
    val testParameters1 = """{"query": "select * from E02_result_table", "table": "E02_result_table1", "as_view":true}"""
    val testParameters2 = """{"query": "select * from E02_result_table1", "table": "E02_result_table2", "as_view":true}"""

    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T03", "SPARK-SQL-EVAL", List("T02"), testParameters2, testTopic, "E02"),
      ProcessTaskData("T02", "SPARK-SQL-EVAL", List("T01"), testParameters1, testTopic, "E02"),
      ProcessTaskData("T01", "SPARK-SQL-EVAL", List.empty, testParameters, testTopic, "E02"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "CA_ALM_R6", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""

    val sparkRun = SparkRun(parametersJson).run()

    val resultDF = spark.sql("select * from E02_result_table")
    assert(orginalDataDF.except(resultDF).isEmpty)

    val resultDF1 = spark.sql("select * from E02_result_table1")
    assert(resultDF.except(resultDF1).isEmpty)

    val resultDF2 = spark.sql("select * from E02_result_table2")
    assert(resultDF1.except(resultDF2).isEmpty)

    assert(sparkRun == Complete)
  }

  "given a workflow for \"SparkSqlEval, SparkMessagesFromQuery\"" should "return Complete and have correct data in result views" in {
    val orginalDataDF: DataFrame = spark.sql(s"select * from testingdb.source_table")

    val sampleData = Seq(("select * from testingdb.source_table", "E03_test_table_1", "NY"),
      ("select * from testingdb.source_table", "E03_test_table_2", "NY"))
    val df1 = sampleData.toDF("a", "b", "c")
    df1.write.mode("overwrite").saveAsTable("testingdb.final_table")

    val testParameters = """{"query": "select * from testingdb.final_table", "as_view":true}"""
    val testParameters1 = """{"query": "select * from E03_test_table_1", "table": "E03_result_table1", "as_view":true}"""
    val testParameters2 = """{"query": "select * from E03_result_table1", "table": "E03_result_table2", "as_view":true}"""
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T02", "SPARK-SQL-EVAL", List("T01"), testParameters1, testTopic, "E03"),
      ProcessTaskData("T03", "SPARK-SQL-EVAL", List("T02"), testParameters2, testTopic, "E03"),
      ProcessTaskData("T01", "SPARK-MESSAGES-FROM-QUERY", List.empty, testParameters, testTopic, "E03"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "GLC_C6", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""

    val sparkRun = SparkRun(parametersJson).run()

    val resultDF = spark.sql("select * from E03_test_table_1")
    assert(orginalDataDF.except(resultDF).isEmpty)

    val resultDF1 = spark.sql("select * from E03_result_table1")
    assert(resultDF.except(resultDF1).isEmpty)

    val resultDF2 = spark.sql("select * from E03_result_table2")
    assert(resultDF1.except(resultDF2).isEmpty)

    assert(sparkRun == Complete)
  }
  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given a workflow for \"SparkLoadTableFromFile, SparkSqlEval, SparkAssert\"" should "return Complete and have correct data in result views" in {
  //    val successCase1TestParquet001 = "success_case2_load_test_parquet001"
  //    val testParameters =
  //      s"""{"bucket":"tests/hsbc/emf","file_path":"/testingFiles/spark_ingest_mockup_data/$successCase1TestParquet001",""" +
  //        """"file_type":"testing","table_name":"E04_testTable1","dataset_name":"exampleDB"}"""
  //    val testParameters1 = s"""{"query": "select * from exampleDB.E04_testTable1", "table": "E04_result_table1", "as_view":true}"""
  //    val testParameters2 = s"""{"assertion": "select * from E04_result_table1","message":"some log message","log_level":"info"}"""
  //    val sourceProcessTasks: Seq[ProcessTaskData] = List(
  //      ProcessTaskData("T01", "SPARK-LOAD-TABLE-FROM-FILE", List.empty, testParameters, testTopic, "E04"),
  //      ProcessTaskData("T02", "SPARK-SQL-EVAL", List("T01"), testParameters1, testTopic, "E04"),
  //      ProcessTaskData("T03", "SPARK-ASSERT", List("T02"), testParameters2, testTopic, "E04"))
  //
  //    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val loadInfoRawList =
  //      List(
  //        LoadInfoRaw(
  //          file_type = "testing",
  //          schema_json = Some(
  //            "[{\"mode\":\"REQUIRED\",\"name\":\"binaryFld\",\"type\":\"Boolean\"}," +
  //              "{\"mode\":\"NULLABLE\",\"name\":\"numericFld\",\"type\":\"Decimal(33,9)\"}," +
  //              "{\"mode\":\"NULLABLE\",\"name\":\"intFld\",\"type\":\"Long\"}," +
  //              "{\"mode\":\"NULLABLE\",\"name\":\"floatFld\",\"type\":\"Double\"}," +
  //              "{\"mode\":\"NULLABLE\",\"name\":\"dateFld\",\"type\":\"Date\"}," +
  //              "{\"mode\":\"NULLABLE\",\"name\":\"datatimeFld\",\"type\":\"Timestamp\"}]"),
  //          extension = Some("parquet"),
  //          ingest_hierarchy = None,
  //          ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
  //          max_bad_records = Some("1")))
  //    loadInfoRawList.toDF().write.mode("overwrite").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  //
  //    val dummyFileTypeDF = spark.read.format("parquet").load(s"tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/$successCase1TestParquet001")
  //    val parametersJson =
  //      """{"workflow": "GLC_C7", "process_tasks_constraints": [{"attribute": "location", "value": "UK"}]}"""
  //
  //    val sparkRun = SparkRun(parametersJson).run()
  //    assert(sparkRun == Complete)
  //    val resultDF = spark.sql("select * from exampleDB.E04_testTable1")
  //    assert(dummyFileTypeDF.except(resultDF).isEmpty)
  //    val resultDF1 = spark.sql("select * from E04_result_table1")
  //    assert(resultDF.except(resultDF1).isEmpty)
  //  }

  "given a workflow for \"SparkAssert, SparkSqlEval, SparkMessagesFromQuery\"" should "return Complete and have correct data in result views" in {
    val tableName = TableUtils.createTable(Seq((false, 1, "something"), (true, 1, "somethingElse")))
    val orginalDataDF = spark.sql(s"select * from $tableName")

    val sampleData = Seq(("select * from E05_result_table1", "E05_output_table_1"),
      ("select * from E05_result_table2", "E05_output_table_2"))
    val df1 = sampleData.toDF("a", "b")
    df1.write.mode("overwrite").saveAsTable("testingdb.output_table")

    val testParameters = s"""{"assertion": "select * from $tableName","message":"some log message","log_level":"info"}"""
    val testParameters1 = s"""{"query": "select * from $tableName", "table": "E05_result_table1", "as_view":true}"""
    val testParameters2 = s"""{"query": "select * from $tableName", "table": "E05_result_table2", "as_view":true}"""
    val testParameters3 = """{"query": "select * from testingdb.output_table", "as_view":true}"""
    val testParameters4 = s"""{"assertion": "select * from E05_output_table_1","message":"testing assert","log_level":"info"}"""
    val testParameters5 = s"""{"assertion": "select * from E05_output_table_2","message":"testing assert","log_level":"info"}"""

    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-ASSERT", List.empty, testParameters, testTopic, "E05"),
      ProcessTaskData("T02", "SPARK-SQL-EVAL", List("T01"), testParameters1, testTopic, "E05"),
      ProcessTaskData("R01", "SPARK-SQL-EVAL", List.empty, testParameters2, testTopic, "E05"),
      ProcessTaskData("A01", "SPARK-ASSERT", List("R02"), testParameters4, testTopic, "E05"),
      ProcessTaskData("A02", "SPARK-ASSERT", List("R02"), testParameters5, testTopic, "E05"),
      ProcessTaskData("R02", "SPARK-MESSAGES-FROM-QUERY", List("R01", "T02"), testParameters3, testTopic, "E05"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "GLC_C8", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

    val sparkRun = SparkRun(parametersJson).run()

    val resultDF1 = spark.sql("select * from E05_result_table2")
    assert(orginalDataDF.except(resultDF1).isEmpty)

    val resultDF2 = spark.sql("select * from E05_result_table1")
    assert(orginalDataDF.except(resultDF2).isEmpty)

    val resultDF3 = spark.sql("select * from E05_output_table_1")
    assert(resultDF2.except(resultDF3).isEmpty)

    val resultDF4 = spark.sql("select * from E05_output_table_2")
    assert(resultDF1.except(resultDF4).isEmpty)

    assert(sparkRun == Complete)
  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given a workflow for \"SparkResolve, SparkSqlFromFile, SparkCurate\" with extra SparkRun parameters and placeholder in command and sql file" should
  //    "return Complete, have data properly resolved, processed and curated, and have extra parameters properly passed to commands" in {
  //
  //    val curateLoadInfoSourceData =
  //      List(
  //        LoadInfoRaw(
  //          file_type = curateFileType,
  //          schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"entity_uuid\",\"type\":\"String\"}," +
  //            "{\"mode\":\"REQUIRED\",\"name\":\"col_a\",\"type\":\"String\"}]"),
  //          extension = Some("parquet"), ingest_hierarchy = None,
  //          ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
  //          max_bad_records = Some("1")))
  //    curateLoadInfoSourceData.toDF().write.mode(SaveMode.Overwrite)
  //      .saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  //
  //    val resolvedTableName = "E21_resolve_table"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
  //        s""""table_name": "$resolvedTableName", "as_view":true}"""
  //    val sqlFromFileResultTableName = "E06_result_table"
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        s""""file_name":"sql_from_file_testing.text","target_table":"$sqlFromFileResultTableName", "as_view":true}"""
  //    val sparkCurateParameters =
  //      s"""{"source_table_name":"$sqlFromFileResultTableName","file_type":"$curateFileType", """ +
  //        s""""metadata":{"file_type":"$curateFileType"}}"""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid),
  //        ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List("T01"), sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid),
  //        ProcessTaskData("T03", "SPARK-CURATE", List("T02"), sparkCurateParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val extraParamForSqlFromFileContent = """"col_a_value": "row2_data""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam, $extraParamForSqlFromFileContent}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid","__file_type","__created","__metadata")
  //    val resolvedDF = spark.sql(s"select * from $resolvedTableName")
  //    assert(originalDf.except(resolvedDF).isEmpty)
  //
  //    val sqlFromFileResultDf = spark.sql(s"select * from $sqlFromFileResultTableName")
  //    val expectedSqlFromFileResultDf = resolvedDF.where("col_a == 'row2_data'")
  //    assert(sqlFromFileResultDf.except(expectedSqlFromFileResultDf).isEmpty)
  //
  //    val curateResultDf = spark.table(s"${curateFileType}.${EmfConfig.defaultTableName}").select("entity_uuid", "col_a")
  //    val uuid = curateResultDf.select("entity_uuid").as[String].first
  //    assert(uuidRegEx.findAllIn(uuid).length == 1)
  //    assert(curateResultDf.select("col_a").except(expectedSqlFromFileResultDf.select("col_a")).isEmpty)
  //  }

  "spark sql eval with as_view is false, dataset is none and write_truncate, " should "return complete" in {

    val testTopic = ""
    val resolvedProcessTaskEntityUuid = "E06"
    val sample1 = """{"key" : "key1", "value": 1}"""
    val df = spark.read.json(Seq(sample1).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")

    val sparkSqlEvalParameters = """{"query" : "select * from test_temp_2", "table": "test_table", "as_view":false}"""

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T02", "SPARK-SQL-EVAL", List.empty, sparkSqlEvalParameters, testTopic, resolvedProcessTaskEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

    val sparkRun = SparkRun(parametersJson)

    val sparkRunResult = sparkRun.run()
    assert(sparkRunResult == Complete)
  }
  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "spark sql from file with as_view is false, dataset is given and write_truncate, " should "return complete" in {
  //
  //    val testTopic = ""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val sqlFromFileResultTableName = "E06_result_table"
  //
  //    val sample1 = """{"key" : "key1", "value": 1}"""
  //    val df = spark.read.json(Seq(sample1).toDS())
  //    df.write.mode("overwrite").saveAsTable("test_temp_2")
  //
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        s""""file_name":"sql_from_file_testing_command.text","target_table":"$sqlFromFileResultTableName", "as_view":false, "writeDisposition":"write_append", "dataset":"exampleDS1"}"""
  //
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""
  //
  //    val sparkRun = SparkRun(parametersJson)
  //
  //    val sparkRunResult = sparkRun.run()
  //    assert(sparkRunResult == Complete)
  //  }
  //
  //  "spark sql from file with as_view is false, dataset is none and write_truncate, " should "return complete" in {
  //
  //    val testTopic = ""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val sqlFromFileResultTableName = "E06_result_table"
  //
  //    val sample1 = """{"key" : "key1", "value": 1}"""
  //    val df = spark.read.json(Seq(sample1).toDS())
  //    df.write.mode("overwrite").saveAsTable("test_temp_2")
  //
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        s""""file_name":"sql_from_file_testing_command.text","target_table":"$sqlFromFileResultTableName", "as_view":false, "writeDisposition":"write_append"}"""
  //
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""
  //
  //    val sparkRun = SparkRun(parametersJson)
  //
  //    val sparkRunResult = sparkRun.run()
  //    assert(sparkRunResult == Complete)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11550
  //  "given a workflow for \"SparkCurate\" with metadata as Map[String, String] in SparkRun" should "return Complete, resolved " +
  //    "to correct entity_uuid" in {
  //
  //    val curateFileType2 = "curate_result2"
  //    // Prepare Source Table Data
  //    spark.sql(s"CREATE DATABASE IF NOT EXISTS $curateFileType2")
  //    spark.sql(
  //      s"""
  //         |CREATE VIEW IF NOT EXISTS $curateFileType2.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
  //         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
  //         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
  //         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$curateFileType2' group by m.entity_uuid, m.file_type
  //       """.stripMargin)
  //    val query =
  //      s"""create table if not exists ${curateFileType2}.${EmfConfig.defaultTableName} (col_a String)
  //        partitioned by (entity_uuid String) stored as parquet"""
  //    spark.sql(query)
  //    val sourceTableAccessViewName = s"$curateFileType2.${EmfConfig.defaultAccessView}"
  //    val resolutionSourceTableEntityUuid = "E21"
  //    val resolvedTableSourceData = Seq((resolutionSourceTableEntityUuid, "row1_data"), (resolutionSourceTableEntityUuid, "row2_data"))
  //    resolvedTableSourceData.toDF("entity_uuid", "col_a").write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(sourceTableAccessViewName)
  //
  //    val curateLoadInfoSourceData =
  //      List(
  //        LoadInfoRaw(
  //          file_type = curateFileType2,
  //          schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"entity_uuid\",\"type\":\"String\"}," +
  //            "{\"mode\":\"REQUIRED\",\"name\":\"col_a\",\"type\":\"String\"}]"),
  //          extension = Some("parquet"), ingest_hierarchy = None,
  //          ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
  //          max_bad_records = Some("1")))
  //    curateLoadInfoSourceData.toDF().write.mode(SaveMode.Overwrite)
  //      .saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  //
  //    val sparkCurateParameters =
  //      s"""{"source_table_name":"$sourceTableAccessViewName","file_type":"$curateFileType2", """ +
  //        s""""metadata":{"file_type":"$curateFileType2","run_no":"1000","md5":"5.6","flag":"true","run_date":"2021-05-01","timestamp":"2021-05-01T00:00:00.123","array":"[UK,US]"}}"""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T03", "SPARK-CURATE", List(), sparkCurateParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val criteria = ResolutionCriteria(curateFileType2, List(ResolutionConstraint("run_no", "1000"),
  //      ResolutionConstraint("md5", "5.6"), ResolutionConstraint("flag", "true"),
  //      ResolutionConstraint("run_date", "2021-05-01"),
  //      ResolutionConstraint("timestamp", "2021-05-01T00:00:00.123"), ResolutionConstraint("array", "UK"), ResolutionConstraint("array", "US")))
  //    val sqlExecutor = new SqlExecutor()
  //    assert(new SparkResolveService(sqlExecutor, new CatalogueDAO(sqlExecutor))
  //      .constructCatalogue4Uuids(criteria, false)._1.nonEmpty)
  //
  //    spark.sql(s"DROP DATABASE IF EXISTS ${curateFileType2} CASCADE")
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given a workflow for SparkExport with complex type parameterisation" should "return Complete" in {
  //    val metadata = "[$input_metadata]"
  //
  //    val testParameters =
  //      s"""{"source_dataset_name": "testingdb", "source_table_name": "source_table", "target_file_name":"sys_radar_sdi_cashflow_v01_00", "target_bucket_name":"$temporaryBucketName", "metadata":$metadata}""".stripMargin
  //
  //    val sourceProcessTasks: Seq[ProcessTaskData] = List(
  //      ProcessTaskData("T01", "SPARK-EXPORT", List.empty, testParameters, testTopic, "E07"))
  //
  //    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      """{"workflow": "complex_param_test", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}], "input_metadata": {"file_type":"test_file_type"}}"""
  //
  //    val sparkRun = SparkRun(parametersJson).run()
  //
  //    assert(sparkRun == Complete)
  //    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
  //    //    val loadLocation = temporaryBucketName + s"/sys_radar_sdi_cashflow_v01_00/*/*/source_table/${EmfConfig.spark_readable_meta_chunk_token}"
  //    //    val df = spark.read.json(loadLocation)
  //    //    val paramMap = df.columns map {
  //    //      column => column -> df.select(column).head().get(0).toString
  //    //    } toMap
  //    //
  //    //    assert(paramMap("attribute")=="file_type")
  //    //    assert(paramMap("value")=="test_file_type")
  //    //    assert(paramMap("data_type")=="string")
  //  }
  //
  //  "given a workflow for SparkExport with complex type parameterisation (with meta_query)" should "return Complete" in {
  //    val simpleSchema = StructType(Array(
  //      StructField("attribute", StringType, true),
  //      StructField("value", StringType, false),
  //      StructField("data_type", StringType, true)
  //    ))
  //    val metadata = "[$input_metadata]"
  //
  //    val testParameters =
  //      s"""{"source_dataset_name": "testingdb", "source_table_name": "source_table", "target_file_name":"sys_radar_sdi_cashflow_v01", "target_bucket_name":"$temporaryBucketName", "metadata":$metadata, "meta_query":"select \'file_type\',\'test_file_type2\'"}""".stripMargin
  //
  //    val sourceProcessTasks: Seq[ProcessTaskData] = List(
  //      ProcessTaskData("T01", "SPARK-EXPORT", List.empty, testParameters, testTopic, "E07"))
  //
  //    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      """{"workflow": "complex_param_test", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}], "input_metadata": {"file_type":"test_file_type"}}"""
  //
  //    val sparkRun = SparkRun(parametersJson).run()
  //
  //    assert(sparkRun == Complete)
  //
  //    // FCCC-11203: CI Tech Debt as unable to use MetaDataTextFileReaderToDF to read __metadata_chunk_token__
  //    //    val loadLocation = temporaryBucketName + s"/sys_radar_sdi_cashflow_v01/*/*/source_table/${EmfConfig.spark_readable_meta_chunk_token}"
  //    //
  //    //    val df = spark.read.format("json").schema(simpleSchema).load(s"$loadLocation")
  //    //
  //    //    val paramMap = df.columns map { column => column -> df.select(column).head(2)} toMap
  //    //
  //    //    val file_type = paramMap("attribute")(1)(0).toString
  //    //    val value = paramMap("value")(1)(0).toString
  //    //    val data_type = paramMap("data_type")(1)(0).toString
  //    //
  //    //    assert(file_type=="file_type")
  //    //    assert(value=="test_file_type2")
  //    //    assert(data_type=="string")
  //
  //  }
  //
  //  "given a workflow for SparkCatalogue" should "return Complete" in {
  //
  //    val testTopic = ""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //
  //    val sourceProcessTasks: Seq[ProcessTaskData] = List(
  //      ProcessTaskData("T01", "SPARK-CATALOGUE", List.empty, "", testTopic, resolvedProcessTaskEntityUuid))
  //
  //    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")
  //
  //    createProcessTaskView()
  //
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //    assert(sparkRunResult == Complete)
  //  }
  //
  //  "given a workflow for SparkSqlFromFile with external parameterization" should "return Complete" in {
  //    //setup jvm parameter for externalParametersFilePath
  //    System.setProperty("externalParametersFilePath", "tests/resources/workflowTest/external_parameters.json")
  //
  //    val columns = Seq("Name", "Age", "City")
  //    val dataDF = Seq(("Gavin", 45, "London"), ("Bill", 50, "London"), ("Philip", 38, "NewYork")).toDF(columns: _*)
  //    dataDF.write.mode("overwrite").saveAsTable("customer")
  //
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        """"file_name":"sql_from_file_with_parameters.sql","target_dataset":"[$customer_db]" ,"target_table":"[$customer_from_london_tbl]", "as_view":false, "write_disposition":"write_truncate"}"""
  //
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("TEST_ORDER_ID", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, "E08"))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      s"""{"workflow": "external_parameter_test", "process_tasks_constraints": [{"attribute": "site", "value": "UK"}], "city_filter":"London", "customer_db": "testing_db"}"""
  //
  //
  //    val sparkRun = SparkRun(parametersJson)
  //
  //    val sparkRunResult = sparkRun.run()
  //    assert(sparkRunResult == Complete)
  //
  //    val resultDf = spark.sql("select * from testing_db.customer_london")
  //    assert(resultDf.count() == 2)
  //    assert(resultDf.except(dataDF.where("city == 'London'")).isEmpty)
  //  }

  "given a workflow for \"SparkResolveFromInputRequirements\" with placeholder parameters in command as_view=false" should
    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
    // Prepare Source Table Data
    val input_req_table = "input_req_table"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("[$group_run_loc]", "[$group_run_uk]", "[$group_run_op]"),
      ResolutionConstraintRaw("[$group_run_md5]", "[$group_run_10]", "[$group_run_op]")))

    val whereClause = Option(List(ResolutionConstraintRaw("[$group_run_colB]", "[$group_run_row1]", "[$group_run_op]")))

    spark.sql(s"CREATE DATABASE IF NOT EXISTS temp_db")
    spark.sql(s"CREATE TABLE IF NOT EXISTS temp_db.$input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches INT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")
    val inputRequirementRaw = InputRequirementRaw(
      file_type = "[$resolution_file_type]",
      table_name = "[$view_table]",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "[$group_run_data]",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    spark.sql(s"TRUNCATE TABLE temp_db.$input_req_table")
    inputRequirementDS.toDF.write.format("hive").insertInto(s"temp_db.$input_req_table")

    val sparkResolveParameters =
      s"""{"input_requirements_table_name": "[$$input_req_table_name]",""" +
        s""""dataset_name":"[$$target_dataset]","as_view":false}"""

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-RESOLVE-FROM-INPUT-REQUIREMENTS", List.empty, sparkResolveParameters, testTopic, "E06"))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    // Trigger SparkRun
    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}],""" +
        s""""resolution_file_type": "Person",""" +
        s""""target_dataset":"temp_db","view_table":"resolve_view_table",""" +
        s""""group_run_loc":"location","group_run_uk":"UK","group_run_op":"=",""" +
        s""""group_run_md5":"md5","group_run_10":"10",""" +
        s""""group_run_colB":"col_a","group_run_row1":"row2_data",""" +
        s""""group_run_data":"data","input_req_table_name":"input_req_table"}"""

    val sparkRunResult = SparkRun(parametersJson).run()

    // Assert the results
    assert(sparkRunResult == Complete)

    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid", "__file_type", "__created", "__metadata")
    val resolvedDF = spark.sql(s"select * from temp_db.resolve_view_table")
    assert(resolvedDF.count() == 1)
    val resolvedDfWithoutRuntimeUuidColumn = resolvedDF.drop(EmfConfig.runtime_uuid_column) // Drop the extra column added by FCCC-12084
    assert(resolvedDfWithoutRuntimeUuidColumn.except(originalDf.where("col_a == 'row2_data'")).isEmpty)
  }

  "given a workflow for \"SparkCreateTable\" and \"SparkResolveFromInputRequirements\" with placeholder parameters in command as_view=false and inject_metadata=true" should
    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val file_type = "Person"
    // Prepare Source Table Data
    val input_req_table = "input_req_table_with_metadata"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("[$group_run_loc]", "[$group_run_uk]", "[$group_run_op]"),
      ResolutionConstraintRaw("[$group_run_md5]", "[$group_run_10]", "[$group_run_op]")))

    val whereClause = Option(List(ResolutionConstraintRaw("[$group_run_colB]", "[$group_run_row1]", "[$group_run_op]")))

    spark.sql(s"CREATE DATABASE IF NOT EXISTS temp_db")
    spark.sql(s"CREATE TABLE IF NOT EXISTS temp_db.$input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches INT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")
    val inputRequirementRaw = InputRequirementRaw(
      file_type = "[$resolution_file_type]",
      table_name = "[$view_table]",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "[$group_run_data]",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    inputRequirementDS.toDF.write.format("hive").insertInto(s"temp_db.$input_req_table")
    val loadInfoRawList = List(LoadInfoRaw(file_type = s"$file_type", schema = Some("col_a:String"), extension = Some("parquet"), ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"), max_bad_records = Some("1")))
    loadInfoRawList.toDF().write.mode(SaveMode.Overwrite).saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    val sparkResolveParameters =
      s"""{"inject_metadata":true, "input_requirements_table_name": "[$$input_req_table_name]",""" +
        s""""dataset_name":"[$$target_dataset]","as_view":false}"""

    val sparkCreateTableParameters =
      s"""{"inject_metadata":true, "file_type": "[$$resolution_file_type]",""" +
        s""""dataset_name":"[$$target_dataset]","table_name":"[$$view_table]"}"""
    val testWorkflowEntityUuid = "E06"
    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(
        ProcessTaskData("T01", "SPARK-CREATE-TABLE", List.empty, sparkCreateTableParameters, testTopic, testWorkflowEntityUuid),
        ProcessTaskData("T02", "SPARK-RESOLVE-FROM-INPUT-REQUIREMENTS", List("T01"), sparkResolveParameters, testTopic, testWorkflowEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    // Trigger SparkRun
    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}],""" +
        s""""resolution_file_type": "Person",""" +
        s""""target_dataset":"temp_db","view_table":"resolve_view_table_with_meta",""" +
        s""""group_run_loc":"location","group_run_uk":"UK","group_run_op":"=",""" +
        s""""group_run_md5":"md5","group_run_10":"10",""" +
        s""""group_run_colB":"col_a","group_run_row1":"row2_data",""" +
        s""""group_run_data":"data","input_req_table_name":"input_req_table_with_metadata"}"""

    val sparkRunResult = SparkRun(parametersJson).run()

    // Assert the results
    assert(sparkRunResult == Complete)

    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName")
    val resolvedDF = spark.sql(s"select * from temp_db.resolve_view_table_with_meta")

    assert(resolvedDF.count() == 1)
    assert(resolvedDF.columns.contains("__created"))
    assert(resolvedDF.columns.contains("__file_type"))
    assert(resolvedDF.columns.contains("__metadata"))

    assert(resolvedDF.except(originalDf.where("col_a == 'row2_data'")).isEmpty)
  }

  "given a workflow for \"SparkResolveFromInputRequirements\" with placeholder parameters in command as_view=true" should
    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
    // Prepare Source Table Data
    val input_req_table = "input_req_table"
    val resolutionConstraint = Option(List(ResolutionConstraintRaw("[$group_run_loc]", "[$group_run_uk]", "[$group_run_op]"),
      ResolutionConstraintRaw("[$group_run_md5]", "[$group_run_10]", "[$group_run_op]")))

    val whereClause = Option(List(ResolutionConstraintRaw("[$group_run_colB]", "[$group_run_row1]", "[$group_run_op]")))

    spark.sql(s"CREATE DATABASE IF NOT EXISTS temp_db")
    spark.sql(s"CREATE TABLE IF NOT EXISTS temp_db.$input_req_table " +
      "(file_type STRING, table_name STRING, " +
      "constraints ARRAY<STRUCT<attribute: STRING, value: STRING, operator: STRING>>, " +
      "created_to TIMESTAMP, created_from TIMESTAMP, latest_only BOOLEAN, min_matches INT, " +
      "source_entity_type STRING, where_clause ARRAY<STRUCT<attribute: STRING, value: STRING, " +
      "operator: STRING>>) stored as parquet")
    val inputRequirementRaw = InputRequirementRaw(
      file_type = "[$resolution_file_type]",
      table_name = "[$view_table]",
      constraints = resolutionConstraint,
      created_to = Some(Timestamp.valueOf("2021-01-02 00:00:00")),
      created_from = Some(Timestamp.valueOf("2020-12-31 00:00:00")),
      latest_only = false,
      min_matches = Some(1),
      source_entity_type = "[$group_run_data]",
      where_clause = whereClause
    )
    val inputRequirementDS = spark.createDataset(Seq(inputRequirementRaw))
    spark.sql(s"TRUNCATE TABLE temp_db.$input_req_table")
    inputRequirementDS.toDF.write.format("hive").insertInto(s"temp_db.$input_req_table")

    val sparkResolveParameters =
      s"""{"input_requirements_table_name": "[$$input_req_table_name]","as_view":true}"""

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-RESOLVE-FROM-INPUT-REQUIREMENTS", List.empty, sparkResolveParameters, testTopic, "E06"))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    // Trigger SparkRun
    val parametersJson =
      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}],""" +
        s""""resolution_file_type": "Person",""" +
        s""""target_dataset":"temp_db","view_table":"resolve_view_table",""" +
        s""""group_run_loc":"location","group_run_uk":"UK","group_run_op":"=",""" +
        s""""group_run_md5":"md5","group_run_10":"10",""" +
        s""""group_run_colB":"col_a","group_run_row1":"row2_data",""" +
        s""""group_run_data":"data","input_req_table_name":"input_req_table"}"""

    val sparkRunResult = SparkRun(parametersJson).run()

    // Assert the results
    assert(sparkRunResult == Complete)

    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid", "__file_type", "__created", "__metadata")
    val resolvedDF = spark.sql(s"select * from resolve_view_table")

    assert(resolvedDF.count() == 1)
    assert(resolvedDF.except(originalDf.where("col_a == 'row2_data'")).isEmpty)
  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given spark sql eval with query resulting empty " should "return complete" in {
  //
  //    val testTopic = ""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val sqlFromFileResultTableName = "E06_result_table"
  //
  //    val sample1 = """{"key" : "key1", "value": 1}"""
  //    val df = spark.read.json(Seq(sample1).toDS())
  //    df.write.mode("overwrite").saveAsTable("test_temp_2")
  //
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        s""""file_name":"sql_from_file_testing_nodata.text","target_table":"$sqlFromFileResultTableName", "as_view":false, "writeDisposition":"write_append", "dataset":"exampleDS1"}"""
  //
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""
  //
  //    val sparkRun = SparkRun(parametersJson)
  //
  //    val sparkRunResult = sparkRun.run()
  //    assert(sparkRunResult == Complete)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11550
  //  "given a workflow for \"SparkResolve\" with placeholder parameters in command as_view=true" should
  //    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
  //
  //
  //    val resolvedTableName = "E21_resolve_table"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
  //        s""""table_name": "$resolvedTableName", "as_view":true}"""
  //
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid","__file_type","__created","__metadata")
  //    val resolvedDF = spark.sql(s"select * from $resolvedTableName")
  //    assert(originalDf.except(resolvedDF).isEmpty)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11550
  //  "given a workflow for \"SparkResolve\" with placeholder parameters in command as_view=false" should
  //    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
  //
  //    val resolvedTableName = "E21_resolve_table2"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
  //        s""""table_name": "$resolvedTableName", "as_view":false,"dataset_name":"testingdb"}"""
  //
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid","__file_type","__created","__metadata")
  //    val resolvedDF = spark.sql(s"select * from testingdb.$resolvedTableName")
  //    assert(originalDf.except(resolvedDF).isEmpty)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11550
  //  "given a workflow for \"SparkResolve\" with placeholder parameters in command default as_view=false" +
  //    "and dataset_name=testing_db" should "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
  //
  //    val resolvedTableName = "E21_resolve_table2"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
  //        s""""table_name": "$resolvedTableName","dataset_name":"testingdb"}"""
  //
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid","__file_type","__created","__metadata")
  //    val resolvedDF = spark.sql(s"select * from testingdb.$resolvedTableName")
  //    assert(originalDf.except(resolvedDF).isEmpty)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11550
  //  "given a workflow for \"SparkResolve\" with placeholder parameters in command default as_view=false" should
  //    "return Complete, have data properly resolved and have extra parameters properly passed to commands" in {
  //
  //    val resolvedTableName = "E21_resolve_table2"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
  //        s""""table_name": "$resolvedTableName"}"""
  //
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //  }

  // FCCC-11203:- Tech Debt for follow-up on failed CI tests introduced with changes made under ticket FCCC-11122
  //  "given double quotes in constrains" should
  //    "test passed" in {
  //
  //    val curateLoadInfoSourceData =
  //      List(
  //        LoadInfoRaw(
  //          file_type = curateFileType,
  //          schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"entity_uuid\",\"type\":\"String\"}," +
  //            "{\"mode\":\"REQUIRED\",\"name\":\"col_a\",\"type\":\"String\"}]"),
  //          extension = Some("parquet"), ingest_hierarchy = None,
  //          ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
  //          max_bad_records = Some("1")))
  //    curateLoadInfoSourceData.toDF().write.mode(SaveMode.Overwrite)
  //      .saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
  //
  //    val resolvedTableName = "E21_resolve_table"
  //    val sparkResolveParameters =
  //      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
  //        """"constraints": "[{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]"},""" +
  //        s""""table_name": "$resolvedTableName", "as_view":true}"""
  //    val sqlFromFileResultTableName = "E06_result_table"
  //    val sparkSqlFromFileParameters =
  //      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
  //        s""""file_name":"sql_from_file_testing.text","target_table":"$sqlFromFileResultTableName", "as_view":true}"""
  //    val sparkCurateParameters =
  //      s"""{"source_table_name":"$sqlFromFileResultTableName","file_type":"$curateFileType", """ +
  //        s""""metadata":{"file_type":"$curateFileType"}}"""
  //    val resolvedProcessTaskEntityUuid = "E06"
  //    val processTasksSourceData: Seq[ProcessTaskData] =
  //      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid),
  //        ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List("T01"), sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid),
  //        ProcessTaskData("T03", "SPARK-CURATE", List("T02"), sparkCurateParameters, testTopic, resolvedProcessTaskEntityUuid))
  //    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
  //      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  //
  //    // Trigger SparkRun
  //    val extraParamForSparkResolveParam =
  //      """"resolution_file_type": "Person""""
  //    val extraParamForSqlFromFileContent = """"col_a_value": "row2_data""""
  //    val parametersJson =
  //      s"""{"workflow": "GLC_C9", "process_tasks_constraints": [{"attribute": "location", "value": "US"}], """ +
  //        s"""$extraParamForSparkResolveParam, $extraParamForSqlFromFileContent}"""
  //
  //    val sparkRunResult = SparkRun(parametersJson).run()
  //
  //    // Assert the results
  //    assert(sparkRunResult == Complete)
  //
  //    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid","__file_type","__created","__metadata")
  //    val resolvedDF = spark.sql(s"select * from $resolvedTableName")
  //    assert(originalDf.except(resolvedDF).isEmpty)
  //
  //    val sqlFromFileResultDf = spark.sql(s"select * from $sqlFromFileResultTableName")
  //    val expectedSqlFromFileResultDf = resolvedDF.where("col_a == 'row2_data'")
  //    assert(sqlFromFileResultDf.except(expectedSqlFromFileResultDf).isEmpty)
  //
  //    val curateResultDf = spark.table(s"${curateFileType}.${EmfConfig.defaultTableName}").select("entity_uuid", "col_a")
  //    val uuid = curateResultDf.select("entity_uuid").as[String].first
  //    assert(uuidRegEx.findAllIn(uuid).length == 1)
  //    assert(curateResultDf.select("col_a").except(expectedSqlFromFileResultDf.select("col_a")).isEmpty)
  //  }

  "CRM command in workflow" should "return Complete" in {
    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 0)
    val inputSchema = StructType(List(
      StructField("Uniq_Account_ID", StringType, true),
      StructField("Uniq_CRM_ID", StringType, true),
      StructField("Undrawn_Flag", StringType, true),
      StructField("ADV_CRM_Priority_Order_Sequence_Number", StringType, true),
      StructField("Actual_Unweighted_Collateral_USD", DoubleType, true),
      StructField("ADV_Original_Exposure_Post_Provision_Pre_CRM_USD", DoubleType, true),
      StructField("Effective_CRM_Factor", DoubleType, true),
      StructField("Cstar", DoubleType, true)))

    val outputSchema = StructType(List(
      StructField("Uniq_Account_ID", StringType, true),
      StructField("Uniq_CRM_ID", StringType, true),
      StructField("Undrawn_Flag", StringType, true),
      StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
      StructField("Regulator", StringType, true),
      StructField("PRA_Reporting_Approach_From_CRM_Engine", StringType, true),
      StructField("Adjustment_Flag", StringType, true),
      StructField("Original_Exposure_Covered_USD", DoubleType, true),
      StructField("CbyE_Ratio", DoubleType, true),
      StructField("CRM_Eligible_For_Exposure_Flag", StringType, true),
      StructField("Effective_CRM_Amount_After_Efficiency", DoubleType, true),
      StructField("Effective_CRM_Amount_Allocated_USD", DoubleType, true),
      StructField("Effective_CRM_Amount_Available_USD", DoubleType, true),
      StructField("Original_Exposure_not_covered", DoubleType, true),
      StructField("Comment", StringType, true),
      StructField("Secured_Indicator", StringType, true),
      StructField("Allocation_Order", DoubleType, true)
    ))
    spark.sql("CREATE DATABASE IF NOT EXISTS crm_input_dataset")
    spark.sql("CREATE DATABASE IF NOT EXISTS crm_output_dataset")
    spark.sql("CREATE DATABASE IF NOT EXISTS test_dataset")
    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_INPUT_ADV.csv", Some(inputSchema))
    inputDF.write.mode(SaveMode.Overwrite).format("hive").saveAsTable("crm_input_dataset.crm_input_table")

    val expectedOutputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/CRM_OUTPUT_EXPECTED_ADV.csv", Some(outputSchema)).na.fill(0)

    val testParameters = """{"source_dataset":"crm_input_dataset","source_table":"crm_input_table","target_dataset":"crm_output_dataset","target_table":"crm_output_table","approach":"ADV", "crm_read_sql":"SELECT Uniq_Account_ID AS Unique_Account_Id, Uniq_CRM_ID As Unique_Mitigant_Id, Undrawn_Flag,[$approach]_CRM_Priority_Order_Sequence_Number AS CRM_Priority_Order_Sequence_Number, COALESCE(Actual_Unweighted_Collateral_USD,0) AS Credit_Mitigant_Value, COALESCE([$approach]_Original_Exposure_Post_Provision_Pre_CRM_USD ,0) AS Total_Original_Exposure_pre_CCF,  coalesce(Effective_CRM_Factor,0) AS Effective_CRM_Factor, coalesce(Cstar,0) AS Cstar FROM [$dataset].[$table]"}"""
    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(ProcessTaskData("T01", "GBQ-RWA-CRM", List.empty, testParameters, testTopic, "E32"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "RWA_CRM_TEST", "process_tasks_constraints": [], "target_dataset":"test_dataset"}"""
    val sparkRun = SparkRun(parametersJson).run()
    val resultDF = spark.sql("select * from crm_output_dataset.crm_output_table")

    assert(sparkRun == Complete)
    assert(expectedOutputDF.except(resultDF).isEmpty)
  }


  "spark sql from file with as_view is false, with parallel write on same table " should "return complete" in {

    val testTopic = ""
    val resolvedProcessTaskEntityUuid = "E06"
    val sqlFromFileResultTableName = "E06_result_table"

    //val sample1 = """{"key" : "key1", "value": 1}"""
    val df = spark.read.json("tests/hsbc/emf/testingFiles/spark_ingest_mockup_data/test_college_sample_with_typed_data_adjustable/test_college_sample_E1CC15ED71594DA28C4079104CDB4018.json")
    df.write.mode("overwrite").saveAsTable("test_temp_2")

    val sparkSqlFromFileParameters =
      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
        s""""file_name":"sql_from_file_testing_command.text","target_dataset": "testingdb", "target_table":"$sqlFromFileResultTableName", "as_view":false, "writeDisposition":"write_append"}"""

    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid),
        ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid),
        ProcessTaskData("T03", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      s"""{"workflow": "GLC_C9","target_dataset": "testingdb","process_tasks_constraints": [{"attribute": "location", "value": "US"}]}"""

    val sparkRun = SparkRun(parametersJson)

    val sparkRunResult = sparkRun.run()
    assert(sparkRunResult == Complete)
    assert(spark.table(s"testingdb.${sqlFromFileResultTableName}").count() == 48195)
  }

  "spark sql from file with as_view is false, with difference in datatype precision and scale" should "not truncate the values" in {

    val testParameters1 = """{"query": "select 'a' as col1, 0.0 as col2", "table": "E09_result_table", "dataset": "testingdb", "as_view":false}"""
    val testParameters2 = """{"query": "select 'b' as col1, 4032.67247 as col2", "table": "E09_result_table", "dataset": "testingdb", "as_view":false}"""

    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-SQL-EVAL", List.empty, testParameters1, testTopic, "E09"),
      ProcessTaskData("T02", "SPARK-SQL-EVAL", List("T01"), testParameters2, testTopic, "E09"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

    val parametersJson =
      """{"workflow": "E09_WF", "process_tasks_constraints": [], "target_dataset": "testingdb"}"""

    val sparkRun = SparkRun(parametersJson).run()

    val resultDF = spark.table("testingdb.E09_result_table")
    assert(sparkRun == Complete)
    //assert table schema
    val col2Field: StructField = resultDF.schema.filter(f=>f.name=="col2").filter(f=>f.name=="col2").head
    assert(col2Field.name == "col2")
    assert(col2Field.dataType.isInstanceOf[DecimalType])
    assert(col2Field.dataType.simpleString == "decimal(38,18)")
    assert(col2Field.dataType == DecimalType.SYSTEM_DEFAULT)

    //assert table content
    assert(resultDF.select("col2").except(spark.sql("select 0.0 union all select 4032.67247")).isEmpty)
  }

}package hsbc.emf.command

import java.sql.Timestamp

import hsbc.emf.constants.Complete
import hsbc.emf.data.ingestion.MetadataRaw
import hsbc.emf.data.orchestration.ProcessTaskData
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode

class SparkRunWorkflowCommandExtraParamTest extends IntegrationTestSuiteBase {
  import spark.implicits._
  val nullParents: List[String] = null
  val emptyTopic = ""
  val emptyDomain = ""
  val processTasksFileType = "process_tasks"
  val nowTimestamp = new Timestamp(System.currentTimeMillis)
  val testingDb = "testing_db"

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.processTasksDatabaseName}")
    spark.sql(
      s"""create table if not exists ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}
         |(order_id string, command string, parents array<string>, parameters string, topic string)
         |partitioned by
         |(entity_uuid string)
         |stored as parquet""".stripMargin)
    spark.sql(
      s"""create view if not exists ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultAccessView} as
         | select d.*, m.created, m.metadata as metadata
         | from ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName} d
         | left outer join
         | (select entity_uuid, created, metadata,  DENSE_RANK() OVER(PARTITION BY file_type ORDER BY created DESC) AS rank
         |  from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}) m
         | on m.entity_uuid = d.entity_uuid and m.rank = 1""".stripMargin)

    spark.sql(s"CREATE DATABASE IF NOT EXISTS $testingDb")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $processTasksFileType.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$processTasksFileType' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.processTasksDatabaseName} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $testingDb CASCADE")
    super.afterAll()
  }

  "given a workflow for SparkSqlFromFile using a command-level parameter in sql file" should "return Complete" in {
    // Test values
    val sqlFileName = "sql_from_file_with_parameters.sql"
    val sourceTableName = "customer"  // need to match the SQL contents in the SQL file
    val resultTableName = "result_table1"
    val workflowName = "command_level_extra_parameter_test"

    // Prepare Process Tasks Data
    val processTasksEntityUuid = "b617f28b-1db7-4c8b-ba19-aea3c203d557"
    val sparkSqlFromFileParameters =
      s"""{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", "file_name": "$sqlFileName", """ +
        s""" "target_table": "$resultTableName", "as_view": true, """ +
        """ "city_filter": "London" }"""  // city_filter is command-level extra parameter

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("TEST_ORDER_ID", "SPARK-SQL-FROM-FILE", nullParents, sparkSqlFromFileParameters, emptyTopic, processTasksEntityUuid)
    )
    processTasksSourceData.toDS.write.mode(SaveMode.Append).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(processTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", workflowName, "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(processTasksEntityUuid, processTasksFileType, nowTimestamp,
        "site", "UK", "STRING", emptyDomain, Some(nowTimestamp))
    )
    catalogueSourceData.toDF.write.mode(SaveMode.Append).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare Source Table Data
    val sourceTableColumns = Seq("Name", "Age", "City")
    val sourceTableDf = Seq(("Gavin", 45, "London"), ("Bill", 50, "London"), ("Philip", 38, "NewYork")).toDF(sourceTableColumns: _*)
    sourceTableDf.createOrReplaceTempView(sourceTableName)

    // Execute Spark Run
    val sparkRunParametersJson =
      s"""{"workflow": "$workflowName", "process_tasks_constraints": [{"attribute": "site", "value": "UK"}] }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson).run()
    assert(sparkRunResult == Complete)

    // Assert the result
    val resultDf = spark.sql(s"select * from $resultTableName")
    assert(resultDf.count() == 2)
    assert(resultDf.except(sourceTableDf.where("city == 'London'")).isEmpty)
  }

  "given a workflow for SparkSqlFromFile using an extra parameter \"target_dataset\": \"[$target_dataset]\" in command level "
    "and [$target_dataset] in sql file" should "return Complete" in {
    // Test values
    val sqlFileName = "sql_from_file_with_target_dataset_parameter.sql"
    val sourceTableName = "customer"  // need to match the SQL contents in the SQL file
    val resultTableName = "result_table2"
    val workflowName = "command_level_target_dataset_parameter_test"

      // Prepare Process Tasks Data
    val processTasksEntityUuid = "c1be1fe0-b673-45f3-a1c5-b2c23363b8fe"
    val sparkSqlFromFileParameters =
      s"""{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", "file_name": "$sqlFileName", """ +
        s""" "target_table": "$resultTableName", "as_view": true, """ +
        """ "target_dataset": "[$target_dataset]", "city_filter": "London" } """ // extra parameters in command level

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("TEST_ORDER_ID", "SPARK-SQL-FROM-FILE", nullParents, sparkSqlFromFileParameters, emptyTopic, processTasksEntityUuid)
    )
    processTasksSourceData.toDS.write.mode(SaveMode.Append).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(processTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", workflowName, "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(processTasksEntityUuid, processTasksFileType, nowTimestamp,
        "site", "UK", "STRING", emptyDomain, Some(nowTimestamp))
    )
    catalogueSourceData.toDF.write.mode(SaveMode.Append).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare Source Table Data
    val sourceTableColumns = Seq("Name", "Age", "City")
    val sourceTableDf = Seq(("Gavin", 45, "London"), ("Bill", 50, "London"), ("Philip", 38, "NewYork")).toDF(sourceTableColumns: _*)
    sourceTableDf.toDF.write.mode(SaveMode.Overwrite).saveAsTable(s"$testingDb.$sourceTableName")

    // Execute Spark Run
    val sparkRunParametersJson =
      s"""{"workflow": "$workflowName", "process_tasks_constraints": [{"attribute": "site", "value": "UK"}], """ +
        s""" "target_dataset": "$testingDb" }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson).run()
    assert(sparkRunResult == Complete)

    // Assert the result
    val resultDf = spark.sql(s"select * from $resultTableName")
    assert(resultDf.count() == 2)
    assert(resultDf.except(sourceTableDf.where("city == 'London'")).isEmpty)
  }
}package hsbc.emf.command

import java.sql.Timestamp

import hsbc.emf.constants.Complete
import hsbc.emf.data.ingestion.MetadataRaw
import hsbc.emf.data.orchestration.ProcessTaskData
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode

class SparkRunWorkflowOfWorkflowTest extends IntegrationTestSuiteBase {
  import spark.implicits._
  val nullParents: List[String] = null
  val emptyTopic = ""
  val emptyDomain = ""
  val processTasksFileType = "process_tasks"
  val nowTimestamp = new Timestamp(System.currentTimeMillis)

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.processTasksDatabaseName}")
    spark.sql(
      s"""create table if not exists ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}
         |(order_id string, command string, parents array<string>, parameters string, topic string)
         |partitioned by
         |(entity_uuid string)
         |stored as parquet""".stripMargin)
    spark.sql(
      s"""create view if not exists ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultAccessView} as
         | select d.*, m.created, m.metadata as metadata
         | from ${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName} d
         | left outer join
         | (select entity_uuid, created, metadata,  DENSE_RANK() OVER(PARTITION BY file_type ORDER BY created DESC) AS rank
         |  from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultAccessView}) m
         | on m.entity_uuid = d.entity_uuid and m.rank = 1""".stripMargin)
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS $processTasksFileType.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '$processTasksFileType' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.processTasksDatabaseName} CASCADE")
    super.afterAll()
  }

  "Workflow of Workflow" should "trigger SparkRun for sub-workflow successfully" in {
    // Prepare Process Tasks Data
    spark.catalog.dropTempView(EmfConfig.processTaskCacheView)
    val subWorkflowProcessTasksEntityUuid = "e2d36633-8f38-478b-8a55-f2e062d97a00"
    val subWorkflowSparkSqlEvalParameters = """{"query": "select '[$param_from_spark_run]' as col1", "table": "sub_workflow_result_table", "as_view":true}"""
    val mainWorkflowProcessTasksEntityUuid = "8ddbb3bb-7a01-4473-858a-0d544d196593"
    val mainWorkflowSparkRunParameters = """{"workflow": "sub_workflow", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("S01", "SPARK-SQL-EVAL", nullParents, subWorkflowSparkSqlEvalParameters, emptyTopic, subWorkflowProcessTasksEntityUuid),
      ProcessTaskData("M01", "SPARK-RUN", nullParents, mainWorkflowSparkRunParameters, emptyTopic, mainWorkflowProcessTasksEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "sub_workflow", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "main_workflow", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)))
    catalogueSourceData.toDF.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Execute Spark Run
    val sparkRunParametersJson =
      """{"workflow": "main_workflow",""" +
        """ "process_tasks_constraints": [{"attribute": "location", "value": "HK"}],""" +
        """ "param_from_spark_run": "col1_value_from_spark_run" }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson).run()

    // Assert the result
    assert(sparkRunResult == Complete)
    assert(spark.table("sub_workflow_result_table").select("col1").as[String].collect.head == "col1_value_from_spark_run")
  }

  "Workflow of Workflow having SparkRun again as a sub-workflow" should "trigger SparkRun for sub-workflow successfully" in {
    spark.catalog.dropTempView(EmfConfig.processTaskCacheView)
    // Prepare Process Tasks Data
    val subWorkflowProcessTasksEntityUuid1 = "0ea3a382-710d-403c-ac70-95cd5796a70d"
    val subWorkflowSparkRunParameters = """{"workflow": "sub_workflow2", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""
    val subWorkflowProcessTasksEntityUuid2 = "0c51cbd8-edf4-4cd9-a184-b6a12b83a54f"
    val subWorkflowSparkSqlEvalParameters = """{"query": "select '[$param_from_spark_run]' as col1", "table": "sub_workflow2_result_table", "as_view":true}"""
    val mainWorkflowProcessTasksEntityUuid = "86873a05-124b-4809-9381-deab119bbbcb"
    val mainWorkflowSparkRunParameters = """{"workflow": "sub_workflow1", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("S01", "SPARK-RUN", nullParents, subWorkflowSparkRunParameters, emptyTopic, subWorkflowProcessTasksEntityUuid1),
      ProcessTaskData("S02", "SPARK-SQL-EVAL", nullParents, subWorkflowSparkSqlEvalParameters, emptyTopic, subWorkflowProcessTasksEntityUuid2),
      ProcessTaskData("M01", "SPARK-RUN", nullParents, mainWorkflowSparkRunParameters, emptyTopic, mainWorkflowProcessTasksEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(subWorkflowProcessTasksEntityUuid1, processTasksFileType, nowTimestamp,
        "workflow", "sub_workflow1", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid1, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid2, processTasksFileType, nowTimestamp,
        "workflow", "sub_workflow2", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid2, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "main_workflow", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)))
    catalogueSourceData.toDF.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Execute Spark Run
    val sparkRunParametersJson =
      """{"workflow": "main_workflow",""" +
        """ "process_tasks_constraints": [{"attribute": "location", "value": "HK"}],""" +
        """ "param_from_spark_run": "col1_value_from_spark_run" }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson).run()

    // Assert the result
    assert(sparkRunResult == Complete)
    assert(spark.table("sub_workflow2_result_table").select("col1").as[String].collect.head == "col1_value_from_spark_run")
  }

  // FCCC-11064: Pass Enabled/Disabled to sub-workflow for Bug FCCC-11046
  "Workflow of Workflow having enabled in top-level SparkRun but no enabled in subworkflow-level SparkRun" should
    "pass the enabled to subworkflow-level SparkRun and commands in subworkflow can be filtered based on their labels" in {
    spark.catalog.dropTempView(EmfConfig.processTaskCacheView)
    // Prepare Process Tasks Data
    val mainWorkflowProcessTasksEntityUuid = "a1707a53-10b1-4e8b-ae27-7f802e55a57e"
    val mainWorkflowCommand1Parameters = """{"workflow": "sub_workflow", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""
    val subWorkflowProcessTasksEntityUuid = "61358a3d-be19-40ff-96d1-61f3397a908a"
    val subWorkflowCommand1Parameters = """{"labels":{"exec_type":["FOTC_ADJ_FIRST","RWA_ADJ_FIRST","LIQ"]},""" + // Took ref from Bug FCCC-11046
      """ "query": "select '[$param_from_spark_run]' as col1", "table": "sub_workflow_result_table1", "as_view":true}"""
    val subWorkflowCommand2Parameters = """{"labels":{"exec_type":["FOTC_ADJ_FIRST","RWA_ADJ_FIRST"]},""" + // Took ref from Bug FCCC-11046
      """ "query": "select '[$param_from_spark_run]' as col1", "table": "sub_workflow_result_table2", "as_view":true}"""

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("M01", "SPARK-RUN", nullParents, mainWorkflowCommand1Parameters, emptyTopic, mainWorkflowProcessTasksEntityUuid),
      ProcessTaskData("S01", "SPARK-SQL-EVAL", nullParents, subWorkflowCommand1Parameters, emptyTopic, subWorkflowProcessTasksEntityUuid),
      ProcessTaskData("S02", "SPARK-SQL-EVAL", List("S01"), subWorkflowCommand2Parameters, emptyTopic, subWorkflowProcessTasksEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "sub_workflow", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "main_workflow", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)))
    catalogueSourceData.toDF.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Execute Spark Run
    val sparkRunParametersJson =
      """{"workflow": "main_workflow",""" +
        """ "process_tasks_constraints": [{"attribute": "location", "value": "HK"}],""" +
        """ "enabled": {"site": ["[$site]"], "exec_type": ["[$exec_type]"]}, """ +  // These 2 lines took reference of the
        """ "site": "HK", "exec_type": "LIQ", """ +                                 // dim_queue.json used in Bug FCCC-11046.
        """ "param_from_spark_run": "col1_value_from_spark_run" }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson).run()

    // Assert the result
    assert(sparkRunResult == Complete)
    assert(spark.table("sub_workflow_result_table1").select("col1").as[String].collect.head == "col1_value_from_spark_run")
    assert(!spark.catalog.tableExists("sub_workflow_result_table2"))
  }
  // Feature/fccc 11435 bug fix for 11220
  "Reuse the same UUID for sub workflow" should
    "workflow uuid equal to sub workflow uuid" in {
    spark.catalog.dropTempView(EmfConfig.processTaskCacheView)
    // Prepare Process Tasks Data
    val mainWorkflowProcessTasksEntityUuid = "a9797a97-44c1-4e4b-ae44-4f444e44a44e"
    val mainWorkflowCommand1Parameters = """{"workflow": "sub_workflow_task", "process_tasks_constraints": [{"attribute": "location", "value": "HK"}]}"""
    val subWorkflowProcessTasksEntityUuid = "99999a9d-be99-99ff-99d9-99f9999a999a"
    val subWorkflowCommand1Parameters = """{"labels":{"exec_type":["FOTC_ADJ_FIRST","RWA_ADJ_FIRST","LIQ"]},""" + // Took ref from Bug FCCC-11046
      """ "query": "select '[$run_uuid]' as col1", "table": "sub_workflow_result_table1", "as_view":true}"""
    val subWorkflowCommand2Parameters = """{"labels":{"exec_type":["FOTC_ADJ_FIRST","RWA_ADJ_FIRST"]},""" + // Took ref from Bug FCCC-11046
      """ "query": "select '[$param_from_spark_run]' as col1", "table": "sub_workflow_result_table2", "as_view":true}"""

    val processTasksSourceData: Seq[ProcessTaskData] = Seq(
      ProcessTaskData("M01", "SPARK-RUN", nullParents, mainWorkflowCommand1Parameters, emptyTopic, mainWorkflowProcessTasksEntityUuid),
      ProcessTaskData("S01", "SPARK-SQL-EVAL", nullParents, subWorkflowCommand1Parameters, emptyTopic, subWorkflowProcessTasksEntityUuid),
      ProcessTaskData("S02", "SPARK-SQL-EVAL", List("S01"), subWorkflowCommand2Parameters, emptyTopic, subWorkflowProcessTasksEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.defaultTablePartition)
      .saveAsTable(s"${EmfConfig.processTasksDatabaseName}.${EmfConfig.defaultTableName}")

    // Prepare corresponding Catalogue Data for the Process Tasks Data
    val catalogueSourceData: Seq[MetadataRaw] = Seq(
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "sub_workflow_task", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(subWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "workflow", "main_workflow_task", "STRING", emptyDomain, Some(nowTimestamp)),
      MetadataRaw(mainWorkflowProcessTasksEntityUuid, processTasksFileType, nowTimestamp,
        "location", "HK", "STRING", emptyDomain, Some(nowTimestamp)))
    catalogueSourceData.toDF.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName}")

    // Execute Spark Run
    val mainWorkflowRunUuid: Option[String] = Some("test-parent-child-uuid")
    val sparkRunParametersJson =
      """{"workflow": "main_workflow_task",""" +
        """ "process_tasks_constraints": [{"attribute": "location", "value": "HK"}],""" +
        """ "enabled": {"site": ["[$site]"], "exec_type": ["[$exec_type]"]}, """ +  // These 2 lines took reference of the
        """ "site": "HK", "exec_type": "LIQ", """ +                                 // dim_queue.json used in Bug FCCC-11046.
        """ "param_from_spark_run": "col1_value_from_spark_run" }"""
    val sparkRunResult = SparkRun(sparkRunParametersJson,parentRunUuid = mainWorkflowRunUuid).run() //new parameter test for parent runuuid

    //Checking for uuid passed to subworkflow, the parent uuid stored in catalog.data table and
    // the child uuid stored in sub_workflow_result_table1. Join two tables and count if result = 1
    val resultDf = spark.sql(
      s"""select parentTable.entity_uuid as parentUuid, childTable.col1 as childUuid
         |from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} as parentTable,
         |sub_workflow_result_table1 as childTable where parentTable.entity_uuid = childTable.col1 and
         |parentTable.entity_uuid = "${mainWorkflowRunUuid.get}" and
         |parentTable.attribute = "${EmfConfig.sparkRunGeneratedParamNameTargetDataset}" and
         |parentTable.file_type = "${EmfConfig.sparkRunCatalogueFileType}"""".stripMargin)

    // Assert the result
    assert(sparkRunResult == Complete)
    assert(resultDf.count() == 1)
  }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.crm.{Approach, STD}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRwaCrmMessage
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.service.crm.SparkCrmService
import org.apache.spark.sql.SparkSession

import scala.util.{Failure, Success, Try}

class SparkRwaCrm(val sourceDataset: String, val sourceTable: String,
                  val targetDataset: String, val targetTable: String,
                  val approach: Approach = STD, val crmReadSql: String)
                 (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand {

  def run(): ExecutionResult = {
    val sparkRwaCrmMessage = SparkRwaCrmMessage(sourceDataset, sourceTable, targetDataset, targetTable, approach, crmReadSql)
    EmfLogger.debug(s"Starting SparkRwaCrm command execution with SparkRwaCrmMessage: $sparkRwaCrmMessage")
    if (messageValidate(sparkRwaCrmMessage)) {
      Try {
        new SparkCrmService().calculate(sparkRwaCrmMessage)
        EmfLogger.debug("SparkRwaCrm command executed successfully")
        Complete
      } match {
        case Success(_) => Complete
        case Failure(exception) =>
          ExceptionHandler.handle(s"SparkRwaCrm command execution failed with error: ${exception.getMessage}",exception)
          Failed
      }

    } else {
      EmfLogger.error(s"SparkRwaCrm command failed with error: Messages Validation failed , Please" +
        s" make sure that sourceDataset, targetDataset, sourceTable, targetTable and crmReadSql should not be empty")
      Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = {
    val msg = message.asInstanceOf[SparkRwaCrmMessage]
    msg.source_dataset != null && msg.source_dataset.trim.nonEmpty &&
      msg.target_dataset != null && msg.target_dataset.trim.nonEmpty &&
      msg.source_table != null && msg.source_table.trim.nonEmpty &&
      msg.target_table != null && msg.target_table.trim.nonEmpty &&
      msg.crm_read_sql != null && msg.crm_read_sql.trim.nonEmpty
  }
}
package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.crm.Approach


case class SparkRwaCrmMessage(source_dataset: String, source_table: String,
                              target_dataset : String, target_table : String,
                              approach: Approach, crm_read_sql: String) extends ISparkCommandMessage
package hsbc.emf.service.crm

import hsbc.emf.data.crm.FOU
import hsbc.emf.data.sparkcmdmsg.SparkRwaCrmMessage
import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.infrastructure.io.readers.CsvFileReaderToDF
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.types.{DoubleType, StringType, StructField, StructType}
import org.apache.spark.sql.{DataFrame, SaveMode}

class SparkRwaCrmSerivceTest extends IntegrationTestSuiteBase {

  val targetDataset: String = "target"
  val sourceDataset: String = "source"

  val outputSchema = StructType(List(
    StructField("Uniq_Account_Id", StringType, true),
    StructField("Uniq_CRM_ID", StringType, true),
    StructField("Undrawn_Flag", StringType, true),
    StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
    StructField("Regulator", StringType, true),
    StructField("PRA_Reporting_Approach_From_CRM_Engine", StringType, true),
    StructField("Adjustment_Flag", StringType, true),
    StructField("Original_Exposure_Covered_USD", DoubleType, true),
    StructField("CbyE_Ratio", DoubleType, true),
    StructField("CRM_Eligible_For_Exposure_Flag", StringType, true),
    StructField("Effective_CRM_Amount_After_Efficiency", DoubleType, true),
    StructField("Effective_CRM_Amount_Allocated_USD", DoubleType, true),
    StructField("Effective_CRM_Amount_Available_USD", DoubleType, true),
    StructField("Original_Exposure_not_covered", DoubleType, true),
    StructField("Comment", StringType, true),
    StructField("Secured_Indicator", StringType, true),
    StructField("Allocation_Order", DoubleType, true)
  ))

  val inputSchema = StructType(List(
    StructField("Unique_Account_Id", StringType, true),
    StructField("Unique_Mitigant_Id", StringType, true),
    StructField("Undrawn_Flag", StringType, true),
    StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
    StructField("Credit_Mitigant_Value", DoubleType, true),
    StructField("Total_Original_Exposure_pre_CCF", DoubleType, true),
    StructField("Effective_CRM_Factor", DoubleType, true),
    StructField("Cstar", DoubleType, true)))

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${targetDataset}")
    spark.sql(s"create database if not exists ${sourceDataset}")
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${targetDataset} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${sourceDataset} CASCADE")
    super.afterAll()
  }

  "given CRM Source data  " should "Calculate the Secured and Unsecured " in {

    val sourceTable: String = "test1"
    val targetTable: String = "target1"

    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 1)
    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/test_case1_data/test_case1.csv", Some(inputSchema))

    inputDF.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${sourceDataset}.${sourceTable}")

    val crmReadSql = s"SELECT  Unique_Account_Id, Unique_Mitigant_Id , Undrawn_Flag, CRM_Priority_Order_Sequence_Number," +
      s"Credit_Mitigant_Value,Total_Original_Exposure_pre_CCF,Effective_CRM_Factor,Cstar" +
      s" FROM [$$dataset].[$$table] "

    val message: SparkRwaCrmMessage = new SparkRwaCrmMessage(sourceDataset, sourceTable, targetDataset, targetTable, FOU, crmReadSql)

    new SparkCrmService().calculate(message)
    val resultDF: DataFrame = spark.sql(s"select * from ${targetDataset}.${targetTable}")

    var expectedOutputDF = spark.read.schema(outputSchema).csv("tests/hsbc/emf/testingFiles/" +
      "spark_crm_mockup_data/test_case1_data/output.csv")

    expectedOutputDF = expectedOutputDF.na.fill(0)

    assert(expectedOutputDF.count() == resultDF.count())

    val colNames = Seq("Uniq_Account_Id", "Uniq_CRM_ID", "Undrawn_Flag", "CRM_Priority_Order_Sequence_Number","Regulator",
      "PRA_Reporting_Approach_From_CRM_Engine", "Adjustment_Flag", "Original_Exposure_Covered_USD", "CbyE_Ratio", "CRM_Eligible_For_Exposure_Flag",
      "Effective_CRM_Amount_After_Efficiency", "Effective_CRM_Amount_Allocated_USD", "Effective_CRM_Amount_Available_USD",
      "Original_Exposure_not_covered", "Comment", "Secured_Indicator", "Allocation_Order")

    val sortedResultDF = resultDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    val sortedExpectedOutputDF = expectedOutputDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    assert(sortedResultDF.except(sortedExpectedOutputDF).isEmpty)
  }
}
package hsbc.emf.command


import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.data.crm.{Approach, FOU, STD}
import hsbc.emf.infrastructure.config.CsvFileFormatConfig
import hsbc.emf.infrastructure.io.readers.CsvFileReaderToDF
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.SaveMode
import org.apache.spark.sql.types.{DoubleType, StringType, StructField, StructType}

class SparkRwaCrmTest extends IntegrationTestSuiteBase {

  val targetDataset: String = "target"
  val sourceDataset: String = "source"

  val outputSchema = StructType(List(
    StructField("Uniq_Account_Id", StringType, true),
    StructField("Uniq_CRM_ID", StringType, true),
    StructField("Undrawn_Flag", StringType, true),
    StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
    StructField("Regulator", StringType, true),
    StructField("PRA_Reporting_Approach_From_CRM_Engine", StringType, true),
    StructField("Adjustment_Flag", StringType, true),
    StructField("Original_Exposure_Covered_USD", DoubleType, true),
    StructField("CbyE_Ratio", DoubleType, true),
    StructField("CRM_Eligible_For_Exposure_Flag", StringType, true),
    StructField("Effective_CRM_Amount_After_Efficiency", DoubleType, true),
    StructField("Effective_CRM_Amount_Allocated_USD", DoubleType, true),
    StructField("Effective_CRM_Amount_Available_USD", DoubleType, true),
    StructField("Original_Exposure_not_covered", DoubleType, true),
    StructField("Comment", StringType, true),
    StructField("Secured_Indicator", StringType, true),
    StructField("Allocation_Order", DoubleType, true)
  ))

  val inputSchema = StructType(List(
    StructField("Unique_Account_Id", StringType, true),
    StructField("Unique_Mitigant_Id", StringType, true),
    StructField("Undrawn_Flag", StringType, true),
    StructField("CRM_Priority_Order_Sequence_Number", StringType, true),
    StructField("Credit_Mitigant_Value", DoubleType, true),
    StructField("Total_Original_Exposure_pre_CCF", DoubleType, true),
    StructField("Effective_CRM_Factor", DoubleType, true),
    StructField("Cstar", DoubleType, true)))

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${targetDataset}")
    spark.sql(s"create database if not exists ${sourceDataset}")
  }

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS ${targetDataset} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${sourceDataset} CASCADE")
    super.afterAll()
  }

  "given valid inputs in SparkRwaCrm command " should "return Complete " in {

    val sourceTable: String = "test1"
    val targetTable: String = "target1"

    val config = CsvFileFormatConfig(delimiter = ",", skipRows = 1)
    val inputDF = new CsvFileReaderToDF().read(config, s"tests/hsbc/emf/testingFiles/" +
      s"spark_crm_mockup_data/test_case1_data/test_case1.csv", Some(inputSchema))

    inputDF.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${sourceDataset}.${sourceTable}")
    val crmReadSql = s"SELECT  Unique_Account_Id, Unique_Mitigant_Id , Undrawn_Flag, CRM_Priority_Order_Sequence_Number," +
      s"Credit_Mitigant_Value,Total_Original_Exposure_pre_CCF,Effective_CRM_Factor,Cstar" +
      s" FROM [$$dataset].[$$table] "

    val execResult = new SparkRwaCrm(sourceDataset, sourceTable, targetDataset, targetTable, FOU, crmReadSql).run()

    val resultDF = spark.sql(s"select * from ${targetDataset}.${targetTable}")
    assert(execResult == Complete)

    var expectedOutputDF = spark.read.schema(outputSchema).csv("tests/hsbc/emf/testingFiles/" +
      "spark_crm_mockup_data/test_case1_data/output.csv")
    expectedOutputDF = expectedOutputDF.na.fill(0)

    assert(expectedOutputDF.count() == resultDF.count())
    
    val colNames = Seq("Uniq_Account_Id", "Uniq_CRM_ID", "Undrawn_Flag", "CRM_Priority_Order_Sequence_Number",
      "Regulator", "PRA_Reporting_Approach_From_CRM_Engine", "Adjustment_Flag", "Original_Exposure_Covered_USD",
      "CbyE_Ratio", "CRM_Eligible_For_Exposure_Flag", "Effective_CRM_Amount_After_Efficiency",
      "Effective_CRM_Amount_Allocated_USD", "Effective_CRM_Amount_Available_USD", "Original_Exposure_not_covered",
      "Comment", "Secured_Indicator", "Allocation_Order")

    val sortedResultDF = resultDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    val sortedExpectedOutputDF = expectedOutputDF.select(colNames.head, colNames.tail: _*).orderBy(colNames.head, colNames.tail: _*)
    assert(sortedResultDF.except(sortedExpectedOutputDF).isEmpty)
  }


  "given invalid inputs in SparkRwaCrm command " should "return Failed " in {
    val sourceTable: String = "test2"
    val targetTable: String = "target2"
    val approach: Approach = STD

    val crmreadsql = s""

    val execResult = new SparkRwaCrm(sourceDataset, sourceTable, targetDataset, targetTable, approach, crmreadsql).run()
    assert(execResult == Failed)
  }


}
package hsbc.emf.infrastructure.spark

import org.apache.spark.sql.SparkSession

trait SparkSessionWrapper {

  implicit val spark: SparkSession

  private val masterUrl = System.getProperty("SparkMasterUrl", "local")

  def createSparkSession(applicationName: String): SparkSession = {
    val session = SparkSession.builder()
      .master(masterUrl)
      .appName(applicationName)
      .enableHiveSupport.getOrCreate
    session
  }

}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkSqlEvalMessage
import hsbc.emf.data.sqleval.{WriteAppend, WriteDisposition}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.sqleval.SparkSqlEvalService

import org.apache.spark.sql.SparkSession

class SparkSqlEval(val query: String,
                   val table: String,
                   val writeDisposition: WriteDisposition = WriteAppend,
                   val asView: Boolean = false,
                   val dataset: Option[String] = None)
                  (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {
  def run(): ExecutionResult = {
    Try {
      EmfLogger.debug("SparkSqlEval.RUN query: " + query)

      val dsName: Option[String] = checkAndUpdateDataset()
      val sparkSqlEvalMsg = SparkSqlEvalMessage(query, table, writeDisposition, asView, dsName)
      new SparkSqlEvalService(new SqlExecutor()).sqlEval(sparkSqlEvalMsg)
      EmfLogger.info(s"SparkSqlEval command executed successfully and the result of Query: $query " +
        s"is saved to Table: $table with inputs as_view: $asView, write_disposition: $writeDisposition, dataset: $dsName")
    } match {
      case Success(_) => Complete
      case Failure(exception) => {
        ExceptionHandler.handle("SparkSqlEval command execution failed", exception)
        Failed
      }
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true

  private def checkAndUpdateDataset(): Option[String] = {
    if (!asView && dataset.isEmpty)
      try {
        Some(placeholderParams.format(s"${EmfConfig.sparkRunGeneratedParamNameTargetDataset}"))
      }
      catch {
        case ex: Exception =>
          EmfLogger.error(s"Failed to lookup target_dataset from " +
            s"placeholderParams for the case that asView is false and dataset is omitted ")
          throw ex
      }
    else
      dataset

  }

}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.sqleval.{WriteDisposition, WriteAppend}

case class SparkSqlEvalMessage(query: String, table: String,
                               write_disposition : WriteDisposition = WriteAppend, as_view: Boolean = false,
                                dataset: Option[String] = None
                              ) extends ISparkCommandMessage

package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.data.sqleval.WriteAppend
import hsbc.emf.infrastructure.helper.JsonReader
import org.scalatest.FlatSpec

class SparkSqlEvalMessageTest extends FlatSpec {

  "given json with required fields" should "return message object" in {

    val params = """{"query" : "SQLQuery1", "table": "testTable1", "as_view":true}"""

    val sparkSqlEvalMessage = JsonReader.deserialize[SparkSqlEvalMessage](params).right.get
    assert(sparkSqlEvalMessage.isInstanceOf[SparkSqlEvalMessage])

    //Optional parameters, values not passed in json and default values are set
    assert(sparkSqlEvalMessage.as_view.equals(true))
    assert(sparkSqlEvalMessage.write_disposition.equals(WriteAppend))
    assert(sparkSqlEvalMessage.dataset.equals(None))
  }

  "given json with all fields" should "return message object" in {

    val params = """{"query" : "SQLQuery2", "table": "testTable2","as_view":false,"writeDisposition":"write_append","dataset":"exampleDS1"}"""

    val sparkSqlEvalMessage = JsonReader.deserialize[SparkSqlEvalMessage](params).right.get
    assert(sparkSqlEvalMessage.isInstanceOf[SparkSqlEvalMessage])

    assert(sparkSqlEvalMessage.query.equals("SQLQuery2"))
    assert(sparkSqlEvalMessage.table.equals("testTable2"))
    assert(sparkSqlEvalMessage.as_view.equals(false))
    assert(sparkSqlEvalMessage.write_disposition.equals(WriteAppend))
    assert(sparkSqlEvalMessage.dataset.equals(Some("exampleDS1")))
  }

}
package hsbc.emf.service.sqleval

import scala.collection.mutable.ListBuffer
import scala.util.{Failure, Success, Try}

import hsbc.emf.data.logging._
import hsbc.emf.data.sparkcmdmsg._
import hsbc.emf.data.sqleval.WriteAppend
import hsbc.emf.infrastructure.config.{EmfConfig, OrcFileFormatConfig}
import hsbc.emf.infrastructure.exception.{EmfAssertEvaluationException, EmfInvalidInputException, EmfServiceException}
import hsbc.emf.infrastructure.helper.{CloudTypeUtils, HelperUtility, HiveUtils}
import hsbc.emf.infrastructure.io.readers.TextFileReaderToString
import hsbc.emf.infrastructure.io.writers.DataFrameWriterService
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.{AssertInfo, AuditLogger}
import hsbc.emf.infrastructure.sql.ISqlExecutor

import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}
import org.apache.spark.sql.functions._

class SparkSqlEvalService(sqlExecutor: ISqlExecutor)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkSqlEvalService with MessageContext {
  @throws(classOf[EmfServiceException])
  override def sqlEval(msg: SparkSqlEvalMessage): Unit = {
    if (checkForEmptyTable(msg.query)) {

      msg.write_disposition match {
        case WriteAppend => {
          msg.as_view match {
            case true =>
              HiveUtils.checkTableInCatalogue(msg.table) match {
                case true =>
                  spark.table(s"${msg.table}").union(sqlExecutor.execute(msg.query)).createOrReplaceTempView(msg.table)
                case false =>
                  sqlExecutor.execute(msg.query).createOrReplaceTempView(msg.table)
                  spark.catalog.cacheTable(msg.table)
              }
            case false =>
              val df = sqlExecutor.execute(msg.query)
              saveResultToTargetTable(df, msg.table, msg.dataset, SaveMode.Append)
          }
        }
        case _ => {
          msg.as_view match {
            case true => {
              sqlExecutor.execute(msg.query).createOrReplaceTempView(msg.table)
              spark.catalog.cacheTable(msg.table)
            }
            case false => {
              val df = sqlExecutor.execute(msg.query)
              saveResultToTargetTable(df, msg.table, msg.dataset, SaveMode.Overwrite)
            }
          }
        }
      }
    }
  }

  private def saveResultToTargetTable(resultDF: DataFrame, table: String, dataset: Option[String], saveMode: SaveMode): Unit = {
    val dfWriter = new DataFrameWriterService(OrcFileFormatConfig())
    val fullTableName = s"${dataset.getOrElse("default")}.${table}"
    if (spark.catalog.tableExists(dataset.getOrElse("default"), table)) {
      // FCCC- 11875 : to fix the issue 412/404 (parallel write) error in GCP/Azure, add extra partitioned column x__uuid to resulting dataframe.
      if (spark.table(fullTableName).columns.contains(EmfConfig.runtime_uuid_column)) {
        val updatedDF = resultDF.withColumn(EmfConfig.runtime_uuid_column, lit(HelperUtility.generateRunUUID()))
        dfWriter.saveDFAsTable(updatedDF, table, dataset, saveMode, List(EmfConfig.runtime_uuid_column), None, Some(true))
      } else {
        if (resultDF.columns.contains(EmfConfig.runtime_uuid_column)) {
          val updatedDF = resultDF.drop(EmfConfig.runtime_uuid_column)
          dfWriter.saveDFAsTable(updatedDF, table, dataset, saveMode, List.empty[String], None, Some(true))
        } else {
          dfWriter.saveDFAsTable(resultDF, table, dataset, saveMode, List.empty[String], None, Some(true))
        }
      }
    } else {
      val updatedDF = resultDF.withColumn(EmfConfig.runtime_uuid_column, lit(HelperUtility.generateRunUUID()))
      dfWriter.saveDFAsTable(updatedDF, table, dataset, saveMode, List(EmfConfig.runtime_uuid_column), None, Some(true))
    }
    spark.catalog.cacheTable(fullTableName)
  }

  private def checkForEmptyTable(query: String): Boolean = {
    val res = sqlExecutor.execute(query)
    if (res.columns.size > 0)
      return true
    else {
      EmfLogger.warn("Output of Query contains no results, hence returning")
      return false
    }
  }

  @throws(classOf[EmfServiceException])
  def sqlFromFile(msg: SparkSqlFromFileMessage): String = {
    val sqlQuery = new TextFileReaderToString().read(
      s"${CloudTypeUtils.prependFsProtocol(msg.bucket, EmfConfig.cloudType)}/${msg.file_name}")
    sqlQuery
  }

  @throws(classOf[EmfServiceException])
  @throws(classOf[EmfInvalidInputException])
  override def evalQueryToGetMessageDetails(message: SparkMessagesFromQueryMessage): List[SparkSqlEvalMessage] = {
    val dataFrame = sqlExecutor.execute(message.query)
    val listOfSparkSqlEvalMessage = new ListBuffer[SparkSqlEvalMessage]()
    if (dataFrame.columns.length >= 2) {
      if (!dataFrame.isEmpty) {
        val dataFrameWithFirst2Columns = dataFrame.selectExpr(dataFrame.columns.take(2): _*)
        dataFrameWithFirst2Columns.collect().foreach {
          row =>
            listOfSparkSqlEvalMessage += SparkSqlEvalMessage(row.getString(0), row.getString(1), message.write_disposition, message.as_view, message.target_dataset)
        }
        listOfSparkSqlEvalMessage.toList
      }
      else {
        EmfLogger.warn(s"Output of Query - ${message.query} is empty.")
        List.empty
      }
    }
    else {
      EmfLogger.error(s"Output of Query - ${message.query} contains only ${dataFrame.columns.length} column," +
        s" however minimum number of required columns are 2")
      throw EmfInvalidInputException(s"Output of Query - ${message.query} contains only ${dataFrame.columns.length} column," +
        s" however minimum number of required columns are 2")
    }
  }

  override def sqlAssert(message: SparkAssertMessage): Boolean = {

    val level = Try {
      Severity(message.log_level)
    } match {
      case Success(value) => value
      case Failure(e) => throw new EmfAssertEvaluationException("Assert Evaluation Error", e)
    }

    val dfRowCountIsOneAndAssertionResult: Boolean = Try(sqlExecutor.execute(message.assertion)) match {
      // query returns a df of size one and with a first column of type boolean
      case Success(df) => Try(df.take(2).map {
        _.getBoolean(0)
      }) match {
        case Success(a) => a.length == 1 && a(0) == true
        case Failure(e) =>
          EmfLogger.error(s"sqlAssert with query '${message.assertion}' failed. first Column is not a boolean ${e.getMessage}. Message was ${message.message}")
          throw new EmfAssertEvaluationException(s"sqlAssert with query '${message.assertion}' failed. First Column is not a boolean", e)
      }
      case Failure(e) =>
        EmfLogger.error(s"sqlAssert with query '${message.assertion}' failed with error ${e.getMessage} Message was ${message.message}")
        throw new EmfAssertEvaluationException(s"sqlAssert with query '${message.assertion}' failed", e)
    }

    if (dfRowCountIsOneAndAssertionResult)
      EmfLogger.log(level)(s"Assertion Passed. '${message.message}'")
    else
      EmfLogger.log(level)(s"Assertion Failed. '${message.message}'")

    //Audit AssertInfo
    val assertInfo = AssertInfo(messageInfo, message.assertion, dfRowCountIsOneAndAssertionResult, message.message, message.log_level)
    AuditLogger().audit[AssertInfo](assertInfo)

    (dfRowCountIsOneAndAssertionResult, Seq("fatal", "error").contains(message.log_level)) match {
      //if both failure and >critical then false
      case (false, true) =>
        EmfLogger.error(s"sqlAssert with query '${message.assertion}' failed. Message was ${message.message}")
        false
      //if not critical or error return true
      case _ =>
        EmfLogger.debug(s"sqlAssert with query '${message.assertion}' executed successfully. Message was ${message.message}")
        true
    }

  }
}package hsbc.emf.service.sqleval

import hsbc.emf.data.sparkcmdmsg.{SparkAssertMessage, SparkMessagesFromQueryMessage, SparkSqlEvalMessage, SparkSqlFromFileMessage}
import hsbc.emf.infrastructure.exception.{EmfInvalidInputException, EmfSqlAnalysisException}
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.TableUtils
import hsbc.emf.sparkutils.{IntegrationTestSuiteBase}
import org.apache.hadoop.mapred.InvalidInputException
import org.scalatest.FlatSpec
import org.apache.spark.sql.Row
import org.apache.spark.sql.types.{StringType, StructField, StructType}

class SparkSqlEvalServiceTest extends FlatSpec with IntegrationTestSuiteBase {

  import spark.implicits._

  "given an sql query for unknown table" should "return exception" in {
    val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
    val sparkSqlEvalMsg = SparkSqlEvalMessage("select * from unknowtable", "unknowntable")
    // assertion for exception
    val caught = intercept[EmfSqlAnalysisException] {
      sparkSqlEvalService.sqlEval(sparkSqlEvalMsg)
    }
    assert(caught.getMessage.toLowerCase.contains("table or view not found"))
  }

  "create work flow test cache" should "return single row" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_1")
    val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
    sparkSqlEvalService.sqlEval(SparkSqlEvalMessage("select * from test_temp_1", "test_temp_cache", as_view = true))
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from test_temp_cache")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "given SparkSqlEvalMessage returning empty frame" should "return" in {
    val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
    sparkSqlEvalService.sqlEval(SparkSqlEvalMessage("CREATE TABLE IF NOT EXISTS re_source_pairs (source_pairs STRING)",  "testTableEmpty1"))
    val sqlExec = new SqlExecutor()
    val caught = intercept[EmfSqlAnalysisException] {
      sqlExec.execute("select * from testTableEmpty1")
    }
    assert(caught.getMessage.toLowerCase.contains("table or view not found"))
  }

  "given valid file" should "return query string" in {
    val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
    val sqlQuery = sparkSqlEvalService.sqlFromFile(SparkSqlFromFileMessage("tests/hsbc/emf/testingFiles", "test_sql_1.text", "test_temp_cache_2"))
    assert(sqlQuery == "select * from test_temp_2")
  }

  "given invalid file" should "throw exception InvalidInputException" in {
    val caught = intercept[InvalidInputException] {
      val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
      sparkSqlEvalService.sqlFromFile(SparkSqlFromFileMessage("tests/hsbc/emf/testingFiles", "non-existing-file", "test_temp_cache_2"))
    }
    assert(caught.getMessage.toLowerCase.contains("input path does not exist"))

  }

  "given a valid SparkMessagesFromQueryMessage object, output of query containing at least 2 columns to" +
    "evalQueryToGetMessageDetails" should "return List of SparkSqlEvalMessage" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": "1"}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("testing_table")

    val sampleData = Seq(("select key,value from testing_table", "test_table_1"), ("select * from testing_table", "test_table_2"))
    val df1 = sampleData.toDF("y", "x")
    df1.write.mode("overwrite").saveAsTable("finalize_table")

    val listOfSparkSqlEvalMsg = new SparkSqlEvalService(new SqlExecutor())
      .evalQueryToGetMessageDetails(SparkMessagesFromQueryMessage("select * from finalize_table"))

    val actual = List(SparkSqlEvalMessage("select key,value from testing_table", "test_table_1"),
      SparkSqlEvalMessage("select * from testing_table", "test_table_2"))

    assert(listOfSparkSqlEvalMsg.equals(actual))
  }


  "given an invalid SparkMessagesFromQueryMessage object, output of query containing 2 columns but empty to " +
    "evalQueryToGetMessageDetails" should "return empty List of SparkSqlEvalMessage, and not throw excpetion" in {

    val schema = StructType(List(StructField("a", StringType), StructField("b", StringType)))
    val emptyDF = spark.createDataFrame(spark.sparkContext.emptyRDD[Row], schema)
    emptyDF.write.mode("overwrite").saveAsTable("testing_table")

    val listOfSparkSqlEvalMsg = new SparkSqlEvalService(new SqlExecutor()).evalQueryToGetMessageDetails(SparkMessagesFromQueryMessage("select * from testing_table"))
    assert(listOfSparkSqlEvalMsg.equals(List.empty))
  }


  "given an invalid SparkMessagesFromQueryMessage object, output of query containing less than 2 columns to" +
    "evalQueryToGetMessageDetails" should "return EmfInvalidInputException" in {
    import spark.implicits._
    val sample = """{"key" : "a", "value": "1"}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_table")

    val sampleData = Seq("select key,value from test_table", "select * from test_table")

    val df1 = sampleData.toDF("y")

    df1.write.mode("overwrite").saveAsTable("final_table")
    val caught = intercept[EmfInvalidInputException] {
      new SparkSqlEvalService(new SqlExecutor()).evalQueryToGetMessageDetails(SparkMessagesFromQueryMessage("select * from final_table"))
    }
    assert(!caught.getMessage.isEmpty)
    assert(caught.getMessage.contains("minimum number of required columns are 2"))
  }

  "sqlAssert(), if the sql query fails and throws an exception" should "re-throw the execption" in {
    val tableName = "sqlAsserTestTabe"
    val testQuery = s"select _col1 from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "debug")

    assertThrows[Exception](new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message))
  }

  "sqlAssert(), if the first column of the returned dataframe is not a boolean." should "re-throw the execption" in {
    val tableName = TableUtils.createTable(Seq((1.0, 1, "something")))
    val testQuery = s"select * from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "debug")

    assertThrows[Exception](new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message))
  }

  "sqlAssert(),If the log_level is \"error\" and dataframe has number of rows not equal to one," should "return false" in {
    val tableName = TableUtils.createTable((Seq((false, 1, "something"), (true, 1, "somethingElse"))))
    val testQuery = s"select * from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "error")

    assert((new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message)) == false)
  }

  "sqlAssert(),If the log_level is in \"debug\", \"info\", \"warning\",  and dataframe has number of rows not equal to one," should "return true" in {
    val tableName = TableUtils.createTable(Seq((false, 1, "something"), (true, 1, "somethingElse")))
    val testQuery = s"select * from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "info")

    assert((new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message)) == true)
  }

  "run(),in other circumstances" should "return true" in {
    val tableName = TableUtils.createTable(Seq((false, 1, "something")))
    val testQuery = s"select * from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "info")

    assert((new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message)) == true)
  }

  "run(),If the log_level is \"fatal\", and has value false," should "return false" in {
    val tableName = TableUtils.createTable(Seq((false, 1, "something")))
    val testQuery = s"select * from $tableName"
    val message = new SparkAssertMessage(testQuery, "some log message", "fatal")

    assert((new SparkSqlEvalService(new SqlExecutor()).sqlAssert(message)) == false)
  }
}package hsbc.emf.command

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.sqleval.{WriteAppend, WriteTruncate}
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class SparkSqlEvalTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  override def beforeAll(): Unit = {
    super.beforeAll()
    spark.sql(s"create database if not exists exampleDB")
  }

  override def afterEach(): Unit = {
    super.afterEach()
    spark.sql("drop table if exists test_temp_2")
    spark.sql("drop table if exists test_table1")
  }

  override def afterAll(): Unit = {
    spark.sql(s"drop database if exists exampleDB cascade")
    super.afterAll()
  }

  "non existing table query in command" should "return failed" in {
    val execResult = new SparkSqlEval("select * from hello", "hello_cache", asView = true).run()
    assert(execResult == Failed)
  }

  "spark sql eval with valid table " should "return single row" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val execResult = new SparkSqlEval("select * from test_temp_2", "test_temp_2_cache", asView = true).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from test_temp_2_cache")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "spark sql eval with existing table, as_view is true and write_append, " should "return two rows" in {

    // data set up
    val sample1 =
      """{"key" : "key1", "value": 1}"""
    val df = spark.read.json(Seq(sample1).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")

    // existing table
    val sample2 =
      """{"key" : "key2", "value": 2}"""
    val df2 = spark.read.json(Seq(sample2).toDS())
    df2.write.mode("overwrite").saveAsTable("test_table1")

    val execResult = new SparkSqlEval("select * from test_temp_2", "test_table1", WriteAppend, asView = true).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from test_table1")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 2)

    assert(spark.catalog.listTables("default").filter(row => row.name == "test_table1" && row.isTemporary).count() == 1)
  }

  "spark sql eval with as_view is false and write_append, " should "return complete" in {

    // data set up
    val sample1 =
      """{"key" : "key1", "value": 1}"""
    val df = spark.read.json(Seq(sample1).toDS())
    df.write.format("hive").mode("overwrite").saveAsTable("test_temp_2")


    // existing table
    val sample2 =
      """{"key" : "key2", "value": 2}"""
    val df2 = spark.read.json(Seq(sample2).toDS())
    df2.write.format("hive").mode("overwrite").saveAsTable("exampleDB.test_table2")

    val execResult = new SparkSqlEval("select * from test_temp_2", "test_table2", WriteAppend, asView = false,  Some("exampleDB")).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from exampleDB.test_table2")
    val content = dfCache.as[(String, BigInt)].collect.toMap

    assert(content.size == 2)
    assert(content("key1") == 1)
    assert(content("key2") == 2)
  }

  "spark sql eval with as_view is false and write_truncate, " should "return complete" in {


    // data set up
    val preSample =
        """{"key" : "key1", "value": 1}"""
    val preDf = spark.read.json(Seq(preSample).toDS())
    preDf.write.format("hive").mode("overwrite").saveAsTable("exampleDB.test_table3")

    val sample1 =
      """{"key" : "key1", "value": 1}"""
    val df = spark.read.json(Seq(sample1).toDS())
    df.write.format("hive").mode("overwrite").saveAsTable("test_temp_2")

    val execResult = new SparkSqlEval("select * from test_temp_2", "test_table3", WriteTruncate, asView = false,  Some("exampleDB")).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from exampleDB.test_table3")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("key1") == 1)
    assert(dfCache.except(df).isEmpty)
  }

  "spark sql eval with as_view is false,write_truncate and Dataset to None " should "return Failed" in {

    // data set up
    val sample1 =
      """{"key" : "key1", "value": 1}"""
    val df = spark.read.json(Seq(sample1).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")

    val execResult = new SparkSqlEval("select * from test_temp_2", "test_table3", WriteTruncate, asView = false, None).run()
    assert(execResult == Failed)
  }

  "SparkSqlEval" should s"be given a SparkSession with ${EmfConfig.sparkConfSqlCrossJoinEnabledName} " +
    s"spark conf as ${EmfConfig.sparkConfSqlCrossJoinEnabledValue}" in {
    // the implicit val spark being asserted will be used by the SparkSqlEval constructor
    assert(spark.sparkContext.getConf.get(EmfConfig.sparkConfSqlCrossJoinEnabledName) == EmfConfig.sparkConfSqlCrossJoinEnabledValue)
    assert(new SparkSqlEval("select * from hello", "hello_cache").run() == Failed)  // Failed because non-exist table
  }

  "given spark sql eval with query resulting empty " should "return complete" in {
    val execResult1: ExecutionResult = (new SparkSqlEval("CREATE TABLE IF NOT EXISTS re_source_pairs (source_pairs STRING)",  "testTable-Empty1", WriteAppend,asView = false, Some("exampleDB"))).run()
    assert(execResult1 == Complete)
    val execResult2: ExecutionResult = (new SparkSqlEval("CREATE TABLE IF NOT EXISTS re_source_pairs (source_pairs STRING)",  "testTable2-Empty2", WriteTruncate,asView = false,Some("exampleDB") )).run()
    assert(execResult2 == Complete)
    val execResult3: ExecutionResult = (new SparkSqlEval("CREATE TABLE IF NOT EXISTS re_source_pairs (source_pairs STRING)", "testTable2-Empty3", WriteAppend,asView = true, Some("exampleDB"))).run()
    assert(execResult3 == Complete)
    val execResult4: ExecutionResult = (new SparkSqlEval("CREATE TABLE IF NOT EXISTS re_source_pairs (source_pairs STRING)",  "testTable2-Empty4", WriteTruncate,asView = true, Some("exampleDB"))).run()
    assert(execResult4 == Complete)
  }

}package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkSqlFromFileMessage
import hsbc.emf.data.sqleval.{WriteAppend, WriteDisposition}
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.sqleval.SparkSqlEvalService

import org.apache.spark.sql.SparkSession

class SparkSqlFromFile(val bucket: String,
                       val fileName: String,
                       val targetTable: String,
                       val targetDataset: Option[String] = None,
                       val asView: Boolean = false,
                       val writeDisposition: WriteDisposition = WriteAppend)
                      (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand with MessageContext {

  def run(): ExecutionResult = {
    Try {
      val sparkSqlFileMsg = SparkSqlFromFileMessage(bucket, fileName, targetTable, targetDataset, asView, writeDisposition)
      if (!this.messageValidate(sparkSqlFileMsg)) {
        Failed
      } else {
        val sparkSqlEvalService = new SparkSqlEvalService(new SqlExecutor())
        val sqlQuery = PlaceholderParameterisation.insertParams(placeholderParams, sparkSqlEvalService.sqlFromFile(sparkSqlFileMsg))
        val sparkSqlEval = new SparkSqlEval(sqlQuery, targetTable, writeDisposition, asView, targetDataset)
        sparkSqlEval.placeholderParams = placeholderParams
        sparkSqlEval.run() match {
          case Complete =>
            EmfLogger.info("SparkSqlFromFile command executed successfully")
            Complete
          case _ => Failed
        } // use the ExecutionResult of sparkSqlEval.run() as the method return value
      }
    } match {
      case Success(executionResult) => executionResult
      case Failure(exception) => {
        ExceptionHandler.handle("SparkSqlFromFile command execution failed", exception)
        Failed
      }
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage
import hsbc.emf.data.sqleval.{WriteDisposition, WriteAppend, WriteTruncate}

case class SparkSqlFromFileMessage(bucket: String, file_name: String, target_table: String,
                                   target_dataset: Option[String] = None, as_view: Boolean = false,
                                   write_disposition: WriteDisposition = WriteAppend
                                  ) extends ISparkCommandMessagepackage hsbc.emf.data.sparkcmdmsg

import hsbc.emf.data.sqleval.WriteAppend
import hsbc.emf.infrastructure.helper.JsonReader
import org.scalatest.FlatSpec

class SparkSqlFromFileMessageTest extends FlatSpec {

  "given json with required fields" should "return message object" in {

    val params = """{"bucket" : "bucket2", "file_name": "file2", "target_table": "testTable2", "as_view":true}"""

    val sparkSqlFromFileMessage = JsonReader.deserialize[SparkSqlFromFileMessage](params).right.get
    assert(sparkSqlFromFileMessage.isInstanceOf[SparkSqlFromFileMessage])

    //Optional parameters, values not passed in json and default values are set
    assert(sparkSqlFromFileMessage.as_view.equals(true))
    assert(sparkSqlFromFileMessage.write_disposition.equals(WriteAppend))
    assert(sparkSqlFromFileMessage.target_dataset.equals(None))
  }

  "given json with all fields" should "return message object" in {

    val params = """{"bucket" : "bucket2", "file_name": "file2", "target_table": "testTable2", "as_view":false, "writeDisposition":"write_append", "target_dataset":"exampleDS1"}"""

    val sparkSqlFromFileMessage = JsonReader.deserialize[SparkSqlFromFileMessage](params).right.get
    assert(sparkSqlFromFileMessage.isInstanceOf[SparkSqlFromFileMessage])

    assert(sparkSqlFromFileMessage.bucket.equals("bucket2"))
    assert(sparkSqlFromFileMessage.file_name.equals("file2"))
    assert(sparkSqlFromFileMessage.target_table.equals("testTable2"))
    assert(sparkSqlFromFileMessage.as_view.equals(false))
    assert(sparkSqlFromFileMessage.write_disposition.equals(WriteAppend))
    assert(sparkSqlFromFileMessage.target_dataset.equals(Some("exampleDS1")))
  }

}
package hsbc.emf.command

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.data.sqleval.{WriteAppend, WriteTruncate}
import hsbc.emf.infrastructure.sql.SqlExecutor

class SparkSqlFromFileTest extends IntegrationTestSuiteBase {

  val file_path = "tests/hsbc/emf/testingFiles/"
  import spark.implicits._

  override def afterAll(): Unit = {
    spark.sql(s"DROP DATABASE IF EXISTS exampleDB CASCADE")
    super.afterAll()
  }

  "given spark sql eval with valid table " should "return single row" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val targetTable = "test_temp_cache_3"
    val execResult: ExecutionResult = (new SparkSqlFromFile(storageLocation, fileName, targetTable, asView = true)).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from test_temp_cache_3")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  //
  "given spark sql eval with valid inputs as_view is false and write_disposition is write_truncate " should "return Complete" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val execResult: ExecutionResult = (new SparkSqlFromFile(storageLocation, fileName, "testTable1", Some("exampleDB"), asView = false, WriteTruncate)).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select key,value from exampleDB.testTable1")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "given spark sql eval with valid inputs as_view is true and write_disposition is write_truncate " should "return Complete" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val execResult: ExecutionResult = (new SparkSqlFromFile(storageLocation, fileName, "testTable2", Some("exampleDB"), true, WriteTruncate)).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from testTable2")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "given spark sql eval with valid inputs as_view is false and write_disposition is write_append " should "return Complete" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val execResult: ExecutionResult = (new SparkSqlFromFile(storageLocation, fileName, "testTable3", Some("exampleDB"), false, WriteAppend)).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select key,value from exampleDB.testTable3")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "given spark sql eval with valid inputs as_view is true and write_disposition is write_append " should "return Complete" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val execResult: ExecutionResult = (new SparkSqlFromFile(storageLocation, fileName, "testTable4", Some("exampleDB"), true,  WriteAppend)).run()
    assert(execResult == Complete)
    val sqlExec = new SqlExecutor()
    val dfCache = sqlExec.execute("select * from testTable4")
    val content = dfCache.as[(String, BigInt)].collect.toMap
    assert(content.size == 1)
    assert(content("a") == 1)
  }

  "given spark sql eval with invalid inputs as_view is flase,write_disposition is write_append and dataset is None" should "return Failed" in {
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_temp_2")
    val storageLocation = s"$file_path"
    val fileName = "test_sql_1.text"
    val execResult: ExecutionResult = new SparkSqlFromFile(storageLocation, fileName, "testTable4", None, false,  WriteAppend).run()
    assert(execResult == Failed)
  }

  "given spark sql eval with query resulting empty " should "return complete" in {

    val fileName = "sql_from_file_testing_nodata.text"

    val execResult1: ExecutionResult = (new SparkSqlFromFile("tests/hsbc/emf/testingFiles/service/orchestration", fileName, "testTable-Empty1", Some("exampleDB"),asView = false,WriteAppend )).run()
    assert(execResult1 == Complete)
    val execResult2: ExecutionResult = (new SparkSqlFromFile("tests/hsbc/emf/testingFiles/service/orchestration", fileName, "testTable2-Empty2", Some("exampleDB"),asView = false,WriteTruncate )).run()
    assert(execResult2 == Complete)
    val execResult3: ExecutionResult = (new SparkSqlFromFile("tests/hsbc/emf/testingFiles/service/orchestration", fileName, "testTable2-Empty3", Some("exampleDB"),asView = true,WriteAppend )).run()
    assert(execResult3 == Complete)
    val execResult4: ExecutionResult = (new SparkSqlFromFile("tests/hsbc/emf/testingFiles/service/orchestration", fileName, "testTable2-Empty4", Some("exampleDB"),asView = true,WriteTruncate )).run()
    assert(execResult4 == Complete)
  }
}
package hsbc.emf.command

import scala.util.{Failure, Success, Try}

import hsbc.emf.constants.{Complete, ExecutionResult, Failed}
import hsbc.emf.dao.ingestion.LoadInfoDAO
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkTriggerMessage
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.logging.audit.ExceptionHandler
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.trigger.SparkTriggerService

import org.apache.spark.sql.SparkSession

class SparkTrigger(val bucketCfs: String, val filePathInput: String)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkCommand {

  def run(): ExecutionResult = {
    Try {
      val sparkTriggerMessage = SparkTriggerMessage(bucketCfs, filePathInput)
      new SparkTriggerService(new LoadInfoDAO(new SqlExecutor())).trigger(sparkTriggerMessage)
      EmfLogger.debug(s"SparkTrigger command executed successfully for file(s) landed: $bucketCfs/$filePathInput")
    } match {
      case Success(_) => Complete
      case Failure(ex) =>
        ExceptionHandler.handle("SparkTrigger command execution failed", ex)
        Failed
    }
  }

  def messageValidate(message: ISparkCommandMessage): Boolean = true
}package hsbc.emf.data.sparkcmdmsg

import hsbc.emf.command.ISparkCommandMessage

case class SparkTriggerMessage(bucketCfs: String, filePathInput: String) extends ISparkCommandMessagepackage hsbc.emf.service.trigger

import hsbc.emf.command.SparkRun
import hsbc.emf.constants.{Complete, Failed}
import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.{LoadInfo, MetadataEntry}
import hsbc.emf.data.logging._
import hsbc.emf.data.sparkcmdmsg.{SparkIngestMessage, SparkTriggerMessage}
import hsbc.emf.infrastructure.config.{CsvFileFormatConfig, EmfConfig, JsonFileFormatConfig, MetaDataTextFileFormatConfig}
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, EmfLoadInfoException, SparkTriggerServiceException}
import hsbc.emf.infrastructure.helper._
import hsbc.emf.infrastructure.helper.SchemaUtility.mapStructType
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.io.readers.SparkFileReaderService
import hsbc.emf.infrastructure.logging.EmfLogger
import hsbc.emf.infrastructure.logging.audit._
import hsbc.emf.service.ingestion.{SparkCatalougeService, SparkCuratedStorageService, SparkIngestService}

import org.apache.spark.sql.{DataFrame, SparkSession}
import org.apache.spark.sql.types.StructType

class SparkTriggerService(loadInfoDAO: ILoadInfoDAO)(implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends ISparkTriggerService {

  def trigger(message: SparkTriggerMessage): Unit = {
    try {
      val fileLocation = s"${
        CloudTypeUtils.prependFsProtocol(
          message.bucketCfs, EmfConfig.cloudType)
      }/${message.filePathInput}"
      val fileType: String = getFileType(fileLocation)

      // 2) LOAD_INFO entry exist?
      var loadInfo: LoadInfo = null
      try {
        loadInfo = loadInfoDAO.readByType(fileType).get // if it's not exists will throw the exception
      } catch {
        case e: EmfLoadInfoDaoException =>
          EmfLogger.error(
            s"SparkTriggerService.trigger there is no file_type entry present in the table" +
              s" ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} for $fileType ")
          throw e
      }

      val sourceFileDF = getSourceFileDF(loadInfo, fileType, fileLocation)
      if (fileType != null & fileType == EmfConfig.dimQueueFileType) {
        val colName = "parameters"
        if (sourceFileDF.columns.contains(colName)) {
          val parametersJson = sourceFileDF.select(colName).collect().head.mkString
          if (parametersJson != null & parametersJson.nonEmpty) {
            callIngestService(message)
            // TODO: this is quick fix for existing dim_queue json format. Currently program reads only parameters attribute from dim queue file. Need to decide on dim_queue file json format . Those dim_queue attributes will be populated to MessageInfo for logging
            implicit val messageInfo: MessageInfo = createMessageInfoFromDimqueue(sourceFileDF)
            AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Active))
            val sparkRun = SparkRun(parametersJson)
            AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, InProgress))
            sparkRun.run() match {
              case Complete => AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Finish))
              case Failed =>
                AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Fail))
                val customMessage = s"SparkTriggerService.trigger failed to complete SparkRun for fileType: $fileType with parameters: $parametersJson "
                throw new SparkTriggerServiceException(customMessage, None.orNull)
            }
          } else {
            val customMessage = s"SparkTriggerService.trigger failed as parametersJson: $parametersJson" +
              s" is null or empty for fileType: $fileType"
            EmfLogger.error(customMessage)
            throw new SparkTriggerServiceException(customMessage, None.orNull)
          }
        } else {
          val customMessage = s"SparkTriggerService.trigger failed as dim_queue file does not contain colName: $colName"
          EmfLogger.error(customMessage)
          throw new SparkTriggerServiceException(customMessage, None.orNull)
        }
      } else {
        handleWorkflow(loadInfo, fileType, message)
      }
    } catch {
      case e: Exception =>
        val customMessage = s"SparkTriggerService.trigger fails to perform trigger with message $message  : ${e.getMessage}"
        EmfLogger.error(customMessage)
        throw new SparkTriggerServiceException(customMessage, e)
    }
  }

  private def getSourceFileDF(loadInfo: LoadInfo, fileType: String, fileLocation: String): DataFrame = {

    val loadInfoSchemaStructType = StructType(loadInfo.schema.schema.map(
      schemaItem => mapStructType(schemaItem.mode, schemaItem.name, schemaItem.`type`, schemaItem.fields,
        timeStampDateAsString = false)))

    val sourceFileDF = loadInfo.fileFormatConfig match {
      case csvConfig: CsvFileFormatConfig =>
        SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, Some(loadInfoSchemaStructType), modeFailfast = true)
      case jsonConfig: JsonFileFormatConfig =>
        if (fileType != null & fileType == EmfConfig.dimQueueFileType) {
          SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, None)
        } else {
          if (SchemaUtility.checkSchemaContainTimestampOrDate(loadInfo.schema.schema)) {
            val loadInfoSchemaStructTypeModified = StructType(loadInfo.schema.schema.map(
              schemaItem => mapStructType(schemaItem.mode, schemaItem.name, schemaItem.`type`, schemaItem.fields, timeStampDateAsString = true)))
            val rawSourceFileDF = SparkFileReaderService(loadInfo.fileFormatConfig).read(
              loadInfo.fileFormatConfig, fileLocation, Some(loadInfoSchemaStructTypeModified), modeFailfast = true)
            DataFrameValueHandler.cleanAndCastTimeStampAndDate(loadInfo.schema.schema, rawSourceFileDF)
          } else {
            SparkFileReaderService(loadInfo.fileFormatConfig).read(loadInfo.fileFormatConfig, fileLocation, Some(loadInfoSchemaStructType), modeFailfast = true)
          }
        }
      case otherConfig => SparkFileReaderService(loadInfo.fileFormatConfig).read(
        loadInfo.fileFormatConfig, fileLocation, Some(loadInfoSchemaStructType), modeFailfast = true)
    }
    sourceFileDF
  }

  private def callIngestService(message: SparkTriggerMessage): Unit = {
    val sparkIngestMessage = SparkIngestMessage(message.bucketCfs, message.filePathInput)
    val sparkIngestService = new SparkIngestService(
      loadInfoDAO, new HiveRepair(), new SparkCuratedStorageService(), new SparkCatalougeService())
    sparkIngestService.ingest(sparkIngestMessage)
  }

  private def getFileType(fileLocation: String): String = {
    import spark.implicits._
    val config = MetaDataTextFileFormatConfig()
    val metaDataDF: DataFrame = SparkFileReaderService(config).read(config, fileLocation, None)

    if (metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").count() > 0) {
      metaDataDF.as[MetadataEntry].filter(entry => entry.attribute == "file_type").head.value
    } else {
      val customMessage = s"SparkTriggerService.trigger there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token} at $fileLocation"
      EmfLogger.error(customMessage)
      throw new EmfLoadInfoException(customMessage)
    }
  }

  private def handleWorkflow(loadInfo: LoadInfo, fileType: String, message: SparkTriggerMessage): Unit = {
    val curWorkflowName = if (loadInfo.ingestionWorkflowName.getOrElse("") != "") loadInfo.ingestionWorkflowName.getOrElse(EmfConfig.defaultWorkflowName) else EmfConfig.defaultWorkflowName

    val parametersJson: String =
      """{"workflow": "%1$s", "process_tasks_constraints": [],
        |"bucket_cfs":"%2$s", "file_path_input":"%3$s"
        |}""".format(curWorkflowName, message.bucketCfs, message.filePathInput).stripMargin

    if (parametersJson != null & parametersJson.nonEmpty) {
      AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Active))
      val sparkRun = SparkRun(parametersJson)
      AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, InProgress))
      sparkRun.run() match {
        case Complete => AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Finish))
        case Failed =>
          AuditLogger().audit[MessageStateInfo](MessageStateInfo(messageInfo, Fail))
          throw new SparkTriggerServiceException(s"SparkTriggerService.trigger failed to complete SparkRun for " +
            s"fileType: $fileType with parameters: $parametersJson ", None.orNull)
      }
    }
    else {
      val customMessage = s"SparkTriggerService.trigger failed as parametersJson: $parametersJson" +
        s" is null or empty for fileType: $fileType"
      EmfLogger.error(customMessage)
      throw new SparkTriggerServiceException(customMessage, None.orNull)
    }
  }

  //TODO - message info instance creation - change this once dim_queue json structure is finalised
  private def createMessageInfoFromDimqueue(dimQueueDF: DataFrame): MessageInfo = {
    val dimQueueMap = dimQueueDF.head().getValuesMap[String](dimQueueDF.schema.fieldNames)
    val parametersJson = dimQueueMap("parameters")
    val parametersMap = JsonReader.deserializeWithCheck[Map[String, Any]](parametersJson)
    val runUUID = parametersMap.getOrElse("run_uuid", HelperUtility.generateRunUUID()).toString
    val workflow = dimQueueMap.getOrElse("workflow", parametersMap("workflow").toString)
    val orderId = dimQueueMap.getOrElse("order_id", s"$workflow-run")
    val command = dimQueueMap.getOrElse("command", "SPARK-RUN")
    val messageId = dimQueueMap.getOrElse("message_id", HelperUtility.generateRunUUID())
    MessageInfo(runUUID, workflow, orderId, command, parametersJson, List.empty, messageId)
  }
}
package hsbc.emf.service.trigger

import hsbc.emf.dao.ingestion.ILoadInfoDAO
import hsbc.emf.data.ingestion.LoadInfoRaw
import hsbc.emf.data.orchestration.ProcessTaskData
import hsbc.emf.data.sparkcmdmsg.SparkTriggerMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.exception.{EmfLoadInfoDaoException, SparkTriggerServiceException}
import hsbc.emf.infrastructure.hive.HiveRepair
import hsbc.emf.infrastructure.services.mapper.LoadInfoRawToLoadInfoMapper
import hsbc.emf.infrastructure.sql.SqlExecutor
import hsbc.emf.service.ingestion.ISparkCatalougeService
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.{DataFrame, SaveMode}
import org.scalamock.scalatest.MockFactory

import scala.util.matching.Regex


class SparkTriggerServiceTest extends IntegrationTestSuiteBase with MockFactory {
  val mockLoadInfoDAO = mock[ILoadInfoDAO]
  val mockSqlExecutor = mock[SqlExecutor]
  val mockSparkCatalougeService = mock[ISparkCatalougeService]
  var hiveRepair: HiveRepair = null
  var SparkTriggerService4Validation: SparkTriggerService = null
  var dimSchemaJsonString = ""
  val curateFileType = "curate_result"
  val uuidRegEx = new Regex("[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}")


  val defaultTableName = EmfConfig.defaultTableName
  val bucketCfs = "tests/hsbc/emf"
  val successCase1TestDimQueue001 = "dim_queue001"
  val successCase2TestDimQueue001 = "dim_queue002"
  val successCase3TestDimQueue001 = "dim_queue003"
  val failureCase1Test = "failure_case1_test"
  val failureCase2Test = "failure_case2_test"
  val failureCase3Test = "failure_case3_test"
  val failureCase5Test = "failure_case5_test"
  val failureCase6Test = "failure_case6_test"
  val failureCase7Test = "failure_case7_test"
  val successCase3TestDefaultWorkflow = "success_case3_test_default_workflow"
  val successCase4TestAvroDefaultWorkflow = "success_case4_test_avro_default_workflow"
  val successCase5TestOrcDefaultWorkflow = "success_case5_test_orc_default_workflow"
  val successCase6TestJsonDefaultWorkflow = "success_case6_test_json_default_workflow"
  val successCase7TestCsvDefaultWorkflow = "success_case7_test_csv_default_workflow"
  val successCase8TestOtherWorkflow = "success_case8_test_other_workflow"
  val successCaseFTPUK001 = "success_ftp_uk_001"
  val testTopic = ""

  import spark.implicits._


  override def beforeAll(): Unit = {
    super.beforeAll()
    hiveRepair = new HiveRepair()
    //SparkTriggerService4Validation = new SparkTriggerService(mockLoadInfoDAO, hiveRepair, new SparkCuratedStorageService(), new SparkCatalougeService())

    spark.sql(s"CREATE DATABASE IF NOT EXISTS test_db")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS ${EmfConfig.process_tasks}")
    spark.sql("CREATE DATABASE IF NOT EXISTS Person")
    val sample = """{"key" : "a", "value": 1}"""
    val df = spark.read.json(Seq(sample).toDS())
    df.write.mode("overwrite").saveAsTable("test_db.source_table")

    spark.sql(s"create database if not exists ${EmfConfig.dimQueueFileType}")

    // case 3 prepartion: create db and table for file type 'success_case3_test_default_workflow'
    // case 3 prepartion: create db and table for file type 'success_case3_test_default_workflow'
    spark.sql(s"create database if not exists $successCase3TestDefaultWorkflow")
    spark.sql(s"create table if not exists $successCase3TestDefaultWorkflow.$defaultTableName (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) stored as parquet")

    spark.sql(s"create database if not exists $successCase4TestAvroDefaultWorkflow")
    spark.sql(s"create table if not exists $successCase4TestAvroDefaultWorkflow.$defaultTableName (`rule_id` STRING, `timestamp1` TIMESTAMP, `date1` DATE, `rule_expression` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `component` ARRAY<STRUCT<`source_table`: STRING, `component_key_expression`: STRING, `metric_name`: STRING, `alias`: STRING, `metric_expression`: STRING, `where_condition`: STRING, `timestamp3`: TIMESTAMP, `date3`: DATE, `join_clause`: STRING>>)  using avro")

    spark.sql(s"create database if not exists $successCase5TestOrcDefaultWorkflow")
    spark.sql(s"create table if not exists $successCase5TestOrcDefaultWorkflow.$defaultTableName (`rule_id` STRING, `timestamp1` TIMESTAMP, `date1` DATE, `rule_expression` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>, `component` ARRAY<STRUCT<`source_table`: STRING, `component_key_expression`: STRING, `metric_name`: STRING, `alias`: STRING, `metric_expression`: STRING, `where_condition`: STRING, `timestamp3`: TIMESTAMP, `date3`: DATE, `join_clause`: STRING>>)  using orc")

    spark.sql(s"create database if not exists $successCase6TestJsonDefaultWorkflow")
    spark.sql(s"create table if not exists $successCase6TestJsonDefaultWorkflow.$defaultTableName (`timestamp1` TIMESTAMP,`date1` DATE,`component` ARRAY<STRUCT<`timestamp3`: TIMESTAMP,`date3`: DATE,`alias`: STRING, `component_key_expression`: STRING, `join_clause`: STRING, `metric_expression`: STRING, `metric_name`: STRING, `source_table`: STRING, `where_condition`: STRING>>, `rule_expression` STRING, `rule_id` STRING, `rule_metadata` ARRAY<STRUCT<`attribute`: STRING, `value`: STRING>>) using json")

    spark.sql(s"create database if not exists $successCase7TestCsvDefaultWorkflow")
    spark.sql(s"create table if not exists $successCase7TestCsvDefaultWorkflow.$defaultTableName (binaryFld Boolean, numericFld Decimal(33,9), intFld Long, floatFld Double, dateFld Date, datatimeFld Timestamp) partitioned by (entity_uuid String) ROW FORMAT DELIMITED FIELDS TERMINATED BY '|' stored as textfile")


    spark.sql(s"create database if not exists ${EmfConfig.loadInfoDatabaseName}")
    spark.sql(s"create table if not exists ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} (file_type String, schema String, primary_key String, extension String, delimiter String, prefix String, skip_rows String, quote_character String, dataset_name String, dynamic_flag Boolean, max_bad_records String, schema_json String, file_description String, file_category String, labels String, write_disposition String, ingestion_workflow_name String, ingest_hierarchy String, expiry_days Int, archive_days Int, ingestion_parameters String, allow_quoted_newlines Boolean) partitioned by (entity_uuid String) stored as parquet")


    spark.sql(s"create database if not exists $successCaseFTPUK001")
    spark.sql(s"create table if not exists $successCaseFTPUK001.$defaultTableName (`IP_DETL_REC_TYP_CDE` STRING,`IP_DETL_SRCE_SYS_CDE` STRING, `IP_ID_CHAR` string, `IP_TYPE_CDE` string, `IP_NAME` string, `IP_LEGAL_ENT_CDE` string, `IP_RPT_ENTY_CDE` string ,`IP_HSBC_GROUP_MB_TYPE_CDE` string,`IP_BUS_CUST_TYPE_CDE` string,`IP_STD_INDUS_CLASS_CDE` string,`PARENT_IP_ID_CHAR` string,`IP_PARENT_IP_SRCE_SYS_CDE` string,`IP_PARENT_IP_ID_TYP_CDE` string, `IP_LCL_RELN_MGR_ID` string,`IP_CTRY_OF_DOMCL` string,`IP_PLTCL_SB_DVSN_CDE` string,`IP_CTRY_OF_INC` string,`IP_ANNL_TRNVR_AMT` double, `IP_ANNL_TRNVR_CRNCY_CDE` string, `IP_ANNL_TRNVR_AMT_EFF_DT` date, `IP_GLOBL_LOB_GRP_CDE` string, `IP_GLOBL_LOB_SB_GRP_CDE` string, `IP_MODY_SHT_TERM_RTNG_CDE` string,`IP_MODY_RTNG_LONG_TERM` string, `IP_S_P_RATING_SHORT_TERM` string, `IP_S_P_RATING_LONG_TERM` string, `IP_FTCH_RTNG_SHRT_TERM` string, `IP_FTCH_RTNG_LONG_TERM` string, `IP_DBRS_RTNG_SHRT_TERM` string, `IP_DBRS_RTNG_LONG_TERM` string, `IP_INT_CUST_RISK_RTNG_CDE` string, `IP_INTRN_CUSTRR_TYP_CDE` string, `IP_CREDIT_SCR_CDE` string, `IP_CREDIT_SCR_TYPE_CDE` string, `IP_ALT_IP_SYS_ID` string, `ALT_IP_ID` string, `IP_ALT_IP_ID_TYP_CDE` string, `IP_ACCT_OPEN_DT` date, `TRD_FIN_CLASS_B_ASET_IND` string, `COST_CTR` string, `CUST_CONN` string, `IP_DOB_DT` date, `IP_OCCUPATION_NAME` string, `IP_PRIM_BANK_IND` string, `IP_CHANL_CDE` string, `IP_NUM_OF_EMPLY_CNT` int, `IP_ANNL_ASSET_AMT` double, `IP_ANNL_ASSET_CRNCY_CDE` string, `IP_ANNL_ASSET_DT` date, `IP_MOODYS_SHRT_TERM_RTNG_DT` date, `IP_S_P_SHRT_TERM_RTNG_DT` date, `IP_FTCH_SHRT_TERM_RTNG_DT` date, `IP_DBRS_SHRT_TERM_RTNG_DT` date, `IP_MOODYS_LONG_TERM_RTNG_DT` date,`IP_S_P_LONG_TERM_RTNG_DT` date, `IP_FTCH_LONG_TERM_RTNG_DT` date, `IP_DBRS_LONG_TERM_RTNG_DT` date, `IP_MODY_LCL_OFCE_RGST_CTRY_CDE` string, `IP_S_P_LCL_OFCE_RGST_CTRY_CDE` string, `IP_FTCH_LCL_OFCE_RGST_CTRY_CDE` string, `IP_DBRS_LCL_OFCE_OF_REGIS_CDE` string, `IP_RGLT_UNRGLT_FIN_INST_IND` string, `IP_CUST_MO_INCM_ACTL_AMT` double, `IP_CUST_MO_INCM_ACTL_CRNCY_CDE` string, `IP_NUM_OF_PROP_MTGE_NUM` int, `IP_DEBT_TO_INCM_RATIO_PCT` double, `IP_BUREAU_NAME` string, `IP_ORIGN_BUREAU_SCR` string, `IP_INTRN_ORIGN_APP_SCR` string, `IP_PAYROLL_INDUS_CDE` string,`IP_CUST_PRPS_AT_ORIGN_CDE` string) using avro")

    val catalogueData = spark.read
      .format("csv")
      .option("header", "true")
      .option("delimiter", ",")
      .option("dateFormat", "yyyy-MM-dd HH:mm:ss")
      .option("inferSchema", "true")
      .option("nullValue", "null")
      .load("tests/hsbc/emf/testingFiles/service/orchestration/catalogue.csv")

    catalogueData.write.mode(SaveMode.Overwrite).format("hive").partitionBy(EmfConfig.catalogueTablePartitions: _*)
      .saveAsTable(s"${EmfConfig.catalogueDatabaseName}.${EmfConfig.catalogueTableName}")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS ${EmfConfig.process_tasks}.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '${EmfConfig.process_tasks}' group by m.entity_uuid, m.file_type
       """.stripMargin)
    dimSchemaJsonString =
      """[ { "mode": "NULLABLE", "name": "msg_id", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "run_uuid", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "workflow", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "order_id", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "command", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "priority", "type": "INTEGER" },
        |{ "mode": "NULLABLE", "name": "parameters", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "created", "type": "TIMESTAMP" },
        |{ "mode": "NULLABLE", "name": "run_date", "type": "TIMESTAMP" },
        |{ "mode": "REPEATED", "name": "parents", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "description", "type": "STRING" },
        |{ "mode": "NULLABLE", "name": "topic", "type": "STRING" } ]""".stripMargin

    spark.sql(s"CREATE DATABASE IF NOT EXISTS $curateFileType")
    spark.sql(s"""create table if not exists $curateFileType.${EmfConfig.defaultTableName} (col_a String)
    partitioned by (entity_uuid String) stored as parquet""")
    spark.sql(s"CREATE DATABASE IF NOT EXISTS Person")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS Person.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = 'person' group by m.entity_uuid, m.file_type
       """.stripMargin)
  }

  override def afterAll(): Unit = {
    //    spark.sql(s"drop database if exists ${EmfConfig.catalogueDatabaseName} cascade")

    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.process_tasks} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS test_db CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS Person CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $curateFileType CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $successCase3TestDefaultWorkflow CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $successCase4TestAvroDefaultWorkflow CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $successCase5TestOrcDefaultWorkflow CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $successCase6TestJsonDefaultWorkflow CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS $successCase7TestCsvDefaultWorkflow CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS ${EmfConfig.dimQueueFileType} CASCADE")
    spark.sql(s"DROP DATABASE IF EXISTS  $successCaseFTPUK001 CASCADE")
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
    super.afterAll()
  }

  "Failure case 1 - give an invalid SparkTriggerMessage - invalid location" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase1Test"
    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(
        mockLoadInfoDAO
      ).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }

    assert(caught.getMessage.contains(s"Path does not exist"))
  }

  "Failure case 2 - no file_type in present in token" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase2Test"
    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(
        mockLoadInfoDAO).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }

    assert(caught.getMessage.contains(s"there is no file_type attribute found in the ${EmfConfig.spark_readable_meta_chunk_token}"))
  }

  "Failure case 3 - no file_type exists in load_info.data table" should "throw exception" in {
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase3Test"
    (mockLoadInfoDAO.readByType _).expects(failureCase3Test).throwing(
      new EmfLoadInfoDaoException(s"SparkTriggerService.ingest there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName} for '$failureCase3Test'", new Throwable()))
    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(
        mockLoadInfoDAO).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }

    assert(caught.getMessage.contains(s"there is no file_type entry present in the table ${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}"))
  }

  "Failure case 5: given dim_queue file with \"parameters\" field missing " should "throw exception" in {

    val fileType = "dim_queue"
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase5Test"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(mockLoadInfoDAO).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }

    assert(caught.getMessage.contains(s"SparkTriggerService.trigger failed as dim_queue file does not contain colName: parameters"))
  }

  "Failure case 6: given dim_queue file with \"parameters\" field is empty " should "throw exception" in {

    val fileType = "dim_queue"
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase6Test"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
        }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(
        mockLoadInfoDAO
      ).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }

    assert(caught.getMessage.contains(s"SparkTriggerService.trigger failed as parametersJson:  is null or empty for fileType"))

  }

  "Failure case 7: given dim_queue file with invalid workflow " should "throw exception" in {
    // 6. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_trigger_mockup_data/x__metadata_chunk_token__
    val fileType = "dim_queue"
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$failureCase7Test"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
        }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = fileType,
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).twice()

    spark.sql(s"create table if not exists ${EmfConfig.dimQueueFileType}.$defaultTableName (msg_id String, run_uuid String, workflow String, order_id String, command String, priority String, parameters String, created Timestamp, run_date Timestamp, parents String, description String, topic String) using json")

    // 3. prepare a source file for the table ingestion testing
    val caught = intercept[SparkTriggerServiceException] {
      new SparkTriggerService(mockLoadInfoDAO).trigger(SparkTriggerMessage(bucketCfs, filePathInput))
    }
    assert(caught.getMessage.contains("SparkTriggerService.trigger failed to complete SparkRun for fileType: dim_queue"))
    spark.sql(s"drop table ${EmfConfig.dimQueueFileType}.$defaultTableName")
  }

  "Success case 1: given a dim_queue file with a basic workflow" should "trigger & complete Spark Run command" in {
    val fileType = EmfConfig.dimQueueFileType
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$successCase1TestDimQueue001"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
        }""".stripMargin

    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )

    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).twice()

    // 3. prepare data for basic workflow
    val orginalDataDF : DataFrame = spark.sql(s"select * from test_db.source_table")
    val testParameters = s"""{"query": "select * from test_db.source_table", "table": "E01_result_table", "as_view":true}"""
    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(ProcessTaskData("T01", "SPARK-SQL-EVAL", List.empty, testParameters,
      testTopic, "E01"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()


    spark.sql(s"create table if not exists ${EmfConfig.dimQueueFileType}.$defaultTableName (msg_id String, run_uuid String, workflow String, order_id String, command String, priority String, parameters String, created Timestamp, run_date Timestamp, parents array<string>, description String, topic String) STORED AS ORC")

    //4. prepare a source file for the table ingestion testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // Assert the results
    val resultDF = spark.sql("select * from E01_result_table")
    assert(resultDF.count()>0)
    assert(orginalDataDF.except(resultDF).isEmpty)

    val tableDF = spark.sql(s"select * from ${EmfConfig.dimQueueFileType}.$defaultTableName")
    assert(tableDF.count() == 1)

    spark.sql(s"drop table ${EmfConfig.dimQueueFileType}.$defaultTableName")
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")

  }


  "Success case 2: given a dim_queue file with extra workflow parameters and placeholder" should "trigger & complete Spark Run command" in {
    val fileType = EmfConfig.dimQueueFileType
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$successCase2TestDimQueue001"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).twice()

    //3. prepare data for basic workflow

    val resolutionSourceTableAccessViewName = s"Person.${EmfConfig.defaultAccessView}"
    val resolutionSourceTableEntityUuid = "E21"
    val resolvedTableSourceData = Seq((resolutionSourceTableEntityUuid, "row1_data"), (resolutionSourceTableEntityUuid, "row2_data"))
    resolvedTableSourceData.toDF("entity_uuid", "col_a").write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(resolutionSourceTableAccessViewName)

    val curateLoadInfoSourceData =
      List(
        LoadInfoRaw(
          file_type = curateFileType,
          schema_json = Some("[{\"mode\":\"REQUIRED\",\"name\":\"entity_uuid\",\"type\":\"String\"}," +
            "{\"mode\":\"REQUIRED\",\"name\":\"col_a\",\"type\":\"String\"}]"),
          extension = Some("parquet"), ingest_hierarchy = None,
          ingestion_parameters = Some("{\"is_adjustable\":\"false\"}"),
          max_bad_records = Some("1")))
    curateLoadInfoSourceData.toDF().write.mode(SaveMode.Append)
      .saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    val resolvedTableName = "E21_resolve_table"
    val sparkResolveParameters =
      """{"criteria": {"file_type": "[$resolution_file_type]", """ +
        """"constraints": [{"attribute":"location","value":"UK"},{"attribute":"md5","value":"10"}]},""" +
        s""""table_name": "$resolvedTableName","as_view":true}"""
    val sqlFromFileResultTableName = "E06_result_table"
    val sparkSqlFromFileParameters =
      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
        s""""file_name":"sql_from_file_testing.text","target_table":"$sqlFromFileResultTableName", "as_view":true}"""
    val sparkCurateParameters =
      s"""{"source_table_name":"$sqlFromFileResultTableName","file_type":"$curateFileType", """ +
        s""""metadata":{"file_type":"$curateFileType"}}"""
    val resolvedProcessTaskEntityUuid = "E06"
    val processTasksSourceData: Seq[ProcessTaskData] =
      Seq(ProcessTaskData("T01", "SPARK-RESOLVE", List.empty, sparkResolveParameters, testTopic, resolvedProcessTaskEntityUuid),
        ProcessTaskData("T02", "SPARK-SQL-FROM-FILE", List("T01"), sparkSqlFromFileParameters, testTopic, resolvedProcessTaskEntityUuid),
        ProcessTaskData("T03", "SPARK-CURATE", List("T02"), sparkCurateParameters, testTopic, resolvedProcessTaskEntityUuid))
    processTasksSourceData.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    spark.sql(s"create table if not exists ${EmfConfig.dimQueueFileType}.$defaultTableName (msg_id String, run_uuid String, workflow String, order_id String, command String, priority String, parameters String, created Timestamp, run_date Timestamp, parents array<string>, description String, topic String) STORED AS ORC")
    spark.sql(
      s"""
         |CREATE VIEW IF NOT EXISTS ${EmfConfig.dimQueueFileType}.${EmfConfig.catalogueDatabaseName} AS SELECT m.entity_uuid as table_uuid, m.file_type AS file_type,
         |MAX(m.reporting_date) AS reporting_date,MIN(m.created) AS created,
         |collect_list(distinct named_struct('attribute', m.attribute, 'value', m.value, 'data_type', m.data_type, 'domain', m.domain)) as metadata,
         |  m.entity_uuid as entity_uuid FROM catalogue.data m WHERE lower(m.file_type) = '${EmfConfig.dimQueueFileType}' group by m.entity_uuid, m.file_type
       """.stripMargin)
    // 4. prepare a source file for the table ingestion testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    val tableDF = spark.sql(s"select * from ${EmfConfig.dimQueueFileType}.$defaultTableName")
    assert(tableDF.count() == 1)
    spark.sql(s"drop table ${EmfConfig.dimQueueFileType}.$defaultTableName")

    // Assert the results
    val originalDf = spark.sql(s"select * from $resolutionSourceTableAccessViewName").drop("entity_uuid")
    val resolvedDF = spark.sql(s"select * from $resolvedTableName")
    assert(originalDf.except(resolvedDF).isEmpty)

    val sqlFromFileResultDf = spark.sql(s"select * from $sqlFromFileResultTableName")
    val expectedSqlFromFileResultDf = resolvedDF.where("col_a == 'row2_data'")
    assert(sqlFromFileResultDf.except(expectedSqlFromFileResultDf).isEmpty)

    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType' and attribute='run_uuid'")
    val run_uuid = metadataTableDF.select("value").as[String].first
    assert(uuidRegEx.findAllIn(run_uuid).length == 1)

    val curateResultDf = spark.table(s"$curateFileType.${EmfConfig.defaultTableName}" )
      .select( "entity_uuid", "col_a" )
    val uuid = curateResultDf.select("entity_uuid").as[String].first
    assert(uuidRegEx.findAllIn(uuid).length == 1)
    assert(curateResultDf.select("col_a").except(expectedSqlFromFileResultDf.select("col_a")).isEmpty)
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }


  "Success case 3: given a valid SparkTriggerMessage with empty ingestion_workflow_name -- Target is Parquet" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val fileType = successCase3TestDefaultWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger( SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType'")
    assert(metadataTableDF.count().equals(13L))
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }

  "Success case 4: given a valid SparkTriggerMessage with empty ingestion_workflow_name -- Target is Avro" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val fileType = successCase4TestAvroDefaultWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "avro"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false",
         |"curate_format":"avro",
         |"use_avro_logical_types": "true"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType'")
    assert(metadataTableDF.count() == 5)
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }

  "Success case ftp_uk_001 (FCCC-10932): given a valid SparkTriggerMessage with in valid run_uuid -- Target is Avro" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    val fileType = successCaseFTPUK001
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$successCaseFTPUK001"
    val sourceFormat = "avro"
    val schemaJsonString = """[{"name":"IP_DETL_REC_TYP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_DETL_SRCE_SYS_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ID_CHAR","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_TYPE_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_NAME","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_LEGAL_ENT_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_RPT_ENTY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_HSBC_GROUP_MB_TYPE_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_BUS_CUST_TYPE_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_STD_INDUS_CLASS_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"PARENT_IP_ID_CHAR","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_PARENT_IP_SRCE_SYS_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_PARENT_IP_ID_TYP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_LCL_RELN_MGR_ID","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CTRY_OF_DOMCL","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_PLTCL_SB_DVSN_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CTRY_OF_INC","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_TRNVR_AMT","type":"double", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_TRNVR_CRNCY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_TRNVR_AMT_EFF_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_GLOBL_LOB_GRP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_GLOBL_LOB_SB_GRP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_MODY_SHT_TERM_RTNG_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_MODY_RTNG_LONG_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_S_P_RATING_SHORT_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_S_P_RATING_LONG_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_FTCH_RTNG_SHRT_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_FTCH_RTNG_LONG_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_DBRS_RTNG_SHRT_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_DBRS_RTNG_LONG_TERM","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_INT_CUST_RISK_RTNG_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_INTRN_CUSTRR_TYP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CREDIT_SCR_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CREDIT_SCR_TYPE_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ALT_IP_SYS_ID","type":"string", "mode": "NULLABLE"},
                             |                {"name":"ALT_IP_ID","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ALT_IP_ID_TYP_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ACCT_OPEN_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"TRD_FIN_CLASS_B_ASET_IND","type":"string", "mode": "NULLABLE"},
                             |                {"name":"COST_CTR","type":"string", "mode": "NULLABLE"},
                             |                {"name":"CUST_CONN","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_DOB_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_OCCUPATION_NAME","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_PRIM_BANK_IND","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CHANL_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_NUM_OF_EMPLY_CNT","type":"int", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_ASSET_AMT","type":"double", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_ASSET_CRNCY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ANNL_ASSET_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_MOODYS_SHRT_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_S_P_SHRT_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_FTCH_SHRT_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_DBRS_SHRT_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_MOODYS_LONG_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_S_P_LONG_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_FTCH_LONG_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_DBRS_LONG_TERM_RTNG_DT","type":"date", "mode": "NULLABLE"},
                             |                {"name":"IP_MODY_LCL_OFCE_RGST_CTRY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_S_P_LCL_OFCE_RGST_CTRY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_FTCH_LCL_OFCE_RGST_CTRY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_DBRS_LCL_OFCE_OF_REGIS_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_RGLT_UNRGLT_FIN_INST_IND","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CUST_MO_INCM_ACTL_AMT","type":"double", "mode": "NULLABLE"},
                             |                {"name":"IP_CUST_MO_INCM_ACTL_CRNCY_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_NUM_OF_PROP_MTGE_NUM","type":"int", "mode": "NULLABLE"},
                             |                {"name":"IP_DEBT_TO_INCM_RATIO_PCT","type":"double", "mode": "NULLABLE"},
                             |                {"name":"IP_BUREAU_NAME","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_ORIGN_BUREAU_SCR","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_INTRN_ORIGN_APP_SCR","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_PAYROLL_INDUS_CDE","type":"string", "mode": "NULLABLE"},
                             |                {"name":"IP_CUST_PRPS_AT_ORIGN_CDE","type":"string", "mode": "NULLABLE"}]""".stripMargin

    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false",
         |"curate_format":"avro",
         |"use_avro_logical_types": "true"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("TFTP", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count().equals(2L))
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType' and attribute='run_uuid'")
    assert(metadataTableDF.count() == 1)
    val run_uuid = metadataTableDF.select("value").as[String].first
    assert(uuidRegEx.findAllIn(run_uuid).length == 1)

    val fileNameMetadataWithEmptyStringDomainSql =
      s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where " +
        s"file_type='$fileType' and attribute='file_name' and domain = ''"
    val filenameMetadata = spark.sql(fileNameMetadataWithEmptyStringDomainSql).select("value").as[String].first
    val expectedFileNameTail = filePathInput + s"/${EmfConfig.spark_readable_meta_chunk_token}FTPUK_INVOLVED-PARTY_GB_DAILY_MAIN"
    assert(filenameMetadata.endsWith(expectedFileNameTail))

    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }

  "Success case 5: given a valid SparkTriggerMessage with empty ingestion_workflow_name -- Target is ORC" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_trigger_mockup_data/x__metadata_chunk_token__
    val fileType = successCase5TestOrcDefaultWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "orc"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
        }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")
    //
    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType'")
    assert(metadataTableDF.count()== 5 )
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }

  "Success case 6: given a valid SparkTriggerMessage with empty ingestion_workflow_name -- Target is JSON" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_trigger_mockup_data/x__metadata_chunk_token__
    val fileType = successCase6TestJsonDefaultWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "json"
    val schemaJsonString =
      """[{"type": "STRING", "name": "rule_id", "mode": "NULLABLE"},
        | {"type": "TIMESTAMP", "name": "timestamp1", "mode": "NULLABLE"},
        | {"type": "DATE", "name": "date1", "mode": "NULLABLE"},
        | {"type": "STRING", "name": "rule_expression", "mode": "NULLABLE"},
        | {"fields": [{"type": "STRING", "name": "attribute", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "value", "mode": "NULLABLE"}],
        |  "type": "RECORD", "name": "rule_metadata", "mode": "REPEATED"},
        | {"fields": [{"type": "STRING", "name": "source_table", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "component_key_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_name", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "alias", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "metric_expression", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "where_condition", "mode": "NULLABLE"},
        |             {"type": "TIMESTAMP", "name": "timestamp3", "mode": "NULLABLE"},
        |             {"type": "DATE", "name": "date3", "mode": "NULLABLE"},
        |             {"type": "STRING", "name": "join_clause", "mode": "NULLABLE"}],
        | "type": "RECORD", "name": "component", "mode": "REPEATED"}]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"json"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")


    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count() == 2)
    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType'")
    assert(metadataTableDF.count() == 5)
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }


  "Success case 7: given a valid SparkTriggerMessage with empty ingestion_workflow_name -- Target is CSV" should "trigger successfully" in {
    spark.catalog.dropTempView(EmfConfig.loadInfoCacheView)
    // 1. prepare dedicated LoadInfo object as per ./tests/hsbc/emf/testingFiles/spark_trigger_mockup_data/x__metadata_chunk_token__
    val fileType = successCase7TestCsvDefaultWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "csv"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"csv"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = None,
      max_bad_records = Some("1"),
      delimiter = Some("|"),
      skip_rows = Some("0"),
      quote_character = Some("")
    )
    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)
    val loadInfoRawList = List(loadInfoRaw)
    loadInfoRawList.toDF().write.mode("append").saveAsTable(s"${EmfConfig.loadInfoDatabaseName}.${EmfConfig.defaultTableName}")


    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    // 3. set process_task in default work flow
    val sparkIngestParameters =
      """{"bucket_cfs":"[$bucket_cfs]","file_path_input":"[$file_path_input]"}""".stripMargin
    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("T01", "SPARK-INGEST", List.empty, sparkIngestParameters, testTopic, "E31"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()

    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // 5. check record count for source table and catalogue table
    val tableDF = spark.sql(s"select * from $fileType.$defaultTableName")
    assert(tableDF.count().equals(1L))

    val metadataTableDF = spark.sql(s"select * from ${EmfConfig.catalogueDatabaseName}.${EmfConfig.defaultTableName} where file_type='$fileType'")
    assert(metadataTableDF.count().equals(13L))
    spark.sql(s"DROP VIEW IF EXISTS ${EmfConfig.process_tasks}.${EmfConfig.defaultAccessView}")
  }


  "Success case 8: given a valid SparkTriggerMessage with a ingestion_workflow_name" should "trigger successfully" in {
    // setup jvm parameter for externalParametersFilePath
    System.setProperty("externalParametersFilePath", "tests/resources/workflowTest/external_parameters2.json")

    val fileType = successCase8TestOtherWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin

    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = Some("external_parameter_test"),
      max_bad_records = Some("1")
    )

    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()


    val columns = Seq("Name", "Age", "City")
    val dataDF = Seq(("Gavin", 45, "London"), ("Bill", 50, "London"), ("Philip", 38, "NewYork")).toDF(columns: _*)
    dataDF.write.mode("overwrite").saveAsTable("customer")

    val sparkSqlFromFileParameters =
      """{"bucket": "tests/hsbc/emf/testingFiles/service/orchestration", """ +
        """"file_name":"sql_from_file_with_parameters.sql","target_dataset":"[$customer_db]" ,"target_table":"[$customer_from_newyork_tbl]", "as_view":false, "write_disposition":"write_truncate"}"""

    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("TEST_ORDER_ID", "SPARK-SQL-FROM-FILE", List.empty, sparkSqlFromFileParameters, testTopic, "E08"))
    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")
    createProcessTaskView()


    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    val resultDf = spark.sql("select Name, Age, City from test_db.customer_newyork")
    assert(resultDf.count() == 1)
    assert(resultDf.except(dataDF.where("city == 'NewYork'")).isEmpty)

  }

  "Success case 8.1: given a valid SparkTriggerMessage with a ingestion_workflow_name" should "trigger successfully" in {
    // setup jvm parameter for externalParametersFilePath

    System.setProperty("externalParametersFilePath", "tests/resources/workflowTest/external_parameters2.json")

    val fileType = successCase8TestOtherWorkflow
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$fileType"
    val sourceFormat = "parquet"
    val schemaJsonString =
      """[
        |{"mode":"REQUIRED","name":"binaryFld","type":"Boolean"},
        |{"mode":"NULLABLE","name":"numericFld","type":"Decimal(33,9)"},
        |{"mode":"NULLABLE","name":"intFld","type":"Long"},
        |{"mode":"NULLABLE","name":"floatFld","type":"Double"},
        |{"mode":"NULLABLE","name":"dateFld","type":"Date"},
        |{"mode":"NULLABLE","name":"datatimeFld","type":"Timestamp"}
      ]""".stripMargin

    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
      }""".stripMargin
    val loadInfoRaw = LoadInfoRaw(
      file_type = s"$fileType",
      schema_json = Some(schemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      ingestion_workflow_name = Some("external_parameter_test"),
      max_bad_records = Some("1")
    )

    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).once()

    val columns = Seq("Name", "Age", "City")
    val dataDF = Seq(("Gavin", 45, "London"), ("Bill", 50, "London"), ("Philip", 38, "NewYork")).toDF(columns: _*)
    dataDF.write.mode("overwrite").saveAsTable("customer")

    val parameters =
      """{"query": "select * from customer where city = '[$city_filter]' ", "table": "customer_eval_table", "dataset": "test_db"}"""

    val sourceProcessTasks: Seq[ProcessTaskData] = List(
      ProcessTaskData("TEST_ORDER_ID", "SPARK-SQL-EVAL", List.empty, parameters, testTopic, "E08"))
    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")
    createProcessTaskView()


    // 4. prepare a source file for the table trigger testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    val resultDf = spark.sql("select * from test_db.customer_eval_table")
    assert(resultDf.count() == 1)
  }

  "Success case: check table has been created during project running" should "table create success" in {
    val tableExistBefore = spark.catalog.databaseExists("TEST_DATABASE")
    val fileType = EmfConfig.dimQueueFileType
    val filePathInput = s"/testingFiles/spark_trigger_mockup_data/$successCase3TestDimQueue001"
    val sourceFormat = "json"
    val ingestionParametersString =
      s"""{
         |"is_adjustable":"false"
         |,"curate_format":"orc"
        }""".stripMargin

    val loadInfoRaw = LoadInfoRaw(
      file_type = s"${fileType}",
      schema_json = Some(dimSchemaJsonString),
      extension = Some(sourceFormat),
      ingest_hierarchy = None,
      ingestion_parameters = Some(ingestionParametersString),
      max_bad_records = Some("1")
    )

    val loadInfo = LoadInfoRawToLoadInfoMapper.map(loadInfoRaw)

    // 2. set the mockup object expectation
    (mockLoadInfoDAO.readByType _).expects(fileType).returning(Some(loadInfo)).twice()

    // 3. prepare data for basic workflow
    val orginalDataDF : DataFrame = spark.sql(s"select * from test_db.source_table")
    val testParameters = s"""{"query": "select * from test_db.source_table", "table": "E01_result_table", "as_view":true}"""
    val sourceProcessTasks: Seq[ProcessTaskData] = Seq(ProcessTaskData("T01", "SPARK-SQL-EVAL", List.empty, testParameters,
      testTopic, "E01"))

    sourceProcessTasks.toDS.write.mode(SaveMode.Overwrite).format("hive")
      .saveAsTable(s"${EmfConfig.process_tasks}.${EmfConfig.defaultTableName}")

    createProcessTaskView()


    spark.sql(s"create table if not exists ${EmfConfig.dimQueueFileType}.$defaultTableName (msg_id String, run_uuid String, workflow String, order_id String, command String, priority String, parameters String, created Timestamp, run_date Timestamp, parents array<string>, description String, topic String) STORED AS ORC")

    //4. prepare a source file for the table ingestion testing
    val sparkTriggerService = new SparkTriggerService(mockLoadInfoDAO)
    sparkTriggerService.trigger(SparkTriggerMessage(bucketCfs, filePathInput))

    // Assert the results
    val tableExistAfter = spark.catalog.databaseExists("TEST_DATABASE")

    assert(tableExistBefore == false && tableExistAfter == true)

    spark.sql(s"DROP TABLE ${EmfConfig.dimQueueFileType}.$defaultTableName")

  }
}package hsbc.emf.udf

import org.apache.spark.sql.SparkSession
import org.apache.spark.sql.expressions.UserDefinedFunction

import scala.reflect.runtime.universe._

private[udf] trait SparkUdfRegisterable extends Serializable {
  protected val functionName: String

  def register(implicit sparkSession: SparkSession): UserDefinedFunction
}

private[udf] abstract class SparkUdfRegisterableFunction1[I: TypeTag, O: TypeTag]
  extends SparkUdfRegisterable with (I => O) {
  def register(implicit sparkSession: SparkSession): UserDefinedFunction = {
    sparkSession.udf.register(functionName, this.apply _)
  }
}

private[udf] abstract class SparkUdfRegisterableFunction2[I1: TypeTag, I2: TypeTag, O: TypeTag]
  extends SparkUdfRegisterable with ((I1, I2) => O) {
  def register(implicit sparkSession: SparkSession): UserDefinedFunction = {
    sparkSession.udf.register(functionName, this.apply _)
  }
}


private[udf] abstract class SparkUdfRegisterableFunction3[I1: TypeTag, I2: TypeTag, I3: TypeTag, O: TypeTag]
  extends SparkUdfRegisterable with ((I1, I2, I3) => O) {
  def register(implicit sparkSession: SparkSession): UserDefinedFunction = {
    sparkSession.udf.register(functionName, this.apply _)
  }
}
package hsbc.emf.infrastructure.sql

import hsbc.emf.infrastructure.exception.{EmfSqlAnalysisException, EmfSqlException}
import org.apache.spark.sql.{AnalysisException, DataFrame, SparkSession}

class SqlExecutor(implicit val spark: SparkSession) extends ISqlExecutor {
  @throws(classOf[EmfSqlAnalysisException])
  @throws(classOf[EmfSqlException])
  def execute(sql: String): DataFrame = {
    try {
     spark.sqlContext.sql(sql)
    } catch {
      case e: AnalysisException => throw new EmfSqlAnalysisException(e.getMessage(), e.getCause)
      case e: Exception => throw new EmfSqlException(e.getMessage, e.getCause)
    }
  }
}
package hsbc.emf.infrastructure.sql

import hsbc.emf.infrastructure.exception.{EmfSqlAnalysisException, EmfSqlException}
import hsbc.emf.sparkutils.{IntegrationTestSuiteBase}
import org.scalatest.FlatSpec

class SqlExecutorTest extends IntegrationTestSuiteBase {

  import spark.implicits._

  "given an invalid sql" should "return exception" in {
    var sqlExecutor = new SqlExecutor()
    val testSql = "select 'a' as fld1 from no_table"
    // assertion for exception
    val caught = intercept[EmfSqlAnalysisException] {
      val df = sqlExecutor.execute(testSql)
    }
    assert(caught.getMessage.toLowerCase.contains("table or view not found"))
  }

  "given a valid sql without a shared spark session" should "return a dataframe" in {
    var sqlExecutor = new SqlExecutor()
    val testSql = "select 'a' as fld1, 'b' as fld2"
    // 1. verify the row count of the dataframe
    val df = sqlExecutor.execute(testSql)
    assert(df.collectAsList().size() == 1)
    // 2. verify the field value
    val obj = df.as[TestObj].collectAsList().get(0)
    assert(obj.fld1 == "a" && obj.fld2 == "b")
  }

  "given a valid sql with a shared spark session" should "return a dataframe" in {
    var sqlExecutor = new SqlExecutor()
    val testSql = "select 'a' as fld1, 'b' as fld2"
    // 1. verify the row count of the dataframe
    val df = sqlExecutor.execute(testSql)
    assert(df.collectAsList().size() == 1)
    // 2. verify the field value
    val obj = df.as[TestObj].collectAsList().get(0)
    assert(obj.fld1 == "a" && obj.fld2 == "b")
  }
}

case class TestObj(fld1: String, fld2: String)package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.{NotImplementedComparableValue, UnsupportedComparisonOperator}
import hsbc.emf.infrastructure.helper.ResolutionHelper._
import hsbc.emf.infrastructure.helper.StringUtils.{makeList, removeQuotes}

object StringComparator extends IComparator {

  override def compare[T <: ComparableValue](entity: T)(inputString: String)(operator: ComparisonOperator): Boolean = {

    val entityStringValue = entity match {
      case ComparableString(value) => value
      case _ =>
        throw new NotImplementedComparableValue(s"StringComparator.compare - Not implemented StringComparator value: $entity")

    }
    val cleanedInputString = removeQuotes(inputString)

    cleanedInputStringNullCheck(operator, cleanedInputString)

    def equal(): Boolean = entityStringValue.equals(parse[String](cleanedInputString))

    def like(): Boolean = entityStringValue.contains(parse[String](cleanedInputString))

    def in(): Boolean = makeList(inputString).find(x => entityStringValue.equals(x)) match {
      case Some(_) => true
      case None => false
    }

    operator match {
      case Equal => equal()
      case NotEqual => !equal()
      case Like => like()
      case NotLike => !like()
      case In => in()
      case NotIn => !in()
      case Is => false
      case IsNot => true
      case _ => throw new UnsupportedComparisonOperator(s"StringComparator.compare - Not supported StringComparator operator: $operator")
    }
  }
}
package hsbc.emf.service.resolution

import hsbc.emf.data.resolution._
import hsbc.emf.infrastructure.exception.UnsupportedComparisonOperator
import org.scalatest.FlatSpec

class StringComparatorTest extends FlatSpec {

  "given similar values, an Equal operator" should "return true" in {
    val result = StringComparator.compare(ComparableString("value"))("value")(Equal)
    assert(result)

    val result1 = StringComparator.compare(ComparableString("value"))(" value ")(Equal)
    assert(result1)
  }

  "given case differences, an Equal operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("VALUE"))("value")(Equal)
    assert(!result)

    val result1 = StringComparator.compare(ComparableString("value"))("VALUE")(Equal)
    assert(!result1)
  }

  "given similar values, a NotEqual operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("value"))("value")(NotEqual)
    assert(!result)
  }

  "given dis-similar values, an Equal operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("value"))("value2")(Equal)
    assert(!result)
  }

  "given dis-similar values, a NotEqual operator" should "return true" in {
    val result = StringComparator.compare(ComparableString("value"))("value2")(NotEqual)
    assert(result)
  }

  "given a substring with a Like operator" should "return true" in {
    val result = StringComparator.compare(ComparableString("some value set"))("value")(Like)
    assert(result)
  }

  "given a substring with a NotLike operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("some value set"))("value")(NotLike)
    assert(!result)
  }

  "given a substring with a In operator" should "return true" in {
    val result = StringComparator.compare(ComparableString("value3"))("[value1,value3,value2]")(In)
    assert(result)

    val result1 = StringComparator.compare(ComparableString("value3"))("[value1, value3, value2]")(In)
    assert(result1)

    val result2 = StringComparator.compare(ComparableString("value3"))("[\"value1\",\"value3\",\"value2\"]")(In)
    assert(result2)

    val result3 = StringComparator.compare(ComparableString("value3"))("[\" value1 \",\" value3 \",\" value2 \"]")(In)
    assert(result3)

  }

  "given a substring with a NotIn operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("value3"))("[value,value3,value2]")(NotIn)
     assert(!result)

    val result1 = StringComparator.compare(ComparableString("value3"))("[value, value3, value2]")(NotIn)
    assert(!result1)

    val result2 = StringComparator.compare(ComparableString("value3"))("[\"value\",\"value3\",\"value\"]")(NotIn)
    assert(!result2)

    val result3 = StringComparator.compare(ComparableString("value3"))("[\" value \",\" value3 \",\" value2 \"]")(NotIn)
    assert(!result3)

  }

  "given any values with an unsupported operator" should "return an UnsupportedComparisonOperator error" in {

    val op: ComparisonOperator = LessThan

    val caught1 = intercept[UnsupportedComparisonOperator] {
       StringComparator.compare(ComparableString("value"))("value2")(op)
    }
    assert(!caught1.getMessage.isEmpty)

    val caught2 = intercept[UnsupportedComparisonOperator] {
      StringComparator.compare(ComparableString("value"))(null)(op)
    }
    assert(!caught2.getMessage.isEmpty)

    val caught3 = intercept[UnsupportedComparisonOperator] {
      StringComparator.compare(ComparableString("value"))("null")(op)
    }
    assert(!caught3.getMessage.isEmpty)

    val caught4 = intercept[UnsupportedComparisonOperator] {
      StringComparator.compare(ComparableString("value"))("Null")(op)
    }
    assert(!caught4.getMessage.isEmpty)
  }


  "given a value with Is null operator" should "return false" in {
    val result = StringComparator.compare(ComparableString("some value set"))(null)(Is)
    assert(!result)
    val result1 = StringComparator.compare(ComparableString("some value set"))("null")(Is)
    assert(!result1)
    val result2 = StringComparator.compare(ComparableString("some value set"))("Null")(Is)
    assert(!result2)
  }


  "given a value with IsNot null operator" should "return true" in {
    val result = StringComparator.compare(ComparableString("some value set"))(null)(IsNot)
    assert(result)
    val result1 = StringComparator.compare(ComparableString("some value set"))("null")(IsNot)
    assert(result1)
    val result2 = StringComparator.compare(ComparableString("some value set"))("Null")(IsNot)
    assert(result2)
  }

}package hsbc.emf.infrastructure.helper

import hsbc.emf.infrastructure.helper.ResolutionHelper.nullCheck

import scala.util.matching.Regex

object StringUtils {

  def removeQuotes(value: String): String =
    if (nullCheck(value)) value
    else {
      if (value.startsWith("\"") && value.endsWith("\"")) {
        value.replaceAll("^.|.$", "").trim
      }
      else value.trim
    }

  def removeBraces(value: String): String =
    if (value.startsWith("[") && value.endsWith("]")) {
      value.replaceAll("^.|.$", "")
    }
    else value

  def removeBrackets(value: String): String =
    if (value.startsWith("(") && value.endsWith(")")) {
      value.replaceAll("^.|.$", "")
    }
    else value

  def makeList(value: String): List[String] =
    if (nullCheck(value)) List.empty[String]
    else removeBraces(value).split(",").toList.map(removeQuotes)


  def encloseQuotes(value: String): String = {
    if ((value.startsWith("\"") & value.endsWith("\""))) {
      value
    }
    else {
      s""""${value}""""
    }
  }

  def splitIntoList(value: String): List[String] = value.split(",").toList

  /**
    * Search the json string using regex pattern.
    * Remove the value quotes if the string match the keyName-base regex pattern.
    * ex:   "keyname1": "1" =>"keyname1": 1, "keyname2": ["1"] => "keyname2": [1]
    *
    * @param keyName
    * @param jsonString
    * @param delimiter
    * @param splitDelimiter
    * @return
    */
  def removeQuotesMatchByRegex( keyName: String, jsonString: String, delimiter: String = ".", splitDelimiter: String = "\\."): String = {
    if (keyName.contains(delimiter)) {
      removeComplexValueQuotes(keyName, jsonString, splitDelimiter)
    } else {
      removeValueQuotes(keyName, jsonString)
    }
  }

  def removeComplexValueQuotes(keyName: String, jsonString: String, splitDelimiter: String): String = {
    val arr = keyName.split(splitDelimiter)
    var findFlag = true
    var resultJson = jsonString
    val (parentName, childName) = (arr(0), arr(1))
    val itemName = childName.replace("[", "").replace("]", "")
    val isArray = childName.contains("[")
    val parentRegex = if (isArray) s"""(?i)"$parentName"[\\s\\S]*?"$itemName"[ :]*\\[([\\"]{1,}[\\s\\S]*?)\\]""".r
      else s"""(?i)"$parentName"[\\s\\S]*"$itemName"[ :\\[]*[\\"]((\\-|\\+)?\\d+(\\.\\d+)?|false|true)[\\"]""".r
    val childRegex: Regex = if (isArray) s"""(?i)"$itemName"[ :]*\\[([\\"]{1,}[\\s\\S]*?)\\]""".r
      else s"""(?i)"$itemName"[ :]*[\\"]((\\-|\\+)?\\d+(\\.\\d+)?|false|true)[\\"]""".r

    while (findFlag) {
      resultJson = parentRegex.findFirstMatchIn(resultJson) match {
        case Some(matchItem) =>

          childRegex.findFirstMatchIn(matchItem.group(0)) match {
            case Some(matchChildItem) =>
              matchItem.before + matchChildItem.before.toString +
                "\"" + itemName + "\": " +
                (if (isArray) "[" + matchChildItem.group(1).replace("\"", "") + "]" else matchChildItem.group(1)) +
                matchChildItem.after + matchItem.after
            case _ => resultJson
          }

        case _ =>
          findFlag = false
          resultJson
      }
    }
    resultJson
  }

  def removeValueQuotes(keyName: String, jsonString: String): String = {

    var resultJson = jsonString
    if (keyName.contains("["))
    {
      val itemName = keyName.replace("[", "").replace("]", "")
      val regex: Regex = s"""(?i)"$itemName"[ :\\[]*([\\"]{1,}[\\s\\S]*?)[\\]]{1}""".r
      regex.findFirstMatchIn(resultJson) match {
        case Some(matchItem) =>
          matchItem.before + "\"" + itemName + "\": [" + matchItem.group(1).replace( "\"", "") + "]" + matchItem.after
        case _ =>
          resultJson
      }
    } else {
      var findFlag = true
      val regex: Regex = s"""(?i)"$keyName"[ :]*[\\"]((\\-|\\+)?\\d+(\\.\\d+)?|false|true)[\\"]""".r
      while (findFlag) {
        resultJson = regex.findFirstMatchIn(resultJson) match {
          case Some(matchItem) =>
            matchItem.before + "\"" + keyName + "\": " + matchItem.group(1) + matchItem.after
          case _ =>
            findFlag = false
            resultJson
        }
      }
      resultJson
    }
  }

}
package hsbc.emf.sparkutils

import org.apache.spark.sql.{Encoder, SparkSession}

import scala.util.Random

object TableUtils {

  //Helper. creates a temporary table from a Seq and returns the name of the table
  def createTable[T: Encoder](data: Seq[T], tableName: String = Random.alphanumeric.take(5).mkString)(implicit spark: SparkSession): String = {
    import spark.implicits._
    val testDF = data.toDF
    val regex = "^[(A-Za-z)].\\w+"
    var viewName = tableName
    while (!viewName.matches(regex))
      viewName = Random.alphanumeric.take(5).mkString
    testDF.createOrReplaceTempView(viewName)
    viewName
  }
}
package hsbc.emf.sparkutils

import org.scalatest.FlatSpec

import scala.util.Random

class TableUtilsTest extends FlatSpec with IntegrationTestSuiteBase {

  import spark.implicits._

  "Test TableUtils.createTable" should "return valid table name" in {

    val regex = "^[(A-Za-z)].\\w+"
    val tableName = TableUtils.createTable(Seq((false, 1, "something")))
    val invalidTableName = "29920"
    assert(!invalidTableName.matches(regex))
    assert(tableName.matches(regex))
  }
}
package hsbc.emf.udf.cashflows.data

import hsbc.emf.udf.cashflows.{CashFlowsInput, CashFlowsOutput}

trait TestDataSet {
  val input: CashFlowsInput
  val target: Seq[CashFlowsOutput]
}
package hsbc.emf.service.ingestion.data

import java.sql.{Date, Timestamp}

case class TestCsv001(binaryFld: Boolean = true, numericFld: BigDecimal = BigDecimal(0.00000000001), intFld: Long = 1000000000, floatFld: Double = 100000.000001, dateFld: Date = Date.valueOf("2021-03-16"), datatimeFld: Timestamp = Timestamp.valueOf("2021-03-16 00:00:00"))

case class TestOrc001(binaryFld: Boolean = true, numericFld: BigDecimal = BigDecimal(0.00000000001), intFld: Long = 1000000000, floatFld: Double = 100000.000001, dateFld: Date = Date.valueOf("2021-03-16"), datatimeFld: Timestamp = Timestamp.valueOf("2021-03-16 00:00:00"))

case class TestJson001(binaryFld: Boolean = true, numericFld: BigDecimal = BigDecimal(0.00000000001), intFld: Long = 1000000000, floatFld: Double = 100000.000001, dateFld: Date = Date.valueOf("2021-03-16"), datatimeFld: Timestamp = Timestamp.valueOf("2021-03-16 00:00:00"))

case class TestParquet001(binaryFld: Boolean = true, numericFld: BigDecimal = BigDecimal(0.00000000001), intFld: Long = 1000000000, floatFld: Double = 100000.000001, dateFld: Date = Date.valueOf("2021-03-16"), datatimeFld: Timestamp = Timestamp.valueOf("2021-03-16 00:00:00"))
package hsbc.emf.infrastructure.io.readers

import org.apache.spark.sql.SparkSession

class TextFileReaderToString(implicit val spark: SparkSession) {

   def read(fileLocation: String): String = {
     val rdd = spark.sparkContext.textFile(fileLocation)
     val lines = rdd.collect()
     lines.mkString("\n")
   }
}package hsbc.emf.infrastructure.io.readers

import hsbc.emf.infrastructure.config.TextFileFormatConfig
import hsbc.emf.infrastructure.exception.EmfIoException
import hsbc.emf.sparkutils.{IntegrationTestSuiteBase}
import org.scalatest.FlatSpec
import org.apache.hadoop.mapred.InvalidInputException

import scala.io.Source

class TextFileReaderToStringTest extends IntegrationTestSuiteBase {
  "given valid text file" should "read content" in {
    val content = (new TextFileReaderToString().read("tests/hsbc/emf/testingFiles/test1.text"))
    val expected = Source.fromFile("tests/hsbc/emf/testingFiles/test1.text").mkString.split('\r').mkString
    assert(content == expected)
  }

  "given non-existing file" should "return exception" in {
     val caught = intercept[InvalidInputException] {
       val content = (new TextFileReaderToString().read("non/existing/file"))
     }
     assert(caught.getMessage.toLowerCase.contains("input path does not exist"))
  }

}package hsbc.emf.utils


import org.scalactic.Tolerance._

import org.scalactic._

// Provide tolerant matching of Doubles within Case Classes and Seq of these
object TolerantCaseCaseEquality {


  import TripleEquals._

  // Tolerance is either absolute or fraction value of 'defaultTolerance'
  def equivalent(a: Double, b: Double, tol: Double): Boolean = {
    (a === b +- tol) || (a / b === 1.0 +- tol)
  }

  class ProductEquality[T <: Product](tol: Double) extends Equality[T] {

    def areEqual(a: T, b: Any): Boolean = {

      b match {
        case p: T => (a.productIterator.toArray zip p.productIterator.toList).forall {
          case (a: Double, b: Double) => equivalent(a, b, tol)
          case (a: Some[_], b: Some[_]) => (a.get, b.get) match {
            case (x: Double, y: Double) => equivalent(x, y, tol)
            case (x, y) => x === y
          }
          case (a: Any, b: Any) => a === b
        }
        case _ => false
      }
    }
  }

  class SeqEquality[T <: Product](tol: Double) extends Equality[Seq[T]] {

    private implicit val productEq: ProductEquality[T] = new ProductEquality[T](tol)

    override def areEqual(a: Seq[T], b: Any): Boolean =
      b match {
        case p: Seq[T] => (a zip p).forall { case (a, b) => a === b }
        case _ => false
      }
  }

}
package hsbc.emf.utils

import hsbc.emf.utils.TolerantCaseCaseEquality._
import org.scalatest.FlatSpec

case class TestCase(name: String, age: Int, height: Option[Double])

class TolerantCaseCaseEqualityTest extends FlatSpec {
  val tol = 0.002
  implicit val equality: ProductEquality[TestCase] = new ProductEquality[TestCase](tol)
  behavior of "CaseClassHelper class ProductEquality  "

  it should s"match doubles to within tolerance $tol" in {

    assert(TestCase("ben", 13, Some(1.4)) === TestCase("ben", 13, Some(1.4000001)))

  }

  it should s"match sequence of case classes doubles to within tolerance$tol " in {
    implicit val equality: SeqEquality[TestCase] = new SeqEquality[TestCase](tol)
    assert(
      Seq(TestCase("ben", 13, Some(553.0472804999999))) === Seq(TestCase("ben", 13, Some(552.082102)))
    )

  }

}
package hsbc.emf.udf

import hsbc.emf.udf.calcuncoveredrolloff.CalcUncoveredRollOffJavaScript

import org.graalvm.polyglot.Context

private[udf] trait UdfBuilder[T] extends ThreadLocal[Context] {

  override def initialValue(): Context = {
    Context
      .newBuilder("js")
      .allowExperimentalOptions(true)
      .allowAllAccess(true)
      .build()
  }

  def safeExecute[T](block: => T): T = {
    context.enter()
    val ret = block
    context.leave()
    ret
  }

  final private[udf] def context: Context = this.get()

  def apply: T

}
package hsbc.emf.udf

import hsbc.emf.udf.Iinversenormaldistribution.InverseNormalDistribution
import hsbc.emf.udf.calcencumberance.CalcEncumbrance
import hsbc.emf.udf.calcmonetisation.CalcMonetisation
import hsbc.emf.udf.calcuncoveredrolloff.CalcUncoveredRollOff
import hsbc.emf.udf.cashflows.CashFlows
import hsbc.emf.udf.dateaddinternal.DateAddInternal
import hsbc.emf.udf.evalexpression.EvaluateExpression
import hsbc.emf.udf.ilmcalcmonetisation.IlmCalcMonetisation
import hsbc.emf.udf.reevalexpression.ReEvaluateExpression
import hsbc.emf.udf.yearsfraction.YearsFraction
import org.apache.spark.sql.SparkSession

object UdfRegistration {

  private val udfs: Seq[SparkUdfRegisterable] = Seq(
    InverseNormalDistribution.apply,
    CalcUncoveredRollOff.apply,
    CashFlows.apply,
    EvaluateExpression.apply,
    DateAddInternal.apply,
    ReEvaluateExpression.apply,
    CalcMonetisation.apply,
    IlmCalcMonetisation.apply,
    YearsFraction.apply,
    CalcEncumbrance.apply
  )

  // Integration point
  def registerAllUdfs(implicit sparkSession: SparkSession): Unit = {
    udfs.foreach(_.register)
  }
}
package hsbc.emf.udf

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.catalog
import org.scalatest.FlatSpec

class UdfRegistrationTest extends FlatSpec with IntegrationTestSuiteBase {
  behavior of "UdfRegistration"

  it should "register the UDF 'FOTC_UDF_calc_uncovered_roll_off' n the spark catalogue" in {
    UdfRegistration.registerAllUdfs(spark)
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_calc_uncovered_roll_off")
    assert(result.name == "FOTC_UDF_calc_uncovered_roll_off")
  }

  it should "register the UDF 'cashflows' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("cashflows")
    assert(result.name == "cashflows")
  }

  it should "register the UDF 'FOTC_UDF_DATE_ADD_INTERVAL' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_DATE_ADD_INTERVAL")
    assert(result.name == "FOTC_UDF_DATE_ADD_INTERVAL")
  }

  it should "register the UDF 'eval_expression' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("eval_expression")
    assert(result.name == "eval_expression")
  }

  it should "register the UDF 'INVERSE_NORMAL_DISTRIBUTION' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("INVERSE_NORMAL_DISTRIBUTION")
    assert(result.name == "INVERSE_NORMAL_DISTRIBUTION")
  }
  it should "register the UDF 'FOTC_UDF_ilm_calc_monetisation' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_ilm_calc_monetisation")
    assert(result.name == "FOTC_UDF_ilm_calc_monetisation")
  }
  it should "register the UDF 'FOTC_UDF_calc_monetisation' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_calc_monetisation")
    assert(result.name == "FOTC_UDF_calc_monetisation")
  }

  it should "register the UDF 'FOTC_UDF_years_fraction' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_years_fraction")
    assert(result.name == "FOTC_UDF_years_fraction")
  }
  it should "register the UDF 'FOTC_UDF_calc_encumberance' in the spark catalogue" in {
    val result: catalog.Function = spark.catalog.getFunction("FOTC_UDF_calc_encumberance")
    assert(result.name == "FOTC_UDF_calc_encumberance")
  }
}
package hsbc.emf.infrastructure.helper

import org.apache.spark.sql.SparkSession

class ViewUtils (implicit spark: SparkSession) {

  def dropColumnsFromView(viewName: String, dropColumns: List[String]): Unit = {
    val df = spark.table(viewName)
    spark.catalog.uncacheTable(viewName)
    df.drop(dropColumns:_*).createOrReplaceTempView(viewName)
    spark.catalog.cacheTable(viewName)
  }

  def loadViewFromQuery(sqlQuery: String, viewName: String): Unit = {
    spark.sql(sqlQuery).createOrReplaceTempView(viewName)
    spark.catalog.cacheTable(viewName)
  }

  def dropView(viewName: String): Unit = {
    spark.catalog.uncacheTable(viewName)
  }

  def viewRecordCount(viewName: String): Long = {
    spark.sql(s"select count(*) from ${viewName}").head().getLong(0)
  }
}
package hsbc.emf.infrastructure.helper

import hsbc.emf.sparkutils.IntegrationTestSuiteBase

class ViewUtilsTest extends IntegrationTestSuiteBase {
  import spark.implicits._

  "ViewUtilsTest: given valid remove columns in view" should "remove columns from view" in {
    val tempView = "temp_view"
    val sample = s"""[{"entity_uuid": "T12","key": 10, "value": "ten"}]"""
    spark.read.json(Seq(sample).toDS).createOrReplaceTempView(tempView)
    (new ViewUtils()).dropColumnsFromView(tempView, List("entity_uuid", "value"))
    val df = spark.table(tempView)
    assert(df.columns.size == 1)
    assert(df.head().getLong(0) == 10)
  }

  "ViewUtilsTest: given in-valid remove columns in view" should "not remove columns from view" in {
    val tempView = "temp_view"
    val sample = s"""[{"entity_uuid": "T12","key": 10, "value": "ten"}]"""
    val df = spark.read.json(Seq(sample).toDS)
    df.createOrReplaceTempView(tempView)
    (new ViewUtils()).dropColumnsFromView(tempView, List("a", "b"))
    val df2 = spark.table(tempView)
    assert(df.except(df2).count == 0)
  }
}package hsbc.emf.service.orchestration

import scala.util.{Failure, Success, Try}

import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.ingestion.MetadataRaw
import hsbc.emf.data.logging.MessageInfo
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.helper.{HelperUtility, HiveUtils}
import hsbc.emf.infrastructure.logging.{EmfLogger, MessageContext}
import hsbc.emf.infrastructure.logging.audit.{AuditLogger, MetadataInfo}
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.sql.ISqlExecutor

import org.apache.spark.sql.SparkSession

class WorkflowExecEnvInitializer(sqlExecutor: ISqlExecutor, catalogueDAO: ICatalogueDAO)
                                (implicit val spark: SparkSession, implicit val messageInfo: MessageInfo) extends IWorkflowExecEnvInitializer with MessageContext {
  def generateRunUuidAndZzzDb(sparkRunMessage: SparkRunMessage,
                              placeholderParameters: PlaceholderParameters): PlaceholderParameters = {
    Try {
      // Generate Run UUID if it is not provided
      val runUuid = sparkRunMessage.run_uuid.getOrElse(HelperUtility.generateRunUUID())

      // Generate target dataset if it is not provided (it can be provided for sub-workflow in WoW scenario)
      val targetDataset =
        if (placeholderParameters.format.contains(EmfConfig.sparkRunGeneratedParamNameTargetDataset) && !"".equals(placeholderParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset).trim())) {
          // It is provided, return the provided value
          placeholderParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset)
        }
        else {
          // It is not provided, generate a temp database
          EmfConfig.sparkRunGenerateDbPrefix + HelperUtility.generateDatabaseNameUUID()
        }
      if (!spark.catalog.databaseExists(targetDataset)) {
        HiveUtils.createDatabase(targetDataset, None)
        // Catalogue the mapping between run_uuid and database name, with current timestamp
        val metadataRaw = MetadataRaw(
          runUuid, EmfConfig.sparkRunCatalogueFileType, new java.sql.Timestamp(System.currentTimeMillis()),
          EmfConfig.sparkRunGeneratedParamNameTargetDataset, targetDataset, "String", "", None)
        catalogueDAO.write(List(metadataRaw))
        //Log audit for Metadata
        val metadataInfo = MetadataInfo(messageInfo, metadataRaw.entity_uuid, metadataRaw.file_type, metadataRaw.attribute, metadataRaw.value, metadataRaw.data_type, metadataRaw.domain, metadataRaw.reporting_date.orNull, metadataRaw.created)
        AuditLogger().audit(metadataInfo)
      }
      EmfLogger.info(s"run_uuid for workflow ${sparkRunMessage.workflow} = $runUuid")
      EmfLogger.info(s"target_dataset for workflow ${sparkRunMessage.workflow} = $targetDataset")
      // Return the generated parameters to pass to the commands within the workflow
      PlaceholderParameters(Map(
        EmfConfig.sparkRunGeneratedParamNameRunUuid -> runUuid,
        EmfConfig.sparkRunGeneratedParamNameTargetDataset -> targetDataset))
    } match {
      case Success(v) => v
      case Failure(exception) =>
        EmfLogger.error("WorkflowExecEnvInitializer.generateRunUuidAndZzzDb failed with cause: " + exception.getMessage)
        throw new RuntimeException("WorkflowExecEnvInitializer.generateRunUuidAndZzzDb failed", exception)
    }
  }
}
package hsbc.emf.service.orchestration

import java.sql.Timestamp

import hsbc.emf.dao.ingestion.ICatalogueDAO
import hsbc.emf.data.resolution.ResolutionConstraint
import hsbc.emf.data.sparkcmdmsg.SparkRunMessage
import hsbc.emf.infrastructure.config.EmfConfig
import hsbc.emf.infrastructure.orchestration.placeholderparams.PlaceholderParameters
import hsbc.emf.infrastructure.sql.ISqlExecutor
import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.scalamock.scalatest.MockFactory

class WorkflowExecEnvInitializerTest extends IntegrationTestSuiteBase with MockFactory {

  val hexRegEx = "[a-fA-F0-9]"
  val runUuidRegEx = s"$hexRegEx{8}-$hexRegEx{4}-$hexRegEx{4}-$hexRegEx{4}-$hexRegEx{12}"
  val zzzDbRegEx = s"${EmfConfig.sparkRunGenerateDbPrefix}$hexRegEx{8}_$hexRegEx{4}_$hexRegEx{4}_$hexRegEx{4}_$hexRegEx{12}"

  val emptyResolutionConstraints = List.empty[ResolutionConstraint]
  val nowTimestamp = new Timestamp(System.currentTimeMillis)
  val noneSparkVerion: Option[String] = None
  val emptyDisabled = Map.empty[String, List[String]]
  val emptyEnabled = Map.empty[String, List[String]]
  val noneRunUuid: Option[String] = None

  override def afterAll(): Unit = {
    spark.sql("DROP DATABASE IF EXISTS target_dataset")
    spark.sql("DROP DATABASE IF EXISTS target_dataset2")
    super.afterAll()
  }

  "given no run_uuid in sparkRunMessage and no target_dataset in sparkRunPlaceholderParams, generateRunUuidAndZzzDb" should
    "return PlaceholderParameters with newly generated run_uuid and target_dataset" in {
    val sqlExecutor: ISqlExecutor = mock[ISqlExecutor]
    (sqlExecutor.execute _).expects(*).never
    val catalogueDAO: ICatalogueDAO = mock[ICatalogueDAO]
    (catalogueDAO.write _).expects(*).once
    val sparkRunMessage = SparkRunMessage("workflow_name", emptyResolutionConstraints, nowTimestamp,
                                          noneSparkVerion, emptyDisabled, emptyEnabled, noneRunUuid)
    val sparkRunPlaceholderParams = PlaceholderParameters(Map.empty[String, Any])
    val newParameters = new WorkflowExecEnvInitializer(sqlExecutor, catalogueDAO).generateRunUuidAndZzzDb(sparkRunMessage, sparkRunPlaceholderParams)
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameRunUuid).matches(runUuidRegEx))
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset).matches(zzzDbRegEx))
  }

  "given run_uuid in sparkRunMessage and no target_dataset in sparkRunPlaceholderParams, generateRunUuidAndZzzDb" should
    "return PlaceholderParameters with the provided run_uuid and a newly generated target_dataset" in {
    val sqlExecutor: ISqlExecutor = mock[ISqlExecutor]
    (sqlExecutor.execute _).expects(*).never
    val catalogueDAO: ICatalogueDAO = mock[ICatalogueDAO]
    (catalogueDAO.write _).expects(*).once
    val sparkRunMessage = SparkRunMessage("workflow_name", emptyResolutionConstraints, nowTimestamp,
                                          noneSparkVerion, emptyDisabled, emptyEnabled, Some("my_run_uuid"))
    val sparkRunPlaceholderParams = PlaceholderParameters(Map.empty[String, Any])
    val newParameters = new WorkflowExecEnvInitializer(sqlExecutor, catalogueDAO).generateRunUuidAndZzzDb(sparkRunMessage, sparkRunPlaceholderParams)
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameRunUuid) == "my_run_uuid")
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset).matches(zzzDbRegEx))
  }

  "given run_uuid in sparkRunMessage and target_dataset in sparkRunPlaceholderParams, generateRunUuidAndZzzDb" should
    "return PlaceholderParameters with the provided run_uuid and target_dataset" in {
    val sqlExecutor: ISqlExecutor = mock[ISqlExecutor]
    (sqlExecutor.execute _).expects(*).never
    val catalogueDAO: ICatalogueDAO = mock[ICatalogueDAO]
    (catalogueDAO.write _).expects(*).once
    val sparkRunMessage = SparkRunMessage("workflow_name", emptyResolutionConstraints, nowTimestamp,
      noneSparkVerion, emptyDisabled, emptyEnabled, Some("my_run_uuid"))
    val sparkRunPlaceholderParams = PlaceholderParameters(Map(EmfConfig.sparkRunGeneratedParamNameTargetDataset -> "my_target_dataset"))
    val newParameters = new WorkflowExecEnvInitializer(sqlExecutor, catalogueDAO).generateRunUuidAndZzzDb(sparkRunMessage, sparkRunPlaceholderParams)
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameRunUuid) == "my_run_uuid")
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset) == "my_target_dataset")
  }

  "given run_uuid in sparkRunMessage and target_dataset in sparkRunPlaceholderParams and target_database exists, generateRunUuidAndZzzDb" should
    "return PlaceholderParameters with the provided run_uuid and target_dataset" in {
    val sqlExecutor: ISqlExecutor = mock[ISqlExecutor]
    (sqlExecutor.execute _).expects(*).never
    val catalogueDAO: ICatalogueDAO = mock[ICatalogueDAO]
    (catalogueDAO.write _).expects(*).never
    val sparkRunMessage = SparkRunMessage("workflow_name", emptyResolutionConstraints, nowTimestamp,
      noneSparkVerion, emptyDisabled, emptyEnabled, Some("my_run_uuid2"))
    spark.sql("create database my_target_dataset2")
    val sparkRunPlaceholderParams = PlaceholderParameters(Map(EmfConfig.sparkRunGeneratedParamNameTargetDataset -> "my_target_dataset2"))
    val newParameters = new WorkflowExecEnvInitializer(sqlExecutor, catalogueDAO).generateRunUuidAndZzzDb(sparkRunMessage, sparkRunPlaceholderParams)
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameRunUuid) == "my_run_uuid2")
    assert(newParameters.format(EmfConfig.sparkRunGeneratedParamNameTargetDataset) == "my_target_dataset2")
  }
}
package hsbc.emf.infrastructure.logging.audit

import java.sql.Timestamp

import hsbc.emf.data.logging.MessageInfo

case class WorkflowSpawnInfo(message: MessageInfo, spawnMessage: MessageInfo, created: Timestamp = new Timestamp(System.currentTimeMillis())) extends ContextInfopackage hsbc.emf.data.sqleval

sealed trait WriteDisposition{val name: String}

case object WriteAppend extends WriteDisposition{val name = "write_append"}
case object WriteTruncate extends WriteDisposition{val name = "write_truncate"}package hsbc.emf.infrastructure.serde

import hsbc.emf.data.sqleval.{WriteDisposition, WriteAppend, WriteTruncate}
import org.json4s.CustomSerializer
import org.json4s.JsonAST.{JNull, JString}

case object WriteDispositionSerializer extends CustomSerializer[WriteDisposition](format => (
  {
    case JString(writeDisposition) =>  writeDisposition match {
      case "write_append" => WriteAppend
      case "write_truncate" => WriteTruncate
    }
    case JNull => null
  },
  {
    case writeDisposition:WriteDisposition => JString(writeDisposition.getClass.getSimpleName.replace("$",""))
  }))
package hsbc.emf.udf.yearsfraction

import hsbc.emf.udf.{CommonJavaScript, SparkUdfRegisterableFunction1, UdfBuilder}
import org.apache.spark.sql.Row
import org.graalvm.polyglot.proxy.ProxyArray


private[udf] class YearsFraction() extends SparkUdfRegisterableFunction1[Seq[Row], Seq[YearsFractionInputOuput]] {
  import YearsFraction.context
  override val functionName: String = "FOTC_UDF_years_fraction"

  override def apply(input: Seq[Row]): Seq[YearsFractionInputOuput] = {
    YearsFraction.safeExecute {
      // this UDF depends on the function in this JavaScript
      context.eval("js", CommonJavaScript.CashFlowsJavaScript.js)
      context.eval("js", YearsFractionJavaScript.js)
      val jsObject = ProxyArray.fromArray(YearsFractionInput.apply(input): _*)
      context.getBindings("js").putMember("myO", jsObject)
      val value = context.eval("js", s"$functionName(myO)")
      Seq.range(0, value.getArraySize.toInt).map { i => YearsFractionOutput.apply(value.getArrayElement(i)) }
    }
  }

}

private[udf] object YearsFraction extends UdfBuilder[YearsFraction] {

  override def apply: YearsFraction = new YearsFraction
}package hsbc.emf.udf.yearsfraction

object YearsFractionData {

  val input: Seq[YearsFractionInputOuput] = Seq(

    YearsFractionInputOuput(
      ACCOUNT_DEAL_ID = "9PK40018845423031000",
      CASHFLOW_DRILLBACK_ID = "3811|9PK|9PK40018845423031000|GBP|2030-02-01|2030-03-01|P|M|Principal",
      REPORTING_DATE = java.sql.Date.valueOf("2021-02-28"),
      CASHFLOW_DATE = java.sql.Date.valueOf("2030-03-01"),
      DAY_COUNT_CONVENTION = "ACT/365",
      YEARS_FRACTION = Some(0.0)
    ),
    YearsFractionInputOuput(
      ACCOUNT_DEAL_ID = "9PK40018845423031000",
      CASHFLOW_DRILLBACK_ID = "3811|9PK|9PK40018845423031000|GBP|2031-11-03|2031-12-01|P|M|Principal",
      REPORTING_DATE = java.sql.Date.valueOf("2021-02-28"),
      CASHFLOW_DATE = java.sql.Date.valueOf("2031-12-01"),
      DAY_COUNT_CONVENTION = "ACT/365",
      YEARS_FRACTION = Some(0.0)
    ),
    YearsFractionInputOuput(
      ACCOUNT_DEAL_ID = "9PK40018845423031000",
      CASHFLOW_DRILLBACK_ID = "3811|9PK|9PK40018845423031000|GBP|2032-10-01|2032-11-01|P|M|Principal",
      REPORTING_DATE = java.sql.Date.valueOf("2021-02-28"),
      CASHFLOW_DATE = java.sql.Date.valueOf("2032-11-01"),
      DAY_COUNT_CONVENTION = "ACT/365",
      YEARS_FRACTION = Some(0.0)
    ),
    YearsFractionInputOuput(
      ACCOUNT_DEAL_ID = "9PK40018845423031000",
      CASHFLOW_DRILLBACK_ID = "3811|9PK|9PK40018845423031000|GBP|2022-10-03|2022-11-01|I|M|Interest",
      REPORTING_DATE = java.sql.Date.valueOf("2021-02-28"),
      CASHFLOW_DATE = java.sql.Date.valueOf("2022-11-01"),
      DAY_COUNT_CONVENTION = "ACT/365",
      YEARS_FRACTION = Some(0.0)
    )

    ,
    YearsFractionInputOuput(
      ACCOUNT_DEAL_ID = "9PK40018845423031000",
      CASHFLOW_DRILLBACK_ID = "3811|9PK|9PK40018845423031000|GBP|2027-02-01|2027-03-01|I|M|Interest",
      REPORTING_DATE = java.sql.Date.valueOf("2021-02-28"),
      CASHFLOW_DATE = java.sql.Date.valueOf("2027-03-01"),
      DAY_COUNT_CONVENTION = "ACT/365",
      YEARS_FRACTION = Some(0.0)
    )

  )
  // Only the YEARS_FRACTION differs between input and output
  val output: Seq[YearsFractionInputOuput] = (Seq(9.008219178082191, 10.761643835616438, 11.682191780821919, 1.673972602739726, 6.005479452054795).map{Some(_)} zip input).map {
    case (fraction, input) => input.copy(YEARS_FRACTION = fraction)
  }
}package hsbc.emf.udf.yearsfraction

import hsbc.emf.udf.SeqRowToJSCollection
import hsbc.emf.udf.graalvm.{GraalVmValueConverter, ScalaProxyObject}
import org.apache.spark.sql.Row
import org.graalvm.polyglot.Value

// Note the input and output data definitions are identical
// Field names must match those in the function call
case class YearsFractionInputOuput(
                                    ACCOUNT_DEAL_ID: String,
                                    CASHFLOW_DRILLBACK_ID: String,
                                    REPORTING_DATE: java.sql.Date,
                                    CASHFLOW_DATE: java.sql.Date,
                                    DAY_COUNT_CONVENTION: String,
                                    YEARS_FRACTION: Option[Double]
                                  ) extends ScalaProxyObject

private[udf] object YearsFractionInput extends SeqRowToJSCollection[YearsFractionInputOuput] {
  override def apply(v1: Seq[Row]): Seq[YearsFractionInputOuput] = {
    v1.map { e =>
      new YearsFractionInputOuput(
        ACCOUNT_DEAL_ID = e.getString(0),
        CASHFLOW_DRILLBACK_ID = e.getString(1),
        REPORTING_DATE = e.getDate(2),
        CASHFLOW_DATE = e.getDate(3),
        DAY_COUNT_CONVENTION = e.getString(4),
        //This value is never referenced in the JavaScript
        YEARS_FRACTION = None
      )
    }
  }
}

private[udf] object YearsFractionOutput extends GraalVmValueConverter[YearsFractionInputOuput] {
  override def apply(v1: Value): YearsFractionInputOuput = {
    new YearsFractionInputOuput(
      v1.getMember("ACCOUNT_DEAL_ID").asString(),
      v1.getMember("CASHFLOW_DRILLBACK_ID").asString(),
      // Note these two objects are unchanged and the same as input, if the JS logic changes this may break
      java.sql.Date.valueOf(v1.getMember("REPORTING_DATE").toString),
      java.sql.Date.valueOf(v1.getMember("CASHFLOW_DATE").toString),
      v1.getMember("DAY_COUNT_CONVENTION").asString(),
      Option(v1.getMember("YEARS_FRACTION").asDouble())
    )
  }
}package hsbc.emf.udf.yearsfraction

object YearsFractionJavaScript {
  private[yearsfraction] val js =
    """function FOTC_UDF_years_fraction(part) {
      |var result = new Array();
      |  var n = part.length;
      |
      |  for (var i = 0; i < n; i++) {
      |      var item = part[i];
      |      var DayCountFunc = DayCountFactory[item.DAY_COUNT_CONVENTION];
      |      var YearsFraction = DayCountFunc(item.REPORTING_DATE, item.CASHFLOW_DATE);
      |
      |      result.push({ACCOUNT_DEAL_ID: item.ACCOUNT_DEAL_ID,
      |                   CASHFLOW_DRILLBACK_ID: item.CASHFLOW_DRILLBACK_ID,
      |                   REPORTING_DATE: item.REPORTING_DATE,
      |                   CASHFLOW_DATE: item.CASHFLOW_DATE,
      |                   DAY_COUNT_CONVENTION: item.DAY_COUNT_CONVENTION,
      |                   YEARS_FRACTION: YearsFraction});
      |  }
      |  return result;
      |}
      |""".stripMargin
}
package hsbc.emf.udf.yearsfraction

import hsbc.emf.sparkutils.IntegrationTestSuiteBase
import org.apache.spark.sql.Row
import org.apache.spark.sql.functions._
import org.scalatest.FlatSpec

class YearsFractionTest extends FlatSpec with IntegrationTestSuiteBase {
  behavior of "YearsFractionTest"


  it should "convert the input date to a new date inside a UDF" in {
    val testObject = new YearsFraction()
    spark.udf.register("FOTC_UDF_years_fraction", testObject.apply(_: Seq[Row]))
    import spark.implicits._

  // Temp comment
    YearsFractionData.input.toDS().createOrReplaceTempView("YearsFractionTest")
    val target = YearsFractionData.output.toDF.selectExpr(
      """
      struct(
        ACCOUNT_DEAL_ID,
        CASHFLOW_DRILLBACK_ID,
        REPORTING_DATE,
        CASHFLOW_DATE,
        DAY_COUNT_CONVENTION,
        YEARS_FRACTION
      ) as target
    """)

    val results = spark.sql(
      """
        |select FOTC_UDF_years_fraction(
        | collect_list(
        |   struct(
        |     ACCOUNT_DEAL_ID,
        |     CASHFLOW_DRILLBACK_ID,
        |     REPORTING_DATE,
        |     CASHFLOW_DATE,
        |     DAY_COUNT_CONVENTION,
        |     YEARS_FRACTION
        |   )
        | )
        |) as result
        |from YearsFractionTest
        |""".stripMargin).select(explode(col("result")))

    assert(target.intersect(results).count() == 5)
    assert(target.except(results).count() == 0)
  }
}
